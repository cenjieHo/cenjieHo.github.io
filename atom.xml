<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-03T06:40:50.438Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ReentrantLock源码分析</title>
    <link href="http://yoursite.com/2019/05/03/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/ReentrantLock源码分析/</id>
    <published>2019-05-03T06:39:00.000Z</published>
    <updated>2019-05-03T06:40:50.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ReentrantLock</code>可重入锁功能与<code>synchronized</code>类似，用于协调多线程间的同步，并且提供比<code>synchronized</code>更为丰富的功能，比如可响应中断、锁超时等。<code>ReentrantLock</code>本身的实现其实较为简单，因为大部分的复杂逻辑方法已经由AQS实现了，它只需要实现少部分的关键方法即可，所以在学习<code>ReentrantLock</code>之前，个人认为有必要先去了解AQS。</p><p>本文将先说明重入锁的含义、公平锁与非公平锁的对比，然后进入<code>ReentrantLock</code>源码的分析，最后再将其与<code>synchronized</code>关键字进行对比。</p><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>可重入指的是同一个线程可以对同一把锁进行重复加锁，比如线程A获取到了锁并进入了临界区，然后调用另一个同样需要该锁的方法时，它可以成功的再次获取该锁，而不会被阻塞住。那么如果锁不可重入会发生什么问题呢？很简单，还是以上面的这个例子，此时线程A再次尝试获取锁时会被阻塞，此时就发生了死锁。</p><p><code>ReentrantLock</code>和<code>synchronized</code>关键字一样是可重入的，它的内部通过AQS的<code>state</code>变量记录同步状态，每当一个线程进行加锁时<code>state++</code>，而释放锁时<code>state--</code>。因此，当同一个线程重入该锁时，<code>state</code>就表示着该线程重入的次数。</p><h2 id="公平与非公平"><a href="#公平与非公平" class="headerlink" title="公平与非公平"></a>公平与非公平</h2><p><code>ReentrantLock</code>是可以设置公平或非公平模式的，事实上，JDK中的许多锁实现都默认为非公平模式。在这里先简单对比一下两种模式的区别：</p><ul><li>公平锁：公平锁保障了多线程获取锁时的顺序，先到的线程先获取到锁，正常情况下每个线程都能获取到锁</li><li>非公平锁：非公平锁不保障多线程获取锁时的顺序，也就是后来的线程有可能抢占了前面先来的线程获取锁的机会</li></ul><p>公平锁保证了每个线程都能按顺序的获取到锁，而非公平锁则有可能导致前面等待许久的线程不停被后来的线程抢占，从而出现“饥饿”问题。但是从效率上来说，非公平锁会比公平锁高出许多，原因在于唤醒一个线程是需要一定时间的，此时后来的线程可以利用这段时间获取锁并执行代码逻辑，当后来的线程释放完锁后，前面的线程可能正好完全苏醒并成功获取到锁，这就有一个充分的优势：原本因为苏醒而浪费的时间被后来的线程充分利用了，而后来的线程也不会因为进入阻塞而导致线程切换的开销。因此，非公平锁的效率其实是高于公平锁的。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>了解了重入锁和公平与非公平锁后，接下来进入正式的源码分析阶段。</p><p>前面说过，<code>ReentrantLock</code>其实是基于AQS实现的，那么具体是怎么实现的呢？先来看看它的UML类图：</p><p><img src="http://blog.default.nanwulife.com/ReentrantLock.png" alt=""></p><p>可以看出，<code>ReentrantLock</code>的抽象内部类<code>Sync</code>实现了AQS，而<code>Sync</code>有两个具体的子类<code>FairSync</code>和<code>NonfairSync</code>，从名字就可以看出它们分别表示公平模式和非公平模式。通过构造函数的参数可以决定选择哪种模式，如果不传入参数，则默认为非公平模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>先看下实现了AQS的抽象内部类，相关方法在下面会介绍，这里先省略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 交由子类去实现，也就是 FairSync 和 NonfairSync</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  <span class="comment">// ...  &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;  <span class="comment">// ...  &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><p><code>FairSync</code>继承自<code>Sync</code>，实现了公平模式的<code>ReentrantLock</code>的相关逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用 AQS 的 acquire() 方法获取锁</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此方法在 AQS 中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 在 AQS 中并未实现该方法，而交由这里的 FairSync 实现</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();  <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;        <span class="comment">// 如果同步状态为0，表示没有任何一个线程持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;         <span class="comment">// 判断前面是否有等待更长时间的线程</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;  <span class="comment">// 如果没有，通过CAS设置同步状态</span></span><br><span class="line">                setExclusiveOwnerThread(current);   <span class="comment">// 如果设置成功了，则将当前线程设置为锁持有者</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果同步状态不为0，并且当前线程就是锁的持有者，那么进行锁的重入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;   <span class="comment">// 计算重入后的同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);               <span class="comment">// 设置重入后的同步状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取锁失败，会执行AQS的加入同步队列的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;    <span class="comment">// 如果头节点的后继节点不是当前线程，说明有等待时间更长的线程，返回true</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上过过程总结如下：</p><ol><li>执行AQS的<code>acquire()</code>方法</li><li>调用<code>FairSync</code>实现的<code>tryAcquire()</code>方法，如果同步状态为0，则判断有没等待时间更长的线程，如果没有的话就成功获取；若同步状态不为0，且当前线程为持锁线程，则重入该锁</li><li>其它情况，一律返回<code>false</code>并将当前线程加入到同步队列，该过程由AQS实现</li></ol><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p><code>NonfairSync</code>同样继承自<code>Sync</code>，实现了非公平模式的<code>ReentrantLock</code>的相关逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里先直接CAS设置同步状态，如果设置成功，则加锁成功，不需要管同步队列前面是否有等待时间更长的线程</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="comment">// CAS失败了，则调用此方法进入 tryAcquire() 的逻辑</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 与公平模式的唯一不同，不会检查前面是否有等待时间更长的线程，直接CAS</span></span><br><span class="line">        <span class="comment">// CAS 成功就获取锁成功，失败则加入到AQS的同步队列中</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; </span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比公平模式的<code>FairSync</code>和非公平模式的<code>NonfairSync</code>可以发现，它们的差别其实并不大，主要体现在非公平模式在获取锁时不会先检查前面有没有其它等待的线程，而是直接野蛮式CAS，成则获取锁，败则加入同步队列。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁的逻辑比较简单，并且没有公平和非公平之分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法在 AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;      <span class="comment">// 交由子类 Sync 实现</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算释放锁后的同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程没有持有锁，调用该方法会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">// 如果释放后的同步状态为0，表示该锁完全释放了</span></span><br><span class="line">        free = <span class="keyword">true</span>;    </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);  <span class="comment">// 将锁持有者设为 null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);    <span class="comment">// 设置新的同步状态</span></span><br><span class="line">    <span class="keyword">return</span> free;    <span class="comment">// 返回该锁是否被完全释放了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与synchronized的异同"><a href="#与synchronized的异同" class="headerlink" title="与synchronized的异同"></a>与synchronized的异同</h2><p><code>ReentrantLock</code>和<code>synchronized</code>都是用于线程的同步控制，它们的共同点是都可重入，并且<code>synchronized</code>也是非公平锁（<code>ReentrantLock</code>默认为非公平）。而它们之间的不同主要在于以下几点：</p><ul><li><code>ReentrantLock</code>响应中断，而<code>synchronized</code>不响应</li><li><code>ReentrantLock</code>支持超时等待，而<code>synchronized</code>不支持</li><li><code>ReentrantLock</code>可设置成公平锁，而<code>synchronized</code>不可以</li><li>发生异常时，<code>synchronized</code>会自动释放锁，而<code>ReentrantLock</code>需要手动释放锁</li></ul><p>除此之外，<code>ReentrantLock</code>还提供了丰富的接口用于获取锁的状态，比如可以通过<code>isLocked()</code>查询<code>ReentrantLock</code>对象是否处于绑定状态，也可以通过<code>getHoldCount()</code>获取<code>ReentrantLock</code>的加锁次数，也就是重入次数，不过它们的本质都是调用AQS实现的<code>getState()</code>方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.tianxiaobo.com/2018/05/07/Java-%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#21-%E4%B8%8E-synchronized-%E7%9A%84%E5%BC%82%E5%90%8C" target="_blank" rel="noopener">Java 重入锁 ReentrantLock 原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;可重入锁功能与&lt;code&gt;synchronized&lt;/code&gt;类似，用于协调多线程间的
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="ReentrantLock" scheme="http://yoursite.com/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析：Condition</title>
    <link href="http://yoursite.com/2019/05/02/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ACondition/"/>
    <id>http://yoursite.com/2019/05/02/AQS源码分析：Condition/</id>
    <published>2019-05-02T14:32:00.000Z</published>
    <updated>2019-05-03T06:42:19.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Condition</code>是一个与<code>Object</code>中的<code>wait() / nofity() / notifyAll()</code>功能相似的接口，AQS的内部类<code>ConditionObject</code>实现了该接口。它与<code>Object</code>提供的这些方法一样用来协调线程间的同步关系，而不同之处在于<code>Object</code>中的这些方法需要配合<code>Synchronized</code>关键字使用（否则会抛出异常），而<code>Condition</code>中的方法则要配合锁（独占锁）来使用（否则也会抛出异常），并且<code>Condition</code>中的方法功能更为丰富一些，比如说可以设置响应或不响应中断、可以设定超时时间等。</p><p><code>ConditionObject</code>内部维护了一个条件队列，当线程不满足某些条件的时候就会通过<code>await()</code>方法将当前线程加入到条件队列中，而当条件队列上等待的线程被<code>signal() / signalAll()</code>后，又会被转移到AQS的同步队列中尝试获取锁。接下来就其中最核心的三个方法<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>说起，它们也分别对标了<code>Object</code>中的那三个方法。</p><h2 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h2><p><code>await()</code>方法负责将当前线程包装成一个<code>Node</code>后加入到条件队列中，并且需要释放持有的独占锁进入阻塞状态。这里先总结一下它的大致流程：</p><ol><li>将当前线程加入到条件队列中</li><li>完全释放互斥锁</li><li>如果当前线程未在同步队列中，就将其阻塞</li><li>否则，重新获取锁并根据是否发生中断而做出不同反应（抛出异常或重新中断）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 将当前线程包装成 Node 并加入到条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 完全释放互斥锁（不论锁是否可以重入），如果没有持锁，会抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">         <span class="comment">// &lt;3&gt; 只要仍未转移到同步队列就阻塞，转移的情况如下：</span></span><br><span class="line">        <span class="comment">// 1. 其它线程调用 signal 将当前线程节点转移到同步队列并唤醒当前线程</span></span><br><span class="line">        <span class="comment">// 2. 其它线程调用 signalAll</span></span><br><span class="line">        <span class="comment">// 3. 其它线程中断了当前线程，当前线程会自行尝试进入同步队列</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 获取中断模式。在线程从park中被唤醒的时候，需要判断此时是否被中断，若中断则尝试转移到同步队列</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;4&gt; 重新获取互斥锁过程中如果发生中断并且 interruptMode 不为 THROW_IE，则将 interruptMode 设置为 REINTERRUPT</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果线程发生过中断则根据 THROW_IE 或是 REINTERRUPT 分别抛出异常或者重新中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter()"></a>addConditionWaiter()</h3><p>首先看看第一个关键步骤，也就是将当前线程加入到条件队列中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列中最后一个节点的状态是 CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();   <span class="comment">// 清理队列</span></span><br><span class="line">        t = lastWaiter;                 <span class="comment">// 重读 lastWaiter</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程封装为一个 Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  <span class="comment">// 如果当前队列没有节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">// 将当前队列的尾节点连接到新节点</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">// 将新节点作为新尾节点</span></span><br><span class="line">    lastWaiter = node;  </span><br><span class="line">    <span class="comment">// 返回新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里会先判断条件队列中的最后一个节点是否为取消状态，如果是的话就调用<code>unlinkCancelledWaiters()</code>进行清理，清理的过程其实就是将条件队列中所有取消的节点都移除。之后将当前线程封装成<code>Node</code>后与当前队列最后一个节点的<code>nextWaiter</code>关联即可。</p><h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease()"></a>fullyRelease()</h3><p>此时已经将线程加入到条件队列中了，调用<code>fullyRelease()</code>方法完全释放同步状态。这里的“完全”指的是对于重入锁来说，每次加锁都会将AQS的整型成员变量<code>state++</code>，而每次解锁时会将<code>state--</code>，因此这里将<code>state</code>的数量完全释放掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取同步状态数值</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 调用 release() 释放指定数量的同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>; </span><br><span class="line">            <span class="keyword">return</span> savedState;  <span class="comment">// 返回释放的数量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果释放时出现异常，将该 Node 的等待状态设置为 CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue()"></a>isOnSyncQueue()</h3><p>该方法用于判断某个节点是否转移到了同步队列上（因为别的线程有可能通过<code>signal() / signalAll()</code>将其转移了），如果没有就将其阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待状态如果是 CONDITION 则一定是在条件队列，或者如果 prev 为 null 也一定是在条件队列</span></span><br><span class="line">    <span class="comment">// （同步队列新入队的节点的 prev 值是不可能为 null 的，因为有dummy节点的存在）</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// 不在同步队列中，直接返回 false</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 条件队列的节点是通过 nextWaiter 来维护的，不用 next 和 prev，因此如果节点在条件队列中则 next 和 prev 应该都为 null</span></span><br><span class="line">    <span class="comment">// 如果 next 不为 null，则说明一定是在同步队列中</span></span><br><span class="line">    <span class="comment">// 这里还要说明的是在 cancelAcquire() 方法中，一个节点取消的时候会把自己的 next 域指向自己，即 node.next = next; 而不是node.next = null;</span></span><br><span class="line">    <span class="comment">// 通过这种方式，在这里就可以将其和在同步队列上的情况归一化判断，都返回 true</span></span><br><span class="line">    <span class="comment">// 如果 cancelAcquire() 方法中写成 node.next = null; 的形式，这里的判断不满足条件，那么又要往底下进一步判断</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 虽然 node.prev 为 null 可以说明此时节点不在同步队列中，</span></span><br><span class="line">    <span class="comment">// 但如果 node.next 为 null 并不能说明 node 就不在同步队列中，因为新节点入队时会先设置 prev 然后再设置 next</span></span><br><span class="line">    <span class="comment">// 此时由 tail 节点开始从后向前遍历一次，确定节点是否真的不在同步队列中</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting()"></a>checkInterruptWhileWaiting()</h3><p><code>checkInterruptWhileWaiting()</code>方法用于检测线程在等待期间是否发生了中断，注意该方法是在<code>LockSupport.park(this);</code>这一行之后，也就是说此时线程已经从阻塞中返回了，返回的原因有可能是因为中断，也有可能是因为<code>signal() / signalAll()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测线程在等待期间是否发生了中断，如果未发生中断，直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断中断发生的时期，分为两种：</span></span><br><span class="line"><span class="comment"> * 1. 中断在节点被转移到同步队列前发生，此时返回 true</span></span><br><span class="line"><span class="comment"> * 2. 中断在节点被转移到同步队列后发生，此时返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况，中断在节点被转移到同步队列前发生</span></span><br><span class="line">    <span class="comment">// 此时自行将节点转移到同步队列上，并返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果上面的CAS失败了，说明已经有线程调用 signal() / signalAll() 方法了，</span></span><br><span class="line">    <span class="comment">// 这两个方法都会先将节点等待状态由 CONDITION 设为0后，再调用 enq() 方法转移节点</span></span><br><span class="line">    <span class="comment">// 此时有可能仅设置了等待状态而没来得及将节点转移到同步队列中就被切换走了，</span></span><br><span class="line">    <span class="comment">// 此时自旋等待节点成功进入同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield(); <span class="comment">// 让出 CPU</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完上面几个方法，当从<code>while (!isOnSyncQueue(node))</code>循环中跳出时，说明节点已经转移到了同步队列中了，此时通过<code>acquireQueued(node, savedState)</code>方法重新获取锁，并且如果线程发生过中断则根据<code>THROW_IE</code>或是<code>REINTERRUPT</code>分别抛出异常或者重新中断。</p><h2 id="signal-signalAll"><a href="#signal-signalAll" class="headerlink" title="signal() / signalAll()"></a>signal() / signalAll()</h2><p>上面的<code>await()</code>方法中从<code>while (!isOnSyncQueue(node))</code>循环跳出可不是自己独立就能做到的，它是需要<code>signal() / signalAll()</code>配合的。<code>signal() / signalAll()</code>的工作就是负责将条件队列中的节点转移到同步队列中，两个方法的区别在于<code>signal()</code>只会转移首节点，而<code>signalAll()</code>会转移队列上的所有节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signal 方法是不允许的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)      <span class="comment">// 头节点不为 null</span></span><br><span class="line">        doSignal(first);  <span class="comment">// 将头节点转移到同步队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果下面这个条件满足了，说明条件队列中只有一个节点，此时 lastWaiter 设为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用 transferForSignal() 将节点转移到同步队列中，如果失败，且 firstWaiter 不为null，则继续尝试，transferForSignal() 成功了或者队列中没节点了，while 循环就结束了 </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法用于将条件队列中的节点转移到同步队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果将节点的等待状态由 CONDITION 设为0失败，则表明节点被取消</span></span><br><span class="line">    <span class="comment">// 注意：因为 transferForSignal() 不存在竞争的问题，所以唯一的可能就是节点被取消</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 enq() 方法将 node 转移到同步队列中，并返回 node 的前驱节点（原尾节点）p</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱结点状态为取消或者无法将状态CAS到SIGNAL，</span></span><br><span class="line">    <span class="comment">// 则需要唤醒参数node节点对应的线程，使其能开始尝试争锁</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>signal()</code>一定会转移条件队列中的一个节点，除非队列中彻底空了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// // 检查线程是否获取了独占锁，未获取独占锁调用 signalAll() 方法是不允许的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将条件队列中所有节点都转移到同步队列中，与 doSignal() 的主要区别在于 while 循环条件上</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);   <span class="comment">// 调用 transferForSignal() 将节点转移到同步队列中</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signalAll()</code>与<code>signal()</code>的主要不同在于循环条件中，因为它会将条件队列中的所有节点都转移，因此实现起来稍微简单一些。</p><h2 id="JDK-BUG"><a href="#JDK-BUG" class="headerlink" title="JDK BUG"></a>JDK BUG</h2><p>这里再讲一下jdk在上面实现中的一个bug。对比上面<code>await()</code>和<code>signal() / signalAll()</code>的源码可以发现，<code>await()</code>方法并没有做同步控制，也就是<code>signal() / signalAll()</code>方法开头的<code>if (!isHeldExclusively())  throw new IllegalMonitorStateException();</code>。因此，如果没有获取锁就调用该方法，会产生线程竞争的情况，导致条件队列的结构被破坏。例如，以下添加节点到条件队列的方法：</p><pre><code class="java"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>{    Node t = lastWaiter;    <span class="comment">// 如果条件队列中最后一个节点的状态是 CANCELLED</span>    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) {        unlinkCancelledWaiters();   <span class="comment">// 清理队列</span>        t = lastWaiter;                 <span class="comment">// 重读 lastWaiter</span>    }    <span class="comment">// 将当前线程封装为一个 Node</span>    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  <span class="comment">// 如果当前队列没有节点</span>        firstWaiter = node;    <span class="keyword">else</span>            <span class="comment">// 将当前队列的尾节点连接到新节点</span>        t.nextWaiter = node;    <span class="comment">// 将新节点作为新尾节点</span>    lastWaiter = node;      <span class="comment">// 返回新节点</span>    <span class="keyword">return</span> node;}</code></pre><p>如果有两个线程同时执行到<code>if (t == null)</code>时，可能会造成<code>firstWaiter</code>先指向其中一个，之后却被另一个给覆盖了，那么此时其中一个线程将会一直阻塞下去，因为这个线程的node并不在条件队列中，也就永远不会被<code>signal() / signalAll()</code>转移到同步队列上，唯一能从阻塞中返回的可能就是被中断。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/micrari/p/7219751.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读–续篇之Condition</a></li><li><a href="http://www.tianxiaobo.com/2018/05/04/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-Condition-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - Condition 实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt;是一个与&lt;code&gt;Object&lt;/code&gt;中的&lt;code&gt;wait() / nofity()
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析：独占与共享同步状态</title>
    <link href="http://yoursite.com/2019/05/02/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%8B%AC%E5%8D%A0%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/05/02/AQS源码分析：独占与共享同步状态/</id>
    <published>2019-05-02T07:59:00.000Z</published>
    <updated>2019-05-02T14:25:12.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS就是<code>java.util.concurrent.locks</code>包下的<code>AbstractQueuedSynchronizer</code>类，这个类也是整个并发包的核心之一。并发包中像<code>ReentrantLock</code>、<code>CountDownLatch</code>等同步组件都有一个内部类<code>Sync</code>，而所有的<code>Sync</code>都是继承自<code>AbstractQueuedSynchronizer</code>，因此，可以看出AQS的重要性是十分高的。</p><p>AQS主要的工作是维护线程同步队列（CLH）并且负责线程的阻塞和唤醒，它的方法基本可以分为三类：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>所谓独占就是一次只有一个线程能够获取，其它线程必须等它释放，共享则可以有多个线程同时获取。</p><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>AQS内部维护着一个FIFO双向队列，该队列就是CLH同步队列，AQS依赖它来完成同步状态的管理：</p><ul><li>当前线程如果获取同步状态失败时，AQS会将当前线程以及等待状态等信息构成一个节点<code>Node</code>并将其加入到CLH同步队列，同时会阻塞当前线程。</li><li>当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。</li></ul><p>CLH同步队列的结构图如下：<br><img src="http://blog.default.nanwulife.com/0DFE7AA88DBEA0365F5532B4AC4FFF17.jpg" alt=""></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p><code>Node</code>是AQS的静态内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式节点，标记节点在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 独占式节点，标记节点在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为超时或中断，节点会被设置为取消状态，不会参与到竞争当中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点在条件队列中，节点线程等待在 Condition 上，当其它线程对 Condition 调用了 signal() / signalAll() 后，该节点会从条件队列转移到同步队列，加入到同步状态的获取中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次共享模式的同步状态获取会无条件地传播下去</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，也就是上面这几个，不过初始值为0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此节点的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 见 ConditionObject</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>入队操作过程是很简单的，只需要将<code>tail</code>指向新节点、新节点的<code>prev</code>指向当前最后的节点、当前最后的节点的<code>next</code>指向当前节点即可。但是在CLH的实现中需要考虑并发的情况，它通过CAS的方式，来保证正确的添加<code>Node</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// 新建节点</span></span><br><span class="line">    <span class="comment">// 记录原尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置新Node的前驱结点为原尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;   <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">            <span class="keyword">return</span> node;          <span class="comment">// 返回新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);      <span class="comment">// 失败，多次尝试直到成功</span></span><br><span class="line">    <span class="keyword">return</span> node;   <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 多次尝试直到成功</span></span><br><span class="line">        Node t = tail;  <span class="comment">// 记录原尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 原尾节点不存在</span></span><br><span class="line">            <span class="comment">// 创建首尾节点都为 new Node()，作为一个占位节点（空节点）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) </span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 原尾节点存在</span></span><br><span class="line">            <span class="comment">// 将原尾节点设置为新节点的前驱节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;  <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">                <span class="keyword">return</span> t;         <span class="comment">// 返回新节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总体来说就是使用CAS设置新节点为尾节点，如果设置成功则返回新节点，如果失败则继续不断自旋CAS设置新节点为尾节点直到成功。</p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>首节点的线程释放同步状态后，会唤醒它的后继节点，后继节点在获取同步状态成功时将自己设置为首节点，因为只有一个线程能够成功获取到同步状态，所以该过程不需要CAS来保证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 将未使用的字段设为null以帮助GC</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>在进入AQS的核心源码之前有必要先了解一下大量使用到的<code>LockSupport</code>类。</p><p><code>LockSupport</code>也是基于<code>UNSAFE</code>的操作，提供<code>park()</code>用来阻塞线程和<code>unpark()</code>用来唤醒线程，<code>LockSupport</code>的机制是每次<code>unpark()</code>给线程一个“许可”，并且这个许可最多只能为1，如果当前线程有许可，那么<code>park()</code>方法会消耗一个并返回，否则会阻塞线程直到线程重新获得许可，在线程启动之前调用<code>park() / unpark()</code>没有任何效果。</p><p>这里简单的讲一下<code>LockSupport.park() / unpark()</code>与<code>object.wait() / notify()</code>的区别，他们主要的区别在于语义上的不同，阻塞和唤醒是对于线程来说的，<code>LockSupport</code>的<code>park() / unpark()</code>以线程作为方法的参数，更符合这个语义；而<code>notify()</code>只能随机唤醒一个线程，<code>notifyAll()</code>会唤醒所有线程，无法准确的控制某一个线程。</p><h3 id="Thread-interrupt"><a href="#Thread-interrupt" class="headerlink" title="Thread.interrupt"></a>Thread.interrupt</h3><p>AQS中大量用了中断，也就是<code>Thread</code>的<code>interrupt()</code>方法，但要注意的是该方法并不会中断一个正在运行的线程：当调用一个线程的该方法时，如果该线程处于被阻塞状态（如<code>Object.wait()</code>、<code>Thread.join()</code>、<code>Thread.sleep()</code>），那么线程将立即退出被阻塞状态，并抛出一个<code>InterruptedException</code>异常；而如果线程正在运行，那么会将该线程的中断标志设置为<code>true</code>，此时线程将继续正常运行。</p><p><code>LockSupport.park()</code>也能响应中断信号，但它不会抛出<code>InterruptedException</code>异常，因此要想知道线程是被<code>unpark()</code>还是中断，就依赖于该线程的中断标志，可以通过<code>Thread</code>的<code>interrupted()</code>或<code>isInterrupted()</code>方法获取该值，两个方法的区别是<code>interrupted()</code>获取后会将标志位重置为<code>false</code>。</p><h2 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h2><p>接下来进入AQS比较关键的部分：同步状态的获取与释放。这里主要分为以下两类进行分析：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li></ul><h3 id="独占式获取"><a href="#独占式获取" class="headerlink" title="独占式获取"></a>独占式获取</h3><p>独占就是一次只有一个线程能够获取到同步状态。首先来看独占式同步状态获取的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法是一个模板方法，其中<code>tryAcquire(arg)</code>方法需要自定义同步组件（子类）自己去实现，它尝试获取同步状态，获取成功则设置锁状态并返回<code>true</code>，此时该方法就可以直接返回了；否则获取失败返回<code>false</code>，调用<code>addWaiter(Node mode)</code>方法将当前线程包装成<code>Node</code>加入到CLH同步队列尾部（上面已经介绍过），并且<code>mode</code>参数为<code>Node.EXCLUSIVE</code>，表示独占模式。</p><p>接下来会调用<code>boolean acquireQueued(final Node node, int arg)</code>方法，每个线程包装成<code>Node</code>进入同步队列后都会在该方法中自旋，一旦条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  <span class="comment">// 记录是否获取同步状态成功</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;    <span class="comment">// 记录该过程中是否发生过线程中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 开始自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 当前线程的前驱节点是头节点，且获取同步状态成功</span></span><br><span class="line">                setHead(node);   <span class="comment">// 将当前线程设置为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;     <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果获取同步状态失败，则根据条件判断是否应该阻塞自己</span></span><br><span class="line">            <span class="comment">// 如果不阻塞，CPU 就会处于忙等状态，这样会浪费 CPU 资源</span></span><br><span class="line">            <span class="comment">// 并且从阻塞中返回时，要判断是否是因为中断造成的</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 因为 parkAndCheckInterrupt 方法中会将中断标志清除，所以这里重新设为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 获取同步状态发生异常，取消获取</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">// 获得前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)   </span><br><span class="line">         <span class="comment">// 表示pred的下一个节点也就是node的线程需要阻塞等待。在pred的线程释放同步状态时会对node的线程进行唤醒通知，所以这里返回true表示当前线程可以放心的被park</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// Node.CANCELLED</span></span><br><span class="line">        <span class="comment">// 等待状态为CANCELLED时，表示此时前驱结点已经等待超时或者被中断了，需要从CLH队列中将前驱节点删除，循环回溯，直到前一个节点状态 &lt;= 0</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 0 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// CAS将状态修改为Node.SIGNAL，但是会返回false，这一次不会park</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);         <span class="comment">// 上面的方法一旦返回true了，就会执行此方法将当前线程park</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();   <span class="comment">// 判断是否因为中断而醒的，并且将中断标志清除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 节点的等待线程置空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过已经取消了的前驱结点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录非取消状态的前驱节点的后继节点，注意不是当前节点node </span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点等待状态设为 CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，则通过CAS设置前驱节点pred为尾节点</span></span><br><span class="line">    <span class="comment">// 以下两个CAS即使失败了也没关系，失败了说明pred此时已经是尾节点了</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 如果设置成功，就通过CAS将pred的next置空，那么中间被取消的节点就“消失”了</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span></span><br><span class="line">           <span class="comment">// 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也没关系。</span></span><br><span class="line">           <span class="comment">// 实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成功即可</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 唤醒后继节点对应的线程。这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span></span><br><span class="line"><span class="comment">         *        head          node1         node2         tail</span></span><br><span class="line"><span class="comment">         *        ws=0          ws=1          ws=-1         ws=0</span></span><br><span class="line"><span class="comment">         *      +------+  prev +-----+  prev +-----+  prev +-----+</span></span><br><span class="line"><span class="comment">         *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span></span><br><span class="line"><span class="comment">         *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span></span><br><span class="line"><span class="comment">         *      +------+  next +-----+  next +-----+  next +-----+</span></span><br><span class="line"><span class="comment">         *      </span></span><br><span class="line"><span class="comment">         * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span></span><br><span class="line"><span class="comment">         * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span></span><br><span class="line"><span class="comment">         * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span></span><br><span class="line"><span class="comment">         * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span></span><br><span class="line"><span class="comment">         * 时，整个同步队列就回全部阻塞住。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过 CAS 将等待状态设为 0，让后继节点线程多一次尝试获取同步状态的机会</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 后继节点为null或者其状态 &gt; 0（表示超时或者被中断了）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从tail节点开始向前遍历找到最前面的可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的<code>unparkSuccessor()</code>方法中有一个地方很有意思，就是当判断当前节点的<code>next</code>引用为<code>null</code>的时候，还需要从<code>tail</code>节点向前遍历找到可用的节点，之所以要这么做的原因在于：在之前的<code>addWaiter()</code>方法将新节点入队时，有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置新Node的前驱结点为原尾节点</span></span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;   <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;          <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是此时可能已经将新节点的<code>prev</code>指向了原尾节点，但原尾节点的<code>next</code>还并未指向新节点，因此不能从前往后遍历，而应从后往前遍历。</p><p>以下是上述步骤的流程图总结：<br><img src="http://blog.default.nanwulife.com/2018120811001.png" alt=""></p><p>可以看出，虽然获取同步状态的过程表面上是自旋的操作，但是为了避免CPU资源的浪费，在获取同步状态失败后大部分情况还是进入了阻塞，但由于从阻塞中醒来不一定代表就可以获得同步状态了（有可能因为中断），所以此时会通过这个自旋循环再一次的去尝试获取同步状态，看看能不能获取成功。</p><h3 id="独占式获取（响应中断）"><a href="#独占式获取（响应中断）" class="headerlink" title="独占式获取（响应中断）"></a>独占式获取（响应中断）</h3><p>上面的<code>acquire(int arg)</code>方法对中断不响应，也就是线程被中断后，仅仅会通过<code>selfInterrupt()</code>方法（其实就是<code>Thread.currentThread().interrupt()</code>）将该线程的中断标志设置为<code>true</code>，然后线程继续正常运行。为了响应中断，AQS提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在线程等待获取同步状态时如果被中断了，会立刻响应中断，抛出<code>InterruptedException</code>异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 首先判断线程是否已经中断了，如果是的话就直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))       <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;   <span class="comment">// 方法声明抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;     <span class="comment">// 不再返回是否发生过中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 与之前不响应中断的acquireQueued()方法唯一的区别在于这里判断发生了中断后会直接抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独占式获取（超时）"><a href="#独占式获取（超时）" class="headerlink" title="独占式获取（超时）"></a>独占式获取（超时）</h3><p>AQS除了提供上面两个独占式获取的方法外，还提供了一个增强版的方法<code>tryAcquireNanos()</code>，该方法除了能响应中断外，还提供了超时控制，即如果当前线程没有在指定时间内获取同步状态，则会返回<code>false</code>，否则返回<code>true</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 首先判断线程是否已经中断了，如果是的话就直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||   <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到这说明获取失败，重新计算需要休眠的时间（剩余时间）</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 如果已经超时了，那么返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果没有超时，判断了可以被park，并且nanosTimeout大于一个阈值，那么就进入休眠</span></span><br><span class="line">            <span class="comment">// 当nanosTimeout小于阈值的时候不需要休眠，直接快速自旋</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();   <span class="comment">// 响应中断，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独占式释放"><a href="#独占式释放" class="headerlink" title="独占式释放"></a>独占式释放</h3><p>当线程获取了同步状态，执行完相应逻辑后，就需要释放同步状态。AQS提供了<code>release(int arg)</code>方法，释放同步状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 由自定义同步组件自己实现</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 如果头节点不为null且状态不为0（等于0说明后继节点正在运行中，不需要唤醒）</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 将后继节点唤醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="共享式获取"><a href="#共享式获取" class="headerlink" title="共享式获取"></a>共享式获取</h3><p>与独占模式不同，共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、<code>CountDownLatch</code>和<code>Semaphore</code>等同步组件的基础。</p><p>共享式同步状态获取的方法是<code>acquireShared()</code>，对标独占式的<code>acquire()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  <span class="comment">// 由自定义同步组件自己实现。返回负数表示获取失败；返回0表示成功，但是后继争用线程不会成功；返回正数表示获取成功，并且后继争用线程也可能成功。</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与之前独占式的参数不同，这里传入一个Node.SHARED</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 前驱节点是头节点并且获取同步状态成功</span></span><br><span class="line">                    <span class="comment">// 设置当前节点为头节点并且向后传播，不断唤醒下一个共享式节点，从而实现多个节点线程同时获取共享同步状态</span></span><br><span class="line">                    setHeadAndPropagate(node, r); </span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// 记录原首节点</span></span><br><span class="line">    setHead(node);  <span class="comment">// 设置当前节点为新首节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里除了使用条件 propagate &gt; 0 判断是否唤醒后继节点，还有其它的一些判断依据</span></span><br><span class="line">    <span class="comment">// 比如 propagate 是 tryAcquireShared() 的返回值，也是这是决定是否传播唤醒的依据之一</span></span><br><span class="line">    <span class="comment">// 更为详细的解释可以参考 https://www.cnblogs.com/micrari/p/6937995.html</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。</span></span><br><span class="line"><span class="comment"> * 后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate，将唤醒传播下去。</span></span><br><span class="line"><span class="comment"> * 这个函数的作用是保障在 acquire 和 release 存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以下的循环做的事情就是，在队列存在后继线程的情况下，唤醒后继线程；</span></span><br><span class="line"><span class="comment"> * 或者由于多线程同时释放共享锁由于处在中间过程，读到head节点等待状态为0的情况下，</span></span><br><span class="line"><span class="comment"> * 虽然不能unparkSuccessor，但为了保证唤醒能够正确稳固传递下去，设置节点状态为PROPAGATE。</span></span><br><span class="line"><span class="comment"> * 这样的话获取锁的线程在执行setHeadAndPropagate时可以读到PROPAGATE，从而由获取锁的线程去释放后继等待线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * ws = 0 的情况下，这里要尝试将状态从 0 设为 PROPAGATE，保证唤醒向后</span></span><br><span class="line"><span class="comment">             * 传播。setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒</span></span><br><span class="line"><span class="comment">             * 后面的节点。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="共享式释放"><a href="#共享式释放" class="headerlink" title="共享式释放"></a>共享式释放</h3><p>共享式释放同步状态的主要逻辑都在上面的<code>doReleaseShared()</code>方法中，共享节点线程在获取同步状态和释放同步状态时都会调用<code>doReleaseShared()</code>，所以<code>doReleaseShared</code>是多线程竞争集中的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于共享式同步状态的获取与释放，其实这里介绍的较为简单了，由于时间原因，很多细节没有解释清楚，更为详细的分析可以参考这篇优质博客：<a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.iocoder.cn/JUC/sike/aqs-2/" target="_blank" rel="noopener">【死磕 Java 并发】—– J.U.C 之 AQS：同步状态的获取与释放</a></li><li><a href="http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#421-%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li><li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AQS就是&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;包下的&lt;code&gt;AbstractQueuedSyn
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java异常机制总结</title>
    <link href="http://yoursite.com/2019/04/30/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/30/Java异常机制/</id>
    <published>2019-04-30T15:25:32.000Z</published>
    <updated>2019-04-30T16:11:35.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java错误和异常"><a href="#Java错误和异常" class="headerlink" title="Java错误和异常"></a>Java错误和异常</h2><p>在Java中，所有的异常都有一个共同的祖先<code>Throwable</code>，它有两个重要的子类：<code>Exception</code>（异常）和<code>Error</code>（错误），二者都是Java异常处理的重要子类，各自都包含大量子类:<br><img src="http://blog.default.nanwulife.com/Exception.png" alt=""></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p><code>Error</code>是程序无法处理的错误，表示代码运行时Java虚拟机出现的问题。例如，当Java虚拟机不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>，而另外还有一个常见的错误是<code>StackOverflowError</code>。这些错误是不可查的，也不应试图去捕获它，当这些错误发生时，Java虚拟机一般会选择终止。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p><code>Exception</code>异常是程序本身可以处理的异常，它有一个重要的子类<code>RuntimeException</code>，表示JVM常用操作引发的异常。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常<code>NullPointerException</code>、<code>ArithmeticException</code>和<code>ArrayIndexOutOfBoundException</code>。</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p><code>Exception</code>这种异常分为运行时异常和非运行时异常（编译异常）两大类：</p><ul><li>运行时异常：都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException</code>（空指针异常）、<code>IndexOutOfBoundsException</code>（下标越界异常）等。这些异常是不检查异常，Java编译器不会检查它，即使没有用<code>try-catch</code>语句捕获它，也没有用<code>throws</code>子句声明抛出它，也会编译通过。</li><li>非运行时异常：是<code>RuntimeException</code>以外的异常，类型上都属于<code>Exception</code>类及其子类。从程序语法角度讲是必须进行处理的异常（<code>try-catch</code>捕捉或者方法上声明<code>throws</code>抛出），如果不处理，程序就不能编译通过，如<code>IOException</code>、<code>SQLException</code>等。</li></ul><h2 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h2><p>在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><ul><li>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息，运行时系统负责寻找处置异常的代码并执行。</li><li>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止，同时意味着Java程序的终止。</li></ul><p>一旦某个<code>catch</code>捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个<code>try-catch</code>语句结束，其他的<code>catch</code>子句不再有匹配和捕获异常类型的机会。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="noopener">深入理解java异常处理机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java错误和异常&quot;&gt;&lt;a href=&quot;#Java错误和异常&quot; class=&quot;headerlink&quot; title=&quot;Java错误和异常&quot;&gt;&lt;/a&gt;Java错误和异常&lt;/h2&gt;&lt;p&gt;在Java中，所有的异常都有一个共同的祖先&lt;code&gt;Throwable&lt;/code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK与CGLIB动态代理</title>
    <link href="http://yoursite.com/2019/04/30/JDK%E4%B8%8ECGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/30/JDK与CGLIB动态代理/</id>
    <published>2019-04-30T09:19:00.000Z</published>
    <updated>2019-04-30T10:05:39.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看了Spring AOP的源码，其底层就是通过JDK与CGLIB动态代理实现的，因此在这里对两种代理方式进行实践和总结。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先创建一个代理创建器<code>ProxyCreator</code>接口，我们将分别实现<code>JdkProxyCreator</code>与<code>CglibProxyCreator</code>，通过实现<code>getProxy()</code>方法返回一个代理对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建一个<code>UserService</code>接口，提供登陆<code>login()</code>和退出<code>logout()</code>两个方法，并创建一个它的实现类<code>UserServiceImpl</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户"</span> + userId + <span class="string">"登陆成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户"</span> + userId + <span class="string">"退出成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们将分为JDK与CGLIB这两种动态代理方式，为上面的登陆与退出两个方法前后打印日志。</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>首先，创建一个<code>JdkProxyCreator</code>并实现<code>ProxyCreator</code>和<code>InvocationHandler</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyCreator</span> <span class="keyword">implements</span> <span class="title">ProxyCreator</span>, <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxyCreator</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"目标对象必须实现接口"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        <span class="comment">// 该类本身实现了 InvocationHandler 接口，所以将自身作为参数传入</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆前日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出前日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object res = method.invoke(target, args); <span class="comment">// 调用目标方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆后日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出后日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，创建代理对象的核心其实就是这一行代码：<code>Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</code>，其中第一个参数是目标对象的类加载器，第二个参数是目标对象实现的接口，第三个参数则是一个<code>InvocationHandler</code>，因为该类已经实现了这个接口，且打印日志的逻辑都封装在了该接口的<code>invoke</code>方法中了，所以直接传入<code>this</code>即可。</p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyCreator proxyCreator = <span class="keyword">new</span> JdkProxyCreator(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        UserService userServiceProxy = (UserService) proxyCreator.getProxy();</span><br><span class="line">        System.out.println(<span class="string">"代理对象的类型："</span> + userServiceProxy.getClass());</span><br><span class="line">        userServiceProxy.login(<span class="number">1</span>);</span><br><span class="line">        userServiceProxy.logout(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理对象的类型：<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy0</span></span></span><br><span class="line"><span class="class">登陆前日志打印...</span></span><br><span class="line"><span class="class">用户1登陆成功</span></span><br><span class="line"><span class="class">登陆后日志打印...</span></span><br><span class="line"><span class="class">退出前日志打印...</span></span><br><span class="line"><span class="class">用户1退出成功</span></span><br><span class="line"><span class="class">退出后日志打印...</span></span><br></pre></td></tr></table></figure></p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>CGLIB是一款优秀的Java字节码生成框架，它可以生成并操纵Java字节码。因此，CGLIB的动态代理其实就是使用字节码技术为目标类创建子类，并且在子类中拦截父类方法的调用，并且顺势织入横切逻辑。</p><p>首先，在pom.xml中引入CGLIB的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>然后创建一个<code>MethodInterceptor</code>接口的实现类，将打印日志的操作封装在<code>intercept()</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆前日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出前日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object res = methodProxy.invokeSuper(o, objects);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆后日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出后日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>Object res = methodProxy.invokeSuper(o, objects);</code>这一行将会调用父类的实现，也就是目标对象的原始方法。这里要注意的是一定不要写成了<code>method.invoke(o, objects);</code>，否则会造成死循环。</p><p>接着，创建一个<code>CglibProxyCreator</code>实现<code>ProxyCreator</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyCreator</span> <span class="keyword">implements</span> <span class="title">ProxyCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyCreator</span><span class="params">(Object target, MethodInterceptor methodInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不同于JDK动态代理使用<code>Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</code>的方式，这里创建了一个<code>Enhancer</code>对象，并且设置了目标对象的类作为父类，还设置了之前的方法拦截器<code>UserMethodInterceptor</code>（其实这里也可以让该类本身实现<code>MethodInterceptor</code>接口），最后通过<code>enhancer.create()</code>方法返回代理对象。</p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyCreator proxyCreator = <span class="keyword">new</span> CglibProxyCreator(<span class="keyword">new</span> UserServiceImpl(), <span class="keyword">new</span> UserMethodInterceptor());</span><br><span class="line">        UserService userServiceProxy = (UserService) proxyCreator.getProxy();</span><br><span class="line">        System.out.println(<span class="string">"代理对象的类型："</span> + userServiceProxy.getClass());</span><br><span class="line">        userServiceProxy.login(<span class="number">2</span>);</span><br><span class="line">        userServiceProxy.logout(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理对象的类型：class cn.hecenjie.UserServiceImpl$$EnhancerByCGLIB$$76be9bea</span><br><span class="line">登陆前日志打印...</span><br><span class="line">用户2登陆成功</span><br><span class="line">登陆后日志打印...</span><br><span class="line">退出前日志打印...</span><br><span class="line">用户2退出成功</span><br><span class="line">退出后日志打印...</span><br></pre></td></tr></table></figure></p><p>从上面的输出可以看出，代理对象其实是目标对象的一个子类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JDK代理要求目标对象有实现接口，而CGLIB则不需要。从性能上来说，CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间看了Spring AOP的源码，其底层就是通过JDK与CGLIB动态代理实现的，因此在这里对两种代理方式进行实践和总结。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="CGLIB" scheme="http://yoursite.com/tags/CGLIB/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP源码笔记</title>
    <link href="http://yoursite.com/2019/04/30/Spring-AOP%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/30/Spring-AOP源码笔记/</id>
    <published>2019-04-30T03:52:00.000Z</published>
    <updated>2019-04-30T08:08:47.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是看了田小波博主的<a href="www.tianxiaobo.com/2018/06/17/Spring-AOP-源码分析系列文章导读">Spring AOP源码分析系列</a>后自己总结整理的笔记，内容会更偏向于流程上的总结，具体源码细节并未深入研究，并且关于AOP的相关术语这里也不会再说明。</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>本文将会从AOP的入口开始分析，主要涉及以下四个流程：</p><ol start="0"><li>入口分析</li><li>筛选合适的通知器</li><li>创建代理对象</li><li>拦截器链的执行过程</li></ol><h2 id="入口分析"><a href="#入口分析" class="headerlink" title="入口分析"></a>入口分析</h2><p>Spring是通过后置处理器<code>BeanPostProcessor</code>接口在<code>init-method</code>的前后通过切点对bean类中的方法进行匹配后织入的，这个接口是Spring提供的一个扩展接口，通过实现该接口，用户可在Bean初始化前后做一些自定义的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 激活Aware相关的方法</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &lt;2&gt; 后处理器，before</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// &lt;3&gt; 激活用户自定义的 init 方法</span></span><br><span class="line"><span class="comment">// 对应 &lt;bean&gt; 标签中的 init-method 属性</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// &lt;2&gt; 后处理器，after</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring AOP抽象代理创建器<code>AbstractAutoProxyCreator</code>实现了<code>BeanPostProcessor</code>接口，并在Bean初始化后置处理过程中向Bean织入通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="comment">// 如果需要，为 Bean 生成代理对象</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前已经判断过了不需要生成代理，直接返回 Bean</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;1&gt; 如果是基础设施类（Pointcut、Advice、Advisor 等接口的实现类），或是应该跳过的类（默认为false，由子类覆盖），</span></span><br><span class="line"><span class="comment">// 则不应该生成代理，此时直接返回 Bean</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="comment">// 将 &lt;cacheKey, FALSE&gt; 键值对放入缓存中，供上面的if使用</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;2&gt; 为目标 Bean 查找合适的通知器（通知器持有通知）</span></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// &lt;3&gt; 如果找到了合适的通知器，则为 Bean 生成代理对象，否则直接返回 Bean</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="comment">// 返回代理对象，此时IoC容器中 beanName 对应的 bean 是代理对象，而非原始的 bean</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 &lt;cacheKey, FALSE&gt; 键值对放入缓存中，供上面的if使用</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="comment">// &lt;4&gt; specificInterceptors == null，直接返回 bean</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>postProcessAfterInitialization</code>主要过程分为四步：</p><ol><li>若Bean是AOP基础设施类型（Pointcut、Advice、Advisor 等接口的实现类），则直接返回</li><li>为目标Bean查找匹配的通知器（通知器持有通知）</li><li>如果找到了匹配的通知器，则为Bean生成代理对象，并返回该对象</li><li>否则，返回原始bean</li></ol><h2 id="筛选合适的通知器"><a href="#筛选合适的通知器" class="headerlink" title="筛选合适的通知器"></a>筛选合适的通知器</h2><p>上文说过，在创建代理对象前，首先要查找合适的通知器<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code>，这一行代码对应着<code>postProcessAfterInitialization</code>的第二步，具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"><span class="comment">// 查找合适的通知器</span></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;<span class="comment">// 如果没有找到</span></span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;<span class="comment">// 则返回 null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors.toArray();<span class="comment">// 否则，返回找到的通知器</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 查找所有的通知器</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="comment">// 筛选可应用在 beanClass 上的 Advisor，通过 ClassFilter 和 MethodMatcher</span></span><br><span class="line"><span class="comment">// 对目标类和方法进行匹配</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line"><span class="comment">// 拓展操作</span></span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该过程首先会查询出所有的通知器，然后再通过<code>ClassFilter</code>和<code>MethodMatcher</code>对目标类和方法进行匹配，筛选出可应用到当前bean的通知器。下面分析查询出所有的通知器的过程。</p><h3 id="查找所有通知器"><a href="#查找所有通知器" class="headerlink" title="查找所有通知器"></a>查找所有通知器</h3><p>这个方法在子类<code>AnnotationAwareAspectJAutoProxyCreator</code>中被覆写过，增加了对<code>@Aspect</code>注解的解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用父类方法从容器中查找所有的通知器</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// 解析 @Aspect 注解，并构建通知器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两行代码分别做了两件事：</p><ol><li>第一步从容器中获取所有类型为<code>Advisor</code>的bean</li><li>第二步获取容器中所有beanName以及每个beanName对应的bean类型，遍历判断当前bean是否是一个Aspect注解类，若是则调用<code>advisorFactory.getAdvisors</code>获取所有通知器列表，其中会为每个方法调用<code>getAdvisor</code>方法，这个方法会获取AspectJ表达式切点（也就是获取方法上的相关注解如<code>@Before</code>、<code>@After</code>等并创建一个<code>AspectJExpressionPointcut</code>对象），并且创建<code>Advisor</code>实现类（这其中会先根据注解类型创建相应的通知<code>Advice</code>实现类）。</li></ol><h2 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h2><p>当Bean实现了接口时，Spring会基于JDK动态代理为目标Bean创建代理对象，若未实现任何接口，Spring则会通过CGLIB创建代理，而当<code>proxy-target-class</code>属性设为<code>true</code>时，则会强制Spring通过CGLIB的方式创建代理对象，即使目标Bean实现了接口。</p><h3 id="AopProxy"><a href="#AopProxy" class="headerlink" title="AopProxy"></a>AopProxy</h3><p>为目标Bean创建代理对象前，需要先创建<code>AopProxy</code>对象，然后再调用该对象的<code>getProxy</code>方法创建实际的代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Spring中，有两个类实现了<code>AopProxy</code>，一个是<code>CglibAopProxy</code>，另一个是<code>JdkDynamicAopProxy</code>。在<code>postProcessAfterInitialization</code>的第三步<code>Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</code>会根据bean是否实现接口以及一些其它配置来决定使用<code>AopProxy</code>的哪一个实现类为目标bean创建代理对象。</p><h2 id="拦截器链的执行过程"><a href="#拦截器链的执行过程" class="headerlink" title="拦截器链的执行过程"></a>拦截器链的执行过程</h2><p>在上面两个步骤中，Spring AOP已经为目标bean筛选出合适的通知器，创建好了代理对象，接下来就是要执行通知逻辑了。通知可能在目标方法前执行，也可能在目标方法后执行，当目标方法被多个通知匹配到时，Spring通过引入拦截器链来保证每个通知的正常执行。</p><h3 id="JDK动态代理逻辑分析"><a href="#JDK动态代理逻辑分析" class="headerlink" title="JDK动态代理逻辑分析"></a>JDK动态代理逻辑分析</h3><p>对于JDK动态代理，代理逻辑封装在<code>InvocationHandler</code>接口实现类的<code>invoke</code>中，而<code>JdkDynamicAopProxy</code>实现了<code>InvocationHandler</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">MethodInvocation invocation;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Object retVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line"><span class="comment">// in case it comes from a pool.</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取适合当前方法的拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;<span class="comment">// 如果拦截器链为空，则直接执行目标方法</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<span class="comment">// 通过反射执行目标方法</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个方法调用器，并将拦截器链传入其中</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// 执行拦截器链</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的主要流程如下：</p><ol><li>获取适合当前方法的拦截器（将advisor中的advice转成相应的拦截器）</li><li>如果拦截器链为空，则直接通过反射执行目标方法</li><li>否则，创建方法调用器<code>ReflectiveMethodInvocation</code>对象，将拦截器链传入其中</li><li>调用<code>ReflectiveMethodInvocation</code>对象的<code>proceed()</code>方法启动拦截器链</li><li>处理返回值，并返回该值</li></ol><p>其中，启动拦截器是核心步骤，<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法用于启动拦截器链，这里直接引用一副图很好的解释了拦截器链的执行过程：<br><img src="http://blog.default.nanwulife.com/15296571948329.jpg" alt=""></p><p>由上图可以看出，方法调用器每次调用下一个拦截器的<code>invoke</code>方法时，都会将自己作为参数传给该方法，并且通过方法调用器不断调用下一个拦截器，直到拦截器链中的最后一个拦截器执行完后，通过反射的方式执行目标方法，然后再返回到后置拦截器的方法中执行后置拦截器的一些逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是看了田小波博主的&lt;a href=&quot;www.tianxiaobo.com/2018/06/17/Spring-AOP-源码分析系列文章导
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ高级特性</title>
    <link href="http://yoursite.com/2019/04/26/RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/26/RabbitMQ高级特性/</id>
    <published>2019-04-26T05:03:00.000Z</published>
    <updated>2019-04-28T03:05:22.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息返回"><a href="#消息返回" class="headerlink" title="消息返回"></a>消息返回</h2><p><code>mandatory</code>和<code>immediate</code>是发布消息时的两个参数，它们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。<code>mandatory</code>参数告诉服务器该消息至少能路由到一个队列中，而<code>immediate</code>参数告诉服务器要投递的队列必须有消费者。</p><h3 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a>mandatory</h3><p>当<code>mandatory</code>参数设为<code>true</code>时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用<code>Basic.Return</code>命令将消息返回给生产者；当<code>mandatory</code>参数设置为<code>false</code>时，出现上述情形，则消息直接被丢弃。</p><p>对于没有被正确路由而返回给生产者的消息，可以通过给channel添加监听器获取到那些消息。</p><h3 id="immediate"><a href="#immediate" class="headerlink" title="immediate"></a>immediate</h3><p>当<code>immediate</code>参数设为<code>true</code>时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过<code>Basic.Return</code>命令返回给生产者。</p><p>RabbitMQ从3.0的版本开始去掉了对<code>immediate</code>参数的支持。</p><h3 id="备份交换器"><a href="#备份交换器" class="headerlink" title="备份交换器"></a>备份交换器</h3><p>生产者在发送消息的时候如果不设置<code>mandatory</code>参数，那么消息在未被路由的情况下将会丢失；如果设置了<code>mandatory</code>参数，那么需要添加监听器的编程逻辑，生产者的代码会很复杂。如果既不想丢失消息，也不想使代码复杂化，那么可以使用备份交换器，将未被路由的消息存储在RabbitMQ中，需要的时候再去处理。</p><p>备份交换器和普通的交换器没有什么太大的区别，声明一个备份交换器后，在声明普通交换器时添加<code>alternate-exchange</code>参数即可建立它们之间的联系。为了方便使用，备份交换器建议设置为fanout类型的。</p><p><img src="http://blog.default.nanwulife.com/20181207093904597.jpg" alt=""></p><h2 id="过期时间（TTL）"><a href="#过期时间（TTL）" class="headerlink" title="过期时间（TTL）"></a>过期时间（TTL）</h2><p>RabbitMQ可以对消息和队列设置TTL。</p><h3 id="设置消息的TTL"><a href="#设置消息的TTL" class="headerlink" title="设置消息的TTL"></a>设置消息的TTL</h3><p>如果不设置TTL，则表示此消息不会过期，而如果将TTL设置为0，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃。设置消息的TTL有两种方式：</p><ol><li>通过队列属性设置，此时队列中所有消息都有相同的过期时间。</li><li>对消息本身进行单独设置，每条消息的TTL可以不同。</li></ol><p>如果两种方法一起使用，则消息的TTL以两者之间较小的那个数值为准，消息在队列中的生存时间一旦超过设置的TTL时，就会变成死信。</p><p>还要注意的是，对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，因为队列中己过期的消息肯定在队列头部；而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。</p><h3 id="设置队列的TTL"><a href="#设置队列的TTL" class="headerlink" title="设置队列的TTL"></a>设置队列的TTL</h3><p>在声明队列时可以通过<code>x-expires</code>参数控制队列被自动删除前处于未使用状态的时间，未使用的意思是队列上没有任何消费者，队列也没有被重新声明，并且在过期时间段内也未调用过<code>Basic.Get</code>命令。队列的TTL不能像消息一样设置为0。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX（Dead-Letter-Exchange，死信交换器），绑定DLX的队列就称之为死信队列。消息变成死信一般是由于以下几种情况：</p><ul><li>消息被拒绝（<code>Basic.Reject</code> / <code>Basic.Nack</code>），并且设置<code>requeue</code>参数为<code>false</code></li><li>消息过期</li><li>队列达到最大长度值</li></ul><p>DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到死信队列中。</p><p><img src="http://blog.default.nanwulife.com/20181207094035629.png" alt=""></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列存储的对象是对应的延迟消息，即当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。RabbitMQ本身并没有直接支持延迟队列的功能，但是可以通过DLX和TTL模拟出延迟队列的功能。</p><p>生产者将消息发送到过期时间为n毫秒的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器转发到死信队列中，而消费者从死信队列中消费消息。这个时候就达到了“生产者发布了消息，过了n毫秒后消费者消费了消息”的延迟队列的效果。</p><p><img src="http://blog.default.nanwulife.com/20181207094103998.jpg" alt=""></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>可以将队列声明为优先级队列，即在创建队列的时候添加参数<code>x-max-priority</code>指定最大的优先级，值为0-255，此时的规则如下：</p><ul><li>优先级高的消息具备优先被消费的特权</li><li>没有指定优先级的消息会将优先级以0对待</li><li>对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待</li><li>对于相同优先级的消息，后进的排在前面</li></ul><p>如果在消费者的消费速度大于生产者的速度且Broker中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化用以解决因为服务器的异常崩溃导致的消息丢失。RabbitMQ的持久化分为交换器的持久化、队列的持久化和消息的持久化：</p><ul><li>交换器持久化：交换器的持久化是通过在声明交换器时将<code>durable</code>参数置为<code>true</code>实现的。</li><li>队列持久化：队列的持久化是通过在声明队列时将<code>durable</code>参数置为<code>true</code>实现的。如果队列不设置持久化，那么在RabbitMQ服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。但即使设置了该队列为持久化的，也不能保证内部存储的消息不会丢失。</li><li>消息持久化：要确保消息不会丢失，需要通过将消息的投递模式（<code>BasicProperties</code>中的<code>deliveryMode</code>属性）设置为2即可实现消息的持久化。</li></ul><p>就算将交换器、队列、消息都设置了持久化之后也不能百分百保证数据不会丢失。比如说消费者在订阅消费队列时将<code>autoAck</code>参数设置为<code>true</code>，那么当消费者接受到相关消息之后，还没来得及处理就宕机了，这样数据就丢失了。要解决这个问题可以将<code>autoAck</code>参数设置为<code>false</code>，并进行手动确认。</p><p>其次，在持久化的消息正确存入RabbitMQ之后，RabbitMQ并不会为每条消息都进行同步存盘（调用内核的<code>fsync</code>方法），此时仅仅保存到操作系统缓存之中，如果这时候发生了宕机，那么消息将会丢失。要解决这个问题可以使用RabbitMQ的镜像队列机制。</p><h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>当消息的生产者将消息发送出去之后，如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，这样生产者也就不知道消息有没有正确到达服务器。RabbitMQ针对这个问题，提供了两种解决方式：</p><ol><li>通过事务机制实现</li><li>通过发送方确认（publisher confirm）机制实现</li></ol><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>RabbitMQ客户端中与事务机制相关的方法有三个：<code>channel.txSelect</code>、<code>channel.txCommit</code>、<code>channel.txRollback</code>。其中<code>channel.txSelect</code>用于将当前的信道设置成事务模式，<code>channel.txCommit</code>用于提交事务，<code>channel.txRollback</code>用于事务回滚。</p><p>当开启事务并且提交成功，那么消息就一定到达了RabbitMQ中了，如果在事务提交之前由于RabbitMQ异常崩溃或者其它原因抛出异常，这个时候便可以将其捕获，进而通过执行<code>channel.txRollback</code>方法来实现事务回滚，与此同时可以进行消息重发。</p><h3 id="发送方确认机制"><a href="#发送方确认机制" class="headerlink" title="发送方确认机制"></a>发送方确认机制</h3><p>事务机制会严重降低RabbitMQ的消息吞吐量，而发送方确认机制则更加轻量级。</p><p>生产者通过<code>Confirm.Select</code>命令将信道设置成confirm（确认）模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），当消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（<code>Basic.ACK</code>）给生产者（包含消息的唯一ID），生产者可以通过回调方法来处理该确认消息。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。如果RabbitMQ因为内部错误导致消息丢失，就会发送一条<code>Basic.Nack</code>命令，生产者同样也可以在回调方法中处理该命令。</p><p>RabbitMQ回传给生产者的确认消息中的<code>deliveryTag</code>包含了确认消息的序号，此外RabbitMQ也可以设置<code>channel.basicAck</code>方法中的<code>multiple</code>参数（默认为<code>true</code>，也就是批量确认），表示到这个序号之前的所有消息都已经得到了处理。</p><p><img src="http://blog.default.nanwulife.com/1352849-20190223221457597-1239923675.png" alt=""></p><p>事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息。而发送方确认机制如果使用同步串行的编程方式实现，其实并没有比事务机制好多少，但是该机制的优势是在于并不一定需要同步确认，对此有以下两种改进方案：</p><ul><li>批量confirm方法：每发送一批消息后，调用<code>channel.waitForConfirms</code>方法，等待服务器的确认返回（该方法会阻塞到最后一条消息得到确认或者得到nack才结束）。</li><li>异步confirm方法：提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法进行处理。</li></ul><p>对于批量confirm方法，客户端程序需要定期或者定量（达到多少条），亦或者两者结合起来调用<code>channel.waitForConfirms</code>来等待RabbitMQ的确认返回，但是如果出现返回<code>Basic.Nack</code>或者超时情况时，客户端需要将这一批次的消息全部重发。</p><p>而对于异步confirm方法，它的编程比较复杂一些，但因为不会被阻塞，所以性能也略好一些。</p><h2 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h2><p>上面的生产者确认是保证生产者的消息正确的到达了服务器，而为了保证消息从队列可靠地到达消费者，消费者在订阅队列时可以指定<code>autoAck</code>参数，当<code>autoAck</code>等于<code>true</code>时，RabbitMQ会自动把发送出去的消息设置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费了这些消息；当<code>autoAck</code>为<code>false</code>时，RabbitMQ会等待消费者显示地回复确认信号后才从内存（或者磁盘）中移除消息。RabbitMQ不会为未确认的消息设置过期时间，除非消费此消息的消费者已经断开连接，此时RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者。</p><h3 id="消费者拒绝"><a href="#消费者拒绝" class="headerlink" title="消费者拒绝"></a>消费者拒绝</h3><p>在消费者接受到消息后，如果想明确拒绝当前的消息而不是确认，那么可以使用<code>Basic.Reject</code>命令，其中如果将参数<code>requeue</code>设置为<code>false</code>，则RabbitMQ立即会把消息从队列中删除，否则，RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者。</p><p><code>Basic.Reject</code>命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用<code>Basic.Nack</code>这个命令，将<code>multiple</code>设为<code>true</code>则表示拒绝<code>deliveryTag</code>编号之前所有未被当前消费者确认的信息。</p><blockquote><p>注意：如果<code>requeue</code>设置为<code>false</code>，那么可以启用死信队列的功能。</p></blockquote><p><code>Basic.Recover</code>命令用来请求RabbitMQ重新发送还未被确认的消息，也具备可重入队列的特性。如果将其参数<code>requeue</code>设置为<code>true</code>，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。如果将<code>requeue</code>参数设置为<code>false</code>，那么同一条消息会被分配给与之前相同的消费者。</p><h3 id="消息分发"><a href="#消息分发" class="headerlink" title="消息分发"></a>消息分发</h3><p>当RabbitMQ队列拥有多个消费者时，队列收到的消息将以轮询的分发方式发送给消费者，但轮询的分发机制在各台机器性能差异较大时效率很低，那么就可以使用<code>Basic.Qos</code>命令限制信道上的消费者所能保持的最大未确认消息的数量，此时RabbitMQ会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ就不会向这个消费者再发送任何消息，直到消费者确认了某条消息后，RabbitMQ将相应的计数减一，之后消费者才可以继续接收消息。</p><h2 id="可靠性总结"><a href="#可靠性总结" class="headerlink" title="可靠性总结"></a>可靠性总结</h2><p>为了提升数据的可靠性，从上文分析可以总结出以下几个途径：</p><ul><li>设置<code>mandatory</code>参数或者备份交换器来处理未能正确路由到队列的消息。</li><li>设置事务机制或者publisher confirm机制保证生产者的消息正确的到达了RabbitMQ。</li><li>设置交换器、队列和消息为持久化。</li><li>设置消费端对应的<code>autoAck</code>参数为<code>false</code>，在消费完消息后手动确认。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li><li><a href="https://dbaplus.cn/news-159-2326-1.html" target="_blank" rel="noopener">玩转不同业务场景，这些RabbitMQ特性会是得力助攻</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息返回&quot;&gt;&lt;a href=&quot;#消息返回&quot; class=&quot;headerlink&quot; title=&quot;消息返回&quot;&gt;&lt;/a&gt;消息返回&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mandatory&lt;/code&gt;和&lt;code&gt;immediate&lt;/code&gt;是发布消息时的两个参数，它们都有当
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ基本概念</title>
    <link href="http://yoursite.com/2019/04/26/RabbitMQ%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/04/26/RabbitMQ基本概念/</id>
    <published>2019-04-26T02:12:00.000Z</published>
    <updated>2019-04-26T04:50:28.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>RabbitMQ整体上是一个生产者-消费者模型，主要负责接收、存储和转发消息。整体架构如下：</p><p><img src="http://blog.default.nanwulife.com/rabbitmq_example.png" alt=""></p><p>这里省略生产者、消费者等最基础的概念，主要介绍队列、交换器、路由键等。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（Queue）是RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一个队列，这时队列中的消息会被分摊（轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><h2 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h2><p>生产者不是直接将消息发送到队列中，而是发送给交换器（Exchange），由交换器将消息路由到一个或者多个队列中。交换器主要有fanout、direct、topic、headers四种类型：</p><ul><li>fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li><li>direct：它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。</li><li>topic：对direct类型的扩展，允许BindingKey和RoutingKey不严格的匹配它约定：<ul><li>RoutingKey和BindingKey为一个点号<code>.</code>分隔的字符串，如<code>com.rabbitmq.client</code></li><li>BindingKey中可以存在两种特殊字符串<code>*</code>和<code>#</code>，用于做模糊匹配，其中<code>*</code>用于匹配一个单词，<code>#</code>用于匹配多规格单词（可以是零个）。</li></ul></li><li>headers：headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。这个类型基本不会使用。</li></ul><h2 id="路由键"><a href="#路由键" class="headerlink" title="路由键"></a>路由键</h2><p>生产者将消息发送给交换器的时候一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效。这里要注意BindingKey并不是所有情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视BindingKey，而是将信息路由到所有绑定到该交换器的队列中。</p><h2 id="Connection与Channel"><a href="#Connection与Channel" class="headerlink" title="Connection与Channel"></a>Connection与Channel</h2><p>无论是生产者还是消费者，都需要和RabbitMQ Broker建立连接，这个连接就是一条TCP连接，也就是Connection。一旦TCP连接建立起来，客户端紧接着可以创建一个AMQP信道（Channel），每个信道都会被指派一个唯一的ID，它是建立在Connection之上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。</p><p><img src="http://blog.default.nanwulife.com/connection_channel.png" alt=""></p><p>因为操作系统建立和销毁TCP连接是非常昂贵的开销，所以RabbitMQ采用TCP连接复用的方式，减少性能开销。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot; class=&quot;headerlink&quot; title=&quot;基本架构&quot;&gt;&lt;/a&gt;基本架构&lt;/h2&gt;&lt;p&gt;RabbitMQ整体上是一个生产者-消费者模型，主要负责接收、存储和转发消息。整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门：单线程及五大数据类型</title>
    <link href="http://yoursite.com/2019/04/21/Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/04/21/Redis五大数据类型及应用场景/</id>
    <published>2019-04-21T07:29:00.000Z</published>
    <updated>2019-04-21T09:57:32.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么Redis是单线程的</h2><p>首先对于Redis的网络通信模块，它是基于I/O多路复用模型实现的，也就是说只使用一个线程就可以处理多个连接，避免了传统方案使用多线程处理多条连接时的上下文切换开销。而对于命令的执行，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，单线程的处理效率就是最高的，使用多线程反而会增大切换开销，并且引入线程安全的问题，因此Redis使用单线程的方案。</p><p>那什么时候应该使用多线程呢？其实对于类似磁盘I/O读写的操作，如果使用单线程执行，当耗时较长时，后面的所有其它请求都会被阻塞在这，这时候就可以使用新的线程去异步的处理之后的一些请求，提高系统的性能。</p><h2 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h2><ul><li>Redis是基于内存的操作</li><li>Redis底层使用C语言实现，效率更高</li><li>Redis使用I/O多路复用，不像传统方案开多个线程处理多个I/O，大大降低了线程切换的开销</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是最基础的类型，字符串长度不能超过512MB。常用的API有如下几个：</p><ul><li><code>get key</code>：获取一个<code>key</code>的<code>value</code></li><li><code>set key value</code>：设置一个<code>key</code>的<code>value</code></li><li><code>del key</code>：删除一个<code>key</code></li><li><code>incr key</code>：<code>key</code>自增1，如果<code>key</code>不存在，自增后<code>key</code>的<code>value</code>为1</li><li><code>decr key</code>：<code>key</code>自减1，如果<code>key</code>不存在，自减后<code>key</code>的<code>value</code>为-1</li><li><code>incrby key k</code>：<code>key</code>自增k，如果<code>key</code>不存在，自增后<code>key</code>的<code>value</code>为k</li><li><code>set key value</code>：不管<code>key</code>是否存在，都设置<code>value</code></li><li><code>setnx key value</code>：当<code>key</code>不存在时才设置<code>value</code></li><li><code>mget key1 key2 key3...</code>：批量获取<code>key</code>，原子操作</li><li><code>mset key1 value1 key2 value2 key3 value3</code>：批量设置<code>key</code>的<code>value</code></li></ul><p>适用场景：</p><ul><li>记录某个用户的页面访问量：<code>incr userid:pageview</code></li><li>实现分布式锁</li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希可以理解为Map中的Map，因为它每个key对应的value都是一个Map结构，每个field不能相同，但value可以相同。常用的API有如下几个：</p><ul><li><code>hget key field</code>：获取<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hgetall key</code>：返回<code>key</code>对应所有的<code>field</code>和<code>value</code></li><li><code>hset key field value</code>：设置<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hdel key field</code>：删除<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hmget key field1 field2 ... fieldN</code>：批量获取<code>key</code>的一批<code>field</code>对应的<code>value</code></li><li><code>hmset key field1 value1 field2 value2 ... fieldN valueN</code>：批量设置<code>key</code>的一批<code>field</code>对应的<code>value</code></li></ul><p>要注意的是，哈希结构无法针对某个指定的<code>field</code>设置超时时间，TTL不好控制。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）用来存储多个有序（插入顺序）的字符串，每个字符串称为元素，并且元素是可以重复的。常用的API有如下几个：</p><ul><li><code>rpush key value1 value2 ... valuen</code>：从列表右端插入元素</li><li><code>lpush key value1 value2 ... valuen</code>：从列表左端插入元素</li><li><code>linsert key before|after value newValue</code>：在某个<code>key</code>下的<code>list</code>指定的<code>value</code>前|后插入<code>newValue</code></li><li><code>lpop key</code>：从列表左侧弹出一个元素</li><li><code>rpop key</code>：从列表右侧弹出一个元素</li><li><code>lrem key count value</code>：根据<code>count</code>的值，从列表中删除所有<code>value</code>相等的元素。当<code>count</code> &gt; 0时，从左到右删除最多<code>count</code>个<code>value</code>相等的元素；当<code>count</code> &lt; 0时，从右到左删除最多<code>Math.abs(count)</code>个<code>value</code>相等的元素；当<code>count</code> = 0时，删除所有<code>value</code>相等的元素。</li><li><code>ltrim key start end</code>：按照索引范围修剪列表，即删除索引范围之外的元素</li><li><code>lrange key start end</code>：获取列表索引范围内的所有元素，包含<code>end</code></li><li><code>blpop key timeout</code>：<code>lpop</code>阻塞版本，<code>timeout</code>是阻塞超时时间，<code>timeout</code>为0表示永不阻塞</li><li><code>brpop key timeout</code>：<code>rpop</code>阻塞版本，<code>timeout</code>是阻塞超时时间，<code>timeout</code>为0表示永不阻塞</li></ul><p>适用场景：</p><ul><li>用户动态的时间轴：当用户更新动态的时候可以使用<code>lpush</code>命令加入列表，使用<code>lrange</code>命令展示一定数量的动态，并且使用<code>ltrim</code>限制动态的数量。</li><li>使用<code>lpush</code> + <code>lpop</code>实现一个栈，使用<code>lpush</code> + <code>rpop</code>实现一个队列。</li><li>使用<code>lpush</code> + <code>brpop</code>实现一个消息队列。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）与列表类似，都是用来保存多个字符串，但集合中的元素是无序的，因此不能通过索引来操作元素，并且集合中的元素不能有重复。常用的API有如下几个：</p><ul><li><code>sadd key element</code>：向<code>key</code>添加<code>element</code>，如果<code>element</code>已经存在，则添加失败</li><li><code>srem key element</code>：将<code>key</code>中的<code>element</code>移除掉</li><li><code>sinter key1 key2</code>：取交集</li><li><code>sdiff key1 key2</code>：取差集</li><li><code>sunion key1 key2</code>：取并集</li><li><code>scard key</code>：返回集合中元素的数量</li><li><code>sismember key member</code>：判断集合<code>key</code>中是否存在<code>member</code></li><li><code>spop key</code>：从集合中随机弹出一个元素</li></ul><p>适用场景：</p><ul><li>使用<code>sadd</code>命令给用户添加标签，或者给标签添加用户，通过<code>sinter</code>命令实现共同关注等功能。</li></ul><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>有序集合与集合一样，元素都不能重复，但有序集合中的元素是有顺序的，与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。常用的API有如下几个：</p><ul><li><code>zadd key score element</code>：添加<code>score</code>和<code>element</code>，<code>score</code>是可以重复的，但<code>element</code>是不能重复的。</li><li><code>zrem key element</code>：删除元素<code>element</code></li><li><code>zscore key element</code>：返回元素<code>element</code>的分数<code>score</code></li><li><code>zincrby key increScore element</code>：增加或减少元素<code>element</code>的分数<code>score</code></li><li><code>zcard key</code>：返回元素的总个数</li><li><code>zrange key start end [WITHSCORES]</code>：返回指定索引范围内的升序元素（相当于排名）</li><li><code>zrangebyscore key minScore maxScore [WITHSCORES]</code>：返回指定分数范围内的升序元素</li><li><code>zcount key minScore maxScore</code>：返回有序集合内在指定分数范围内的个数</li></ul><p>适用场景：</p><ul><li>排行榜：可以将销售量、关注人数、时间戳作为<code>score</code>进行元素的排序</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么Redis是单线程的&quot;&gt;&lt;a href=&quot;#为什么Redis是单线程的&quot; class=&quot;headerlink&quot; title=&quot;为什么Redis是单线程的&quot;&gt;&lt;/a&gt;为什么Redis是单线程的&lt;/h2&gt;&lt;p&gt;首先对于Redis的网络通信模块，它是基于I/O多路
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Pipeline</title>
    <link href="http://yoursite.com/2019/04/21/Redis-%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2019/04/21/Redis-管道/</id>
    <published>2019-04-21T06:28:00.000Z</published>
    <updated>2019-04-21T07:13:14.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>Redis客户端执行一条命令分为以下四个步骤:</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>其中，第一步加第四步称为Round Trip Time（RTT，往返时间）。</p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>Redis提供了批量操作命令（例如<code>mget</code>、<code>mset</code>等），有效的节约了RTT，但大部分命令是不支持批量操作的。由于Redis命令执行本身是很快的（微妙级别），而发送命令以及返回结果的网络耗时往往更大，所以说Redis的性能瓶颈其实是网络。</p><h2 id="Pipeline机制"><a href="#Pipeline机制" class="headerlink" title="Pipeline机制"></a>Pipeline机制</h2><p>Pipeline机制能改善上面这类问题，它能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令按照顺序执行并装填结果返回给客户端。</p><p>Pipeline虽然好用，但是每次Pipeline组装的命令个数不能没有节制，否则一次组装Pipeline数据量过大，一方面会增加客户端的等待时机，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p><h2 id="对比原生批量命令"><a href="#对比原生批量命令" class="headerlink" title="对比原生批量命令"></a>对比原生批量命令</h2><ul><li>原生批量命令是原子性，Pipeline是非原子性的。</li><li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li><li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端与客户端的共同实现。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/yixianyixian/p/8353563.html" target="_blank" rel="noopener">redis学习笔记 - Pipeline与事务</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h2&gt;&lt;p&gt;Redis客户端执行一条命令分为以下四个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送命令&lt;/li&gt;
&lt;li&gt;命令排队&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="http://yoursite.com/2019/04/21/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/04/21/Redis实现分布式锁/</id>
    <published>2019-04-21T03:03:00.000Z</published>
    <updated>2019-04-21T06:23:57.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h2><p>下面的加锁操作直接使用一条原子命令即可，而解锁操作需要用到Lua脚本保证原子性，该实现只适用于在单节点上操作。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>加锁可以使用Redis提供的一条原子命令完成：<code>SET key value NX PX 30000</code>。</p><p>这里对其中的一些参数做一些解释：</p><ul><li><code>key</code>：我们使用key来当锁，因为key是唯一的。</li><li><code>value</code>：为保证可靠性，加锁和解锁要是同一个客户端，客户端自己不能把别人加的锁给解了。所以这里<code>value</code>可用于标识客户端，解锁时需要进行比较。</li><li><code>NX</code>：当key不存在时才进行set操作，若key已经存在，则不做任何操作。这个参数保证了只有一个人能拿到锁。</li><li><code>PX</code>：这里其实可以传入<code>EX</code>或<code>PX</code>，主要目的是设置一个过期时间，锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</li></ul><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>为确保原子性，这里使用Lua脚本实现Redis分布式锁的解锁操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>实现的关键在于一定要先比较<code>value</code>是否相等，这也是上面加锁时提到的客户端自己不能把别人加的锁给解了，如果是同一个客户端那么就直接将<code>key</code>删除即可。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>事实上，上面的分布式锁实现在Redis单机部署的场景下工作是没问题的。但是如果Redis有多个节点的话，加锁就只能作用在一个Redis节点上，即使使用了哨兵或者集群方案保证高可用，如果master节点由于某些原因发生了主从切换，依然会出现锁丢失的情况：</p><ol><li>在Redis的master节点上获取到锁</li><li>这个锁的key还没来得及同步到slave节点</li><li>master故障，发生故障转移，slave节点升级为master节点</li><li>导致锁丢失</li></ol><h2 id="Redlock实现"><a href="#Redlock实现" class="headerlink" title="Redlock实现"></a>Redlock实现</h2><p>由于上述的分布式锁只适用于单机环境，Redis作者基于分布式环境提出了一种更高级的实现方式：Redlock。</p><p>在Redis的分布式环境中，我们假设有N个Redis master节点，这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁，我们确保将在每个实例上使用此方法获取和释放锁。这里假设有5个Redis master节点，并且运行在5台不同的服务器上以保证他们不会同时都宕掉。以下为加锁操作：</p><ol><li>首先获取当前的本地时间</li><li>使用相同的key和value依次尝试在5个实例上申请锁。在获得锁的过程中，为每一个锁操作设置一个快速失败时间（如果想要获得一个10秒的锁，那么每一个锁操作的失败时间设为5-50ms）。这样可以避免客户端与一个已经故障的master节点通信占用太长时间，通过快速失败的方式尽快与集群中的其他节点完成锁操作。</li><li>客户端计算出与master获得锁操作过程中消耗的时间（即当前时间减去第一步记录的时间），当且仅当客户端获得锁的过程中消耗的时间小于锁的存活时间，并且在一半以上的master节点中都获得锁，才认为client成功的获得了锁。</li><li>如果已经获得了锁，客户端执行任务的有效时间是锁的存活时间减去获得锁的过程中所消耗的时间。</li><li>如果客户端获得锁的数量不足一半以上，或获得锁的时间超时，那么认为获得锁失败，客户端应尽快地释放（部分）已经成功取到的锁，这样其他的客户端就不必非得等到锁过完有效时间才能取到。</li></ol><p>这个算法的核心思想其实在于只可能有一个客户端能获取到大部分master节点中的锁，也就避免了多个客户端都能获取到锁的情况。对于释放锁来说，过程就相对简单一些了：向所有的Redis实例发送释放锁命令即可，不用关心之前有没有从Redis实例成功获取到锁。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.redis.cn/topics/distlock.html" target="_blank" rel="noopener">Redis分布式锁</a></li><li><a href="http://cmsblogs.com/?p=3266#Redlock-2" target="_blank" rel="noopener">Redlock：Redis分布式锁最牛逼的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;普通实现&quot;&gt;&lt;a href=&quot;#普通实现&quot; class=&quot;headerlink&quot; title=&quot;普通实现&quot;&gt;&lt;/a&gt;普通实现&lt;/h2&gt;&lt;p&gt;下面的加锁操作直接使用一条原子命令即可，而解锁操作需要用到Lua脚本保证原子性，该实现只适用于在单节点上操作。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>String源码分析</title>
    <link href="http://yoursite.com/2019/04/20/String%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/04/20/String源码分析/</id>
    <published>2019-04-20T04:17:00.000Z</published>
    <updated>2019-04-21T11:32:45.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String-简介"><a href="#String-简介" class="headerlink" title="String 简介"></a>String 简介</h2><p><code>String</code>实例是常量，一旦创建后就不能再修改其值。以下为它的继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><img src="http://blog.default.nanwulife.com/String%20UML.png" alt=""></p><p>可以看出<code>String</code>实现了<code>Serializable</code>、<code>CharSequence</code>、<code>Comparable</code>接口，其中<code>CharSequence</code>主要提供一些对字符序列的只读访问，许多类如<code>StringBuilder</code>、<code>StringBuffer</code>也都实现了此接口，里面就只有几个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>String</code>类通过<code>final</code>修饰，不可被继承，同时<code>String</code>底层的字符数组也是被<code>final</code>修饰的，<code>char</code>属于基本数据类型，一旦被赋值之后也是不能被修改的，所以<code>String</code>是不可变的。这里对<code>final</code>做一个简单的总结：</p><ul><li>修饰类：当用<code>final</code>修饰一个类时，表明这个类不能被继承。也就是说，<code>String</code>类是不能被继承的，</li><li>修饰方法：把方法锁定，以防任何继承类对其覆盖。</li><li>修饰变量：修饰基本数据类型变量，则其数值一旦在初始化之后便不能更改；修饰引用类型变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];<span class="comment">// String的核心，用final修饰，无法再被修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值，默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>String</code>有很多重载的构造方法，介绍如下：</p><ol><li><p>空参数构造方法，初始化字符串实例，默认为空字符，理论上不需要用到这个构造方法，实际上定义一个空字符<code>String = &quot;&quot;</code>就会初始化一个空字符串的<code>String</code>对象，而此构造方法，也是把空字符的<code>value[]</code>拷贝一遍而已，源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过一个字符串参数构造<code>String</code>对象，实际上将形参的<code>value</code>和<code>hash</code>赋值给实例对象作为初始化，相当于深拷贝了一个形参<code>String</code>对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过字符数组去构建一个新的<code>String</code>对象，这里使用<code>Arrays.copyOf</code>方法拷贝字符数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在源字符数组基础上，通过偏移量（起始位置）和字符数量，截取构建一个新的<code>String</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果偏移量小于0，则抛出越界异常</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果字符数量小于0，则抛出越界异常</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在截取的字符数量为0的情况下，偏移量在字符串长度范围内，则返回空字符</span></span><br><span class="line">            <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">                <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">        <span class="comment">//如果偏移量大于字符总长度-截取的字符长度，则抛出越界异常</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用Arrays.copyOfRange静态方法，截取一定范围的字符数组，从offset开始，长度为offset+count，赋值给当前实例的字符数组</span></span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过源字节数组，按照一定范围，从<code>offset</code>开始截取<code>length</code>个长度，初始化<code>String</code>实例，同时可以指定字符编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="comment">//字符编码参数为空，抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    <span class="comment">//静态方法 检查字节数组的索引是否越界</span></span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="comment">//使用 StringCoding.decode 将字节数组按照一定范围解码为字符串，从offset开始截取length个长度</span></span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>StringBuffer</code>构建成一个新的<code>String</code>，比较特别的就是这个方法有<code>synchronized</code>锁，同一时间只允许一个线程对这个<code>StringBuffer</code>构建成<code>String</code>对象，所以是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对当前 StringBuffer 对象加同步锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="comment">//拷贝 StringBuffer 字符数组给当前实例的字符数组</span></span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>StringBuilder</code>构建成一个新的<code>String</code>，与另一个构造器不同的是，此构造器不是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="value相关"><a href="#value相关" class="headerlink" title="value相关"></a>value相关</h3><ol><li><p>获取字符串长度，实际上是获取字符数组长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断字符串是否为空，实际上是判断字符数组长度是否为0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据索引参数获取字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//索引小于0或者索引大于字符数组长度，则抛出越界异常</span></span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回字符数组指定位置字符</span></span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><p>实现了<code>Comparable</code>接口的<code>compareTo</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出该方法实现还是比较简单的，直接逐个比较每个字符是否相等，如果其中某个字符不相等就直接返回结果，否则比较它们的长度。</p><h3 id="equals与hashCode"><a href="#equals与hashCode" class="headerlink" title="equals与hashCode"></a>equals与hashCode</h3><p><code>equals</code>方法首先判断两个对象的地址是否相等，如果不等再判断对象是否为<code>String</code>类型，如果是的话再比较它们的长度与值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先判断地址是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要比较的对象是否为 String 类型</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="comment">// 比较两个字符串的长度</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 逐个比较两个字符串中每个字符是否相等</span></span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashCode</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为在大多数构造函数中，其实并没有设置成员变量<code>hash</code>的值，默认值是为0的，因此调用此方法会根据<code>value</code>数组重新计算哈希值，并赋给成员变量<code>hash</code>，下次就可以直接拿到该哈希值了。这里还有一行<code>h = 31 * h + val[i];</code>比较特别，它其实可以推导成一个公式：<code>val[0]*31^(n-1) + val[1]*31^(n-2) + ... + val[n-1]</code>，这里之所以要取31这个数字，原因如下：</p><blockquote><p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：<code>31 * i == (i &lt;&lt; 5) - i</code>，现代的 Java 虚拟机可以自动的完成这个优化。</p></blockquote><p>具体可以参考这篇文章：<a href="https://www.tianxiaobo.com/2018/01/18/String-hashCode-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/" target="_blank" rel="noopener">String hashCode 方法为什么选择数字31作为乘子</a></p><h3 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h3><p>在Java中有8种基本类型和一种比较特殊的类型<code>String</code>，这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。8种基本类型的常量池都是系统协调的，<code>String</code>类型的常量池比较特殊，它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li><li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。<code>intern</code>方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</li></ul><p>关于这个方法网上的解释有很多，但大多都比较混乱，我暂时还没有整理清楚，日后回来填坑。</p><h2 id="String对-的重载"><a href="#String对-的重载" class="headerlink" title="String对 + 的重载"></a>String对 + 的重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String apple = <span class="string">"Apple,"</span>;</span><br><span class="line">        String fruit = apple + <span class="string">"Pear,"</span> + <span class="string">"Orange"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在执行上述代码的时候会自动引入<code>StringBuilder</code>类。虽然在上面的代码中我们并没有使用到<code>StringBuilder</code>类，但是编译器却自动引入了它，因为它更高效。编译器首先会创建一个<code>StringBuilder</code>对象，用来构造最终要生成的<code>String</code>，并为每一个字符串调用一次<code>StringBuilder</code>中的<code>append()</code>方法，因此上述代码一共执行了三次<code>append()</code>方法，最后调用<code>toString</code>生成最终的结果，并保存为<code>fruit</code>。</p><p>但是我们不能认为编译器已经帮我们做了优化，我们就可以随意的使用<code>String</code>对象，下面是两种方法生成一个<code>String</code>，一个方法使用了<code>String</code>对象，另一个使用了<code>StringBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString1</span><span class="params">(String[] strArray)</span></span>&#123;</span><br><span class="line">       String result = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)</span><br><span class="line">           result += strArray[i];</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString2</span><span class="params">(String[] strArray)</span></span>&#123;</span><br><span class="line">       StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)</span><br><span class="line">           result.append(strArray[i]);</span><br><span class="line">       <span class="keyword">return</span> result.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面两个方法都是用来对一个数组中的数据进行连接并返回一个<code>String</code>对象，但是需要我们注意的是<code>getString1</code>方法是在循环内部构造<code>StringBuilder</code>对象的，这意味着每循环一次就会创建一个新的<code>StringBuilder</code>对象。</p><p><code>getString2</code>方法只生成了一个<code>StringBuilder</code>对象，这样更简单更高效的实现了同<code>getString1</code>一样的功能。所以在我们使用<code>String</code>对象时，最好考虑一下是否可以用<code>StringBuilder</code>对象更高效的实现我们想要的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>String</code>类被修饰符<code>final</code>修饰是无法被继承的，而它内部的关键成员变量<code>char value[]</code>同样也是被<code>final</code>修饰不能更改的，因此<code>String</code>是不可变的。</li><li><code>String</code>实现了<code>Serializable</code>接口，可以被序列化；实现了<code>Comparable</code>接口，可用于比较大小；实现了<code>CharSequence</code>，实现了通用的字符序列的只读方法。</li><li><code>String</code>重载了+运算符，会创建一个<code>StringBuilder</code>对象并调用其<code>append()</code>实现字符串拼接。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java 编程思想》Bruce Eckel 著 陈昊鹏 译</li><li><a href="https://juejin.im/post/5c2588d8f265da6110371d2b#heading-3" target="_blank" rel="noopener">String 源码浅析(一)</a></li><li><a href="https://juejin.im/post/59fffddc5188253d6816f9c1#heading-17" target="_blank" rel="noopener">String源码分析</a></li><li><a href="https://www.tianxiaobo.com/2018/01/18/String-hashCode-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/" target="_blank" rel="noopener">String hashCode 方法为什么选择数字31作为乘子</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;String-简介&quot;&gt;&lt;a href=&quot;#String-简介&quot; class=&quot;headerlink&quot; title=&quot;String 简介&quot;&gt;&lt;/a&gt;String 简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;实例是常量，一旦创建后就不能再修改其值。以下为
      
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存设计与优化</title>
    <link href="http://yoursite.com/2019/03/31/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/31/Redis缓存设计与优化/</id>
    <published>2019-03-31T12:28:00.000Z</published>
    <updated>2019-03-31T14:45:22.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>Redis过期策略是：定期删除+惰性删除。</p><p>所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置了过期时间的key（全部都检查的话十分消耗CPU资源），检查其是否过期，如果过期了就删除。但仅依赖此策略会有许多过期的key未被检查到，因此Redis还使用惰性删除策略，即在读/写key的时候再检查其是否过期，如果过期了则删除。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果某些key没有被定期删除，也没及时去读/写以触发惰性删除，那么Redis的内存会越来越高，当已用内存超过<code>maxmemory</code>限定时，就会根据内存淘汰机制删除部分key。Redis内存淘汰机制有以下几个：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>一般的缓存系统，都是根据key去缓存查询，如果不存在对应的value，就应该去数据库查找。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对数据库造成很大的压力，这就叫做缓存穿透。</p><p>第一个解决办法是对查询结果为空的键也进行缓存，由于这种方式需要更多的键，所以可以设置一个短一点的过期时间。</p><p>第二个解决方案则是使用布隆过滤器拦截。布隆过滤器的原理是，当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位数组中的K个点，并把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素有可能在。</p><p><img src="http://blog.default.nanwulife.com/booleanfilter.png" alt=""></p><p>通过布隆过滤器，一个一定不存在的数据会被它拦截掉，从而避免了对数据库的查询压力。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，所有请求都会查询数据库，也会给数据库带来很大压力，这就叫做缓存雪崩。对于缓存雪崩有以下几种解决方案：</p><ul><li>可以给缓存设置过期时间时加上一个随机时间，使得每个key的过期时间分散开来，不会集中在同一时刻失效。</li><li>进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li><li>使用分布式缓存。</li><li>提前演练。</li></ul><h2 id="热点key重建"><a href="#热点key重建" class="headerlink" title="热点key重建"></a>热点key重建</h2><p>当前key是一个热点key（比如说某个热门的娱乐新闻），如果在缓存失效时有大量线程并发请求，那么这些线程会同时去访问数据库并重建key，导致后端系统负载过大，甚至因此崩溃。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180629202036949-8223995.png" alt=""></p><p>为此有以下几种解决方案：</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>可以使用互斥锁的方式实现，直接利用redis的<code>set</code>命令即可（如<code>SET mutexKey &quot;1&quot; EX 10086 NX</code>），为了防止该锁未被正确释放，还应给该锁设置一个过期时间。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703003410961-1677269917.png" alt=""></p><p>这种方式的缺点在于重建的过程中别的线程都会处于等待状态，整体性能不高。</p><h3 id="永远不过期"><a href="#永远不过期" class="headerlink" title="永远不过期"></a>永远不过期</h3><p>我们不为每个key设置一个过期时间，但会添加一个逻辑过期时间属性，每次去读的时候都判断一下当前时间是否已经大于逻辑过期时间，如果是的话就使用单独的线程去构建缓存。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703004145474-1329843618.png" alt=""></p><p>这种方式的缺点在于缓存的构建是异步的，因此别的线程在这个过程中依然会取到老值，不保证数据的一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">缓存穿透与缓存雪崩</a></li><li><a href="https://blog.csdn.net/fouy_yun/article/details/81075432" target="_blank" rel="noopener">分布式缓存击穿（布隆过滤器 Bloom Filter）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过期策略&quot;&gt;&lt;a href=&quot;#过期策略&quot; class=&quot;headerlink&quot; title=&quot;过期策略&quot;&gt;&lt;/a&gt;过期策略&lt;/h2&gt;&lt;p&gt;Redis过期策略是：定期删除+惰性删除。&lt;/p&gt;
&lt;p&gt;所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster</title>
    <link href="http://yoursite.com/2019/03/31/Redis-Cluster/"/>
    <id>http://yoursite.com/2019/03/31/Redis-Cluster/</id>
    <published>2019-03-31T05:21:00.000Z</published>
    <updated>2019-03-31T12:22:57.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster作用"><a href="#Redis-Cluster作用" class="headerlink" title="Redis Cluster作用"></a>Redis Cluster作用</h2><p>Redis Cluster是Redis 3.0开始引入的分布式存储方案，集群由多个节点组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制。集群的作用，可以归纳为两点：</p><ul><li>数据分片：集群将数据分散到多个节点，突破了Redis单机内存大小的限制，存储容量大大增加。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。</li></ul><h2 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h2><p>常见的哈希分区方案包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。</p><ul><li>哈希取余分区：哈希取余分区思路非常简单，首先计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</li><li>一致性哈希分区：一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，范围为<code>0 ~ 2^32-1</code>。对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。<br><img src="http://blog.default.nanwulife.com/U%7BKC_N~EU%5DO%5B9_%7B3KK03U58.png" alt=""></li><li>一致性哈希分区（虚拟节点机制）：普通的一致性哈希在服务器节点数量较少时容易产生数据倾斜问题，各个服务器的负载不均匀。为解决这个问题，引入了虚拟节点机制，每台机器可以负责更多节点，数据负担更加均匀。<br><img src="http://blog.default.nanwulife.com/Y90YE9D$%29CU%7B6AA%604QP~VEB.png" alt=""></li><li>虚拟槽分区：Redis Cluser底层使用的虚拟槽分区，有一个长度为16384的虚拟槽，每个Master节点都会负责一部分的槽，Redis对key计算哈希值，使用的算法是CRC16，然后根据哈希值计算数据属于哪个槽，最后根据槽与节点的映射关系，计算数据属于哪个节点。其中哪个节点负责哪个槽，这是可以由用户指定的。<br><img src="http://blog.default.nanwulife.com/1174710-20181025213453407-302249562.png" alt=""></li></ul><h2 id="节点通信机制"><a href="#节点通信机制" class="headerlink" title="节点通信机制"></a>节点通信机制</h2><h3 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h3><p>在redis sentinel中，节点分为数据节点和sentinel节点：前者存储数据，后者实现额外的控制功能。在redis cluster中，没有数据节点与非数据节点之分，所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点都提供了两个TCP端口，普通端口主要用于为客户端提供服务，集群端口用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信。</p><h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>Gossip过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p><img src="http://blog.default.nanwulife.com/v2-575e785e7d03ad317e5bce4e36debb03_b.gif" alt=""></p><p>Gossip协议的优点：</p><ul><li>负载低：比广播低，广播每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li><li>去中心化：Gossip协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li><li>容错性高：网络中任何节点的宕机和重启都不会影响Gossip消息的传播，Gossip协议具有天然的分布式系统容错特性。<br>Gossip协议的缺点：</li><li>消息的延迟：由于节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用Gossip协议会造成不可避免的消息延迟，不适合用在对实时性要求较高的场景下。</li></ul><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>集群节点间发送的消息有以下几种类型：</p><ul><li>meet：在节点握手阶段，当节点收到客户端的<code>cluster meet</code>命令时，会向新加入的节点发送meet消息，请求新节点加入到当前集群，新节点收到meet消息后会回复一个pong消息。</li><li>ping：集群里每个节点每秒钟会选择部分节点发送ping消息，接收者收到消息后会回复一个pong消息。ping消息使用Gossip协议发送，内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。</li><li>pong：pong消息封装了自身状态数据，可以分为两种：第一种是在接到meet/ping消息后回复的pong消息，第二种是指节点向集群广播pong消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播pong消息。</li><li>fail：当一个主节点判断另一个主节点客观下线后，会向集群广播这一fail消息，通知集群中所有节点标记故障节点为客观下线，并通知故障节点的从节点触发故障转移流程。</li><li>publish：节点收到publish命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该publish命令。</li></ul><h2 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h2><h3 id="moved重定向"><a href="#moved重定向" class="headerlink" title="moved重定向"></a>moved重定向</h3><p>moved异常代表槽已经确认迁移至别的节点。</p><p><img src="http://blog.default.nanwulife.com/1.png" alt=""><br><img src="http://blog.default.nanwulife.com/3.png" alt=""></p><h3 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h3><p>在集群缩容扩容的时候，要对槽进行迁移，在迁移的过程中访问一个key，但是key已经迁移到目标节点，那么就会返回一个ask异常。</p><p><img src="http://blog.default.nanwulife.com/6.png" alt=""></p><h3 id="Smart-Client"><a href="#Smart-Client" class="headerlink" title="Smart Client"></a>Smart Client</h3><p>redis-cli这一类客户端称为Dummy客户端，因为它们在执行命令前不知道数据在哪个节点上，因此需要借助moved异常重定向。为了追求性能，我们不可能每次都随机访问一个节点，再根据moved或ask异常去重定向到目标节点，因此需要实现一个Smart客户端，比如说JedisCluster。JedisCluster的基本原理大致如下：</p><ol><li>从集群中选一个可运行节点，使用<code>cluster slots</code>命令并将结果映射到本地，这样本地就有了slot-&gt;node的映射关系缓存。</li><li>JedisCluster为每个节点创建连接池(即JedisPool)。</li><li>当执行命令时，JedisCluster根据key-&gt;slot-&gt;node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现moved错误时，刷新本地的映射关系缓存。</li></ol><p>这里需要注意的是，JedisCluster中已经包含所有节点的连接池，因此JedisCluster要使用单例。</p><h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>集群伸缩的核心是槽迁移，通过修改槽与节点的对应关系，实现槽（即数据）在节点之间的移动。例如，如果槽均匀分布在集群的3个节点中，此时增加一个节点，则需要从3个节点中分别拿出一部分槽给新节点，从而实现槽在4个节点中的均匀分布。</p><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><ol><li>启动节点</li><li>加入集群：使用<code>cluster meet</code>命令。</li><li>迁移槽和数据</li></ol><h3 id="减少节点"><a href="#减少节点" class="headerlink" title="减少节点"></a>减少节点</h3><ol><li>迁移槽和数据</li><li>忘记节点：使用<code>cluster forget</code>命令</li><li>关闭节点</li></ol><p>这里要注意应先下线从节点再下线主节点，因为若主节点先下线，会触发故障的自动转移。</p><p>在槽迁移未完成时，客户端访问了负责该槽的节点，但key此时已经迁移到了别的节点下，这时候会返回ask异常，通过这个机制使得redis cluster可以无痛的完成扩缩容操作。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>集群对故障发现与故障转移的实现与哨兵思路类似：通过定时任务发送ping消息检测其他节点状态，若某个主节点发现另一个主节点不可用（与参数<code>cluster-node-timeout</code>有关），则标记该节点进行主观下线，而当半数以上持有槽的主节点都标记该节点主观下线，则对该节点进行客观下线，并向集群广播fail消息，让集群中所有节点都将其标记为客观下线，并触发从节点的故障转移。</p><p>在故障转移阶段，主要有以下几个步骤：</p><ul><li>检查资格：每个从节点都会检查与故障主节点的断线时间，如果超过默认值150s（<code>cluster-node-timeout * cluster-slave-validity-factor</code>）则会取消资格。</li><li>准备选举时间：为了保证偏移量比较大的从节点更有可能成为主节点，会将该从节点的延迟时间设置更小一些。</li><li>选举投票：从节点选举胜出需要的票数为N/2+1，其中N为主节点数量（包括故障主节点），但故障主节点实际上不能投票。因此为了能够在故障发生时顺利选出从节点，集群中至少需要3个主节点。</li><li>替换主节点。</li></ul><p>与哨兵一样，集群只实现了主节点的故障转移，从节点故障时只会被下线，不会进行故障转移。因此，使用集群时，应谨慎使用读写分离技术，因为从节点故障会导致读服务不可用，可用性变差。</p><h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><h3 id="cluster-node-timeout"><a href="#cluster-node-timeout" class="headerlink" title="cluster_node_timeout"></a>cluster_node_timeout</h3><p><code>cluster_node_timeout</code>的默认值是15s，影响包括：</p><ul><li>值越大对延迟容忍度越高，并且由于节点发现与其它节点最后通信时间超过<code>cluster_node_timeout / 2</code>时会直接发送ping消息，因此调大该参数还可以降低带宽消耗，但同时也会降低收敛速度。</li><li>影响故障转移的判定和时间，值越大越不容易误判，但完成转移消耗时间越长。</li></ul><h3 id="cluster-require-full-coverage"><a href="#cluster-require-full-coverage" class="headerlink" title="cluster-require-full-coverage"></a>cluster-require-full-coverage</h3><p><code>cluster-require-full-coverage</code>参数设置为yes时，当主节点发生故障而故障转移尚未完成，原主节点中的槽不在任何节点中，此时集群会处于下线状态，无法响应客户端的请求。但在实际应用中为了保证服务的高可用性，都会将该参数设置为no。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://duqingfeng.net/2018/06/12/%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%E6%8A%80%E6%9C%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E3%80%81Redis%20cluster%E8%99%9A%E6%8B%9F%E6%A7%BD%EF%BC%89/" target="_blank" rel="noopener">哈希分区技术之间的对比（一致性哈希、Redis cluster虚拟槽）</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a></li><li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener">P2P 网络核心技术：Gossip 协议</a></li><li><a href="https://enpsl.top/2019/01/24/2019-01-24-redis-cluster-route/" target="_blank" rel="noopener">Redis cluster 客户端路由</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Cluster作用&quot;&gt;&lt;a href=&quot;#Redis-Cluster作用&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster作用&quot;&gt;&lt;/a&gt;Redis Cluster作用&lt;/h2&gt;&lt;p&gt;Redis Cluster是Redi
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper集群节点为什么推荐为奇数</title>
    <link href="http://yoursite.com/2019/03/31/Zookeeper%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%B8%BA%E5%A5%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/31/Zookeeper集群节点为什么推荐为奇数/</id>
    <published>2019-03-31T03:36:00.000Z</published>
    <updated>2019-03-31T03:58:27.604Z</updated>
    
    <content type="html"><![CDATA[<p>不止包括Zookeeper集群，其它大多数集群都推荐节点数最好为奇数个，因此本文将详细说明其中的缘由。首先我们需要明白一个概念“脑裂”：</p><blockquote><p>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，每个小集群都认为其它小集群的节点是不可用的，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。</p></blockquote><p>在zookeeper的选举过程中，有个规则是要求可用节点数量&gt;总节点数量/2。之所以会有这样的要求，就是为了防止集群出现脑裂的时候，可能会出现多个子集群同时服务的情况（即子集群各组选举出自己的leader）。如果遵守这个规则，那么只会有一个子集群能进行Leader选举，因为当前集群中只可能有一个子集群的节点数能超过总节点数的一半。</p><p>说明了可用节点数量&gt;总节点数量/2这个规则后，我们再进一步探索为什么Zookeeper集群节点数推荐为奇数个。主要有以下两个原因：</p><h2 id="1-防止脑裂造成集群不可用"><a href="#1-防止脑裂造成集群不可用" class="headerlink" title="1. 防止脑裂造成集群不可用"></a>1. 防止脑裂造成集群不可用</h2><p>如果集群的数量为偶数个，那么在发生脑裂的时候，可能两个子集群的数量都无法超过总节点数量的一半，也就无法满足Zookeeper进行选举的规则，这时候整个服务对外是彻底不可用的。但是如果集群的数量为奇数个的话，发生脑裂时必然有一个子集群的节点数目大于总节点数目的一半，这时候可以保证当前服务对外依然是可用的。</p><h2 id="2-在容错能力相同的情况下，奇数台更节省资源"><a href="#2-在容错能力相同的情况下，奇数台更节省资源" class="headerlink" title="2. 在容错能力相同的情况下，奇数台更节省资源"></a>2. 在容错能力相同的情况下，奇数台更节省资源</h2><p>比如说，如果当前集群有四个节点，要想完成Leader选举，只允许一个节点不可用，这样才能保证可用的节点数大于总节点数的一半。但如果当前集群有三个节点，要想完成Leader选举，同样也只允许一个节点不可用，因为只有当两个节点都存活的时候才能满足可用节点数大于总节点数的一半。可以看出，以上两个集群都只有一个节点的容错能力，但是第二个集群比第一个集群节约了更多的资源，因此，更推荐Zookeeper的节点数为奇数个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不止包括Zookeeper集群，其它大多数集群都推荐节点数最好为奇数个，因此本文将详细说明其中的缘由。首先我们需要明白一个概念“脑裂”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，每个小集群都认为其它
      
    
    </summary>
    
      <category term="Zookeeper" scheme="http://yoursite.com/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel</title>
    <link href="http://yoursite.com/2019/03/30/Redis-Sentinel/"/>
    <id>http://yoursite.com/2019/03/30/Redis-Sentinel/</id>
    <published>2019-03-30T13:45:00.000Z</published>
    <updated>2019-03-31T05:33:44.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h2><p>复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的，但它故障恢复无法自动化，因此Redis提供了哨兵（Sentinel）这么一个高可用方案。Redis Sentinel由两部分组成，哨兵节点和数据节点：</p><ul><li>哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。</li><li>数据节点：主节点和从节点都是数据节点。</li></ul><p><img src="http://blog.default.nanwulife.com/1174710-20180908182924632-1069251418.png" alt=""></p><p>Redis Sentinel具有以下功能：</p><ul><li>监控：哨兵通过心跳检测会不断地检查主节点和从节点是否运作正常。</li><li>自动故障转移：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供者：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li>通知：哨兵可以将故障转移的结果发送给客户端。</li></ul><h2 id="客户端连接Redis-Sentinel"><a href="#客户端连接Redis-Sentinel" class="headerlink" title="客户端连接Redis Sentinel"></a>客户端连接Redis Sentinel</h2><p>对于Redis Sentinel，它仅仅完成了服务端的高可用，当master挂掉时能选举出一个新的master节点来完成故障转移，但是我们客户端并没有去连接新的master节点，因此我们还要使得客户端也是高可用的。</p><p>Jedis客户端对Redis Sentinel提供了很好的支持。我们只需要向Jedis提供sentinel节点集合和<code>masterName</code>，构造<code>JedisSentinelPool</code>对象，然后便可以像使用普通redis连接池一样来使用了：通过<code>pool.getResource()</code>获取连接，执行具体的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSentinel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">         Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26379"</span>);</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26380"</span>);</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26381"</span>);</span><br><span class="line"> </span><br><span class="line">         JedisSentinelPool pool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels); <span class="comment">//初始化过程做了很多工作</span></span><br><span class="line">         Jedis jedis = pool.getResource();</span><br><span class="line">         jedis.set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">         pool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个过程中，我们的代码不需要显式的指定主节点的地址，就可以连接到主节点。代码中对故障转移也没有任何体现，就可以在sentinel完成故障转移后自动的切换主节点。之所以可以做到这些，是因为客户端完成了以下几个工作：</p><ul><li>遍历sentinel节点，找到一个可用的sentinel节点，通过<code>sentinel get-master-addr-by-name</code>命令获取master节点的信息（IP和端口），之后再对master节点执行<code>role</code>命令判断其是否真的为master节点。</li><li>客户端和sentinel使用了一个发布订阅模式，客户端订阅sentinel的某一个频道，当master发生变化时，sentinel向这个频道发布一条消息，客户端就可以获取再对新的master进行一个连接。</li></ul><p>前面说过sentinel相当于配置提供者，我们得到了sentinel的集合后就可以通过sentinel节点获取到master的地址。这里要注意sentinel只是配置提供者，而不是代理，二者的区别在于如果是配置提供者，客户端在通过sentinel获得master信息后，会直接建立到master的连接，后续的请求会直接发向master，而如果是代理，客户端的每一次请求都会发向sentinel，sentinel再通过主节点处理请求。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><ul><li>10秒每个sentinel对master和slave执行info，以此发现slave节点并确认主从关系。</li><li>2秒每个sentinel通过master节点的channel交换信息（因此sentinel节点之间能够自动感知）。</li><li>每1秒每个sentinel对其它sentinel和redis执行ping也就是心跳检测。</li></ul><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><ul><li>主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线。</li><li>客观下线：哨兵节点在对主节点进行主观下线后，会通过<code>sentinel is-master-down-by-addr</code>命令询问其他哨兵节点该主节点的状态。如果判断主节点下线的哨兵数量达到设置的法定人数（quorum），则对该主节点进行客观下线。</li></ul><p>需要特别注意的是，客观下线是主节点才有的概念，如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</p><h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><p>由于只需要一个sentinel节点完成故障转移，因此sentinel内部需要选举出一个节点作为领导者，同样也是通过<code>sentinel is-master-down-by-addr</code>这个命令完成领导者的选举（这正是这条命令的第二个作用）。过程如下：</p><ol><li>每个做主观下线的sentinel节点向其它sentinel节点发送命令，要求将它设置为领导者。</li><li>收到命令的sentinel节点如果没有同意通过其它sentinel节点发送的命令，那么将同意该请求，否则拒绝。</li><li>如果该sentinel节点发现自己的票数已经超过sentinel集合半数并且超过quorum，那么将它成为领导者。</li></ol><p>需要特别注意的是，客观下线是主节点才有的概念，如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>完成了领导者选举后，由领导者进行故障转移操作：</p><ol><li>从slave节点中选出一个“合适的”节点作为新的master节点：选择优先级最高的从节点(由<code>slave-priority</code>指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。</li><li>对上面slave节点执行<code>slaveof no one</code>命令让其成为master节点。</li><li>向剩余的slave节点发送命令，让它们成为新master节点的slave节点，复制规则和<code>parallel-syncs</code>参数有关。</li><li>更新原来master节点配置为slave，并保持着对其“关注”，当其恢复后命令它去复制新的master节点。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Redis Sentinel无法对从节点进行自动故障转移，在读写分离场景下，从节点故障会导致读服务不可用，需要我们对从节点做额外的监控、切换操作。除此之外，它的存储能力受到单机限制的问题，因此如果我们对扩容有需求的话，应当使用Redis Cluster这么一个高可用的集群方案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9609938.html#t33" target="_blank" rel="noopener">深入学习Redis（4）：哨兵</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Sentinel架构&quot;&gt;&lt;a href=&quot;#Redis-Sentinel架构&quot; class=&quot;headerlink&quot; title=&quot;Redis Sentinel架构&quot;&gt;&lt;/a&gt;Redis Sentinel架构&lt;/h2&gt;&lt;p&gt;复制是高可用Redis的基础
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://yoursite.com/2019/03/30/dis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/30/dis主从复制/</id>
    <published>2019-03-30T08:06:00.000Z</published>
    <updated>2019-03-31T05:34:03.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制是指将主节点（master）的数据复制到从节点（slave）中，数据的复制是单向的，只能由主节点到从节点。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>主从复制过程大体可以分为3个阶段：连接建立阶段、数据同步阶段、命令传播阶段。</p><h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><p>主从复制的开启，完全是在从节点发起的（通过<code>slaveof</code>命令），不需要我们在主节点做任何事情。需要注意的是，<code>slaveof</code>是异步命令，从节点完成主节点ip和port的保存后，向发送<code>slaveof</code>命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p><h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步。数据同步阶段是主从复制最核心的阶段，由从节点向主节点发送<code>psync</code>命令开始同步，并且根据主从节点当前状态的不同，可以分为全量复制和部分复制。</p><p><img src="http://blog.default.nanwulife.com/psync.jpg" alt=""></p><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>全量复制用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。执行过程如下：</p><ul><li>主节点收到全量复制的命令后，执行<code>bgsave</code>，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</li><li>主节点的<code>bgsave</code>执行完成后，将RDB文件发送给从节点，从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行<code>bgsave</code>时的数据库状态。</li><li>主节点将复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</li><li>如果从节点开启了AOF，则会触发<code>bgrewriteaof</code>的执行，从而保证AOF文件更新至主节点的最新状态。</li></ul><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>复制偏移量：主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数。主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。</p><p>复制缓冲区：复制缓冲区是由主节点维护的、固定长度的、先进先出队列，默认大小1MB，当主节点开始有从节点时创建。在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制缓冲区，作为写命令的备份。除了存储写命令，复制缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令，时间较早的写命令会被挤出缓冲区，因此当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</p><p>服务器运行ID（runid）：每个Redis节点（无论主从），在启动时都会自动生成一个随机ID（每次启动都不一样），runid用来唯一识别一个Redis节点。主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来。当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步阶段完成后，主从节点进入命令传播阶段。在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复，因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在没有使用哨兵或集群的场景下，当主节点挂掉了以后，从节点没法完成master选举，从而导致整个服务对外不可用。我们需要自行选择一个从节点作为主节点并继续对外提供服务，并将其它从节点的主节点设为它，由于这些过程都需要手动完成，出错率比较高，因此在真实场景中往往都会使用哨兵或者集群来实现系统的高可用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;主从复制是指将主节点（master）的数据复制到从节点（slave）中，数据的复制是单向的，只能由主节点到从节点。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化：AOF与RDB</title>
    <link href="http://yoursite.com/2019/03/30/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/30/Redis五种数据类型/</id>
    <published>2019-03-30T03:30:00.000Z</published>
    <updated>2019-03-30T08:05:54.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘，当下次Redis重启时，利用持久化文件实现数据恢复。</p><p>Redis持久化分为RDB持久化和AOF持久化：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘，保存的文件后缀是rdb，当Redis重新启动时，可以读取快照文件恢复数据。RDB持久化分为手动触发和自动触发两种方式：</p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>手动触发可以使用<code>save</code>命令和<code>bgsave</code>命令，都可以生成rdb文件。它们的区别在于<code>save</code>命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求；而<code>bgsave</code>命令会创建一个子进程，由子进程来负责创建RDB文件，父进程（即Redis主进程）则继续处理请求，整个过程中只有<code>fork</code>子进程时会阻塞服务器。</p><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>自动触发最常见的情况是在配置文件中通过<code>save m n</code>，指定当m秒内发生n次变化时，会触发<code>bgsave</code>。例如默认配置文件中有以下三行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p><p>只要上面三行任意一条满足时，就会执行<code>bgsave</code>。除此之外，在主从复制的场景下，如果从节点执行全量复制操作，则主节点会执行<code>bgsave</code>命令，并将rdb文件发送给从节点。执行<code>shutdown</code>命令时，也会自动执行rdb持久化。</p><h3 id="启动时加载"><a href="#启动时加载" class="headerlink" title="启动时加载"></a>启动时加载</h3><p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>RDB持久化是将进程数据写入文件，而AOF持久化则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog），当Redis重启时再次执行AOF文件中的命令来恢复数据。与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</p><h3 id="三种策略"><a href="#三种策略" class="headerlink" title="三种策略"></a>三种策略</h3><p>为了提高文件写入效率，在现代操作系统中，当用户将数据写入文件时（<code>write</code>命令），操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但如果系统崩溃，内存缓冲区中的数据将会丢失。因此可以设置同步选项，强制操作系统什么时候将缓冲区中的数据写入到硬盘中（<code>fsync</code>命令），Redis提供了以下三种同步策略：</p><ul><li>always：每个写命令都同步</li><li>everysec：每秒同步一次</li><li>no：让操作系统来决定何时同步</li></ul><p>always会严重降低服务器的性能，而no的不可控性太强，因此Redis使用everysec作为默认配置，但在系统崩溃时可能会丢失一秒的数据。</p><h3 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h3><p>随着Redis服务器执行的写命令越来越多，AOF文件也会越来越大，过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件，而不会对旧的AOF文件进行任何读取、写入操作。</p><p>文件重写主要是针对以下一些语句：</p><ul><li>过期的数据（如<code>expire</code>），可以不用再写入文件。</li><li>多次<code>INCR</code>命令可以合并为一个<code>SET</code>命令。</li><li>无效的命令不再写入文件，比如有些数据被删除了。</li></ul><h3 id="手动触发-1"><a href="#手动触发-1" class="headerlink" title="手动触发"></a>手动触发</h3><p>可以直接调用<code>bgrewriteaof</code>命令重写文件，该命令的执行与<code>bgsave</code>有些类似，都是<code>fork</code>子进程进行具体的工作，且都只有在<code>fork</code>时阻塞。</p><h3 id="自动触发-1"><a href="#自动触发-1" class="headerlink" title="自动触发"></a>自动触发</h3><p>默认配置是当AOF文件大小是上次重写后大小的一倍（<code>auto-aof-rewrite-min-size</code>）且文件大于64M时触发（<code>auto-aof-rewrite-percentage</code>）。</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ol><li>父进程执行<code>fork</code>操作创建子进程，这个过程中父进程是阻塞的。</li><li>子进程创建后，Redis的所有写命令依然写入AOF缓冲区，并根据设置策略同步到硬盘，保证原有AOF机制的正确。</li><li>由于<code>fork</code>操作使用写时复制技术，子进程只能共享<code>fork</code>操作时的内存数据。由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区（图中的aof_rewrite_buf）保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。</li><li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。</li><li>子进程写完新的AOF文件后，向父进程发信号，父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。</li><li>使用新的AOF文件替换老文件，完成AOF重写。</li></ol><p><img src="http://blog.default.nanwulife.com/1174710-20180605092001589-1724580361.png" alt=""></p><h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><ul><li>RDB持久化：RDB文件紧凑，体积小，恢复速度比AOF快很多，但数据的实时性较低。</li><li>AOF持久化：实时性较高，但是文件大，并且恢复速度较慢，且对性能有一定影响。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="fork阻塞：CPU的阻塞"><a href="#fork阻塞：CPU的阻塞" class="headerlink" title="fork阻塞：CPU的阻塞"></a>fork阻塞：CPU的阻塞</h3><p>在Redis中，无论是RDB持久化的<code>bgsave</code>，还是AOF重写的<code>bgrewriteaof</code>，都需要<code>fork</code>出子进程来进行操作，而在操作系统<code>fork</code>的实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间，但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分（内存的一页）制作一个副本。</p><p>也就是说，虽然<code>fork</code>时子进程不会复制父进程的数据空间，但是会复制内存页表，如果Redis内存过大，会导致fork操作时复制内存页表耗时过多，而Redis主进程在进行<code>fork</code>时是完全阻塞的，意味着无法响应客户端的请求，造成请求延迟过大。</p><p>为了防止该问题的发生，我们需要控制Redis单机内存的大小，并且适当放宽AOF重写的触发条件，尽量在写入较少的时间段完成重写。</p><h3 id="AOF追加阻塞：硬盘的阻塞"><a href="#AOF追加阻塞：硬盘的阻塞" class="headerlink" title="AOF追加阻塞：硬盘的阻塞"></a>AOF追加阻塞：硬盘的阻塞</h3><p>AOF持久化过程中，通过<code>fsync</code>命令每秒一次将缓冲区的数据写入磁盘中，但在硬盘负载过高时，<code>fsync</code>操作可能会超过1s，当继续向缓冲区内写入数据时，磁盘负载会越来越大，如果此时Redis进程异常退出，丢失的数据也有可能远超1s。</p><p>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比距离上次<code>fsync</code>成功的时间，如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到<code>fsync</code>同步完成。因此，如果系统硬盘负载过大导致<code>fsync</code>速度太慢，会导致Redis主线程的阻塞。这里还要注意的是，如果使用everysec策略，AOF最多可能丢失2s的数据，而不是1s。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis持久化&quot;&gt;&lt;a href=&quot;#Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化&quot;&gt;&lt;/a&gt;Redis持久化&lt;/h2&gt;&lt;p&gt;Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux五种IO模型</title>
    <link href="http://yoursite.com/2019/03/27/Linux-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/27/Linux-五种IO模型/</id>
    <published>2019-03-27T02:39:00.000Z</published>
    <updated>2019-03-27T05:05:05.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>对于一次IO访问，会分为两个阶段，首先等待数据准备好后被拷贝到操作系统内核的缓冲区中，然后再从操作系统内核的缓冲区拷贝到用户空间。IO模型可以分为以下五种类型：</p><ul><li>阻塞式I/O（Blocking I/O）</li><li>非阻塞式I/O（Non-blocking I/O）</li><li>多路复用I/O（Multiplexing I/O）</li><li>信号驱动I/O（Signal-driven I/O）</li><li>异步I/O（Asynchronous I/O）</li></ul><p>其中信号驱动式IO并不常用，所以重点关注另外四种IO模型。</p><h2 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h2><p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的IO。</p><p>阻塞IO的特点就是能够及时的返回数据，但是在IO执行的两个阶段都被阻塞了，只有当数据从内核复制到了用户空间中，进程才能继续往下执行，因此对性能有所牺牲。</p><p><img src="http://blog.default.nanwulife.com/1492928416812_4.png" alt=""></p><h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h2><p>应用进程执行系统调用之后，内核会立即返回一个错误码，但IO操作还没完成。此时应用进程并没有被阻塞，可以继续执行，但是需要不断的执行系统调用来获知IO操作是否完成，这种方式称为轮询。</p><p>这种模型的CPU利用率比较低，并且因为每过一段时间才去轮询一次，所以存在一个响应延迟。还需要注意的是，拷贝数据的整个过程，进程仍然是属于阻塞的状态。</p><p><img src="http://blog.default.nanwulife.com/1492929000361_5.png" alt=""></p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>使用<code>select</code>或者<code>poll</code>对多个IO端口进行监听，只要多个套接字中的任何一个数据准备好了，就能返回可读，之后应用进程再执行recvfrom系统调用把数据从内核复制到进程中。</p><p>I/O复用模型让单个进程具有处理多个I/O事件的能力，因此相比多进程和多线程技术，它的系统开销小了许多。但是<code>select</code>，<code>poll</code>，<code>epoll</code>函数依然会阻塞应用进程，并且由于多路复用可以处理多个IO，那么多个IO之间的顺序就变得不确定了。</p><p><img src="http://blog.default.nanwulife.com/1492929444818_6.png" alt=""></p><h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p>应用进程使用sigaction系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送SIGIO信号，应用进程收到之后在信号处理程序中调用recvfrom将数据从内核复制到应用进程中。</p><p>相比于非阻塞式I/O的轮询方式，信号驱动I/O的CPU利用率更高。</p><p><img src="http://blog.default.nanwulife.com/1492929553651_7.png" alt=""></p><h2 id="异步非阻塞I-O"><a href="#异步非阻塞I-O" class="headerlink" title="异步非阻塞I/O"></a>异步非阻塞I/O</h2><p>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户进程就可以去做别的事情。等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。这个IO模式的两个阶段，进程都是非阻塞的。</p><p><img src="http://blog.default.nanwulife.com/1492930243286_8.png" alt=""></p><h2 id="五种I-O模型对比"><a href="#五种I-O模型对比" class="headerlink" title="五种I/O模型对比"></a>五种I/O模型对比</h2><ul><li>阻塞式I/O：同步阻塞</li><li>非阻塞式I/O：同步非阻塞（轮询）</li><li>I/O多路复用：同步阻塞（可以监听多个IO）</li><li>信号驱动I/O：同步非阻塞（收到SIGIO信号后才执行recvfrom并阻塞）</li><li>异步I/O：异步非阻塞（两个阶段都不会阻塞）</li></ul><p><img src="http://blog.default.nanwulife.com/1492928105791_3.png" alt=""></p><h2 id="I-O多路复用中的select、poll、epoll"><a href="#I-O多路复用中的select、poll、epoll" class="headerlink" title="I/O多路复用中的select、poll、epoll"></a>I/O多路复用中的select、poll、epoll</h2><p>select，poll，epoll都是IO多路复用的机制，select出现的最早，之后是poll，再是epoll。I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p></blockquote><ul><li><strong>select</strong>：它仅仅知道有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，测试每个流是否有事件发生，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的时间复杂度，同时处理的流越多，无差别轮询时间就越长。</li><li><strong>poll</strong>：poll本质上和select没有区别，需要查询每个fd对应的设备状态，但是它没有最大连接数的限制，因为select的描述符类型使用数组实现，而poll的描述符类型使用链表实现。</li><li><strong>epoll</strong>：epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="https://www.cnblogs.com/aspirant/p/9166944.html" target="_blank" rel="noopener">select、poll、epoll之间的区别(搜狗面试)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;p&gt;对于一次IO访问，会分为两个阶段，首先等待数据准备好后被拷贝到操作系统内核的缓冲区中，然后再从操作系统内核的缓冲区拷贝到用户
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>NIO知识点总结</title>
    <link href="http://yoursite.com/2019/03/10/NIO%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/10/NIO知识点总结/</id>
    <published>2019-03-10T12:55:00.000Z</published>
    <updated>2019-03-11T13:08:04.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java NIO是一个可以替代标准Java IO API的IO API，主要有以下三个核心组件：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>NIO与IO的主要区别在于：</p><ul><li>IO是面向流的，NIO是面向缓冲区的。</li><li>IO是阻塞的，NIO是非阻塞的。</li><li>NIO有选择器，允许一个单独的线程来管理多个输入通道。</li></ul><a id="more"></a><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Java NIO的通道类似流，主要区别在于：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>NIO中有以下几个重要的通道实现。</p><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p><p>注意：FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开FileChannel</span></span><br><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在FileChannel的某个特定位置进行数据的读/写操作</span></span><br><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用FileChannel.truncate()方法截取一个文件，指定长度后面的部分将被删除</span></span><br><span class="line">channel.truncate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上，而通过FileChannel.force()方法则可以将通道里尚未写入磁盘的数据强制写到磁盘上</span></span><br><span class="line">channel.force(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p><ul><li>打开一个SocketChannel并连接到互联网上的某台服务器。</li><li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li></ul><p>SocketChannel是可以设置为非阻塞模式的，设置之后，就可以在异步模式下调用<code>connect()</code>, <code>read()</code>和<code>write()</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开并连接</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//非阻塞模式可以调用finishConnect()的方法确定连接是否建立</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">   <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>ServerSocketChannel是一个可以监听新进来的TCP连接的通道。在打开了ServerSocketChannel之后，可以通过<code>accept()</code>方法监听新进来的连接，当<code>accept()</code>方法返回的时候，它返回一个包含新进来的连接的<code>SocketChannel</code>。因此，<code>accept()</code>方法会一直阻塞到有新连接到达。</p><p>ServerSocketChannel也可以设置成非阻塞模式。在非阻塞模式下，<code>accept()</code>方法会立刻返回，如果还没有新进来的连接,返回的将是<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开通道并监听新进来的连接</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h2><p>DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开DatagramChannel</span></span><br><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过receive()方法从DatagramChannel接收数据到指定的Buffer，如果Buffer容不下收到的数据，多出的数据将被丢弃</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过send()方法从DatagramChannel发送数据</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>Buffer本质是一块可以写入数据，并可以从中读取数据的内存，用于和通道进行交互，过程如下：</p><ul><li>写入数据到Buffer</li><li>调用<code>flip()</code>方法</li><li>从Buffer中读取数据</li><li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li></ul><p>其中<code>flip()</code>方法是将Buffer从写模式切换到读模式，<code>clear()</code>方法会清空整个缓冲区，<code>compact()</code>方法只会清除已经读过的数据并将所有未读的数据拷贝到Buffer起始处。</p><p>Buffer有三个属性：</p><ul><li>capacity</li><li>position：当写数据到Buffer中时，position表示当前的位置；当从Buffer读取数据时，也是从当前位置开始读；将Buffer从写模式切换到读模式，position会被重置为0。</li><li>limit：在写模式下，limit表示你最多能往Buffer里写多少数据，此时limit等于capacity；在读模式下，limit表示最多能读到多少数据，因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。</li></ul><p>Buffer有以下几种类型，它们代表了不同的数据类型：</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h2 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h2><p>要想获得一个Buffer对象首先要进行分配。每一个Buffer类都有一个allocate方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure></p><h2 id="向Buffer写数据"><a href="#向Buffer写数据" class="headerlink" title="向Buffer写数据"></a>向Buffer写数据</h2><p>写数据到Buffer有两种方式：</p><ul><li>从Channel写到Buffer。</li><li>通过Buffer的<code>put()</code>方法写到Buffer里。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"></span><br><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure><h2 id="从Buffer读数据"><a href="#从Buffer读数据" class="headerlink" title="从Buffer读数据"></a>从Buffer读数据</h2><p>从Buffer中读取数据有两种方式：</p><ul><li>从Buffer读取数据到Channel。</li><li>使用get()方法从Buffer中读取数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure><h2 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h2><p><code>rewind()</code>将position设回0，所以可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素。</p><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector是NIO中能够检测一到多个通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h2 id="创建并注册"><a href="#创建并注册" class="headerlink" title="创建并注册"></a>创建并注册</h2><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Selector的创建</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//向Selector注册通道</span></span><br><span class="line">  channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,</span><br><span class="line">  Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>注意<code>register()</code>方法的第二个参数。这是一个interest集合，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件，用SelectionKey的四个常量来表示:</p><ul><li><code>SelectionKey.OP_CONNECT</code>：某个channel成功连接到另一个服务器称为“连接就绪”</li><li><code>SelectionKey.OP_ACCEPT</code>：一个server socket channel准备好接收新进入的连接称为“接收就绪”</li><li><code>SelectionKey.OP_READ</code>：一个有数据可读的通道可以说是“读就绪”</li><li><code>SelectionKey.OP_WRITE</code>：等待写数据的通道可以说是“写就绪”。</li></ul><p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如<code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></p><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>当向Selector注册Channel时，<code>register()</code>法会返回一个SelectionKey对象，这个对象包含以下几个属性：</p><ul><li>terest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><h3 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h3><p>可以用位与操作interest集合和给定的SelectionKey常量来确定某个事件是否在interest集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h3><p>ready集合是通道已经准备就绪的操作的集合。可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪，也可以通过如下的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p><h3 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel Selector"></a>Channel Selector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h3 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h3><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><h2 id="选择通道"><a href="#选择通道" class="headerlink" title="选择通道"></a>选择通道</h2><p>一旦向Selector注册了一或多个通道，就可以调用<code>select()</code>方法选择就绪的通道，方法返回已经就绪的通道数目。<code>select()</code>阻塞到至少有一个通道在你注册的事件上就绪了，而<code>selectNow()</code>不会阻塞。</p><p>一旦调用了<code>select()</code>方法，并且返回值表明有一个或更多个通道就绪了，就可以通过调用<code>selectedKeys()</code>方法返回就绪通道的集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>之后就可以通过遍历这个集合来访问就绪的通道：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意每次迭代末尾的<code>keyIterator.remove()</code>调用。Selector不会自己从集合中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入集合中。</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>用完Selector后调用其<code>close()</code>方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效，但通道本身并不会关闭。</p><h1 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h1><p>Java NIO支持scatter/gather，scatter是指数据从一个channel读取到多个buffer中，而gather则是指数据从多个buffer写入到同一个channel。scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样可以方便的处理消息头和消息体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.read(bufferArray);</span><br><span class="line"></span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>注意，Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这意味着它不适用于动态消息，而Gathering Writes只有position和limit之间的数据才会被写入，因此能较好的处理动态消息。</p><h1 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h1><p>如果两个通道中有一个是FileChannel，那么可以直接将数据从一个通道传输到另外一个通道。</p><h2 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h2><p><code>transferFrom()</code>方法可以将数据从源channel传输到FileChannel中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure></p><h2 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h2><p><code>transferTo()</code>方法将数据从FileChannel传输到其他的channel中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>Path接口表示的是一个与平台无关的路径，既可以是绝对路径也可以是相对路径，文件和目录都用Path表示。</p><h2 id="创建Path"><a href="#创建Path" class="headerlink" title="创建Path"></a>创建Path</h2><p>可以使用Paths工具类的工厂方法创建一个Path对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"C:\\DATA\\test.txt"</span>);</span><br><span class="line"></span><br><span class="line">Path projects = Paths.get(<span class="string">"d:\\data"</span>, <span class="string">"projects"</span>);</span><br><span class="line"></span><br><span class="line">Path currentDir = Paths.get(<span class="string">"."</span>);</span><br><span class="line">Path parentDir = Paths.get(<span class="string">".."</span>);</span><br></pre></td></tr></table></figure><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h2><p><code>normalize()</code>方法可以标准化路径，它会处理路径中的相对路径，去除<code>.</code> <code>..</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"c:/Z_DATA/./test.txt"</span>);</span><br><span class="line">System.out.println(<span class="string">"path = "</span> + path);</span><br><span class="line"></span><br><span class="line">path = path.normalize();</span><br><span class="line">System.out.println(<span class="string">"path = "</span> + path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">path = c:\Z_DATA\.\test.txt</span><br><span class="line">path = c:\Z_DATA\test.txt</span><br></pre></td></tr></table></figure></p><h1 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h1><p>Files工具类封装提供了一些操作文件系统中文件的工具方法，往往和和Path一起使用。</p><h2 id="exists"><a href="#exists" class="headerlink" title="exists()"></a>exists()</h2><p><code>exists()</code>可以判断一个Path在文件系统中是否存在。</p><h2 id="createDirctory"><a href="#createDirctory" class="headerlink" title="createDirctory()"></a>createDirctory()</h2><p>在调用创建方法前最好先检查是否存在，如果已经存在会抛出<code>FileAlreadyExistsException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Path newDir = Paths.get(<span class="string">"c:/Z_DATA/newDir"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!Files.exists(newDir)) &#123;</span><br><span class="line">        Files.createDirectory(newDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h2><p><code>copy()</code>只能复制到不存在的路径，如果复制的目标文件已存在则会抛出异常。强制覆盖已存在文件也是可以的，需要增加相应参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(classPath,<span class="string">"nio-data.txt"</span>);</span><br><span class="line">Path targetPath = Paths.get(classPath,<span class="string">"nio-data-copy.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); <span class="comment">// 复制并覆盖已有文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="move"><a href="#move" class="headerlink" title="move()"></a>move()</h2><p>Java NIO Files类同样提供了移动文件的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(classPath,<span class="string">"nio-data.txt"</span>);</span><br><span class="line">Path targetPath = Paths.get(classPath,<span class="string">"nio-data-copy.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); <span class="comment">// 移动并覆盖已有文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h2><p>删除文件或目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.delete(targetPath);</span><br></pre></td></tr></table></figure><p>如果删除的文件或目录不存在会抛出<code>IOException</code>异常。</p><h1 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h1><p>使用AsynchronousFileChannel可以实现异步地读取和写入文件数据。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们可以使用AsynchronousFileChannel提供的静态方法<code>open()</code>创建它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test.xml"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel =</span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>AsynchronousFileChannel提供了两种读取数据的方式，都是调用它本身的<code>read()</code>方法。</p><h3 id="使用Futrue读取数据"><a href="#使用Futrue读取数据" class="headerlink" title="使用Futrue读取数据"></a>使用Futrue读取数据</h3><p>第一种方式是调用AsynchronousFileChannel的<code>read()</code>方法，该方法返回一个<code>Future</code>类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">buffer.get(data);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure><p>以上代码<code>read()</code>方法会立即返回，即使整个读的过程还没有完全结束。我们可以通过<code>Future.isDone()</code>来检查读取是否完成。</p><h3 id="使用CompletionHandler读取数据"><a href="#使用CompletionHandler读取数据" class="headerlink" title="使用CompletionHandler读取数据"></a>使用CompletionHandler读取数据</h3><p>第二种读取数据的方式是调用AsynchronousFileChannel的另一个<code>read()</code>方法，该方法需要一个<code>CompletionHandler</code>作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.read(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line"></span><br><span class="line">        attachment.flip();</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[attachment.limit()];</span><br><span class="line">        attachment.get(data);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">        attachment.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一旦读取操作完成，<code>CompletionHandler</code>的<code>complete()</code>方法将会被调用。它的第一个参数是个<code>Integer</code>类型，表示读取的字节数。第二个参数<code>attachment</code>是<code>ByteBuffer</code>类型的，用来存储读取的数据(<code>ByteBuffer</code>也可以换成其他合适的对象方便数据写入)。它其实就是由<code>read()</code>方法的第三个参数。读取失败的时候，<code>CompletionHandler</code>的<code>failed()</code>方法会被调用。</p><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><p>就像读取一样，我们同样有两种方式向AsynchronousFileChannel写入数据。</p><h3 id="使用Future读取数据"><a href="#使用Future读取数据" class="headerlink" title="使用Future读取数据"></a>使用Future读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.write(buffer, position);</span><br><span class="line">buffer.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Write done"</span>);</span><br></pre></td></tr></table></figure><p>注意，写入目标文件要提前创建好，如果它不存在的话，<code>write()</code>方法会抛出一个 <code>NoSuchFileException</code>。</p><h3 id="使用CompletionHandler写入数据"><a href="#使用CompletionHandler写入数据" class="headerlink" title="使用CompletionHandler写入数据"></a>使用CompletionHandler写入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line"><span class="keyword">if</span>(!Files.exists(path))&#123;</span><br><span class="line">    Files.createFile(path);</span><br><span class="line">&#125;</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">fileChannel.write(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes written: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Write failed"</span>);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当写入程序完成时，CompletionHandler的<code>completed()</code>方法将会被调用，相反的如果写入失败则会调用<code>failed()</code>方法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">Java NIO 系列教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Java NIO是一个可以替代标准Java IO API的IO API，主要有以下三个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Buffers&lt;/li&gt;
&lt;li&gt;Selectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO与IO的主要区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IO是面向流的，NIO是面向缓冲区的。&lt;/li&gt;
&lt;li&gt;IO是阻塞的，NIO是非阻塞的。&lt;/li&gt;
&lt;li&gt;NIO有选择器，允许一个单独的线程来管理多个输入通道。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NIO" scheme="http://yoursite.com/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
</feed>
