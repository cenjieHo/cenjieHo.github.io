<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-17T14:33:27.641Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MyBatis插件机制</title>
    <link href="http://yoursite.com/2019/05/17/MyBatis%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/17/MyBatis插件机制/</id>
    <published>2019-05-17T14:31:00.000Z</published>
    <updated>2019-05-17T14:33:27.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。MyBatis所允许拦截的接口与方法如下：</p><ul><li><code>Executor</code> </li><li><code>ParameterHandler</code> </li><li><code>ResultSetHandler</code> </li><li><code>StatementHandler</code> </li></ul><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>如果我们要实现一个插件，比如我们想要拦截<code>Executor</code>的<code>query</code>方法，那么可以这样定义插件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">    <span class="meta">@Signature</span>(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = <span class="string">"query"</span>,</span><br><span class="line">        args =&#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="meta">@Signature</span>(...),</span><br><span class="line">    <span class="meta">@Signature</span>(...)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的注解是必须的，<code>@Intercepts</code>注解装载一个<code>@Signature</code>列表，一个<code>@Signature</code>其实就是一个需要拦截的方法封装。那么，当一个拦截器要拦截多个方法，自然就是一个<code>@Signature</code>列表。</p><p>除此之外，我们还需将插件配置到相关文件中，这样MyBatis在启动时可以加载插件，并保存插件实例到拦截器链<code>InterceptorChain</code>中。待准备工作做完后，MyBatis处于就绪状态。我们在执行SQL时，需要先通过<code>DefaultSqlSessionFactory</code>创建<code>SqlSession</code>。<code>Executor</code>实例会在创建<code>SqlSession</code>的过程中被创建，<code>Executor</code>实例创建完毕后，MyBatis会通过JDK动态代理为实例生成代理类。这样，插件逻辑即可在<code>Executor</code>相关方法被调用前执行。配置示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.mybatis3.interceptor.ExamplePlugin"</span>&gt;</span></span><br><span class="line">                // ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h2><p><code>Executor</code>实例是在开启<code>SqlSession</code>时被创建的，<code>Executor</code>的创建过程封装在<code>Configuration</code>中，注册插件也正是这个时候：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 executorType 创建相应的 Executor 实例</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册插件</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面创建好<code>Executor</code>后，紧接着通过拦截器链<code>interceptorChain</code>为<code>Executor</code>实例注册代理逻辑（注意是注册而非执行）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历拦截器集合</span></span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">          <span class="comment">// 调用拦截器的 plugin 方法植入相应的插件逻辑</span></span><br><span class="line">          target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>它的<code>pluginAll()</code>方法会调用具体插件的<code>plugin()</code>方法注册相应的插件逻辑。如果有多个插件，则会多次调用<code>plugin()</code>方法，最终生成一个层层嵌套的代理类。<code>plugin()</code>方法是由具体的插件类实现，以下是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取插件类 @Signature 注解内容</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 获取目标类实现的接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>plugin</code>方法在内部调用了<code>Plugin</code>类的<code>wrap()</code>方法，用于为目标对象生成代理。<code>Plugin</code>类实现了<code>InvocationHandler</code>接口，因此它可以作为参数传给<code>Proxy</code>的<code>newProxyInstance()</code>方法。</p><h2 id="执行插件"><a href="#执行插件" class="headerlink" title="执行插件"></a>执行插件</h2><p>在上面注册插件的过程中，我们在<code>wrap()</code>方法中看到了如下代码，它传入了一个<code>Plugin</code>对象作为参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">    type.getClassLoader(),</span><br><span class="line">    interfaces,</span><br><span class="line">    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br></pre></td></tr></table></figure></p><p><code>Plugin</code>实现了<code>InvocationHandler</code>接口，因此它的<code>invoke()</code>方法会拦截所有的方法调用。<code>invoke()</code>方法会对所拦截的方法进行检测，以决定是否执行插件逻辑。该方法的逻辑如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取被拦截方法列表</span></span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">     <span class="comment">// 检测方法列表是否包含当前被拦截的方法</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="comment">// 执行插件逻辑，在 ExamplePlugin 实现中仅仅为执行被拦截的方法</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 执行被拦截的方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tianxiaobo.com/2018/08/26/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">MyBatis 源码分析 - 插件机制</a></li><li><a href="https://my.oschina.net/zudajun/blog/738973" target="_blank" rel="noopener">Mybatis3.4.x技术内幕（十九）：Mybatis之plugin插件设计原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis缓存机制</title>
    <link href="http://yoursite.com/2019/05/17/MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/17/MyBatis缓存机制/</id>
    <published>2019-05-17T04:10:00.000Z</published>
    <updated>2019-05-17T04:11:42.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓存机制是MyBatis的一大特性，它分为一级和二级缓存，其中一级缓存是<code>SqlSession</code>级别的缓存，其实现较为简单，而二级缓存是mapper级别的缓存，并且多个<code>SqlSession</code>之间可以共享。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个<code>SqlSession</code>对象表示一次数据库会话，对于这种会话级别的数据缓存，我们就称之为一级缓存。通过一级缓存，每次查询时都将结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</p><p><img src="http://blog.default.nanwulife.com/20141121213425390.jpg" alt=""></p><p>我们知道，<code>SqlSession</code>只是一个MyBatis对外的接口，<code>SqlSession</code>将它的工作交给了<code>Executor</code>执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个<code>SqlSession</code>对象时，MyBatis会为这个<code>SqlSession</code>对象创建一个新的<code>Executor</code>执行器，而缓存信息就被维护在这个<code>Executor</code>执行器中，MyBatis将缓存和对缓存相关的操作封装到了<code>Cache</code>接口中。</p><h3 id="PerpetualCache"><a href="#PerpetualCache" class="headerlink" title="PerpetualCache"></a>PerpetualCache</h3><p><code>Executor</code>接口的实现类<code>BaseExecutor</code>中拥有一个<code>Cache</code>接口的实现类<code>PerpetualCache</code>，则对于<code>BaseExecutor</code>对象而言，它将使用<code>PerpetualCache</code>对象维护缓存，下面看一下它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，<code>PerpetualCache</code>实现原理其实很简单，其内部就是通过一个简单的<code>HashMap</code>来实现的，没有其他的任何限制。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>关于一级缓存的生命周期，有以下几条规则：</p><ul><li>MyBatis在开启一个数据库会话时，会创建一个新的<code>SqlSession</code>对象，<code>SqlSession</code>对象中会有一个新的<code>Executor</code>对象，<code>Executor</code>对象中持有一个新的<code>PerpetualCache</code>对象；当会话结束时，<code>SqlSession</code>对象及其内部的<code>Executor</code>对象还有<code>PerpetualCache</code>对象也一并释放掉。</li><li>如果<code>SqlSession</code>调用了<code>close()</code>方法，会释放掉一级缓存<code>PerpetualCache</code>对象，一级缓存将不可用；</li><li>如果<code>SqlSession</code>调用了<code>clearCache()</code>，会清空<code>PerpetualCache</code>对象中的数据，但是该对象仍可使用；</li><li><code>SqlSession</code>中执行了任何一个update操作(<code>update()</code>、<code>delete()</code>、<code>insert()</code>) ，都会清空<code>PerpetualCache</code>对象的数据，但是该对象可以继续使用；</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>对于某个查询，会构建一个key值，根据这个key值去缓存<code>Cache</code>中取出对应的缓存结果</li><li>判断从<code>Cache</code>中根据特定的key值取的数据数据是否为空，即是否命中</li><li>如果命中，则直接将缓存结果返回</li><li>如果没命中：<br> 4.1  去数据库中查询数据，得到查询结果<br> 4.2  将key和查询到的结果分别作为key-value对存储到<code>Cache</code>中<br> 4.3. 将查询结果返回</li><li>结束</li></ol><p><img src="http://blog.default.nanwulife.com/20141120133247125.jpg" alt=""></p><h3 id="CacheKey"><a href="#CacheKey" class="headerlink" title="CacheKey"></a>CacheKey</h3><p>在上面的工作流程中已经看到，<code>Cache</code>中的<code>Map</code>是根据一个key来查询缓存的，这个key的决定因素具体如下：</p><ol><li>传入的<code>statementId</code> （比如为<code>com.xxx.mapper.selectUserName</code>）</li><li>查询时要求的结果集中的结果范围 （结果的范围通过<code>rowBounds.offset</code>和<code>rowBounds.limit</code>表示）</li><li>这次查询所产生的最终要传递给JDBC <code>Preparedstatement</code>的SQL语句（<code>boundSql.getSql()</code>）</li><li>要设置的参数值（只用这个SQL语句所需要的参数）</li></ol><p>因此，CacheKey其实就是由<code>statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值</code>这四个条件并生成哈希构建而成的。MyBatis认为，对于两次查询，只要构建出的CacheKey一样，就认为它们是完全相同的查询，也就可以根据这个CacheKey去缓存中查找已有的缓存结果。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>MyBatis的一级缓存就是简单的使用了<code>HashMap</code>，MyBatis只负责将查询数据库的结果存储到缓存中去，不会去判断缓存存放的时间是否过长、是否过期，并且也没有对缓存的大小进行限制，因此对于准确性要求比较高的数据来说，要控制好<code>SqlSession</code>的生存时间，其生存时间越长，它缓存的数据有可能就越旧，从而造成与真实数据库的误差较大。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>当开一个会话时，一个<code>SqlSession</code>对象会使用一个<code>Executor</code>对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个<code>Executor</code>对象做文章。如果用户配置了<code>cacheEnabled=true</code>，那么MyBatis在为<code>SqlSession</code>对象创建<code>Executor</code>对象时，会对<code>Executor</code>对象加上一个装饰者：<code>CachingExecutor</code>，这时<code>SqlSession</code>使用<code>CachingExecutor</code>对象来完成操作请求。<code>CachingExecutor</code>对于查询请求，会先判断该查询请求在二级缓存中是否有缓存结果，如果有缓存结果，则直接返回该结果；如果缓存中没有，再交给真正的<code>Executor</code>对象来完成查询操作，之后<code>CachingExecutor</code>会将真正<code>Executor</code>返回的查询结果放置到缓存中，然后在返回给用户。</p><p><img src="http://blog.default.nanwulife.com/20141123125640998.jpg" alt=""></p><h3 id="缓存粒度"><a href="#缓存粒度" class="headerlink" title="缓存粒度"></a>缓存粒度</h3><p>MyBatis并不是简单地对整个Application就只有一个<code>Cache</code>缓存对象，它将缓存划分的更细，即是Mapper级别的，每一个Mapper都可以拥有一个<code>Cache</code>对象，具体如下：</p><ul><li>为每一个Mapper分配一个<code>Cache</code>缓存对象（使用<code>&lt;cache&gt;</code>节点配置）</li><li>多个Mapper共用一个<code>Cache</code>缓存对象（使用<code>&lt;cache-ref&gt;</code>节点配置）</li></ul><p><img src="http://blog.default.nanwulife.com/20141123125741812.jpg" alt=""></p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>虽然在Mapper中配置了<code>&lt;cache&gt;</code>，并且为此Mapper分配了<code>Cache</code>对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到<code>Cache</code>对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即在<code>&lt;select&gt;</code>节点中配置<code>useCache=&quot;true&quot;</code>，如 <code>&lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&gt;</code> ，Mapper才会对此Select的查询支持缓存特性。</p><p>总结来说，要想使某条<code>select</code>查询支持二级缓存，需要保证：</p><ol><li>MyBatis支持二级缓存的总开关：全局配置变量参数<code>cacheEnabled=true</code></li><li>该<code>select</code>语句所在的Mapper，配置了<code>&lt;cache&gt;</code>或<code>&lt;cached-ref&gt;</code>节点，并且有效</li><li>该<code>select</code>语句的参数<code>useCache=true</code></li></ol><h3 id="二级缓存实现的选择"><a href="#二级缓存实现的选择" class="headerlink" title="二级缓存实现的选择"></a>二级缓存实现的选择</h3><p>MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的<code>Cache</code>缓存实现类，有大量的<code>Cache</code>的装饰器来增强<code>Cache</code>缓存的功能。另外，MyBatis还允许用户自定义<code>Cache</code>接口实现，用户只需要实现<code>org.apache.ibatis.cache.Cache</code>接口，然后将<code>Cache</code>实现类配置在<code>&lt;cache  type=&quot;&quot;&gt;</code>节点的<code>type</code>属性上即可。除此之外，MyBatis还支持跟第三方内存缓存库如Memecached的集成。总之，使用MyBatis的二级缓存有三个选择:</p><ol><li>MyBatis自身提供的缓存实现</li><li>用户自定义的<code>Cache</code>接口实现</li><li>跟第三方内存缓存库的集成</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/luanlouis/article/details/41280959" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的一级缓存实现详解 及使用注意事项</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/41408341" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的二级缓存的设计原理</a>08341)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;缓存机制是MyBatis的一大特性，它分为一级和二级缓存，其中一级缓存是&lt;code&gt;SqlSession&lt;/code&gt;级别的缓存，其实现较为
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之#{}和${}的区别</title>
    <link href="http://yoursite.com/2019/05/16/MyBatis%E4%B9%8B-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/16/MyBatis之-和-的区别/</id>
    <published>2019-05-16T09:58:00.000Z</published>
    <updated>2019-05-16T10:00:29.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态SQL是MyBatis的强大特性之一，我们在使用MyBatis作为持久层框架时，经常需要动态传递参数，例如我们需要根据用户的姓名来筛选用户时，SQL如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"Lihua"</span>;</span><br></pre></td></tr></table></figure></p><p>上述SQL中，我们希望<code>name</code>是动态可变的，即不同的时刻根据不同的姓名来查询用户，那么在MyBatis的xml中可以如下配置：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = #&#123;<span class="keyword">name</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'$&#123;name&#125;'</span>;</span><br></pre></td></tr></table></figure></p><p>这两种方式的本质是不同的，如果不了解其原理，在某些场景下会导致意想不到的后果。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>MyBatis在对SQL语句进行预编译之前，会对SQL进行动态解析，解析为一个<code>BoundSql</code>对象，也正是在这个阶段<code>#{}</code>和<code>${}</code>会有不同的表现。</p><h3 id=""><a href="#" class="headerlink" title="#{}"></a>#{}</h3><p>在动态SQL解析阶段，<code>#{}</code>解析为一个JDBC预编译（<code>PreparedStatement</code>）的参数标记符。例如，如下的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = #&#123;<span class="keyword">name</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>会被解析为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ?;</span><br></pre></td></tr></table></figure></p><p>也就是说，一个<code>#{}</code>被解析为一个参数占位符<code>?</code>。</p><h3 id="-1"><a href="#-1" class="headerlink" title="${}"></a>${}</h3><p>在动态SQL解析阶段，<code>${}</code>仅仅为一个纯粹的字符串替换。例如，如下的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'$&#123;name&#125;'</span>;</span><br></pre></td></tr></table></figure></p><p>当我们传递的参数为<code>Lihua</code>时，上述SQL解析为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"Lihua"</span>;</span><br></pre></td></tr></table></figure></p><p>也就是说，预编译前的SQL语句已经不包含变量<code>name</code>了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于<code>#{}</code>，它其实就对应着JDBC中的<code>PreparedStatement</code>的<code>?</code>，因此一旦MySQL服务器对SQL模板进行了编译，并且存储了函数，<code>PreparedStatement</code>做的就是把参数进行转义后直接传入参数到数据库，然后让函数执行，也就避免了SQL注入的问题；而<code>${}</code>的变量替换是在动态SQL解析阶段，也就是预编译之前，相当于这个SQL语句已经是个常量了，因此会产生SQL注入的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000004617028" target="_blank" rel="noopener">mybatis深入理解(一)之 # 与 $ 区别以及 sql 预编译</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;动态SQL是MyBatis的强大特性之一，我们在使用MyBatis作为持久层框架时，经常需要动态传递参数，例如我们需要根据用户的姓名来筛选用
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis架构设计</title>
    <link href="http://yoursite.com/2019/05/16/MyBatis%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/05/16/MyBatis架构设计/</id>
    <published>2019-05-16T08:28:00.000Z</published>
    <updated>2019-05-16T08:29:08.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="http://blog.default.nanwulife.com/20180314192452838.jpg" alt=""></p><p>MyBatis和数据库交互有两种方式：</p><ol><li>使用传统的MyBatis提供的API：传递Statement Id和查询参数给<code>SqlSession</code>对象，使用<code>SqlSession</code>对象完成和数据库的交互：<br><img src="http://blog.default.nanwulife.com/20141103155203576.jpg" alt=""></li><li>使用Mapper接口：MyBatis将配置文件中的每一个<code>&lt;mapper&gt;</code>节点抽象为一个<code>Mapper</code>接口，而这个接口中声明的方法和<code>&lt;mapper&gt;</code>节点中的<code>&lt;select | update | delete | insert&gt;</code>节点项对应，即<code>select | update | delete | insert</code>节点的id值为<code>Mapper</code>接口中的方法名称，<code>parameterType</code>值表示<code>Mapper</code>对应方法的入参类型，而<code>resultMap</code>值则对应了<code>Mapper</code>接口表示的返回值类型：<br><img src="http://blog.default.nanwulife.com/20141103163301421.jpg" alt=""></li></ol><p>使用<code>Mapper</code>接口的方式并配置好相关信息后，通过<code>SqlSession.getMapper(XXXMapper.class)</code>方法，MyBatis会根据相应的接口声明的方法信息，通过动态代理机制生成一个<code>Mapper</code>实例，我们使用<code>Mapper</code>接口的某一个方法时，MyBatis会根据这个方法的方法名，确定<code>Statement Id</code>，底层还是通过<code>SqlSession.select(&quot;statementId&quot;,parameterObject);</code>或者<code>SqlSession.update(&quot;statementId&quot;,parameterObject);</code>等等来实现对数据库的操作。</p><h2 id="主要构件"><a href="#主要构件" class="headerlink" title="主要构件"></a>主要构件</h2><p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p><ul><li><code>SqlSession</code>：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li><li><code>Executor</code>：MyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护</li><li><code>StatementHandler</code>：封装了JDBC Statement操作，负责对JDBC Statement的操作，如设置参数、将Statement结果集转换成<code>List</code>集合</li><li><code>ParameterHandler</code>：负责对用户传递的参数转换成JDBC Statement所需要的参数</li><li><code>ResultSetHandler</code>：负责将JDBC返回的<code>ResultSet</code>结果集对象转换成<code>List</code>类型的集合</li><li><code>TypeHandler</code>：负责java数据类型和jdbc数据类型之间的映射和转换</li><li><code>MappedStatement</code>：<code>MappedStatement</code>维护了一条<code>&lt;select | update | delete | insert&gt;</code>节点的封装</li><li><code>SqlSource</code>：负责根据用户传递的<code>parameterObject</code>，动态地生成SQL语句，将信息封装到<code>BoundSql</code>对象中，并返回</li><li><code>BoundSql</code>：表示动态生成的SQL语句以及相应的参数信息</li><li><code>Configuration</code>：MyBatis所有的配置信息都维持在<code>Configuration</code>对象之中。</li></ul><p>它们的关系如下图所示：</p><p><img src="http://blog.default.nanwulife.com/20141028140852531.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的架构设计以及实例分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blog.default.nanwulife.com/20180314192452838.
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>JDBC：PreparedStatement和Statement</title>
    <link href="http://yoursite.com/2019/05/16/JDBC%EF%BC%9APreparedStatement%E5%92%8CStatement/"/>
    <id>http://yoursite.com/2019/05/16/JDBC：PreparedStatement和Statement/</id>
    <published>2019-05-16T06:49:00.000Z</published>
    <updated>2019-05-16T06:49:49.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL支持预编译"><a href="#MySQL支持预编译" class="headerlink" title="MySQL支持预编译"></a>MySQL支持预编译</h2><p>在不使用预编译时，客户端每发送一条sql语句给服务器后，服务器总是需要校验sql语句的语法格式是否正确，然后把sql语句编译成可执行函数，最后才是执行sql语句。其中，校验语法和编译所花的时间可能比执行sql语句花的时间还要多。因此，如果我们需要执行多次<code>insert</code>语句，但每次只是插入的值不同，MySQL都要校验语法和编译，会浪费许多时间，而如果使用预编译功能，那么就只用对sql语句进行一次语法校验和编译，所以效率要高。</p><p>MySQL本身是支持预编译的，MySQL执行预编译分为如下三步：</p><ol><li>执行预编译语句，例如：<code>prepare myFunc from &#39;select * from user where username like ?&#39;</code></li><li>设置变量，例如：<code>set @username=&#39;%小明%&#39;</code></li><li>执行语句，例如：<code>execute myFunc using @username</code></li></ol><p>如果需要再次执行<code>myFunc</code>，那就不再需要第一步，即不需要再编译语句了：</p><ol><li>设置变量，例如：<code>set @username=&#39;%小宋%&#39;</code></li><li>执行语句，例如：<code>execute myFunc using @username</code></li></ol><h2 id="PreparedStatement使用预编译"><a href="#PreparedStatement使用预编译" class="headerlink" title="PreparedStatement使用预编译"></a>PreparedStatement使用预编译</h2><p>JDBC的<code>PreparedStatement</code>接口是有预编译功能的，但是在JDBC MySQL驱动5.0.5以后的版本默认是关闭预编译功能的，因此如果我们不手动开启的话，其实并没有使用到预编译，只是用到了防止sql注入的功能。要开启预编译功能，我们需要设置MySQL连接URL参数：<code>useServerPrepStmts=true</code>，这样才能保证MySQL驱动会先把sql语句发送给服务器进行预编译，然后在执行<code>executeQuery()</code>时只是把参数发送给服务器。</p><p>注意：通过设置MySQL连接参数，目的是告诉MySQL<code>PreparedStatement</code>使用预编译功能，但不管我们是否使用预编译功能，MySQL Server4.1版本以后都是支持预编译功能的。</p><p>当使用不同的<code>PreparedStatement</code>对象来执行相同的sql语句时，还是会出现编译两次的现象，这是因为驱动没有缓存编译后的函数key，导致二次编译。但在实际的应用场景中，我们不可能保持同一个<code>PreparedStatement</code>，此时如果希望缓存编译后的函数的key，那么就要设置MySQL连接参数<code>cachePrepStmts=true</code>。</p><h2 id="在持久层框架中存在的问题"><a href="#在持久层框架中存在的问题" class="headerlink" title="在持久层框架中存在的问题"></a>在持久层框架中存在的问题</h2><p>很多主流持久层框架其实都没有真正的用上预编译，预编译是要我们自己在连接参数上配置的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>MySQL主流版本是支持预编译的，但<code>PremaredStatement</code>在JDBC MySQL驱动5.0.5以后需要手动配置连接参数才可以使用预编译功能，如果同时也开启了缓存，那么MySQL服务器是会缓存编译后的函数，而编译后的函数key缓存在<code>PreparedStatement</code>中，此时不同的<code>PreparedStatement</code>执行相同的sql语句时不会重复编译，也就提高了效率。</li><li><code>Statement</code>对于MySQL数据库是不会对编译后的函数进行缓存的，数据库不会缓存函数，<code>Statement</code>也不会缓存函数的key，所以多次执行相同的sql语句时，还是会先检查sql语句语法是否正确，然后编译sql语句成函数，最后执行函数。</li><li>因为<code>PreparedStatement</code>已经对sql模板进行了编译，并且存储了函数，所以<code>PreparedStatement</code>做的就是把参数进行转义后直接传入参数到数据库，然后让函数执行，这也就是为什么<code>PreparedStatement</code>能够防止sql注入攻击的原因。</li><li><code>PreparedStatement</code>还有一点要注意的是，在数据库端存储的函数和<code>PreparedStatement</code>中存储的函数key，都是建立在数据库连接的基础上的，如果当前数据库连接断开了，数据库端的函数会清空，建立在连接上的<code>PreparedStatement</code>里面的函数key也会被清空。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/Marvel__Dead/article/details/69486947" target="_blank" rel="noopener">JDBC：深入理解PreparedStatement和Statement</a></li><li><a href="https://cs-css.iteye.com/blog/1847772" target="_blank" rel="noopener">探究mysql预编译</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL支持预编译&quot;&gt;&lt;a href=&quot;#MySQL支持预编译&quot; class=&quot;headerlink&quot; title=&quot;MySQL支持预编译&quot;&gt;&lt;/a&gt;MySQL支持预编译&lt;/h2&gt;&lt;p&gt;在不使用预编译时，客户端每发送一条sql语句给服务器后，服务器总是需要校验s
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="PreparedStatement" scheme="http://yoursite.com/tags/PreparedStatement/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池源码分析</title>
    <link href="http://yoursite.com/2019/05/12/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/12/Java线程池源码分析/</id>
    <published>2019-05-12T13:51:00.000Z</published>
    <updated>2019-05-12T13:52:24.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java中实现异步任务的处理，我们通常会使用Executor框架，而它的子类<code>ThreadPoolExecutor</code>则提供了线程池的实现，避免了线程频繁创建与销毁所带来的性能开销，为线程做了统一的管理与监控。因此，本文将从<code>Executor</code>接口开始逐层向下分析，重点关注<code>ThreadPoolExecutor</code>，这也是我们平时使用最多的一个类，深入理解它的原理还是很重要的。</p><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><code>Executor</code>接口位于整个体系的最顶层，它只包含一个<code>execute()</code>方法；<code>ExecutorService</code>也是接口，它在<code>Executor</code>接口的基础上添加了很多的接口方法，所以一般我们会使用这个接口；<code>AbstractExecutorService</code>是抽象类，实现了部分的方法，而把其它一些核心方法交给了子类去实现；<code>ThreadPoolExecutor</code>是最核心的一个类，它真正的实现了线程池的相关功能，是重点需要分析的一个类；<code>ScheduledExecutorService</code>是定时任务相关的接口，本文不会去分析该类。</p><p><img src="http://blog.default.nanwulife.com/ScheduledThreadPoolExecutor.png" alt=""></p><p>除此之外，该体系还涉及一个<code>Executors</code>工具类，它提供了很多创建线程池的静态方法，为我们省去了创建线程池时需要关心的参数细节。</p><h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Executor</code>接口非常简单，只有一个<code>execute()</code>方法，用来提交一个任务去执行。注意参数是<code>Runnable</code>类型的，表示一个任务。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>由于<code>Executor</code>接口只有提交任务的功能，我们更多使用的是<code>ExecutorService</code>，它定义的方法比较丰富，大部分情况下已经能满足我们的需求了。例如 ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(args...);</span><br><span class="line">ExecutorService executor = Executors.newCachedThreadPool(args...);</span><br></pre></td></tr></table></figure></p><p>下面看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭线程池：停止接受外部提交的新任务，而等到正在执行的任务以及队列中等待的任务执行完才真正关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池：停止接受外部提交的新任务，忽略队列里等待的任务，尝试将正在跑的任务中断，然后返回未执行的任务列表</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池是否关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回 true</span></span><br><span class="line">    <span class="comment">// 这个方法必须在调用 shutdown() 或 shutdownNow() 方法之后调用才会返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池后等待所有任务完成，并设置超时时间：调用 shutdown() 或 shutdownNow() 方法后，调用该方法阻塞直到所有任务执行完毕或发生了超时，返回 false 表示发生了超时</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Callable 任务，返回一个 Future</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务，返回一个 Future，第二个参数会放到 Future 中作为返回值</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个接口提供了大部分我们需要的功能，一些不太常用的如<code>invokeAll()</code>、<code>invokeAny()</code>等上面将其省略了，不进行分析。</p><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p><code>AbstractExecutorService</code>抽象类实现了几个实用的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 Runnable 包装成 FutureTask，内部其实会通过 Executors#callable 方法将这个 Runnable 转换成 Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务，和 execute() 不同的是这个会返回一个 Future</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);    <span class="comment">// 将 Runnable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);     <span class="comment">// 将 Runnable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);         <span class="comment">// 将Callable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个抽象类封装了一些基本的方法如<code>submit()</code>，但是都没有真正开启线程来执行任务，它们都只是在方法内部调用了<code>execute()</code>方法，而将该方法交由子类去实现。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是JDK中的线程池实现，这个类实现了一个线程池需要的各个方法，比如任务提交、线程管理、监控等等。关于这个方法内容比较多，因此将会拆开来分析。</p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><p>我们先看看该类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心参数的作用分别如下：</p><ul><li><code>corePoolSize</code>：核心线程数，当线程数小于该值时，线程池会创建新线程来执行新任务</li><li><code>maximumPoolSize</code>：线程池允许创建的最大线程数</li><li><code>keepAliveTime</code>：空闲线程的存活时间，但要注意这个值不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数<code>corePoolSize</code>，那么这些线程不会因为空闲太长时间而被关闭，但也可以通过调用<code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</li><li><code>workQueue</code>：任务队列，用来存储未执行的任务，是<code>BlockingQueue</code>接口的某个实现</li><li><code>threadFactory</code>：线程工厂，可通过工厂为新建的线程设置更有意义的名字</li><li><code>handler</code>：拒绝策略，当线程池和任务队列均处于饱和状态时该使用的处理方式，默认为抛出异常</li></ul><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p><code>ThreadPoolExecutor</code>采用一个32位的整数来存放线程池的状态和当前池中的线程数，其中高3位用于存放线程池状态，低29位表示线程数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 状态控制变量，该变量用于表示线程池的状态和线程数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">/** 该方法用于组合线程池的状态和线程数，通过按位或的方式 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 就是29 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">/** 线程池的最大线程数，也就是（2^29-1）：000 11111111111111111111111111111 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池的状态存放在高3位中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;     <span class="comment">// 111 0000...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 000 0000...，对应 shutdown()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;        <span class="comment">// 001 0000...，对应 shutdownNow()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;       <span class="comment">// 010 0000...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 011 0000...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池的运行状态，~运算符i会将0、1取反</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取线程池中的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure></p><p>这里面的状态还是比较清晰的，并且状态值是顺序递增的。<code>RUNNING</code>表示线程池的初始状态，而<code>SHUTDOWN</code>和<code>STOP</code>分别是调用了<code>shutdown()</code>和<code>shutdownNow()</code>方法后进入的状态，其中在<code>tryTerminate()</code>方法中转换成<code>TIDYING</code>状态，表示在<code>SHUTDOWN / STOP</code>后任务队列和线程池都清空了，此时执行钩子方法<code>terminated()</code>，而当<code>terminated()</code>方法结束后，线程池的状态就会变为<code>TERMINATED</code>。</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p><code>Worker</code>是<code>ThreadPoolExecutor</code>的内部类，用于封装线程池中的工作线程，也就是用来执行任务的，而任务是<code>Runnable</code>（内部变量名叫<code>task</code>或<code>command</code>）。要注意的是，该类继承了AQS，用于实现一个简单的互斥锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程，用来执行任务的</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放此线程完成的任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);   <span class="comment">// 通过构造线程池时传入的线程工厂来创建一个新线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用了外部的 runWorker() 方法</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 以下为AQS相关的方法：</span></span><br><span class="line">    <span class="comment">// 0 表示解锁状态</span></span><br><span class="line">    <span class="comment">// 1 表示加锁状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><p><code>Worker</code>实现了<code>Runnable</code>接口，并将<code>run()</code>方法的实现委托给了外部类<code>ThreadPoolExecutor</code>的<code>runWorker()</code>方法，这个方法就是不断的从任务队列中拿取任务运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">// 用于标记完成任务时是否有异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环：初始任务（首次）或者从阻塞队列中拿一个（后续）</span></span><br><span class="line">        <span class="comment">// 这也体现了线程池的意义，工作线程在执行完一个任务后，会再次到任务队列中获取新的任务，实现了”线程复用“</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取互斥锁，在获取互斥锁时，调用 shutdown() 方法不会中断线程，但是 shutdownNow() 方法无视互斥锁，会中断所有线程</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 判断是否需要中断当前线程。如果线程池的状态 &gt;= STOP ，当前线程未中断，则中断当前线程，否则清除线程中断位</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 交由子类实现的前置处理钩子</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 真正的执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 交由子类实现的后置处理钩子</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++; <span class="comment">// 该 Worker 完成的任务数加一</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while 循环之外</span></span><br><span class="line">        </span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);    <span class="comment">// 处理工作线程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><p>在<code>runWorker()</code>方法中，会尝试通过阻塞队列获取任务来执行，而这个获取任务的逻辑则封装到了<code>getTask()</code>这个核心方法中。在以下几种情况会返回<code>null</code>从而接下来线程退出（<code>runWorker()</code>方法中的循环结束）：</p><ol><li>当前工作线程数超过了<code>maximumPoolSize</code>（由于<code>maximumPoolSize</code>可以动态调整，这是可能的）</li><li>线程池状态为<code>STOP</code>（因为<code>STOP</code>状态不处理阻塞队列中的任务了）</li><li>线程池状态为<code>SHUTDOWN</code>，但阻塞队列为空</li><li>线程数量大于<code>corePoolSize</code>或<code>allowCoreThreadTimeOut</code>设置为<code>true</code>，当线程空闲时间超过<code>keepAliveTime</code>（这里说的空闲时间其实就是<code>poll()</code>方法阻塞在队列上的时间）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上次从阻塞队列 poll 任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if 条件等价于  rs &gt;= STOP || (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 此时将工作线程数减一</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut 是用于设置核心线程是否受 keepAliveTime 影响，</span></span><br><span class="line">        <span class="comment">// 在 allowCoreThreadTimeOut 为 true 或工作线程数 &gt; corePoolSize的情况下，</span></span><br><span class="line">        <span class="comment">// 当前的工作线程会受 keepAliveTime 影响</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 工作线程数 &gt; maximumPoolSize，当前工作线程需要退出</span></span><br><span class="line">        <span class="comment">// 2. timed &amp;&amp; timedOut == true 说明当前线程受 keepAliveTime 影响并且上次获取任务超时。这种情况下，如果当前线程不是最后一个线程或者队列为空，则可以退出</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 timed 变量的值决定是限时阻塞获取还是一直阻塞获取队列中的任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :   <span class="comment">// 超时退出</span></span><br><span class="line">                workQueue.take();   <span class="comment">// 一直阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;    <span class="comment">// 走到这说明 poll 超时了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><p>有了上面的一些概念后，接下来我们看看最核心的<code>execute()</code>方法，它包含了提交任务时的几大过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();      <span class="comment">// 获取线程池的状态控制变量</span></span><br><span class="line">    <span class="comment">// 1. 如果线程数少于核心线程池的大小，则添加一个 Worker 来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 到这里说明当前线程数大于等于核心线程池大小（或者 addWorker() 失败），如果线程池处于 RUNNING 状态，则将这个任务添加到阻塞队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 2.1 线程池已经关闭了，则移除队列中刚提交的任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 2.2 没有工作线程了，则添加一个空任务工作线程用于执行提交的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 如果阻塞队列满了，那么以 maximumPoolSize 为界创建新的 Worker，</span></span><br><span class="line">    <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，此时执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先对上面的三大步骤做个抽象层面的梳理：<br><img src="http://blog.default.nanwulife.com/1787733-248f411a83669fff.webp" alt=""></p><ol><li>如果当前运行的线程数少于<code>corePoolSize</code>，则创建新线程来执行任务</li><li>如果运行的线程数大于或等于<code>corePoolSize</code>，则将任务加入阻塞队列</li><li>如果阻塞队列也满了，则以<code>maximumPoolSize</code>为界创建新线程，如果线程数比<code>maximumPoolSize</code>还大，则执行拒绝策略</li></ol><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>下面开始更细的去分析上述三大流程中涉及的一些方法，首先是<code>addWorker()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 准备提交给这个线程执行的任务，可以为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core 如果为 true，表示使用核心线程数 corePoolSize 作为创建线程的界限；如果为 false，表示使用最大线程数 maximumPoolSize 作为创建线程的界限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();          <span class="comment">// 获取线程池的状态控制变量</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">// 获取线程池的状态</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 当线程池状态小于 SHUTDOWN 时，直接往下继续执行</span></span><br><span class="line">        <span class="comment">// 当线程池状态等于 SHUTDOWN 时，如果 firstTask 为 null，且 workQueue 不为空，是允许创建新的 Worker 的，因为此时要把 workQueue 中的任务执行完；否则，当其中一个条件不满足时，不会继续往下执行</span></span><br><span class="line">        <span class="comment">// 当线程池状态大于 SHUTDOWN 时，不允许创建新的 Worker 提交任务，不会继续往下执行</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);  <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||         <span class="comment">// 如果超过了 2^29-1 这个上限，或者超过了 corePoolSize 或 maximumPoolSize（由传入参数决定使用哪个），一样不会继续往下执行</span></span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功 CAS 新增 Worker 的数目，跳出循环往下走</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 重读状态控制变量，如果线程池状态变了，则重试整个大循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 否则，仅仅是 workerCount 变了，也就是 CAS 新增 workerCount 失败，重试内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行到此处时，线程池线程数已经成功+1，下面进行实质操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;  <span class="comment">// Worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;  <span class="comment">// Worker 是否已经添加到 workers 中</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);  <span class="comment">// 在这个 Worker 的构造函数中，会通过线程工厂 new 一个新线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;  <span class="comment">// 获取在构造 Worker 时线程工厂 new 出的新线程</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 整个线程池的全局锁，因为关闭线程池是需要这个锁的，这能保证持有锁的期间，线程池不会关闭</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 由于获取锁之前线程池状态可能发生了变化，这里需要重新读一次状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 如果小于 SHUTDOWN 或者等于 SHUTDOWN 但 firstTask == null（不接受新任务但会继续执行阻塞队列中的任务）</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// worker 中的 thread 不能是已经启动了的，不然要抛出异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);     <span class="comment">// 将新创建的 Worker 加入到 workers 这个 HashSet 中</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;    <span class="comment">// 记录线程池的历史最大值</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// Worker 添加成功，启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 Worker 线程启动失败，则做一些回滚操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里笔者刚开始很疑惑的一点是，为什么<code>t.start();</code>会执行到<code>Worker</code>中的<code>run()</code>方法，它不是<code>Worker</code>中的属性吗，它自己本身并没有传入一个<code>Runnable</code>吧。但实际上，在通过线程工厂创建这个线程的时候，是传入了一个<code>Runnable</code>的，它就是<code>Worker</code>本身：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);   <span class="comment">// 注意这里的 this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，当我们使用<code>t.start()</code>开启这个<code>Thread</code>的时候，这个<code>Thread</code>中的<code>target</code>是为<code>Worker</code>本身的，所以才会执行它的<code>run()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此时就与之前分析<code>Worker</code>时候的方法串起来了，<code>Worker</code>的<code>run()</code>方法的执行逻辑其实是委托给外部类的<code>runWorker()</code>方法来完成，而<code>runWorker()</code>方法最终调用的就是传入的<code>firstTask</code>或者从阻塞队列中取到的某个任务，执行它的<code>run()</code>方法。</p><h4 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h4><p>线程成功启动后的逻辑已经分析完了，接下来看看线程如果启动失败时会发生什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是回滚后尝试终止线程池：</p><ol><li>从<code>workers</code>中删除失败的Worker</li><li><code>workerCount</code>减一</li><li>调用<code>tryTerminate()</code>尝试终止线程池</li></ol><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p><code>shutdown()</code>方法关闭线程池比较优雅，线程池进入<code>SHUTDOWN</code>后不会再接受新任务，并且中断所有空闲线程（阻塞在队列上的线程），但是任务队列中已有的任务将会继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();  <span class="comment">// 检查是否有 shutdown 的权限，非重点</span></span><br><span class="line">        advanceRunState(SHUTDOWN);  <span class="comment">// 状态切换到 SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers();             <span class="comment">// 中断所有空闲线程，或者说在任务队列上阻塞的线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池（状态流转至 TERMINATED）</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 工作线程在处理任务阶段是被互斥锁保护着的，所以 tryLock() 会返回 false，不会中断到</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p><code>shutdownNow()</code>方法关闭线程池相比<code>shutdown()</code>暴力了一些，会中断所有线程，哪怕线程正在执行任务。线程池进入<code>STOP</code>状态后既不会接受新任务，也不会处理任务队列中已有的任务。需要注意的是，即便<code>shutdownNow()</code>会中断正在执行任务的线程，但不代表任务一定会挂，因为如果提交的任务里面的代码没有对线程中断敏感的逻辑的话，线程中断是不会有任何效果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();      <span class="comment">// 检查是否有 shutdown 的权限，非重点</span></span><br><span class="line">        advanceRunState(STOP);      <span class="comment">// 状态切换到 STOP</span></span><br><span class="line">        interruptWorkers();             <span class="comment">// 与 SHUTDOWN 不同的是，直接中断所有线程</span></span><br><span class="line">        tasks = drainQueue();         <span class="comment">// 将任务队列中的任务收集到 tasks</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池（状态流转至 TERMINATED）</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法在 Worker 类中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>在<code>execute()</code>方法中我们可以看到，有两种情况会调用<code>reject()</code>拒绝策略来处理任务，一个是当任务加入阻塞队列后的短暂空窗期线程池已经关闭了，此时再次查看线程池的状态不为<code>RUNNING</code>就会将任务移出队列并执行拒绝策略，另一个是当线程数超过了<code>maximumPoolSize</code>，无法再创建新线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RejectedExecutionHandler</code>在<code>ThreadPoolExecutor</code>中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果线程池没有被关闭，那么由提交任务的线程自己来执行这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管怎样，直接抛出 RejectedExecutionException 异常</span></span><br><span class="line"><span class="comment">// 这个是默认的策略，如果在构造线程池时不传相应的 handler 的话，那就会使用这个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不做任何处理，直接忽略掉这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果线程池没有被关闭，那么丢弃任务队列中首部的任务，然后提交该任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p><code>Executors</code>是一个工具类，所有的方法都是<code>static</code>的，它为我们创建线程池提供了很大的便利。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>生成一个固定大小的线程池，最大线程数设置为与核心线程数相等，此时<code>keepAliveTime</code>设置为0（因为这里它是没用的，即使不为0，线程池默认也不会回收<code>corePoolSize</code>内的线程），阻塞队列采用<code>LinkedBlockingQueue</code>无界队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>生成只有一个线程的线程池，与<code>newFixedThreadPool</code>唯一的不同在于核心线程和最大线程数都为1，不需要指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>生成一个需要的时候就创建新线程的线程池。这种线程池对于任务可以比较快速地完成的情况下有比较好的性能，如果线程空闲了60秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有线程的关闭，整个线程池不会占用任何的系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从<code>Executor</code>顶层接口逐层向下分析，重点讲解了<code>ThreadPoolExecutor</code>的源码实现，包括核心参数、线程创建过程、执行任务、拒绝策略和线程池的关闭等，由于Executor体系本身内容还是比较多的，因此有些地方依然没有关注到，例如定时相关的<code>ScheduledExecutorService</code>接口和同时实现了<code>ThreadPoolExecutor</code>与<code>ScheduledExecutorService</code>的<code>ScheduledThreadPoolExecutor</code>，并且关于<code>ThreadPoolExecutor</code>的线程池关闭这一块，也还有几个方法没有深入分析，将来有时间一定补上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/micrari/p/7429364.html" target="_blank" rel="noopener">ThreadPoolExecutor源码解读</a></li><li><a href="https://javadoop.com/post/java-thread-pool" target="_blank" rel="noopener">深度解读 java 线程池设计思想及源码实现</a></li><li><a href="http://www.tianxiaobo.com/2018/04/17/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Java 线程池原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java中实现异步任务的处理，我们通常会使用Executor框架，而它的子类&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Executor" scheme="http://yoursite.com/tags/Executor/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码分析</title>
    <link href="http://yoursite.com/2019/05/11/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/11/ThreadLocal源码分析/</id>
    <published>2019-05-11T03:31:00.000Z</published>
    <updated>2019-05-11T03:32:42.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>每个线程读写<code>ThreadLocal</code>是线程隔离的，互相之间不会影响。其原因就是在于<code>Thread</code>类有一个<code>ThreadLocal.ThreadLocalMap</code>类型的属性，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>，读写某个<code>ThreadLocal</code>时都会获取当前线程以及当前线程的<code>ThreadLocalMap</code>属性，对其进行读写，以此实现线程隔离。以下是<code>ThreadLocal</code>的几个关键方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);   <span class="comment">// 将自己作为 key</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);    <span class="comment">// 将自己作为 key</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，<code>ThreadLocal</code>本身并没有太多东西，它只是作为<code>ThreadLocalMap</code>的key，核心源码其实都在<code>ThreadLocalMap</code>中。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>在开始源码分析之前，需要先了解弱引用这个概念，因为在<code>ThreadLocalMap</code>中<code>ThreadLocal</code>并不是直接作为key的，而是使用的弱引用对象<code>Entry</code>。在Java中存在四种引用，分别是强引用、软引用、弱引用和虚引用，它们的区别如下：</p><ul><li>强引用：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的，那么它就不被回收</li><li>软引用：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些</li><li>虚引用：虚引用是Java中最弱的引用，通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收</li></ul><p>之所以需要弱引用，是因为在类似<code>HashMap</code>的结构中，如果存放了一个key为<code>Product</code>对象且value为<code>1</code>的节点，此时我们有一个变量<code>product</code>指向了这个<code>Product</code>对象，当我们不再需要这个对象时，如果直接将<code>product</code>设为<code>null</code>，<code>Product</code>对象其实并不会被回收，因为通过<code>HashMap</code>它还存在一条强引用链，如果我们想让它被垃圾收集器回收，就必须将其彻底从<code>HashMap</code>中移除，让它不再存在任何强引用。如果上述过程我们不想自己手动去实现，而是想告诉垃圾收集器在只有<code>HashMap</code>中的key引用着<code>Product</code>对象的情况下，就可以回收相应的<code>Product</code>对象了，那么就可以使用弱引用。</p><p>Java中的弱引用具体指的是<code>java.lang.ref.WeakReference&lt;T&gt;</code>类，我们使用一个指向<code>Product</code>对象的弱引用对象来作为<code>HashMap</code>的<code>key</code>，只需这样定义这个弱引用对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product(...);</span><br><span class="line">WeakReference&lt;Product&gt; weakProduct = <span class="keyword">new</span> WeakReference&lt;&gt;(product);</span><br></pre></td></tr></table></figure></p><p>而如果要通过<code>weakProduct</code>获取它所指向的<code>Product</code>对象，我们只需要通过这行代码：<code>Product product = weakProductA.get();</code>即可。<code>WeakReference</code>的构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个指向给定对象的弱引用</span></span><br><span class="line">WeakReference(T referent)</span><br><span class="line"><span class="comment">//创建一个指向给定对象并且登记到给定引用队列的弱引用</span></span><br><span class="line">WeakReference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span><br></pre></td></tr></table></figure></p><p>通过将原始对象包装成弱引用对象，当变量<code>product</code>设为<code>null</code>时，指向这个<code>Product</code>对象的就只剩弱引用对象<code>weakProduct</code>了，显然这时候相应的<code>Product</code>对象是弱可达的，所以指向它的弱引用会被清除，这个<code>Product</code>对象随即会被回收，指向它的弱引用对象会进入引用队列中，在引用队列中可以对这些被清除的弱引用对象进行统一管理。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Entry节点"><a href="#Entry节点" class="headerlink" title="Entry节点"></a>Entry节点</h3><p>上面说过，<code>ThreadLocalMap</code>并不是简单的使用<code>ThreadLocal</code>作为key的，其实它内部存储着一个<code>Entry</code>节点数组，而<code>Entry</code>继承了弱引用类<code>WeakReference</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当构造一个<code>Entry</code>节点时，会先调用父类<code>WeakReference</code>的构造函数将<code>ThreadLocal</code>传入，并设置了一个类型为<code>Object</code>的<code>value</code>，用于存放<code>ThreadLocal</code>对应的值。</p><p>这里之所以要使用弱引用<code>Entry</code>节点而不是简单的key-value形式的节点，是因为如果简单的使用key-value形式会造成节点的生命周期与线程强绑定，只要线程存在，那么作为属性的<code>ThreadLocalMap</code>也就存在，在不显式移除的情况下，key对象就依然被强引用着，没办法被回收。在这里通过使用弱引用节点，当我们将某个<code>ThreadLocal</code>对象的强引用设为<code>null</code>后，这个<code>ThreadLocal</code>对象就只剩下弱引用了，之后会被GC回收掉，有效的避免了内存泄漏的问题。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 初始容量默认为16</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Entry 数组，大小必须为2的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中 Entry 的实际个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>与<code>HashMap</code>不同，它是使用的线性探测法而非拉链法解决碰撞冲突的，所以实际上<code>Entry[]</code>数组在逻辑上是作为一个环形存在的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环形意义的下一个索引下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环形意义的前一个索引下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化 table 数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 用位运算而非取模得到下标，这也是为什么容量需要为偶数的原因</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 构造并设置该节点</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 更新表（数组）的大小</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数我们重点需要关注其中的<code>threadLocalHashCode</code>，这是传入的<code>ThreadLocal</code>对象的哈希值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure></p><p>这个哈希值在对象创建时就会生成，每次都会累加<code>0x61c88647</code>，通过这种方式使得与2的幂取模（实际是位运算）后均匀分布，也就提高了线性探测时的效率。</p><h3 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h3><p><code>getEntry()</code>方法会被<code>ThreadLocal</code>的<code>get()</code>方法直接调用，上面也说过，<code>get()</code>方法内部就是先拿到当前线程的<code>ThreadLocalMap</code>，然后将自己<code>this</code>作为参数调用其<code>getEntry()</code>方法。这里要提前说明一点的是，每个索引（slot）上的状态有三种：有效（<code>ThreadLocal</code>未回收），失效（<code>ThreadLocal</code>已回收），空（<code>null</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取这个 key 的索引下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 对应的 entry 不为空且未失效，且弱引用指向的 ThreadLocal 就是传入的 key，则命中返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 因为用的是线性探测，所以往后还是有可能找到目标 Entry 的</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 getEntry() 未直接命中时调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于线性探测法不断向后探测直到遇到 null</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)  <span class="comment">// 如果该 entry 对应的 ThreadLocal 已经被回收（失效），调用 expungeStaleEntry() 来清理无效的 entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 如果该 entry 对应的 ThreadLocal 未被回收，但与传入的 key 不等，则继续向后探测</span></span><br><span class="line">            i = nextIndex(i, len);  <span class="comment">// 环形意义下往后面走，线性探测</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到指定的 key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocal 的核心清理函数，从 staleSlot 下标开始遍历，将无效的的 entry 清理，</span></span><br><span class="line"><span class="comment"> * 即将 entry 中的 value 置为 null，指向这个 entry 的 table[i] 置为 null，直到遍历到空 entry。</span></span><br><span class="line"><span class="comment"> * 另外，在这个过程中还会对非空的 entry 作 rehash。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 entry 对应的 ThreadLocal 已经被回收，此时为了垃圾回收：</span></span><br><span class="line">    <span class="comment">// 将 entry 中的 value 置为 null，显示断开强引用</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将指向这个 entry 的 table[i] 置为 null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将实际 entry 数减一</span></span><br><span class="line">    size--;</span><br><span class="line">    </span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 从 staleSlot 的下一个索引开始，不断向后遍历，直到遇到 null</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果当前 entry 中的 ThreadLocal 已经被回收，则做一次清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 如果 entry 对应的 ThreadLocal 还没被回收，需要做一次 rehash</span></span><br><span class="line">            <span class="comment">// 如果 ThreadLocal 计算出的 hash 对应的索引h与当前位置不同，</span></span><br><span class="line">            <span class="comment">// 则从 h 开始向后线性探测直到第一个空的 slot，把当前的 entry 给挪过去</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;  <span class="comment">// 先将当前索引置 null</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)  <span class="comment">// 遍历找到从索引h开始的第一个空 slot</span></span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;     <span class="comment">// 将 entry 挪到这个空 slot 上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 staleSlot 之后第一个 entry 为 null 的索引下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，<code>getEntry()</code>会经历以下几步：</p><ol><li>根据传入的<code>ThreadLocal</code>的哈希值定位到某个索引下标</li><li>如果该下标对应的<code>entry</code>存在，且其中的<code>ThreadLocal</code>和方法传入的<code>ThreadLocal</code>相同，则直接命中返回</li><li>否则，调用<code>getEntryAfterMiss()</code>进行线性探测，过程中每次碰到失效的 slot，就调用<code>expungeStaleEntry</code>进行段清理（清理并rehash，直到遇到null）</li><li>遍历直到 null 都未命中 key，直接返回 null</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);  <span class="comment">// 获取该键对应的索引下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>;  e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到 key 相同的 entry，覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果当前 entry 失效，则替换失效的 entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线性探测过程中没有遇到 key 相同的 entry，也没遇到失效的 entry，当遇到 null 时跳出循环</span></span><br><span class="line">    <span class="comment">// 在 null 的位置上建立新的 entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换失效的 entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 staleSlot 向前遍历，查找最前的一个无效的 slot</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 staleSlot 向后遍历，看能不能找到相同的 key，如果找到了则和无效的 staleSlot 交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>;  i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了 key，将其与无效的slot交换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从 slotToExpunge 开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的 slot 已经无效，并且向前扫描过程中没有无效 slot，则更新 slotToExpunge 为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找不到相同的 key，则直接设置在失效的 staleSlot 下标上</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在探测过程中如果发现任何无效 slot，则做一次清理（连续段清理+启发式清理）</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 做一次全量清理，并且调低阈值决定是否扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">// 因为做了一次清理，所以 size 很可能会变小</span></span><br><span class="line">    <span class="comment">// 这里是调低阈值判断是否需要扩容，下面一行相当于 if(size &gt;= len / 2)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 全量清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 这里其实可以将 j 设为返回值，j 之前的 entry 其实已经被清理过了，肯定为 null</span></span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容为原来的两倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);   <span class="comment">// 计算新容量时哈希值对应的索引下标</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)   <span class="comment">// 线性探测解决碰撞冲突</span></span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新阈值</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set()</code>方法总体过程如下：</p><ol><li>在遍历（也就是线性探测）遇到null之前，如果遇到了相同的key，则直接覆盖；如果遇到了失效的entry，则调用<code>replaceStaleEntry</code>，效果是最终一定会把key和value放在这个slot上，并且会尽可能地清理无效entry</li><li>遍历过程既没遇到相同的key，也没遇到失效的entry，也就是当前索引上为null，则直接将key和value插在这个空slot上</li><li>如果插入后的<code>size</code>大于阈值，那么做一次全量清理，再根据调低的阈值决定是否需要扩容，扩容两倍（因为容量必须为2的幂）</li></ol><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove()</code>方法相对比较简单，只需要找到对应的key，然后将弱引用显式的断开，并做一次段清理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();                      <span class="comment">// 显式断开弱引用</span></span><br><span class="line">            expungeStaleEntry(i);     <span class="comment">// 进行段清理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里光做<code>e.clear();</code>其实是不够的，因为<code>value</code>此时还被强引用着，所以才需要进行段清理，将<code>table[i] = null;</code>彻底断开强引用。</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>经过上面的分析我们已经清楚在每个<code>Thread</code>中有一个<code>ThreadLocalMap</code>，每个线程在对某个<code>ThreadLocal</code>对象操作时都会先获取当前线程的<code>ThreadLocalMap</code>，然后对<code>ThreadLocalMap</code>进行操作，并且，<code>ThreadLocal</code>不是简单的作为key的，而是将key和value包装成继承自弱引用<code>WeakReference</code>的<code>Entry</code>类。但这里要注意的是，弱引用只是针对key（<code>Entry</code>中的<code>ThreadLocal</code>），当没有任何强引用指向<code>ThreadLocal</code>的时候，它就只剩下弱引用了，GC时将会被回收，但是value却不会被回收，因为它存在一条<code>当前Thread-&gt;ThreadLocalMap-&gt;Entry数组-&gt;Entry-&gt;value</code>的强引用，所以除非线程销毁，否则它将与线程的生命周期绑定，尤其是在有线程复用比如线程池的场景中，一个线程的寿命很长，大对象长期不被回收会影响系统运行效率与安全，也就造成了人们常说的内存泄露。</p><p><img src="http://blog.default.nanwulife.com/1660f7ebfeecebf2.jpg" alt=""></p><p>但是在源码中我们也会发现，<code>ThreadLocalMap</code>实现中是有一套自我清理的机制的，当我们调用<code>get()</code>或者<code>set()</code>方法时会有很高的概率顺便清理掉失效的<code>Entry</code>，防止出现内存泄露。当然，显示地进行<code>remove()</code>是个良好的编程习惯，它可以确保不会发生内存泄露。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/micrari/p/6790229.html" target="_blank" rel="noopener">ThreadLocal源码解读</a></li><li><a href="http://www.importnew.com/21206.html" target="_blank" rel="noopener">十分钟理解Java中的弱引用</a></li><li><a href="https://www.zhihu.com/question/37401125" target="_blank" rel="noopener">Java中的强引用，软引用，弱引用，虚引用有什么用？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;每个线程读写&lt;code&gt;ThreadLocal&lt;/code&gt;是线程隔离的，互相之间不会影响。其原因就是在于&lt;code&gt;Thr
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ：流控与镜像队列</title>
    <link href="http://yoursite.com/2019/05/08/RabbitMQ%EF%BC%9A%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E3%80%81/"/>
    <id>http://yoursite.com/2019/05/08/RabbitMQ：镜像队列、/</id>
    <published>2019-05-08T10:08:45.000Z</published>
    <updated>2019-05-08T10:09:08.516Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="队列的结构"><a href="#队列的结构" class="headerlink" title="队列的结构"></a>队列的结构</h2><p>通常队列由<code>rabbit_amqqueue_process</code>和<code>backing_queue</code>两部分组成，前者负责协议相关的消息处理，即接受生产者发布的消息、向消费者交付消息、处理消息的确认（包括生产端的<code>confirm</code>和消费端的<code>ack</code>）等。<code>backing_queue</code>是消息存储的具体形式和引擎，并向<code>rabbit_amqqueue_process</code>提供相关的接口以供调用。</p><h3 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h3><p>如果消息投递的目的队列是空的，并且有消费者订阅了这个队列，那么该消息会直接发送给消费者，不会经过队列这一步。而当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递。消息存入队列后，不是固定不变的，它会随着系统的负载在队列中不断地流动，消息的状态会不断发生变化。RabbitMQ中的队列消息可能会处于以下四种状态：</p><ul><li>alpha：消息内容（包括消息体、属性和headers）和消息索引都存储在内存中</li><li>beta：消息内容保存在磁盘中，消息索引保存在内存中</li><li>gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中都有</li><li>delta：消息内容和索引都在磁盘中</li></ul><p>其中，gamma状态的消息是只有持久化的消息才会有的状态。</p><p>RabbitMQ在运行时会根据统计的消息传送速率定期计算一个当前内存中能够保存的最大消息数量，如果alpha状态的消息数量大于此值时，就会引起消息的状态转换，多余的消息可能会转换到beta、gamma或者delta状态。其中，delta状态需要执行两次I/O操作才能读取到消息，一次是读消息索引，一次是读消息内容；而对于beta和gamma状态都只需要一次I/O操作就可以读取到消息。</p><p>对于普通的没有设置优先级和镜像的队列来说，<code>backing_queue</code>内部通过5个子队列Q1、Q2、Delta、Q3和Q4来体现消息的各个状态，其中Q1、Q4只包含alpha状态的消息，Q2、Q3包含beta和gamma状态的消息，Delta只包含delta状态的消息，一般情况下，消息按照Q1-&gt;Q2-&gt;Delta-&gt;Q3-&gt;Q4这样的顺序步骤进行流动。如图：<br><img src="http://blog.designpattern.nanwulife.com/G7FVm50dZ65bV06ppeVXQM8AIizdmM8JWHqfUFiQwNoF=1544076799852compressflag.png" alt=""></p><p>从Q1到Q4基本经历了内存到磁盘，再从磁盘到内存的过程，如此可以在队列负载很高的情况下，能够通过将一部分消息由磁盘保存来节省内存空间，而在负载降低的时候，这部分消息又渐渐回到内存被消费者获取，使得整个队列具有很好的弹性。</p><p>通常在负载正常时，如果消息被消费的速度不小于接受新消息的速度，对于非持久化的消息，通常只会处于alpha状态，而对于持久化的消息，一定会进入gamma状态，并且在开启生产端确认机制时，只有到了gamma状态时才会确认该消息已被接收，若消息消费速度足够快、内存也充足，这些消息也不会继续走到下一个状态。</p><p>在系统负载较高时，这些消息若不能很快的被消费掉，就会进入到很深的队列中去，这样会增加处理每个消息的平均开销，因为要花更多的时间和资源处理堆积的消息，如此用来处理新流入的消息的能力就会降低，导致恶性循环。应对这一问题，RabbitMQ有一套流控机制，在下文会介绍。</p><h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>队列具有两种模式，一个是<code>default</code>，一个是<code>lazy</code>。默认情况下，当生产者将消息发送到RabbitMQ中的时候，队列中的消息会尽可能地存储在内存之中，这样可以更加快速地将消息发送给消费者。当RabbitMQ需要释放内存时，将消息换入磁盘会耗费较长时间，也会阻塞队列的操作，进而无法接受新的消息。</p><p>RabbitMQ从3.6.0版本开始引入了惰性队列的概念，即将接受到的消息直接存入文件系统中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。惰性队列虽然减少了内存的消耗，但是增加了I/O的使用，因此对于持久化的消息，本身就不可避免磁盘I/O，使用惰性队列是较佳的选择。要注意的是，如果惰性队列中存储的是非持久化的消息，重启之后消息一样会丢失。</p><h2 id="内存及磁盘告警"><a href="#内存及磁盘告警" class="headerlink" title="内存及磁盘告警"></a>内存及磁盘告警</h2><p>当内存使用超过配置的阈值或者磁盘剩余空间低于配置的阈值时，RabbitMQ会暂时阻塞客户端的连接并停止接收从客户端发来的消息。被阻塞的Connection的状态要么是blocking，要么是blocked，前者对应于并不试图发送消息的Connection，后者对应于一直有消息发送的Connection，这种状态下的Connection会被停止发送消息。注意在一个集群中，如果一个Broker节点的内存或者磁盘受限，都会引起整个集群中所有的Connection被阻塞。</p><h3 id="内存告警"><a href="#内存告警" class="headerlink" title="内存告警"></a>内存告警</h3><p>默认情况下内存阈值为0.4，表示当RabbitMQ使用的内存超过40%时，会产生内存告警并阻塞所有生产者的连接。一旦告警被解除（有消息被消费或者从内存转储到磁盘等情况的发生），一切都会恢复正常。</p><p>在某个Broker快达到内存阈值时，会先尝试将队列中的消息换页到磁盘以释放内存空间。默认情况下，在内存到达内存阈值的50%时会进行换页动作。</p><h3 id="磁盘告警"><a href="#磁盘告警" class="headerlink" title="磁盘告警"></a>磁盘告警</h3><p>当剩余磁盘空间低于确定的阈值时，RabbitMQ同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务崩溃。默认情况下，磁盘阈值为50MB。RabbitMQ会定期检测磁盘剩余空间，检测的频率与上一次执行检测到的磁盘剩余空间大小有关，随着磁盘剩余空间与磁盘阈值的接近，检测频率会有所增加。</p><h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><p>当RabbitMQ出现内存或者磁盘资源达到阈值时，会触发流控机制，阻塞生产者的Connection，让生产者不能继续发送消息，直到内存或者磁盘资源得到释放。RabbitMQ基于Erlang开发，一个消息的生命周期中，会涉及多个进程间的转发，这些Erlang进程之间不共享内存，每个进程都有自己独立的内存空间，如果没有合适的流控机制，可能会导致某个进程占用内存过大，导致OOM。因此，要保证各个进程占用的内容在一个合理的范围。</p><p>RabbitMQ的流控机制的原理实质上就是通过监控各进程的mailbox，当某个进程负载过高来不及接收消息时，这个进程的mailbox就会开始堆积消息，当堆积到一定量时，就会阻塞住上游进程让其不得接收新消息，从而慢慢上游进程的mailbox也会开始积压消息，到了一定的量也会阻塞上游的上游的进程，最后就会使得负责网络数据包接收的进程阻塞掉，暂停接收数据。</p><p>从Connection到Channel到队列再到消息持久化存储形成了一个完整的流控链：<br><img src="http://blog.designpattern.nanwulife.com/7415a593-fa83-383b-869c-42659884dd1b.jpg" alt=""></p><p>其中的各个进程如下所述：</p><ul><li>rabbit_reader：Connection的处理进程，负责接收、解析AMQP协议数据包等</li><li>rabbit_channel：Channel的处理进程，负责处理AMQP协议的各种方法、进行路由解析等</li><li>rabbit_amqqueue_process：队列的处理进程，负责实现队列的所有逻辑</li><li>rabbit_msg_store：负责实现消息的持久化</li></ul><p>对于处于整个流控链中的任意进程，只要该进程阻塞，上游的进程必定全部被阻塞。也就是说，如果某个进程达到性能瓶颈，必然会导致上游所有的进程被阻塞。所以我们可以利用流控机制的这个特点找出瓶颈所在。</p><p>一个Connection触发流控时会处于<code>flow</code>的状态，也就意味着这个Connection的状态每秒在<code>blocked</code>和<code>unblocked</code>之间来回切换数次，这样可以将消息发送的速率控制在服务器能够支撑的范围之内。</p><h2 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h2><p>RabbitMQ的集群在默认模式下，队列实例只存在于一个节点上，既不能保证该节点崩溃的情况下队列还可以继续运行，也不能线性扩展该队列的吞吐量。虽然RabbitMQ的队列实际只会在一个节点上，但元数据可以存在于各个节点上。举个例子来说，当创建一个新的交换器时，RabbitMQ会把该信息同步到所有节点上，这个时候客户端不管连接到哪个RabbitMQ节点，都可以访问到这个新的交换器，也就能找到交换器下的队列：</p><p><img src="http://blog.designpattern.nanwulife.com/OFqjExcshZpj=tsMaQJXIBApa06sCdts0=91EuBoQhpl31544076799852compressflag.png" alt=""></p><p>RabbitMQ内部的元数据主要有：</p><ol><li>队列元数据：队列名称和属性</li><li>交换器元数据：交换器名称，类型和属性</li><li>绑定元数据：路由信息</li></ol><p>尽管交换器和绑定关系能够在单点故障问题上幸免于难，但是队列和其上存储的消息却不行，它们仅存在于单个节点上。引入镜像队列的机制，可以将队列镜像到集群中的其它Broker节点之上，如果集群中的一个节点失效了，队列能够自动地切换到镜像中的另一个节点上以保证服务的可用性。通常情况下，针对每一个配置镜像的队列都包含一个主拷贝和若干个从拷贝，相应架构如下：</p><p><img src="http://blog.designpattern.nanwulife.com/0JeBkrdwK7qUqTzySTsBegsoe6Bhg9PiMa3HYIMFSnPGQ1544076799852compressflag.png" alt=""></p><p>除了发送消息外的所有动作都只会向主拷贝发送，然后再由主拷贝将命令执行的结果广播给各个从拷贝，从拷贝实际只是个冷备（默认的情况下所有RabbitMQ节点上都会有镜像队列的拷贝），如果使用消息确认模式，RabbitMQ会在主拷贝和从拷贝都安全的接受到消息时才通知生产者。从这个结构上来看，如果从拷贝的节点挂了，实际没有任何影响，如果主拷贝挂了，那么会有一个重新选举的过程，这也是镜像队列的优点，除非所有节点都挂了，才会导致消息丢失。重新选举后，RabbitMQ会给消费者一个消费者取消通知（Consumer Cancellation），让消费者重连新的主拷贝。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>不同于普通的非镜像队列，镜像队列的实现结构如下：<br><img src="http://blog.designpattern.nanwulife.com/8=93STeAbnCfJrE7VLgGxEOr1IDyCPEUR8Lb8jY1F6IiF1544076799852compressflag.png" alt=""></p><p>所有对镜像队列主拷贝的操作，都会通过GM同步到各个slave节点，Coodinator负责组播结果的确认。GM是一种可靠的组播通信协议，该协议能够保证组播消息的原子性，即保证组内的存活节点要么都收到消息要么都收不到。</p><p>GM的组播并不是由master来负责通知所有slave的（目的是为了避免master压力过大，同时避免master失效导致消息无法最终ack)，RabbitMQ把所有节点组成一个链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新节点上；当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。操作命令由master发起，也由master最终确认通知到了所有的slave，而中间过程则由slave接力的方式进行消息传播。</p><p><img src="http://blog.designpattern.nanwulife.com/WUD5eU3KpIo3rCJZti5tw1TvD0yeQMZYCnHvQ6i5fXoCb1544076799853compressflag.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li><li><a href="https://sq.163yun.com/blog/article/229026816937607168" target="_blank" rel="noopener">深入理解：RabbitMQ的前世今生</a></li><li><a href="https://ybbct.iteye.com/blog/1562326" target="_blank" rel="noopener">通过流控机制分析rabbitmq性能（持久化）瓶颈</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;队列的结构&quot;&gt;&lt;a href=&quot;#队列的结构&quot; class=&quot;headerlink&quot; title=&quot;队列的结构&quot;&gt;&lt;/a&gt;队列的结构&lt;/h2&gt;&lt;p&gt;通常队列由&lt;code&gt;rabbit_amqqueue_process&lt;/code&gt;和&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://yoursite.com/2019/05/06/Java-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/05/06/Java-8新特性/</id>
    <published>2019-05-06T09:03:00.000Z</published>
    <updated>2019-05-08T10:10:41.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 8是Java开发的一个主要版本，也是一个有着重大改变的版本，在此对Java 8的部分新特性进行总结，主要总结以下几个部分：</p><ul><li>Lambda表达式</li><li>函数式接口</li><li>默认方法</li><li>Stream</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式能够让我们把函数作为方法参数，或者把代码作为数据对待，使用Lambda表达式可以使代码变得更加简洁紧凑。语法如下：</p><ol><li>方法体为表达式，该表达式的值作为返回值返回：<code>(parameters) -&gt; expression</code></li><li>方法体为代码块，必须用<code>{}</code>包裹起来，且需要有一个<code>return</code>返回值：<code>(parameters) -&gt; { statements; }</code></li></ol><p>Lambda表达式还有以下几个特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号</li></ul><p>Lambda表达式的简单例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值 </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure></p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口的重要特点是，我们能够使用Lambda实例化它们，如定义了一个函数式接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么就可以使用Lambda表达式来表示该接口的一个实现（Java 8之前一般是用匿名类实现）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GreetingService greetService1 = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br></pre></td></tr></table></figure></p><p>注意该函数式接口上有一个新的注解<code>@FunctionalInterface</code>，该接口不是必须的，用来标记该接口为只允许有一个抽象方法的函数式接口，当接口不符合函数式接口定义的时候，编译器会报错。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>接口的默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法，我们只需要在方法名前面加个<code>default</code>关键字即可实现默认方法。</p><p>为什么要有这个特性呢？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是当需要修改接口的时候，需要修改全部实现了该接口的类，但是如果我们想给接口添加新方法的同时不影响已有的实现，就可以使用默认方法这个特性，解决接口的修改与现有的实现不兼容的问题。</p><p>如果一个类实现了多个接口，并且这些接口有相同的默认方法，此时可以覆盖接口的默认方法，也可以使用<code>super</code>来调用指定接口的默认方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A.<span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 8还可以在接口中提供静态方法的实现，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>流式操作分为中间操作和最终操作两种，最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。</p><h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>在Java 8中，集合接口有两个方法来生成流：</p><ul><li><code>stream()</code>：为集合创建串行流</li><li><code>parallelStream()</code>：为集合创建并行流</li></ul><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream 提供了新的方法<code>forEach</code>来迭代流中的每个数据。以下代码片段使用<code>forEach</code>输出了10个随机数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random(); </span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<code>forEach</code>是一个终止操作，也就是说该操作必须是流的最后一个操作，一旦被调用，<code>Stream</code>就不能再使用了。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>方法用于通过设置的条件过滤出元素。以下代码片段使用<code>filter</code>方法过滤出空字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>); <span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><code>limit</code>方法用于获取指定数量的流。 以下代码片段使用<code>limit</code>方法打印出10条数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted</code>方法用于对流进行排序。以下代码片段使用<code>sorted</code>方法对输出的10个随机数进行排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random(); </span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h3 id="并行程序"><a href="#并行程序" class="headerlink" title="并行程序"></a>并行程序</h3><p><code>parallelStream</code>是流并行处理程序的代替方法。以下实例我们使用<code>parallelStream</code>来输出空字符串的数量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>); <span class="comment">// 获取空字符串的数量 </span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p><p>我们可以很容易的在顺序运行和并行直接切换。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html" target="_blank" rel="noopener">Java 8 新特性概述</a></li><li><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">Java 8 新特性</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java 8是Java开发的一个主要版本，也是一个有着重大改变的版本，在此对Java 8的部分新特性进行总结，主要总结以下几个部分：&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的装箱与拆箱</title>
    <link href="http://yoursite.com/2019/05/06/Java%E4%B8%AD%E7%9A%84%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2019/05/06/Java中的装箱与拆箱/</id>
    <published>2019-05-06T03:16:00.000Z</published>
    <updated>2019-05-08T10:11:10.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自动装箱和拆箱从Java 1.5开始引入，目的是让原始类型值与对应的包装对象之间可以自动的相互转换，比如将<code>int</code>类型值转换成<code>Integer</code>对象称为装箱，反之将<code>Integer</code>对象转换成<code>int</code>类型值称为拆箱。因为这里的装箱和拆箱是自动进行的而非人为转换，所以就称为自动装箱和拆箱。</p><p>在Java中，原始类型<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code>分别对应的包装类为<code>Byte</code>、<code>Short</code>、<code>Character</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Boolean</code>。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>自动装箱与拆箱其实是编译器自动为我们调用了相关方法，自动装箱是通过调用包装类的<code>valueOf()</code>方法实现的，而自动拆箱是通过调用包装类的<code>xxxValue()</code>方法实现的（xxx代表对应的基本数据类型）。</p><h2 id="何时发生自动装箱和拆箱"><a href="#何时发生自动装箱和拆箱" class="headerlink" title="何时发生自动装箱和拆箱"></a>何时发生自动装箱和拆箱</h2><p>自动装箱和拆箱主要发生在两种情况，一种是赋值时，另一种是在方法调用时。</p><h3 id="赋值时"><a href="#赋值时" class="headerlink" title="赋值时"></a>赋值时</h3><p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before autoboxing</span></span><br><span class="line">Integer iObject = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> iPrimitive = iObject.intValue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//after java5</span></span><br><span class="line">Integer iObject = <span class="number">3</span>; <span class="comment">//autobxing - primitive to wrapper conversion</span></span><br><span class="line"><span class="keyword">int</span> iPrimitive = iObject; <span class="comment">//unboxing - object to primitive conversion</span></span><br></pre></td></tr></table></figure><h3 id="方法调用时"><a href="#方法调用时" class="headerlink" title="方法调用时"></a>方法调用时</h3><p>这是另一个常用的情况，当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">show</span><span class="params">(Integer iParam)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"autoboxing example - method invocation i: "</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="keyword">int</span> result = show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure><p><code>show</code>方法接受<code>Integer</code>对象作为参数，当调用<code>show(3)</code>时，会将<code>int</code>值转换成对应的<code>Integer</code>对象，这就是所谓的自动装箱，<code>show</code>方法返回<code>Integer</code>对象，而<code>int result = show(3);</code>中<code>result</code>为<code>int</code>类型，所以这时候发生自动拆箱操作，将<code>show</code>方法的返回的<code>Integer</code>对象转换成<code>int</code>值。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>自动装箱与拆箱虽然为我们省下了很多不必要的工作，使代码更加简洁清晰，但是如果使用不当，则会引起性能问题。</p><h3 id="循环中的自动装箱"><a href="#循环中的自动装箱" class="headerlink" title="循环中的自动装箱"></a>循环中的自动装箱</h3><p>自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">   sum+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码<code>sum+=i</code>可以看成<code>sum = sum + i</code>，但是<code>+</code>这个操作符不适用于<code>Integer</code>对象，首先<code>sum</code>进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成<code>Integer</code>对象。其内部变化如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = sum.intValue() + i;</span><br><span class="line">Integer sum = Integer.valueOf(result);</span><br></pre></td></tr></table></figure></p><p>由于我们这里声明的<code>sum</code>为<code>Integer</code>类型，在上面的循环中会创建将近4000个无用的<code>Integer</code>对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p><h3 id="对象和原始类型值的比较"><a href="#对象和原始类型值的比较" class="headerlink" title="对象和原始类型值的比较"></a>对象和原始类型值的比较</h3><p>包装类对象和原始类型值的比较是很容易出错的一个地方，需要注意的是，<code>==</code>可以用于原始值的比较，也可以用于对象的比较，但是用于对象之间的比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象。而当其中一个操作数是原始类型值或算术运算时，则比较的是数值（触发自动拆箱）。以下几个例子基本可以涵盖所有情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);               <span class="comment">// 比较对象是否为同一个，因为 Integer 会缓存-128~127之间的对象</span></span><br><span class="line">        System.out.println(e==f);               <span class="comment">// 比较对象是否为同一个，数值在缓存之外</span></span><br><span class="line">        System.out.println(c==(a+b));         <span class="comment">// a+b运算触发自动拆箱，之后数值比较</span></span><br><span class="line">        System.out.println(c.equals(a+b));    <span class="comment">// a+b运算触发自动拆箱，之后自动装箱</span></span><br><span class="line">        System.out.println(g==(a+b));        <span class="comment">// a+b运算触发自动拆箱，之后数值比较</span></span><br><span class="line">        System.out.println(g.equals(a+b));   <span class="comment">// a+b运算触发自动拆箱，之后自动装箱，由于不是同一类型，equals() 返回 false</span></span><br><span class="line">        System.out.println(g.equals(a+h));  <span class="comment">// a+h运算触发自动拆箱，int类型晋升为long，之后自动装箱为Long，equals() 返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">Java中的自动装箱与拆箱</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析Java中的装箱和拆箱</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自动装箱和拆箱从Java 1.5开始引入，目的是让原始类型值与对应的包装对象之间可以自动的相互转换，比如将&lt;code&gt;int&lt;/code&gt;类
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB的MVCC实现原理</title>
    <link href="http://yoursite.com/2019/05/05/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/05/InnoDB的MVCC实现原理/</id>
    <published>2019-05-05T13:45:00.000Z</published>
    <updated>2019-05-05T13:49:42.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>在数据库中经常能听到各种各样的锁，比如说悲观锁、乐观锁、行锁、表锁等等，但实际上前两者是从思想上进行划分的，而后两者是从锁粒度上进行划分的，真正的锁有共享锁和排他锁，也就是常说的读锁（S锁）和写锁（X锁）。</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象进行加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持锁时间、何时释放等，这些规则称为封锁协议，对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>一级封锁协议即事务在修改某行数据时必须先对其加X锁，直到事务结束才释放，事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。一级封锁协议可以防止丢失修改，因为此时别的事务要想修改该数据将会阻塞到对方释放X锁，但如果仅仅是读数据不对其进行修改，是不需要加锁的，也就不能保证可重复读和脏读问题。</p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>二级封锁协议即在一级封锁协议的基础上，事务读取某数据之前必须先对其加S锁，读完后即可释放S锁。二级封锁协议除了防止丢失修改，还可以进一步防止脏读问题，但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>三级封锁协议即在一级封锁协议的基础上，事务读取某数据之前必须先对其加S锁，直到事务结束才释放。三级封锁协议除了防止丢失修改和脏读问题以外，还进一步防止了不可重复读。</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>一次性锁协议指的是在事务开始时，一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。</p><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）：</p><ul><li>加锁阶段：事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段</li><li>解锁阶段：事务只能解锁，也可以操作数据，但不能加锁</li></ul><p>两段锁协议使得事务具有较高的并发度，但是没有解决死锁的问题，因为它在加锁阶段没有顺序要求，如两个事务分别申请了A、B锁，接着又申请了对方的锁，此时进入死锁状态。</p><h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><p>InnoDB采用的是两段锁协议，开始时不断加锁，最后COMMIT或ROLLBACK时一次性释放所有锁，实质上是一种悲观并发控制，而在实际场景下更多都是读多写少的情况，此时悲观的方式会降低系统的并发性能。为了提高并发性能，InnoDB同时实现了MVCC，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高数据库系统的并发性能。</p><h3 id="redo-undo-log"><a href="#redo-undo-log" class="headerlink" title="redo/undo log"></a>redo/undo log</h3><p>为了支持事务，InnoDB实现了redo log与undo log：</p><ul><li>redo log：保存执行的sql语句到一个指定的log文件，当MySQL执行recovery时重新执行redo log记录的sql操作即可，当客户端执行每条sql时，redo log首先会被写入log buffer，当客户端执行COMMIT时，log buffer中的内容会被视情况刷新到磁盘。redo log在磁盘上作为一个独立的文件存在，即InnoDB的log文件。</li><li>undo log：与redo log相反，undo log是为回滚而用，把该行修改前的值copy到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在.ibd数据文件中。</li></ul><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>在MySQL中，InnoDB为每行记录都实现了三个隐藏字段：</p><ul><li>6字节的<code>DB_TRX_ID</code>：事务ID，每处理一个事务，其值自动+1</li><li>7字节的<code>DATA_ROLL_PTR</code>：回滚指针，指向该行修改前的上一个历史版本</li><li>6字节的<code>DB_ROW_ID</code>：如果表中没有显示定义主键或者没有唯一非空索引时InnoDB会自动创建</li></ul><p>当插入一条新数据时，记录上对应的回滚指针为null：</p><p><img src="http://blog.default.nanwulife.com/20170401151910811.jpg" alt=""></p><p>更新记录时，原记录将被放入到undo log中，并通过<code>DATA_ROLL_PT</code>指向该记录：</p><p><img src="http://blog.default.nanwulife.com/20170401151927986.jpg" alt=""></p><p>MySQL就是根据记录上的回滚指针及事务ID判断记录是否可见，如果不可见则按照<code>DATA_ROLL_PT</code>继续回溯查找。</p><h3 id="通过read-view判断行记录是否可见"><a href="#通过read-view判断行记录是否可见" class="headerlink" title="通过read view判断行记录是否可见"></a>通过read view判断行记录是否可见</h3><p><img src="http://blog.default.nanwulife.com/20170401151940733.jpg" alt="">)</p><p>相关源码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">changes_visible</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">trx_id_t</span>    id,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">table_name_t</span>&amp; name)</span> <span class="keyword">const</span></span></span><br><span class="line">MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">ut_ad(id &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//如果ID小于Read View中最小的, 则这条记录是可以看到。说明这条记录是在select这个事务开始之前就结束的</span></span><br><span class="line"><span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">check_trx_id_sanity(id, name);</span><br><span class="line"><span class="comment">//如果比Read View中最大的还要大，则说明这条记录是在事务开始之后进行修改的，所以此条记录不应查看到</span></span><br><span class="line"><span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">ids_t</span>::value_type*    p = m_ids.data();</span><br><span class="line"><span class="keyword">return</span>(!<span class="built_in">std</span>::binary_search(p, p + m_ids.size(), id)); <span class="comment">//判断是否在Read View中， 如果在说明在创建Read View时 此条记录还处于活跃状态则不应该查询到，否则说明创建Read View是此条记录已经是不活跃状态则可以查询到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是，InnoDB的MVCC仅针对RR和RC这两种隔离级别而言。对于<code>Read Uncommitted</code>，由于读取到的总是最新的数据，不管该记录是否已经提交，因此不会遍历版本链，也就不需要MVCC；而对于<code>Serializable</code>级别，使用的仍是悲观并发控制，读加共享锁，写加排他锁，读写相互阻塞。而对于RR和RC级别，它们对于MVCC的可见性实现也是不同的：</p><ul><li>RC：事务内的每个查询语句都会重新创建read view，这样就会产生不可重复读的现象发生</li><li>RR：事务开始时创建read view，直到事务结束的这段时间内每一次查询都不会重建read view，从而实现了可重复读</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVCC是一种用来解决读-写冲突的无锁并发控制机制，它所支持的RR和RC两种隔离级别，读写之间不会被阻塞，大大提高了并发性能。InnoDB实现的四种隔离级别，总体就是通过MVCC+2PL实现的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/joy0921/article/details/80128857" target="_blank" rel="noopener">MVCC原理探究及MySQL源码实现分析</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">【mysql】关于innodb中MVCC的一些理解</a></li><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></li><li><a href="https://www.zhihu.com/question/27876575" target="_blank" rel="noopener">乐观锁和 MVCC 的区别？</a></li><li><a href="https://www.zhihu.com/question/263820564" target="_blank" rel="noopener">MySQL 是如何实现四大隔离级别的？</a></li><li><a href="https://www.cnblogs.com/zszmhd/p/3365220.html" target="_blank" rel="noopener">两阶段锁协议</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁的种类&quot;&gt;&lt;a href=&quot;#锁的种类&quot; class=&quot;headerlink&quot; title=&quot;锁的种类&quot;&gt;&lt;/a&gt;锁的种类&lt;/h2&gt;&lt;p&gt;在数据库中经常能听到各种各样的锁，比如说悲观锁、乐观锁、行锁、表锁等等，但实际上前两者是从思想上进行划分的，而后两者是从锁粒
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
      <category term="MVCC" scheme="http://yoursite.com/tags/MVCC/"/>
    
      <category term="封锁协议" scheme="http://yoursite.com/tags/%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化与反序列化机制</title>
    <link href="http://yoursite.com/2019/05/04/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/04/Java序列化与反序列化机制/</id>
    <published>2019-05-04T14:32:00.000Z</published>
    <updated>2019-05-05T13:47:20.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>序列化是一种对象持久化的手段，使用Java对象序列化，保存对象时会将其状态保存为一组字节，在之后可以再将这些字节组装成对象。简单来说，要实现Java对象的序列化，我们只需要让被序列化类实现<code>Serializable</code>接口，并且使用<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>进行对象的读写即可。但是，关于Java序列化和反序列化其实还有一些更深层次的特性需要了解。</p><h2 id="如何实现对象的序列化"><a href="#如何实现对象的序列化" class="headerlink" title="如何实现对象的序列化"></a>如何实现对象的序列化</h2><p>首先，先介绍一下如何将对象序列化并反序列化。在Java中，被序列化的类必须实现<code>Serializable</code>接口，然后通过<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>进行对象的读写即可实现对象的序列化与反序列化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"LiHua"</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        oo.writeObject(person);</span><br><span class="line">        oo.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        Person anotherPerson = (Person) oi.readObject();</span><br><span class="line">        oi.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(anotherPerson);</span><br><span class="line">        System.out.println(person == anotherPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name=&apos;LiHua&apos;, age=19&#125;</span><br><span class="line">Person&#123;name=&apos;LiHua&apos;, age=19&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>可以看出，对象在序列化到文件后，可以再通过反序列化重新加载进内存，不过虽然这两个对象的属性值都相同，可是它们并不是同一个对象，它们的内存地址并不相同。</p><p>这里需要注意的是，被序列化类虽然实现了<code>Serializable</code>接口，但这个接口并不包含任何方法，仅仅起到标识的作用，那么它是在什么地方起到作用的呢？这里就要从<code>ObjectOutputStream</code>的<code>writeObject</code>方法的调用栈去寻找：<code>writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeSerialData-&gt;invokeWriteObject</code>，在<code>writeObject0</code>这个方法中有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，在序列化时该方法会先判断被序列化的类是否是<code>String</code>、<code>Array</code>、<code>Enum</code>或<code>Serializable</code>类型，如果不是则直接抛出<code>NotSerializableException</code>异常。</p><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的一点是两个类的序列化ID是否一致，也就是我们可以在被序列化的类中加上<code>private static final long serialVersionUID = 1L;</code>来控制该类的序列化版本号，如果序列化与反序列化的该属性不同，则会抛出异常。这个序列化ID可以是随机的一个不重复的<code>long</code>型数值，但是如果没有特殊需求的话，使用默认的<code>1L</code>就可以了。</p><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p><code>transient</code>关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，<code>transient</code>变量的值被设为初始值，如<code>int</code>型的是0，对象型的是<code>null</code>。但是，其实我们也可以使用自定义的序列化和反序列化策略，将<code>transient</code>修饰过的变量序列化到文件中，在<code>ArrayList</code>中就有这样的应用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></p><p>我们知道，<code>ArrayList</code>的本质其实就是通过数组存储元素，但是查看源码会发现这个存储元素的数组<code>elementData</code>被<code>transient</code>修饰了，这并不意味着它就无法被序列化了，相反，<code>ArrayList</code>通过<code>writeObject</code>和<code>readObject</code>方法以自定义的方式将其序列化并反序列化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在序列化的过程中，如果被序列化的类定义了<code>writeObject</code>和<code>readObject</code>方法，虚拟机会试图调用这两个方法进行用户自定义的序列化和反序列化，如果没有这两个方法，则默认调用是<code>ObjectOutputStream</code>的<code>defaultWriteObject</code>方法以及<code>ObjectInputStream</code>的<code>defaultReadObject</code>方法。</p><p>因此，如果我们想在序列化的过程中动态改变序列化的数值，就可以定义这两个方法。典型的应用场景就是在序列化对象数据时，有一些数据是敏感的，我们想在序列化时进行加密，而在反序列化时进行解密，那么此时就可以通过这两个方法来实现。</p><p>那么在上面的<code>ArrayList</code>中，又为什么要用这种方式实现序列化呢？原因是因为<code>ArrayList</code>实际上是动态数组，每次放满元素后都会自动扩容，此时如果实际的元素个数小于容量大小时，会将<code>null</code>元素也序列化到文件中。为了保证只序列化实际存在的元素，<code>ArrayList</code>把<code>elementData</code>用<code>transient</code>关键字修饰，并自定义了序列化反序列化的策略。</p><p>那么这个自定义的序列化反序列化策略又是在哪调用的？还是上面的调用栈<code>writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeSerialData-&gt;invokeWriteObject</code>，在<code>writeSerialData</code>方法中我们可以看到这样一段逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">        bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">        slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">        bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curPut = oldPut;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defaultWriteFields(obj, slotDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会先通过<code>hasWriteObjectMethod</code>判断存在用户自定义的<code>writeObject</code>方法后，调用<code>invokeWriteObject</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, UnsupportedOperationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="keyword">if</span> (writeObjectMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; out &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>writeObjectMethod.invoke(obj, new Object[]{ out });</code>是关键，正是在这里通过反射的方式调用自定义的<code>writeObject</code>方法的。</p><h2 id="父类与静态变量序列化"><a href="#父类与静态变量序列化" class="headerlink" title="父类与静态变量序列化"></a>父类与静态变量序列化</h2><p>关于序列化反序列化机制还有几点需要注意的是，静态变量是无法被序列化的，原因在于序列化保存的是对象的状态，而静态变量属于类的状态。除此之外，如果被序列化的类的父类没有实现<code>Serializable</code>接口时，虚拟机是不会序列化父对象的，要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code>接口。因此，如果我们想要让某些字段不被序列化，可以将这些字段抽取出来放到父类中，且让子类实现<code>Serialzable</code>接口，父类不实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在Java中，只要一个类实现了<code>Serializable</code>接口，那么就可以通过<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>将其对象进行序列化与反序列化。</li><li>如果两个类的<code>serialVersionUID</code>不同，则无法被反序列化，此时会抛出异常。</li><li>序列化不保存静态变量。</li><li>要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code>接口。</li><li>将被序列化的类的字段用<code>transient</code>关键字修饰，可以阻止该字段被序列化，在被反序列化时，该变量的值会被设为初始值。</li><li>可以通过定义<code>writeObject</code>和<code>readObject</code>方法实现自定义的序列化反序列化策略，如对敏感数据进行加密与解密。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="noopener">Java 序列化的高级认识</a></li><li><a href="http://www.importnew.com/18024.html" target="_blank" rel="noopener">深入分析Java的序列化与反序列化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;序列化是一种对象持久化的手段，使用Java对象序列化，保存对象时会将其状态保存为一组字节，在之后可以再将这些字节组装成对象。简单来说，要实现
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2019/05/04/Java%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/05/04/Java中的深拷贝与浅拷贝/</id>
    <published>2019-05-04T10:09:00.000Z</published>
    <updated>2019-05-04T10:10:20.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象并复制其内容，做到了真正完全的拷贝。</li></ul><h2 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h2><p>以下场景中有两个类，一个是<code>Parent</code>，一个是<code>Child</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要实现浅拷贝，只需要让<code>Parent</code>实现<code>Cloneable</code>接口，并覆盖<code>Object</code>的<code>clone()</code>方法即可。以下为测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Parent parent1 = <span class="keyword">new</span> Parent(<span class="string">"parent name"</span>, <span class="keyword">new</span> Child(<span class="string">"child name"</span>));</span><br><span class="line">        Parent parent2 = (Parent) parent1.clone();</span><br><span class="line">        System.out.println(parent1 == parent2);</span><br><span class="line">        System.out.println(parent1.parentName);</span><br><span class="line">        System.out.println(parent2.parentName);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        System.out.println(parent1.child == parent2.child);</span><br><span class="line">        System.out.println(parent1.child.childName);</span><br><span class="line">        System.out.println(parent2.child.childName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">true</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p><p>可以看出，浅拷贝确实创建了一个新的<code>Parent</code>对象，并且属性<code>parentName</code>的值也一模一样，但是对于为引用类型的属性<code>child</code>，实际上与之前引用的是同一个对象。</p><h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><p>要实现深拷贝，常用的方案有以下两种：</p><ol><li>序列化这个对象，再反序列化回来，就可以得到新的对象。</li><li>让属性也实现<code>Cloneable</code>。</li></ol><h3 id="属性实现Cloneable"><a href="#属性实现Cloneable" class="headerlink" title="属性实现Cloneable"></a>属性实现Cloneable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Parent parentClone = (Parent) <span class="keyword">super</span>.clone();</span><br><span class="line">        parentClone.child = (Child) <span class="keyword">this</span>.child.clone();</span><br><span class="line">        <span class="keyword">return</span> parentClone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的浅拷贝不同之处在于这里<code>Child</code>也实现了<code>Cloneable</code>，并覆盖了<code>clone()</code>方法，而<code>Parent</code>的<code>clone()</code>方法也有略微不同，在调用了<code>clone()</code>方法后还调用了属性<code>child</code>的<code>clone()</code>方法重新设置属性，从而实现完完全全的拷贝。</p><p>此时控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">false</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p><p>注意到此时原始对象和拷贝对象的<code>child</code>属性所引用的不再是同一个对象了。</p><h3 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将对象写到流里</span></span><br><span class="line">        OutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//OutputStream op = new ObjectOutputStream();</span></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">        oo.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从流里读对象出来</span></span><br><span class="line">        InputStream bi = <span class="keyword">new</span> ByteArrayInputStream(((ByteArrayOutputStream) bo).toByteArray());</span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">        <span class="keyword">return</span> (oi.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时两个类都不需要再实现<code>Cloneable</code>接口并覆盖<code>clone()</code>方法了，但是它们都需要实现<code>Serializable</code>接口，并且在<code>Parent</code>的克隆方法中要实现序列化反序列化的逻辑，此时控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">false</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝。&lt;/li&gt;
&lt;li&gt;深拷贝：对基本数据类型进行值传递，对引用
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>StringBuilder与StringBuffer源码分析</title>
    <link href="http://yoursite.com/2019/05/03/StringBuilder%E4%B8%8EStringBuffer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/StringBuilder与StringBuffer源码分析/</id>
    <published>2019-05-03T13:32:00.000Z</published>
    <updated>2019-05-06T03:19:04.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>StringBuilder</code>与<code>StringBuffer</code>是两个常用的字符串操作类，与<code>String</code>的不同之处在于他们是可变的，不像<code>String</code>的<code>value</code>数组被<code>final</code>修饰的严严实实的，而<code>StringBuilder</code>和<code>StringBuffer</code>的<code>value</code>数组没有被<code>final</code>修饰过，并且这两个类的实现几乎一样，主要的区别在于<code>StringBuffer</code>的方法由<code>synchronized</code>关键字修饰过，所以是线程安全的。这里先贴出整个体系的UML类图：</p><p><img src="http://blog.default.nanwulife.com/AbstractStringBuilder.png" alt=""></p><h2 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h2><p>从上面的类图也能看到，<code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，<code>AbstractStringBuilder</code>为子类提供了大部分的实现，因此，我们有必要先分析一下<code>AbstractStringBuilder</code>的源码。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p><code>AbstractStringBuilder</code>主要有以下两个成员变量，值得注意的是<code>value</code>并没有被<code>final</code>修饰，意味着它是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 String 一样维护一个字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"><span class="comment">// 字符的个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>在这里顺便将构造函数的源码也分析了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];     <span class="comment">// 初始化为指定容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在分析关键的<code>append()</code>方法前，我们先分析一下数组的扩容操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &gt; <span class="number">0</span>)</span><br><span class="line">        ensureCapacityInternal(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;   <span class="comment">// 如果所需容量大于当前容量，则进行扩容</span></span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;  <span class="comment">// 计算新容量为原来容量的两倍加2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;           <span class="comment">// 如果计算出的新容量不够大</span></span><br><span class="line">        newCapacity = minCapacity;                  <span class="comment">// 直接将新容量设为所需容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE，还要做进一步判断</span></span><br><span class="line">        : newCapacity;                      <span class="comment">// 否则，返回新容量即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所需容量大于整型最大值，则直接抛出 OutOfMemoryError</span></span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所需容量大于 MAX_ARRAY_SIZE 且小于整型最大值时，返回所需容量</span></span><br><span class="line">    <span class="comment">// 如果所需容量小于 MAX_ARRAY_SIZE，返回 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的扩容操作逻辑有点复杂，这里先总结下流程：</p><ol><li>默认的新容量大小为原容量大小的两倍加2，如果还不够，就直接设为所需要的容量大小</li><li>如果新容量大小比<code>MAX_ARRAY_SIZE</code>小，那么直接返回该新容量大小</li><li>否则，检查需要的容量大小是否超过整型最大值，如果超过则抛出异常</li><li>如果需要的容量大小比<code>MAX_ARRAY_SIZE</code>大，则直接返回需要的容量大小；否则，返回<code>MAX_ARRAY_SIZE</code></li></ol><p>其实这个扩容操作和<code>ArrayList</code>的扩容操作逻辑基本一致，这里的<code>MAX_ARRAY_SIZE</code>的值为<code>Integer.MAX_VALUE - 8</code>也就是整型的最大值减8，那么为什么要设置成这个值呢？其实在注释中也有说明，一些虚拟机的实现可能会在数组中存储header words，因此如果分配比这个值更大的容量的话，有可能会导致<code>OutOfMemoryError</code>。</p><h3 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h3><p>接下来看看<code>append()</code>方法，<code>append()</code>方法是整个类的核心，我们在实际中也经常使用。实际上它有很多个重载方法，这里就只分析参数为<code>String</code>类型的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)                <span class="comment">// 如果参数为 null</span></span><br><span class="line">        <span class="keyword">return</span> appendNull();    <span class="comment">// 实际上是添加 'n' 、'u'、'l' 、'l' 四个字符到 value 数组中</span></span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);    <span class="comment">// 扩容</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);        <span class="comment">// 调用 String 的 getChars() 方法将 str 追加到 value 末尾</span></span><br><span class="line">    count += len;   <span class="comment">// 更新字符长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;       <span class="comment">// 返回自身，支持链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = count;</span><br><span class="line">    ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">    value[c++] = <span class="string">'n'</span>;</span><br><span class="line">    value[c++] = <span class="string">'u'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    count = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>append()</code>方法其实逻辑挺简单的，但有两点是需要注意到的，一个是追加字符串的操作是通过<code>String</code>的<code>getChars()</code>完成的，但最后还是调用的<code>System.arraycopy()</code>这个native方法；另一个是该方法返回的是自身<code>this</code>，通过这种方式，我们可以实现<code>append()</code>方法的链式调用。</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>上面分析的<code>AbstractStringBuilder</code>已经实现了大部分需要的方法了，接下来开始分析第一个子类<code>StringBuilder</code>，先看看构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(CharSequence seq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seq.length() + <span class="number">16</span>);</span><br><span class="line">    append(seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>StringBuilder</code>有四个重载的构造函数，并且默认的初始化容量为16，当然我们也可以指定初始化容量，或者直接传入一个已有的字符序列。</p><h3 id="append-1"><a href="#append-1" class="headerlink" title="append()"></a>append()</h3><p><code>StringBuilder</code>的<code>append()</code>方法有非常多的重载，但其实都是调用父类<code>AbstractStringBuilder</code>的方法，在上面已经分析过了，所以这里就简单看一个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><code>StringBuffer</code>和<code>StringBuilder</code>的实现基本一样，只不过方法被<code>synchronized</code>关键字修饰了，因此是线程安全的，比如下面的<code>append()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到方法中有个<code>toStringCache</code>变量，这个变量是最近一次<code>toString()</code>方法的缓存，任何写操作都会将该缓存重设为<code>null</code>，我们看下这个<code>toString()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果缓存为空的话，那么就会先填充缓存，否则直接使用缓存<code>new</code>一个新的<code>String</code>对象并返回，但要注意的是，这里并不会有复制操作，而是直接将<code>String</code>对象中的<code>value</code>指向这个缓存数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>与<code>String</code>不同，<code>StringBuilder</code>和<code>StringBuffer</code>都是可变字符串，底层<code>value</code>数组没有使用<code>final</code>关键字修饰</li><li><code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，它完成了大部分方法的实现，因此子类只需要调用父类的方法即可</li><li><code>StringBuilder</code>和<code>StringBuffer</code>的默认容量都为16，并且默认的扩容大小是原来的两倍加2</li><li><code>StringBuilder</code>不是线程安全的，而<code>StringBuffer</code>通过<code>synchronized</code>关键字保证了线程安全</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;StringBuilder&lt;/code&gt;与&lt;code&gt;StringBuffer&lt;/code&gt;是两个常用的字符串操作类，与&lt;cod
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="StringBuilder" scheme="http://yoursite.com/tags/StringBuilder/"/>
    
      <category term="StringBuffer" scheme="http://yoursite.com/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch与CyclicBarrier源码分析</title>
    <link href="http://yoursite.com/2019/05/03/CountDownLatch%E4%B8%8ECyclicBarrier%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/CountDownLatch与CyclicBarrier源码分析/</id>
    <published>2019-05-03T10:07:00.000Z</published>
    <updated>2019-05-03T10:10:35.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>是基于AQS实现的，它使用AQS中的<code>state</code>成员变量作为计数器，在<code>state</code>不为0的情况下，凡是调用<code>await()</code>方法的线程将会被阻塞，并放入AQS维护的同步队列中，而当<code>state</code>减至0时，队列中的节点会被唤醒，被阻塞的线程即可恢复运行。先来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，它创建了一个<code>Sync</code>对象，并将参数传入，这个参数就是计数器的值。因此，关于<code>CountDownLatch</code>的分析将从这个<code>Sync</code>类开始。</p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p><code>CountDownLatch</code>中有个<code>Sync</code>内部类，它实现了AQS中的几个重要方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);    <span class="comment">// 设置 AQS 的 state 变量，也就是计数器的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();  <span class="comment">// 获取 AQS 的 state 变量值，也就是计数器的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法主要是在 await() 中用到</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 getState() 方法获取 state 变量的值，</span></span><br><span class="line">        <span class="comment">// 如果等于0，则返回正数，后续将不会阻塞线程</span></span><br><span class="line">        <span class="comment">// 如果不等于0，则返回负数，后续将会阻塞线程</span></span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法主要是在 countDown() 中用到</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为可能有多个线程同时调用该方法</span></span><br><span class="line">        <span class="comment">// 所以这里使用 CAS + 循环的方式保证线程安全</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))   <span class="comment">// CAS 将 state 的值减一</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;                  <span class="comment">// 如果减到0了，就返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>使用<code>CountDownLatch</code>同步组件时，基本都会使用到<code>await()</code>方法，当计数器不为0时，这可以阻塞调用该方法的线程。同时，通过这个方法我们也将知道上面介绍的<code>tryAcquireShared()</code>是在何处被调用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 AQS 的 acquireSharedInterruptibly() 方法</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法在AQS中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 响应中断 </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)             <span class="comment">// 该方法由子类 Sync 实现，如果返回值大于0，那么将直接返回</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);  <span class="comment">// 否则，将会放入同步队列中被阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法在AQS中实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);  <span class="comment">// 由 CountDownLatch 的 Sync 具体实现</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;                         </span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h3><p>这个方法也是使用<code>CountDownLatch</code>组件时必不可少的一个方法，当一个线程调用上面的<code>await()</code>方法而被阻塞时，通过<code>countDown()</code>方法能将计数器的值（也就是变量<code>state</code>的值）减一，当计数器的值减为0时，阻塞在<code>await()</code>上的线程也就可以正常返回了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 就像 await() 调用 AQS 的 acquireSharedInterruptibly() 方法一样</span></span><br><span class="line">    <span class="comment">// 这里调用 AQS 的 releaseShared() 方法</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;    <span class="comment">// 该方法由子类 Sync 实现，会将 state--，如果 state 为0了，就返回 true</span></span><br><span class="line">        doReleaseShared();          <span class="comment">// 唤醒同步队列中的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code>的作用和<code>CountDownLatch</code>类似，它是在计数器（等待线程数）达到指定数量后，再唤醒等待线程。它的实现和<code>CountDownLatch</code>不同，并没有直接通过AQS实现同步功能，而是在重入锁<code>ReentrantLock</code>的基础上实现的。先来了解一下它的几个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当 parties 个线程到达屏障后，屏障才会放行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 还剩下没到达屏障的线程数，会在新一轮开启或者当前屏障被破坏时重置为 parties</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当第 parties 个线程到达时回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 代表每一轮的运行状况，仅有一个成员变量 broken 表示屏障是否被破坏</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>接下来看看它的构造函数，与<code>CountDownLatch</code>一样需要传入一个计数器的初始值，除此之外，还可以传入一个回调对象，当最后一个线程到达屏障时会执行该回调逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;   <span class="comment">// 初始时有 parties 个线程未到达屏障</span></span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await-1"><a href="#await-1" class="headerlink" title="await()"></a>await()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 如果 g.broken = true，表示屏障被破坏了，这里直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 如果线程中断，则调用 breakBarrier() 破坏屏障</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// index 表示线程到达屏障的顺序，如果为 parties-1 表明当前是第一个到达屏障的</span></span><br><span class="line">        <span class="comment">// 如果 index 为0，表示当前线程是最后一个到达屏障的</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 如果 index 为0，唤醒所有处于等待状态的线程</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();   <span class="comment">// 重置屏障状态，使其进入新一轮的运行过程中</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">// 返回</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 若执行过程中发生异常，则调用 breakBarrier() 破坏屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行到此处的线程都会被屏障挡住，并进入等待状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)         <span class="comment">// timed 一般传入 false，因此这里条件成立</span></span><br><span class="line">                    trip.await();   <span class="comment">// 阻塞在 Condition 上</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏障被破坏，抛出 BrokenBarrierException 异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏障进入新的运行轮次，此时返回线程在上一轮次到达屏障的顺序</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时判断</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启新的一轮运行过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒所有处于等待状态中的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 重置 count</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重新创建 Generation</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 破坏屏障</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置屏障被破坏的标志</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 重置 count</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有处于等待状态中的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p><code>CyclicBarrier</code>的计数器可以在正常结束一轮后自动重置，当然我们也可以使用<code>reset()</code>方法强制重置，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();      <span class="comment">// 破坏屏障</span></span><br><span class="line">        nextGeneration(); <span class="comment">// 开启新一轮的运行过程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>总的来说，<code>CountDownLatch</code>和<code>CyclicBarrier</code>能够实现的功能差不多，但是<code>CyclicBarrier</code>可以循环使用，并且可以设置回调，因此对于复杂的业务场景，使用<code>CyclicBarrier</code>更合适一些。关于具体的使用场景可以参考之前的一篇文章：<a href="http://hecenjie.cn/2019/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/" target="_blank" rel="noopener">Java中的并发工具类</a> 。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.tianxiaobo.com/2018/05/10/Java-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6-CountDownLatch-%E4%B8%8E-CyclicBarrier-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#32-cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Java 线程同步组件 CountDownLatch 与 CyclicBarrier 原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="CountDownLatch" scheme="http://yoursite.com/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="http://yoursite.com/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock源码分析</title>
    <link href="http://yoursite.com/2019/05/03/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/ReentrantLock源码分析/</id>
    <published>2019-05-03T06:39:00.000Z</published>
    <updated>2019-05-03T06:40:50.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ReentrantLock</code>可重入锁功能与<code>synchronized</code>类似，用于协调多线程间的同步，并且提供比<code>synchronized</code>更为丰富的功能，比如可响应中断、锁超时等。<code>ReentrantLock</code>本身的实现其实较为简单，因为大部分的复杂逻辑方法已经由AQS实现了，它只需要实现少部分的关键方法即可，所以在学习<code>ReentrantLock</code>之前，个人认为有必要先去了解AQS。</p><p>本文将先说明重入锁的含义、公平锁与非公平锁的对比，然后进入<code>ReentrantLock</code>源码的分析，最后再将其与<code>synchronized</code>关键字进行对比。</p><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>可重入指的是同一个线程可以对同一把锁进行重复加锁，比如线程A获取到了锁并进入了临界区，然后调用另一个同样需要该锁的方法时，它可以成功的再次获取该锁，而不会被阻塞住。那么如果锁不可重入会发生什么问题呢？很简单，还是以上面的这个例子，此时线程A再次尝试获取锁时会被阻塞，此时就发生了死锁。</p><p><code>ReentrantLock</code>和<code>synchronized</code>关键字一样是可重入的，它的内部通过AQS的<code>state</code>变量记录同步状态，每当一个线程进行加锁时<code>state++</code>，而释放锁时<code>state--</code>。因此，当同一个线程重入该锁时，<code>state</code>就表示着该线程重入的次数。</p><h2 id="公平与非公平"><a href="#公平与非公平" class="headerlink" title="公平与非公平"></a>公平与非公平</h2><p><code>ReentrantLock</code>是可以设置公平或非公平模式的，事实上，JDK中的许多锁实现都默认为非公平模式。在这里先简单对比一下两种模式的区别：</p><ul><li>公平锁：公平锁保障了多线程获取锁时的顺序，先到的线程先获取到锁，正常情况下每个线程都能获取到锁</li><li>非公平锁：非公平锁不保障多线程获取锁时的顺序，也就是后来的线程有可能抢占了前面先来的线程获取锁的机会</li></ul><p>公平锁保证了每个线程都能按顺序的获取到锁，而非公平锁则有可能导致前面等待许久的线程不停被后来的线程抢占，从而出现“饥饿”问题。但是从效率上来说，非公平锁会比公平锁高出许多，原因在于唤醒一个线程是需要一定时间的，此时后来的线程可以利用这段时间获取锁并执行代码逻辑，当后来的线程释放完锁后，前面的线程可能正好完全苏醒并成功获取到锁，这就有一个充分的优势：原本因为苏醒而浪费的时间被后来的线程充分利用了，而后来的线程也不会因为进入阻塞而导致线程切换的开销。因此，非公平锁的效率其实是高于公平锁的。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>了解了重入锁和公平与非公平锁后，接下来进入正式的源码分析阶段。</p><p>前面说过，<code>ReentrantLock</code>其实是基于AQS实现的，那么具体是怎么实现的呢？先来看看它的UML类图：</p><p><img src="http://blog.default.nanwulife.com/ReentrantLock.png" alt=""></p><p>可以看出，<code>ReentrantLock</code>的抽象内部类<code>Sync</code>实现了AQS，而<code>Sync</code>有两个具体的子类<code>FairSync</code>和<code>NonfairSync</code>，从名字就可以看出它们分别表示公平模式和非公平模式。通过构造函数的参数可以决定选择哪种模式，如果不传入参数，则默认为非公平模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>先看下实现了AQS的抽象内部类，相关方法在下面会介绍，这里先省略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 交由子类去实现，也就是 FairSync 和 NonfairSync</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  <span class="comment">// ...  &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;  <span class="comment">// ...  &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><p><code>FairSync</code>继承自<code>Sync</code>，实现了公平模式的<code>ReentrantLock</code>的相关逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用 AQS 的 acquire() 方法获取锁</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此方法在 AQS 中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 在 AQS 中并未实现该方法，而交由这里的 FairSync 实现</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();  <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;        <span class="comment">// 如果同步状态为0，表示没有任何一个线程持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;         <span class="comment">// 判断前面是否有等待更长时间的线程</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;  <span class="comment">// 如果没有，通过CAS设置同步状态</span></span><br><span class="line">                setExclusiveOwnerThread(current);   <span class="comment">// 如果设置成功了，则将当前线程设置为锁持有者</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果同步状态不为0，并且当前线程就是锁的持有者，那么进行锁的重入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;   <span class="comment">// 计算重入后的同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);               <span class="comment">// 设置重入后的同步状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取锁失败，会执行AQS的加入同步队列的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;    <span class="comment">// 如果头节点的后继节点不是当前线程，说明有等待时间更长的线程，返回true</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上过过程总结如下：</p><ol><li>执行AQS的<code>acquire()</code>方法</li><li>调用<code>FairSync</code>实现的<code>tryAcquire()</code>方法，如果同步状态为0，则判断有没等待时间更长的线程，如果没有的话就成功获取；若同步状态不为0，且当前线程为持锁线程，则重入该锁</li><li>其它情况，一律返回<code>false</code>并将当前线程加入到同步队列，该过程由AQS实现</li></ol><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p><code>NonfairSync</code>同样继承自<code>Sync</code>，实现了非公平模式的<code>ReentrantLock</code>的相关逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里先直接CAS设置同步状态，如果设置成功，则加锁成功，不需要管同步队列前面是否有等待时间更长的线程</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="comment">// CAS失败了，则调用此方法进入 tryAcquire() 的逻辑</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 与公平模式的唯一不同，不会检查前面是否有等待时间更长的线程，直接CAS</span></span><br><span class="line">        <span class="comment">// CAS 成功就获取锁成功，失败则加入到AQS的同步队列中</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; </span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比公平模式的<code>FairSync</code>和非公平模式的<code>NonfairSync</code>可以发现，它们的差别其实并不大，主要体现在非公平模式在获取锁时不会先检查前面有没有其它等待的线程，而是直接野蛮式CAS，成则获取锁，败则加入同步队列。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁的逻辑比较简单，并且没有公平和非公平之分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法在 AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;      <span class="comment">// 交由子类 Sync 实现</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算释放锁后的同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程没有持有锁，调用该方法会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">// 如果释放后的同步状态为0，表示该锁完全释放了</span></span><br><span class="line">        free = <span class="keyword">true</span>;    </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);  <span class="comment">// 将锁持有者设为 null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);    <span class="comment">// 设置新的同步状态</span></span><br><span class="line">    <span class="keyword">return</span> free;    <span class="comment">// 返回该锁是否被完全释放了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与synchronized的异同"><a href="#与synchronized的异同" class="headerlink" title="与synchronized的异同"></a>与synchronized的异同</h2><p><code>ReentrantLock</code>和<code>synchronized</code>都是用于线程的同步控制，它们的共同点是都可重入，并且<code>synchronized</code>也是非公平锁（<code>ReentrantLock</code>默认为非公平）。而它们之间的不同主要在于以下几点：</p><ul><li><code>ReentrantLock</code>响应中断，而<code>synchronized</code>不响应</li><li><code>ReentrantLock</code>支持超时等待，而<code>synchronized</code>不支持</li><li><code>ReentrantLock</code>可设置成公平锁，而<code>synchronized</code>不可以</li><li>发生异常时，<code>synchronized</code>会自动释放锁，而<code>ReentrantLock</code>需要手动释放锁</li></ul><p>除此之外，<code>ReentrantLock</code>还提供了丰富的接口用于获取锁的状态，比如可以通过<code>isLocked()</code>查询<code>ReentrantLock</code>对象是否处于绑定状态，也可以通过<code>getHoldCount()</code>获取<code>ReentrantLock</code>的加锁次数，也就是重入次数，不过它们的本质都是调用AQS实现的<code>getState()</code>方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.tianxiaobo.com/2018/05/07/Java-%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#21-%E4%B8%8E-synchronized-%E7%9A%84%E5%BC%82%E5%90%8C" target="_blank" rel="noopener">Java 重入锁 ReentrantLock 原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;可重入锁功能与&lt;code&gt;synchronized&lt;/code&gt;类似，用于协调多线程间的
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="ReentrantLock" scheme="http://yoursite.com/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析：Condition</title>
    <link href="http://yoursite.com/2019/05/02/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ACondition/"/>
    <id>http://yoursite.com/2019/05/02/AQS源码分析：Condition/</id>
    <published>2019-05-02T14:32:00.000Z</published>
    <updated>2019-05-03T06:42:19.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Condition</code>是一个与<code>Object</code>中的<code>wait() / nofity() / notifyAll()</code>功能相似的接口，AQS的内部类<code>ConditionObject</code>实现了该接口。它与<code>Object</code>提供的这些方法一样用来协调线程间的同步关系，而不同之处在于<code>Object</code>中的这些方法需要配合<code>Synchronized</code>关键字使用（否则会抛出异常），而<code>Condition</code>中的方法则要配合锁（独占锁）来使用（否则也会抛出异常），并且<code>Condition</code>中的方法功能更为丰富一些，比如说可以设置响应或不响应中断、可以设定超时时间等。</p><p><code>ConditionObject</code>内部维护了一个条件队列，当线程不满足某些条件的时候就会通过<code>await()</code>方法将当前线程加入到条件队列中，而当条件队列上等待的线程被<code>signal() / signalAll()</code>后，又会被转移到AQS的同步队列中尝试获取锁。接下来就其中最核心的三个方法<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>说起，它们也分别对标了<code>Object</code>中的那三个方法。</p><h2 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h2><p><code>await()</code>方法负责将当前线程包装成一个<code>Node</code>后加入到条件队列中，并且需要释放持有的独占锁进入阻塞状态。这里先总结一下它的大致流程：</p><ol><li>将当前线程加入到条件队列中</li><li>完全释放互斥锁</li><li>如果当前线程未在同步队列中，就将其阻塞</li><li>否则，重新获取锁并根据是否发生中断而做出不同反应（抛出异常或重新中断）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 将当前线程包装成 Node 并加入到条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 完全释放互斥锁（不论锁是否可以重入），如果没有持锁，会抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">         <span class="comment">// &lt;3&gt; 只要仍未转移到同步队列就阻塞，转移的情况如下：</span></span><br><span class="line">        <span class="comment">// 1. 其它线程调用 signal 将当前线程节点转移到同步队列并唤醒当前线程</span></span><br><span class="line">        <span class="comment">// 2. 其它线程调用 signalAll</span></span><br><span class="line">        <span class="comment">// 3. 其它线程中断了当前线程，当前线程会自行尝试进入同步队列</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 获取中断模式。在线程从park中被唤醒的时候，需要判断此时是否被中断，若中断则尝试转移到同步队列</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;4&gt; 重新获取互斥锁过程中如果发生中断并且 interruptMode 不为 THROW_IE，则将 interruptMode 设置为 REINTERRUPT</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果线程发生过中断则根据 THROW_IE 或是 REINTERRUPT 分别抛出异常或者重新中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter()"></a>addConditionWaiter()</h3><p>首先看看第一个关键步骤，也就是将当前线程加入到条件队列中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列中最后一个节点的状态是 CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();   <span class="comment">// 清理队列</span></span><br><span class="line">        t = lastWaiter;                 <span class="comment">// 重读 lastWaiter</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程封装为一个 Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  <span class="comment">// 如果当前队列没有节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">// 将当前队列的尾节点连接到新节点</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">// 将新节点作为新尾节点</span></span><br><span class="line">    lastWaiter = node;  </span><br><span class="line">    <span class="comment">// 返回新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里会先判断条件队列中的最后一个节点是否为取消状态，如果是的话就调用<code>unlinkCancelledWaiters()</code>进行清理，清理的过程其实就是将条件队列中所有取消的节点都移除。之后将当前线程封装成<code>Node</code>后与当前队列最后一个节点的<code>nextWaiter</code>关联即可。</p><h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease()"></a>fullyRelease()</h3><p>此时已经将线程加入到条件队列中了，调用<code>fullyRelease()</code>方法完全释放同步状态。这里的“完全”指的是对于重入锁来说，每次加锁都会将AQS的整型成员变量<code>state++</code>，而每次解锁时会将<code>state--</code>，因此这里将<code>state</code>的数量完全释放掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取同步状态数值</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 调用 release() 释放指定数量的同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>; </span><br><span class="line">            <span class="keyword">return</span> savedState;  <span class="comment">// 返回释放的数量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果释放时出现异常，将该 Node 的等待状态设置为 CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue()"></a>isOnSyncQueue()</h3><p>该方法用于判断某个节点是否转移到了同步队列上（因为别的线程有可能通过<code>signal() / signalAll()</code>将其转移了），如果没有就将其阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待状态如果是 CONDITION 则一定是在条件队列，或者如果 prev 为 null 也一定是在条件队列</span></span><br><span class="line">    <span class="comment">// （同步队列新入队的节点的 prev 值是不可能为 null 的，因为有dummy节点的存在）</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// 不在同步队列中，直接返回 false</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 条件队列的节点是通过 nextWaiter 来维护的，不用 next 和 prev，因此如果节点在条件队列中则 next 和 prev 应该都为 null</span></span><br><span class="line">    <span class="comment">// 如果 next 不为 null，则说明一定是在同步队列中</span></span><br><span class="line">    <span class="comment">// 这里还要说明的是在 cancelAcquire() 方法中，一个节点取消的时候会把自己的 next 域指向自己，即 node.next = next; 而不是node.next = null;</span></span><br><span class="line">    <span class="comment">// 通过这种方式，在这里就可以将其和在同步队列上的情况归一化判断，都返回 true</span></span><br><span class="line">    <span class="comment">// 如果 cancelAcquire() 方法中写成 node.next = null; 的形式，这里的判断不满足条件，那么又要往底下进一步判断</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 虽然 node.prev 为 null 可以说明此时节点不在同步队列中，</span></span><br><span class="line">    <span class="comment">// 但如果 node.next 为 null 并不能说明 node 就不在同步队列中，因为新节点入队时会先设置 prev 然后再设置 next</span></span><br><span class="line">    <span class="comment">// 此时由 tail 节点开始从后向前遍历一次，确定节点是否真的不在同步队列中</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting()"></a>checkInterruptWhileWaiting()</h3><p><code>checkInterruptWhileWaiting()</code>方法用于检测线程在等待期间是否发生了中断，注意该方法是在<code>LockSupport.park(this);</code>这一行之后，也就是说此时线程已经从阻塞中返回了，返回的原因有可能是因为中断，也有可能是因为<code>signal() / signalAll()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测线程在等待期间是否发生了中断，如果未发生中断，直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断中断发生的时期，分为两种：</span></span><br><span class="line"><span class="comment"> * 1. 中断在节点被转移到同步队列前发生，此时返回 true</span></span><br><span class="line"><span class="comment"> * 2. 中断在节点被转移到同步队列后发生，此时返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况，中断在节点被转移到同步队列前发生</span></span><br><span class="line">    <span class="comment">// 此时自行将节点转移到同步队列上，并返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果上面的CAS失败了，说明已经有线程调用 signal() / signalAll() 方法了，</span></span><br><span class="line">    <span class="comment">// 这两个方法都会先将节点等待状态由 CONDITION 设为0后，再调用 enq() 方法转移节点</span></span><br><span class="line">    <span class="comment">// 此时有可能仅设置了等待状态而没来得及将节点转移到同步队列中就被切换走了，</span></span><br><span class="line">    <span class="comment">// 此时自旋等待节点成功进入同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield(); <span class="comment">// 让出 CPU</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完上面几个方法，当从<code>while (!isOnSyncQueue(node))</code>循环中跳出时，说明节点已经转移到了同步队列中了，此时通过<code>acquireQueued(node, savedState)</code>方法重新获取锁，并且如果线程发生过中断则根据<code>THROW_IE</code>或是<code>REINTERRUPT</code>分别抛出异常或者重新中断。</p><h2 id="signal-signalAll"><a href="#signal-signalAll" class="headerlink" title="signal() / signalAll()"></a>signal() / signalAll()</h2><p>上面的<code>await()</code>方法中从<code>while (!isOnSyncQueue(node))</code>循环跳出可不是自己独立就能做到的，它是需要<code>signal() / signalAll()</code>配合的。<code>signal() / signalAll()</code>的工作就是负责将条件队列中的节点转移到同步队列中，两个方法的区别在于<code>signal()</code>只会转移首节点，而<code>signalAll()</code>会转移队列上的所有节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signal 方法是不允许的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)      <span class="comment">// 头节点不为 null</span></span><br><span class="line">        doSignal(first);  <span class="comment">// 将头节点转移到同步队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果下面这个条件满足了，说明条件队列中只有一个节点，此时 lastWaiter 设为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用 transferForSignal() 将节点转移到同步队列中，如果失败，且 firstWaiter 不为null，则继续尝试，transferForSignal() 成功了或者队列中没节点了，while 循环就结束了 </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法用于将条件队列中的节点转移到同步队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果将节点的等待状态由 CONDITION 设为0失败，则表明节点被取消</span></span><br><span class="line">    <span class="comment">// 注意：因为 transferForSignal() 不存在竞争的问题，所以唯一的可能就是节点被取消</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 enq() 方法将 node 转移到同步队列中，并返回 node 的前驱节点（原尾节点）p</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱结点状态为取消或者无法将状态CAS到SIGNAL，</span></span><br><span class="line">    <span class="comment">// 则需要唤醒参数node节点对应的线程，使其能开始尝试争锁</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>signal()</code>一定会转移条件队列中的一个节点，除非队列中彻底空了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// // 检查线程是否获取了独占锁，未获取独占锁调用 signalAll() 方法是不允许的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将条件队列中所有节点都转移到同步队列中，与 doSignal() 的主要区别在于 while 循环条件上</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);   <span class="comment">// 调用 transferForSignal() 将节点转移到同步队列中</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signalAll()</code>与<code>signal()</code>的主要不同在于循环条件中，因为它会将条件队列中的所有节点都转移，因此实现起来稍微简单一些。</p><h2 id="JDK-BUG"><a href="#JDK-BUG" class="headerlink" title="JDK BUG"></a>JDK BUG</h2><p>这里再讲一下jdk在上面实现中的一个bug。对比上面<code>await()</code>和<code>signal() / signalAll()</code>的源码可以发现，<code>await()</code>方法并没有做同步控制，也就是<code>signal() / signalAll()</code>方法开头的<code>if (!isHeldExclusively())  throw new IllegalMonitorStateException();</code>。因此，如果没有获取锁就调用该方法，会产生线程竞争的情况，导致条件队列的结构被破坏。例如，以下添加节点到条件队列的方法：</p><pre><code class="java"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>{    Node t = lastWaiter;    <span class="comment">// 如果条件队列中最后一个节点的状态是 CANCELLED</span>    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) {        unlinkCancelledWaiters();   <span class="comment">// 清理队列</span>        t = lastWaiter;                 <span class="comment">// 重读 lastWaiter</span>    }    <span class="comment">// 将当前线程封装为一个 Node</span>    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  <span class="comment">// 如果当前队列没有节点</span>        firstWaiter = node;    <span class="keyword">else</span>            <span class="comment">// 将当前队列的尾节点连接到新节点</span>        t.nextWaiter = node;    <span class="comment">// 将新节点作为新尾节点</span>    lastWaiter = node;      <span class="comment">// 返回新节点</span>    <span class="keyword">return</span> node;}</code></pre><p>如果有两个线程同时执行到<code>if (t == null)</code>时，可能会造成<code>firstWaiter</code>先指向其中一个，之后却被另一个给覆盖了，那么此时其中一个线程将会一直阻塞下去，因为这个线程的node并不在条件队列中，也就永远不会被<code>signal() / signalAll()</code>转移到同步队列上，唯一能从阻塞中返回的可能就是被中断。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/micrari/p/7219751.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读–续篇之Condition</a></li><li><a href="http://www.tianxiaobo.com/2018/05/04/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-Condition-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - Condition 实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt;是一个与&lt;code&gt;Object&lt;/code&gt;中的&lt;code&gt;wait() / nofity()
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析：独占与共享同步状态</title>
    <link href="http://yoursite.com/2019/05/02/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%8B%AC%E5%8D%A0%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/05/02/AQS源码分析：独占与共享同步状态/</id>
    <published>2019-05-02T07:59:00.000Z</published>
    <updated>2019-05-02T14:25:12.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS就是<code>java.util.concurrent.locks</code>包下的<code>AbstractQueuedSynchronizer</code>类，这个类也是整个并发包的核心之一。并发包中像<code>ReentrantLock</code>、<code>CountDownLatch</code>等同步组件都有一个内部类<code>Sync</code>，而所有的<code>Sync</code>都是继承自<code>AbstractQueuedSynchronizer</code>，因此，可以看出AQS的重要性是十分高的。</p><p>AQS主要的工作是维护线程同步队列（CLH）并且负责线程的阻塞和唤醒，它的方法基本可以分为三类：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>所谓独占就是一次只有一个线程能够获取，其它线程必须等它释放，共享则可以有多个线程同时获取。</p><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>AQS内部维护着一个FIFO双向队列，该队列就是CLH同步队列，AQS依赖它来完成同步状态的管理：</p><ul><li>当前线程如果获取同步状态失败时，AQS会将当前线程以及等待状态等信息构成一个节点<code>Node</code>并将其加入到CLH同步队列，同时会阻塞当前线程。</li><li>当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。</li></ul><p>CLH同步队列的结构图如下：<br><img src="http://blog.default.nanwulife.com/0DFE7AA88DBEA0365F5532B4AC4FFF17.jpg" alt=""></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p><code>Node</code>是AQS的静态内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式节点，标记节点在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 独占式节点，标记节点在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为超时或中断，节点会被设置为取消状态，不会参与到竞争当中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点在条件队列中，节点线程等待在 Condition 上，当其它线程对 Condition 调用了 signal() / signalAll() 后，该节点会从条件队列转移到同步队列，加入到同步状态的获取中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次共享模式的同步状态获取会无条件地传播下去</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，也就是上面这几个，不过初始值为0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此节点的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 见 ConditionObject</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>入队操作过程是很简单的，只需要将<code>tail</code>指向新节点、新节点的<code>prev</code>指向当前最后的节点、当前最后的节点的<code>next</code>指向当前节点即可。但是在CLH的实现中需要考虑并发的情况，它通过CAS的方式，来保证正确的添加<code>Node</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// 新建节点</span></span><br><span class="line">    <span class="comment">// 记录原尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置新Node的前驱结点为原尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;   <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">            <span class="keyword">return</span> node;          <span class="comment">// 返回新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);      <span class="comment">// 失败，多次尝试直到成功</span></span><br><span class="line">    <span class="keyword">return</span> node;   <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 多次尝试直到成功</span></span><br><span class="line">        Node t = tail;  <span class="comment">// 记录原尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 原尾节点不存在</span></span><br><span class="line">            <span class="comment">// 创建首尾节点都为 new Node()，作为一个占位节点（空节点）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) </span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 原尾节点存在</span></span><br><span class="line">            <span class="comment">// 将原尾节点设置为新节点的前驱节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;  <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">                <span class="keyword">return</span> t;         <span class="comment">// 返回新节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总体来说就是使用CAS设置新节点为尾节点，如果设置成功则返回新节点，如果失败则继续不断自旋CAS设置新节点为尾节点直到成功。</p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>首节点的线程释放同步状态后，会唤醒它的后继节点，后继节点在获取同步状态成功时将自己设置为首节点，因为只有一个线程能够成功获取到同步状态，所以该过程不需要CAS来保证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 将未使用的字段设为null以帮助GC</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>在进入AQS的核心源码之前有必要先了解一下大量使用到的<code>LockSupport</code>类。</p><p><code>LockSupport</code>也是基于<code>UNSAFE</code>的操作，提供<code>park()</code>用来阻塞线程和<code>unpark()</code>用来唤醒线程，<code>LockSupport</code>的机制是每次<code>unpark()</code>给线程一个“许可”，并且这个许可最多只能为1，如果当前线程有许可，那么<code>park()</code>方法会消耗一个并返回，否则会阻塞线程直到线程重新获得许可，在线程启动之前调用<code>park() / unpark()</code>没有任何效果。</p><p>这里简单的讲一下<code>LockSupport.park() / unpark()</code>与<code>object.wait() / notify()</code>的区别，他们主要的区别在于语义上的不同，阻塞和唤醒是对于线程来说的，<code>LockSupport</code>的<code>park() / unpark()</code>以线程作为方法的参数，更符合这个语义；而<code>notify()</code>只能随机唤醒一个线程，<code>notifyAll()</code>会唤醒所有线程，无法准确的控制某一个线程。</p><h3 id="Thread-interrupt"><a href="#Thread-interrupt" class="headerlink" title="Thread.interrupt"></a>Thread.interrupt</h3><p>AQS中大量用了中断，也就是<code>Thread</code>的<code>interrupt()</code>方法，但要注意的是该方法并不会中断一个正在运行的线程：当调用一个线程的该方法时，如果该线程处于被阻塞状态（如<code>Object.wait()</code>、<code>Thread.join()</code>、<code>Thread.sleep()</code>），那么线程将立即退出被阻塞状态，并抛出一个<code>InterruptedException</code>异常；而如果线程正在运行，那么会将该线程的中断标志设置为<code>true</code>，此时线程将继续正常运行。</p><p><code>LockSupport.park()</code>也能响应中断信号，但它不会抛出<code>InterruptedException</code>异常，因此要想知道线程是被<code>unpark()</code>还是中断，就依赖于该线程的中断标志，可以通过<code>Thread</code>的<code>interrupted()</code>或<code>isInterrupted()</code>方法获取该值，两个方法的区别是<code>interrupted()</code>获取后会将标志位重置为<code>false</code>。</p><h2 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h2><p>接下来进入AQS比较关键的部分：同步状态的获取与释放。这里主要分为以下两类进行分析：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li></ul><h3 id="独占式获取"><a href="#独占式获取" class="headerlink" title="独占式获取"></a>独占式获取</h3><p>独占就是一次只有一个线程能够获取到同步状态。首先来看独占式同步状态获取的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法是一个模板方法，其中<code>tryAcquire(arg)</code>方法需要自定义同步组件（子类）自己去实现，它尝试获取同步状态，获取成功则设置锁状态并返回<code>true</code>，此时该方法就可以直接返回了；否则获取失败返回<code>false</code>，调用<code>addWaiter(Node mode)</code>方法将当前线程包装成<code>Node</code>加入到CLH同步队列尾部（上面已经介绍过），并且<code>mode</code>参数为<code>Node.EXCLUSIVE</code>，表示独占模式。</p><p>接下来会调用<code>boolean acquireQueued(final Node node, int arg)</code>方法，每个线程包装成<code>Node</code>进入同步队列后都会在该方法中自旋，一旦条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  <span class="comment">// 记录是否获取同步状态成功</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;    <span class="comment">// 记录该过程中是否发生过线程中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 开始自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 当前线程的前驱节点是头节点，且获取同步状态成功</span></span><br><span class="line">                setHead(node);   <span class="comment">// 将当前线程设置为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;     <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果获取同步状态失败，则根据条件判断是否应该阻塞自己</span></span><br><span class="line">            <span class="comment">// 如果不阻塞，CPU 就会处于忙等状态，这样会浪费 CPU 资源</span></span><br><span class="line">            <span class="comment">// 并且从阻塞中返回时，要判断是否是因为中断造成的</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 因为 parkAndCheckInterrupt 方法中会将中断标志清除，所以这里重新设为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 获取同步状态发生异常，取消获取</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">// 获得前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)   </span><br><span class="line">         <span class="comment">// 表示pred的下一个节点也就是node的线程需要阻塞等待。在pred的线程释放同步状态时会对node的线程进行唤醒通知，所以这里返回true表示当前线程可以放心的被park</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// Node.CANCELLED</span></span><br><span class="line">        <span class="comment">// 等待状态为CANCELLED时，表示此时前驱结点已经等待超时或者被中断了，需要从CLH队列中将前驱节点删除，循环回溯，直到前一个节点状态 &lt;= 0</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 0 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// CAS将状态修改为Node.SIGNAL，但是会返回false，这一次不会park</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);         <span class="comment">// 上面的方法一旦返回true了，就会执行此方法将当前线程park</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();   <span class="comment">// 判断是否因为中断而醒的，并且将中断标志清除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 节点的等待线程置空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过已经取消了的前驱结点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录非取消状态的前驱节点的后继节点，注意不是当前节点node </span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点等待状态设为 CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，则通过CAS设置前驱节点pred为尾节点</span></span><br><span class="line">    <span class="comment">// 以下两个CAS即使失败了也没关系，失败了说明pred此时已经是尾节点了</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 如果设置成功，就通过CAS将pred的next置空，那么中间被取消的节点就“消失”了</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span></span><br><span class="line">           <span class="comment">// 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也没关系。</span></span><br><span class="line">           <span class="comment">// 实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成功即可</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 唤醒后继节点对应的线程。这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span></span><br><span class="line"><span class="comment">         *        head          node1         node2         tail</span></span><br><span class="line"><span class="comment">         *        ws=0          ws=1          ws=-1         ws=0</span></span><br><span class="line"><span class="comment">         *      +------+  prev +-----+  prev +-----+  prev +-----+</span></span><br><span class="line"><span class="comment">         *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span></span><br><span class="line"><span class="comment">         *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span></span><br><span class="line"><span class="comment">         *      +------+  next +-----+  next +-----+  next +-----+</span></span><br><span class="line"><span class="comment">         *      </span></span><br><span class="line"><span class="comment">         * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span></span><br><span class="line"><span class="comment">         * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span></span><br><span class="line"><span class="comment">         * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span></span><br><span class="line"><span class="comment">         * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span></span><br><span class="line"><span class="comment">         * 时，整个同步队列就回全部阻塞住。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过 CAS 将等待状态设为 0，让后继节点线程多一次尝试获取同步状态的机会</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 后继节点为null或者其状态 &gt; 0（表示超时或者被中断了）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从tail节点开始向前遍历找到最前面的可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的<code>unparkSuccessor()</code>方法中有一个地方很有意思，就是当判断当前节点的<code>next</code>引用为<code>null</code>的时候，还需要从<code>tail</code>节点向前遍历找到可用的节点，之所以要这么做的原因在于：在之前的<code>addWaiter()</code>方法将新节点入队时，有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置新Node的前驱结点为原尾节点</span></span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;   <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;          <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是此时可能已经将新节点的<code>prev</code>指向了原尾节点，但原尾节点的<code>next</code>还并未指向新节点，因此不能从前往后遍历，而应从后往前遍历。</p><p>以下是上述步骤的流程图总结：<br><img src="http://blog.default.nanwulife.com/2018120811001.png" alt=""></p><p>可以看出，虽然获取同步状态的过程表面上是自旋的操作，但是为了避免CPU资源的浪费，在获取同步状态失败后大部分情况还是进入了阻塞，但由于从阻塞中醒来不一定代表就可以获得同步状态了（有可能因为中断），所以此时会通过这个自旋循环再一次的去尝试获取同步状态，看看能不能获取成功。</p><h3 id="独占式获取（响应中断）"><a href="#独占式获取（响应中断）" class="headerlink" title="独占式获取（响应中断）"></a>独占式获取（响应中断）</h3><p>上面的<code>acquire(int arg)</code>方法对中断不响应，也就是线程被中断后，仅仅会通过<code>selfInterrupt()</code>方法（其实就是<code>Thread.currentThread().interrupt()</code>）将该线程的中断标志设置为<code>true</code>，然后线程继续正常运行。为了响应中断，AQS提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在线程等待获取同步状态时如果被中断了，会立刻响应中断，抛出<code>InterruptedException</code>异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 首先判断线程是否已经中断了，如果是的话就直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))       <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;   <span class="comment">// 方法声明抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;     <span class="comment">// 不再返回是否发生过中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 与之前不响应中断的acquireQueued()方法唯一的区别在于这里判断发生了中断后会直接抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独占式获取（超时）"><a href="#独占式获取（超时）" class="headerlink" title="独占式获取（超时）"></a>独占式获取（超时）</h3><p>AQS除了提供上面两个独占式获取的方法外，还提供了一个增强版的方法<code>tryAcquireNanos()</code>，该方法除了能响应中断外，还提供了超时控制，即如果当前线程没有在指定时间内获取同步状态，则会返回<code>false</code>，否则返回<code>true</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 首先判断线程是否已经中断了，如果是的话就直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||   <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到这说明获取失败，重新计算需要休眠的时间（剩余时间）</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 如果已经超时了，那么返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果没有超时，判断了可以被park，并且nanosTimeout大于一个阈值，那么就进入休眠</span></span><br><span class="line">            <span class="comment">// 当nanosTimeout小于阈值的时候不需要休眠，直接快速自旋</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();   <span class="comment">// 响应中断，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独占式释放"><a href="#独占式释放" class="headerlink" title="独占式释放"></a>独占式释放</h3><p>当线程获取了同步状态，执行完相应逻辑后，就需要释放同步状态。AQS提供了<code>release(int arg)</code>方法，释放同步状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 由自定义同步组件自己实现</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 如果头节点不为null且状态不为0（等于0说明后继节点正在运行中，不需要唤醒）</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 将后继节点唤醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="共享式获取"><a href="#共享式获取" class="headerlink" title="共享式获取"></a>共享式获取</h3><p>与独占模式不同，共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、<code>CountDownLatch</code>和<code>Semaphore</code>等同步组件的基础。</p><p>共享式同步状态获取的方法是<code>acquireShared()</code>，对标独占式的<code>acquire()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  <span class="comment">// 由自定义同步组件自己实现。返回负数表示获取失败；返回0表示成功，但是后继争用线程不会成功；返回正数表示获取成功，并且后继争用线程也可能成功。</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与之前独占式的参数不同，这里传入一个Node.SHARED</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 前驱节点是头节点并且获取同步状态成功</span></span><br><span class="line">                    <span class="comment">// 设置当前节点为头节点并且向后传播，不断唤醒下一个共享式节点，从而实现多个节点线程同时获取共享同步状态</span></span><br><span class="line">                    setHeadAndPropagate(node, r); </span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// 记录原首节点</span></span><br><span class="line">    setHead(node);  <span class="comment">// 设置当前节点为新首节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里除了使用条件 propagate &gt; 0 判断是否唤醒后继节点，还有其它的一些判断依据</span></span><br><span class="line">    <span class="comment">// 比如 propagate 是 tryAcquireShared() 的返回值，也是这是决定是否传播唤醒的依据之一</span></span><br><span class="line">    <span class="comment">// 更为详细的解释可以参考 https://www.cnblogs.com/micrari/p/6937995.html</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。</span></span><br><span class="line"><span class="comment"> * 后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate，将唤醒传播下去。</span></span><br><span class="line"><span class="comment"> * 这个函数的作用是保障在 acquire 和 release 存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以下的循环做的事情就是，在队列存在后继线程的情况下，唤醒后继线程；</span></span><br><span class="line"><span class="comment"> * 或者由于多线程同时释放共享锁由于处在中间过程，读到head节点等待状态为0的情况下，</span></span><br><span class="line"><span class="comment"> * 虽然不能unparkSuccessor，但为了保证唤醒能够正确稳固传递下去，设置节点状态为PROPAGATE。</span></span><br><span class="line"><span class="comment"> * 这样的话获取锁的线程在执行setHeadAndPropagate时可以读到PROPAGATE，从而由获取锁的线程去释放后继等待线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * ws = 0 的情况下，这里要尝试将状态从 0 设为 PROPAGATE，保证唤醒向后</span></span><br><span class="line"><span class="comment">             * 传播。setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒</span></span><br><span class="line"><span class="comment">             * 后面的节点。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="共享式释放"><a href="#共享式释放" class="headerlink" title="共享式释放"></a>共享式释放</h3><p>共享式释放同步状态的主要逻辑都在上面的<code>doReleaseShared()</code>方法中，共享节点线程在获取同步状态和释放同步状态时都会调用<code>doReleaseShared()</code>，所以<code>doReleaseShared</code>是多线程竞争集中的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于共享式同步状态的获取与释放，其实这里介绍的较为简单了，由于时间原因，很多细节没有解释清楚，更为详细的分析可以参考这篇优质博客：<a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.iocoder.cn/JUC/sike/aqs-2/" target="_blank" rel="noopener">【死磕 Java 并发】—– J.U.C 之 AQS：同步状态的获取与释放</a></li><li><a href="http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#421-%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li><li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AQS就是&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;包下的&lt;code&gt;AbstractQueuedSyn
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java异常机制总结</title>
    <link href="http://yoursite.com/2019/04/30/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/30/Java异常机制/</id>
    <published>2019-04-30T15:25:32.000Z</published>
    <updated>2019-04-30T16:11:35.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java错误和异常"><a href="#Java错误和异常" class="headerlink" title="Java错误和异常"></a>Java错误和异常</h2><p>在Java中，所有的异常都有一个共同的祖先<code>Throwable</code>，它有两个重要的子类：<code>Exception</code>（异常）和<code>Error</code>（错误），二者都是Java异常处理的重要子类，各自都包含大量子类:<br><img src="http://blog.default.nanwulife.com/Exception.png" alt=""></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p><code>Error</code>是程序无法处理的错误，表示代码运行时Java虚拟机出现的问题。例如，当Java虚拟机不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>，而另外还有一个常见的错误是<code>StackOverflowError</code>。这些错误是不可查的，也不应试图去捕获它，当这些错误发生时，Java虚拟机一般会选择终止。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p><code>Exception</code>异常是程序本身可以处理的异常，它有一个重要的子类<code>RuntimeException</code>，表示JVM常用操作引发的异常。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常<code>NullPointerException</code>、<code>ArithmeticException</code>和<code>ArrayIndexOutOfBoundException</code>。</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p><code>Exception</code>这种异常分为运行时异常和非运行时异常（编译异常）两大类：</p><ul><li>运行时异常：都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException</code>（空指针异常）、<code>IndexOutOfBoundsException</code>（下标越界异常）等。这些异常是不检查异常，Java编译器不会检查它，即使没有用<code>try-catch</code>语句捕获它，也没有用<code>throws</code>子句声明抛出它，也会编译通过。</li><li>非运行时异常：是<code>RuntimeException</code>以外的异常，类型上都属于<code>Exception</code>类及其子类。从程序语法角度讲是必须进行处理的异常（<code>try-catch</code>捕捉或者方法上声明<code>throws</code>抛出），如果不处理，程序就不能编译通过，如<code>IOException</code>、<code>SQLException</code>等。</li></ul><h2 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h2><p>在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><ul><li>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息，运行时系统负责寻找处置异常的代码并执行。</li><li>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止，同时意味着Java程序的终止。</li></ul><p>一旦某个<code>catch</code>捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个<code>try-catch</code>语句结束，其他的<code>catch</code>子句不再有匹配和捕获异常类型的机会。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="noopener">深入理解java异常处理机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java错误和异常&quot;&gt;&lt;a href=&quot;#Java错误和异常&quot; class=&quot;headerlink&quot; title=&quot;Java错误和异常&quot;&gt;&lt;/a&gt;Java错误和异常&lt;/h2&gt;&lt;p&gt;在Java中，所有的异常都有一个共同的祖先&lt;code&gt;Throwable&lt;/code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK与CGLIB动态代理</title>
    <link href="http://yoursite.com/2019/04/30/JDK%E4%B8%8ECGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/30/JDK与CGLIB动态代理/</id>
    <published>2019-04-30T09:19:00.000Z</published>
    <updated>2019-04-30T10:05:39.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看了Spring AOP的源码，其底层就是通过JDK与CGLIB动态代理实现的，因此在这里对两种代理方式进行实践和总结。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先创建一个代理创建器<code>ProxyCreator</code>接口，我们将分别实现<code>JdkProxyCreator</code>与<code>CglibProxyCreator</code>，通过实现<code>getProxy()</code>方法返回一个代理对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建一个<code>UserService</code>接口，提供登陆<code>login()</code>和退出<code>logout()</code>两个方法，并创建一个它的实现类<code>UserServiceImpl</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户"</span> + userId + <span class="string">"登陆成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户"</span> + userId + <span class="string">"退出成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们将分为JDK与CGLIB这两种动态代理方式，为上面的登陆与退出两个方法前后打印日志。</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>首先，创建一个<code>JdkProxyCreator</code>并实现<code>ProxyCreator</code>和<code>InvocationHandler</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyCreator</span> <span class="keyword">implements</span> <span class="title">ProxyCreator</span>, <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxyCreator</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"目标对象必须实现接口"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        <span class="comment">// 该类本身实现了 InvocationHandler 接口，所以将自身作为参数传入</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆前日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出前日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object res = method.invoke(target, args); <span class="comment">// 调用目标方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆后日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出后日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，创建代理对象的核心其实就是这一行代码：<code>Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</code>，其中第一个参数是目标对象的类加载器，第二个参数是目标对象实现的接口，第三个参数则是一个<code>InvocationHandler</code>，因为该类已经实现了这个接口，且打印日志的逻辑都封装在了该接口的<code>invoke</code>方法中了，所以直接传入<code>this</code>即可。</p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyCreator proxyCreator = <span class="keyword">new</span> JdkProxyCreator(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        UserService userServiceProxy = (UserService) proxyCreator.getProxy();</span><br><span class="line">        System.out.println(<span class="string">"代理对象的类型："</span> + userServiceProxy.getClass());</span><br><span class="line">        userServiceProxy.login(<span class="number">1</span>);</span><br><span class="line">        userServiceProxy.logout(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理对象的类型：<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy0</span></span></span><br><span class="line"><span class="class">登陆前日志打印...</span></span><br><span class="line"><span class="class">用户1登陆成功</span></span><br><span class="line"><span class="class">登陆后日志打印...</span></span><br><span class="line"><span class="class">退出前日志打印...</span></span><br><span class="line"><span class="class">用户1退出成功</span></span><br><span class="line"><span class="class">退出后日志打印...</span></span><br></pre></td></tr></table></figure></p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>CGLIB是一款优秀的Java字节码生成框架，它可以生成并操纵Java字节码。因此，CGLIB的动态代理其实就是使用字节码技术为目标类创建子类，并且在子类中拦截父类方法的调用，并且顺势织入横切逻辑。</p><p>首先，在pom.xml中引入CGLIB的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>然后创建一个<code>MethodInterceptor</code>接口的实现类，将打印日志的操作封装在<code>intercept()</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆前日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出前日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object res = methodProxy.invokeSuper(o, objects);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆后日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出后日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>Object res = methodProxy.invokeSuper(o, objects);</code>这一行将会调用父类的实现，也就是目标对象的原始方法。这里要注意的是一定不要写成了<code>method.invoke(o, objects);</code>，否则会造成死循环。</p><p>接着，创建一个<code>CglibProxyCreator</code>实现<code>ProxyCreator</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyCreator</span> <span class="keyword">implements</span> <span class="title">ProxyCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyCreator</span><span class="params">(Object target, MethodInterceptor methodInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不同于JDK动态代理使用<code>Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</code>的方式，这里创建了一个<code>Enhancer</code>对象，并且设置了目标对象的类作为父类，还设置了之前的方法拦截器<code>UserMethodInterceptor</code>（其实这里也可以让该类本身实现<code>MethodInterceptor</code>接口），最后通过<code>enhancer.create()</code>方法返回代理对象。</p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyCreator proxyCreator = <span class="keyword">new</span> CglibProxyCreator(<span class="keyword">new</span> UserServiceImpl(), <span class="keyword">new</span> UserMethodInterceptor());</span><br><span class="line">        UserService userServiceProxy = (UserService) proxyCreator.getProxy();</span><br><span class="line">        System.out.println(<span class="string">"代理对象的类型："</span> + userServiceProxy.getClass());</span><br><span class="line">        userServiceProxy.login(<span class="number">2</span>);</span><br><span class="line">        userServiceProxy.logout(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理对象的类型：class cn.hecenjie.UserServiceImpl$$EnhancerByCGLIB$$76be9bea</span><br><span class="line">登陆前日志打印...</span><br><span class="line">用户2登陆成功</span><br><span class="line">登陆后日志打印...</span><br><span class="line">退出前日志打印...</span><br><span class="line">用户2退出成功</span><br><span class="line">退出后日志打印...</span><br></pre></td></tr></table></figure></p><p>从上面的输出可以看出，代理对象其实是目标对象的一个子类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JDK代理要求目标对象有实现接口，而CGLIB则不需要。从性能上来说，CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间看了Spring AOP的源码，其底层就是通过JDK与CGLIB动态代理实现的，因此在这里对两种代理方式进行实践和总结。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="CGLIB" scheme="http://yoursite.com/tags/CGLIB/"/>
    
  </entry>
  
</feed>
