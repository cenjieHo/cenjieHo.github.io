<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Cenjie&#39;s Blog</title>
  
  <subtitle>水木今山的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-17T03:36:25.883Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTTPS的过程与原理</title>
    <link href="http://yoursite.com/2019/02/17/HTTPS%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/17/HTTPS的过程与原理/</id>
    <published>2019-02-17T03:05:00.000Z</published>
    <updated>2019-02-17T03:36:25.883Z</updated>
    
    <content type="html"><![CDATA[<p>由于HTTP存在明文通信、无法验证服务器的真实性等弊端，使用HTTPS的人变得越来越多。HTTPS并不是新的协议，而是在HTTP基础之上加一层TLS模块，TLS提供了加密、认证以及消息完整性校验的服务，从而保证通信的安全性。</p><a id="more"></a><h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>HTTPS总的流程就相当于使用非对称加密的方式来传递对称私钥，之后的通信就可以使用这个私钥进行对称加密了。</p><p><img src="http://blog.default.nanwulife.com/2012072310244445.png" alt="HTTPS的过程与原理"></p><h3 id="客户端发起HTTPS请求"><a href="#客户端发起HTTPS请求" class="headerlink" title="客户端发起HTTPS请求"></a>客户端发起HTTPS请求</h3><p>用户在浏览器里输入一个https网址，然后连接到server的443端口。</p><h3 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h3><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。</p><h3 id="传送证书"><a href="#传送证书" class="headerlink" title="传送证书"></a>传送证书</h3><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h3 id="客户端解析证书"><a href="#客户端解析证书" class="headerlink" title="客户端解析证书"></a>客户端解析证书</h3><p>这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。</p><h3 id="传送加密信息"><a href="#传送加密信息" class="headerlink" title="传送加密信息"></a>传送加密信息</h3><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><h3 id="服务段解密信息"><a href="#服务段解密信息" class="headerlink" title="服务段解密信息"></a>服务段解密信息</h3><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><h3 id="传输加密后的信息"><a href="#传输加密后的信息" class="headerlink" title="传输加密后的信息"></a>传输加密后的信息</h3><p>这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。</p><h3 id="客户端解密信息"><a href="#客户端解密信息" class="headerlink" title="客户端解密信息"></a>客户端解密信息</h3><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p><h2 id="证书认证"><a href="#证书认证" class="headerlink" title="证书认证"></a>证书认证</h2><p>单纯的加密是无法保证通信安全的，TLS还需要通过证书机制来保证访问的服务器是真实的。</p><p><img src="http://blog.default.nanwulife.com/2402164-db6c5a0d348fcc15.png" alt=""></p><p>证书是由权威机构颁发的，服务端如果能够提供一个合法的证书，说明这个服务端是合法的，可以被信任。整个证书的认证过程如下：</p><ul><li>客户端获取到了站点证书，拿到了站点的公钥</li><li>要验证站点可信后，才能使用其公钥，因此客户端找到其站点证书颁发者的信息</li><li>站点证书的颁发者验证了服务端站点是可信的，但客户端依然不清楚该颁发者是否可信</li><li>再往上回溯，找到了认证了中间证书商的根证书颁发者。由于根证书颁发者非常少，我们浏览器之前就认识了，因此可以认为根证书颁发者是可信的</li><li>一路倒推，证书颁发者可信，那么它所颁发的所有站点也是可信的，最终确定我们所要访问的服务端是可信的</li><li>客户端使用证书中包含的公钥，继续完成TLS的握手过程</li></ul><p>如果证书过期了、颁发机构不受信任或者证书绑定的域名和请求的域名不一致等原因，浏览器会抛出异常信息，说明此时的访问是不安全的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank" rel="noopener">图解HTTPS</a></li><li><a href="https://www.jianshu.com/p/24af67c40e8d" target="_blank" rel="noopener">TLS整理（下）：TLS如何保证安全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于HTTP存在明文通信、无法验证服务器的真实性等弊端，使用HTTPS的人变得越来越多。HTTPS并不是新的协议，而是在HTTP基础之上加一层TLS模块，TLS提供了加密、认证以及消息完整性校验的服务，从而保证通信的安全性。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
      <category term="TLS" scheme="http://yoursite.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB和MyISAM的区别</title>
    <link href="http://yoursite.com/2019/02/16/InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/02/16/InnoDB和MyISAM的区别/</id>
    <published>2019-02-16T07:05:00.000Z</published>
    <updated>2019-02-16T07:11:45.835Z</updated>
    
    <content type="html"><![CDATA[<ol><li>InnoDB支持事务，MyISAM不支持。</li><li>InnoDB支持外键，而MyISAM不支持。</li><li>InnoDB是聚集索引，而MyISAM是非聚集索引。</li><li>InnoDB不保存表的具体行数，执行<code>select count(*) from table</code>时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;InnoDB支持事务，MyISAM不支持。&lt;/li&gt;
&lt;li&gt;InnoDB支持外键，而MyISAM不支持。&lt;/li&gt;
&lt;li&gt;InnoDB是聚集索引，而MyISAM是非聚集索引。&lt;/li&gt;
&lt;li&gt;InnoDB不保存表的具体行数，执行&lt;code&gt;select c
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MyISAM" scheme="http://yoursite.com/tags/MyISAM/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>访问一个网页的全过程</title>
    <link href="http://yoursite.com/2019/02/13/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/13/访问一个网页的全过程/</id>
    <published>2019-02-13T10:09:00.000Z</published>
    <updated>2019-02-18T03:18:09.754Z</updated>
    
    <content type="html"><![CDATA[<ol><li>客户端用户从浏览器输入<code>www.google.com</code>网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的。</li></ol><a id="more"></a><ol start="3"><li><p>如果hosts与DNS缓存都没有解析记录时，系统会把浏览器的解析请求交给客户端本地设置的DNS服务器地址解析，如果本地DNS服务器的本地缓存有对应的解析记录，就会直接返回IP地址。</p></li><li><p>如果本地DNS服务器没有对应的解析记录，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<code>google.com</code>)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<code>google.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.google.com</code>主机。</p></li><li><p>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li><li><p>通过DNS解析拿到了ip之后，就可以通过ip向服务器发送http请求了，因为http工作在应用层，tcp工作在传输层，所以发生http请求之前，还会进行tcp的三次握手建立连接。</p></li><li><p>在连接成功建立后，开始向web服务器发送请求，当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求报文，请求报文由<code>请求方法 URI 协议/版本</code>、<code>请求头</code>、<code>请求正文</code>三部分组成。</p></li><li><p>请求报文由应用层向下，依次经过传输层、网络层、数据链路层与物理层。应用层的任务是通过应用进程间的交互来完成特定网络应用，有HTTP、DNS等众多协议，传输层的主要任务则是负责向两台主机进程之间的通信提供通用的数据传输服务，包括TCP与UDP两种协议，TCP是面向连接的、可靠的的数据传输服务，而UDP提供无连接的、不可靠的数据传输服务，TCP主要提供完整性服务，UDP主要提供及时性服务；传输层是为主机中的进程提供数据传输服务，而网络层则是为不同主机提供数据传输服务，这一层有IP协议，由于主机之间可以有很多链路，数据链路层则是为同一链路的主机提供数据传输服务。最终物理层考虑怎样在传输媒体上传输数据比特流。数据通过以太网电缆传送到服务器，服务器拿到数据包后同样再由数据链路层、网络层、传输层依次向上解析，应用层最终收到请求内容。</p></li><li><p>服务器收到请求报文之后，就会将响应报文返回给客户端，响应报文由<code>协议/版本 状态码 描述</code>、<code>响应头</code>、<code>响应正文</code>三部分组成。这里的状态码分为1XX（信息类）、2XX（成功类）、3XX（重定向类）、4XX（客户端错误）、5XX（服务器错误）。</p></li><li><p>当浏览器加载一个完整的页面时，还需要与服务器断开连接，这个过程就是tcp的四次挥手。</p></li><li><p>在HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。因此，每次的请求都会造成无谓的TCP连接建立与断开，增加通信量的开销。为了解决这个问题，HTTP/1.1使用长连接减少开销，只要任意一端没有明确提出断开连接，就保持TCP连接状态，当客户端再次访问这个服务器上的网页时，会继续使用这一条已经建立的连接。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;客户端用户从浏览器输入&lt;code&gt;www.google.com&lt;/code&gt;网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程断点续传下载器</title>
    <link href="http://yoursite.com/2019/02/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/12/多线程断点续传下载器/</id>
    <published>2019-02-12T08:58:00.000Z</published>
    <updated>2019-02-12T11:13:32.667Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究多线程的断点续传下载。断点续传的原理其实很简单，就是在下载时将下载进度保存到一个临时文件中，如果下载过程遇到什么意外中断了，下次下载同一个文件时就可以从临时文件中读取到上次下载发生中断时的进度，然后从这个进度开始继续下载。</p><a id="more"></a><p>要使用断点续传下载首先要判断服务器是否支持范围请求，假如在响应中存在<code>Accept-Ranges</code>首部并且它的值不为 <code>none</code>，那么表示该服务器支持范围请求。通常情况下Web服务器会默认开启对范围请求的支持，我们只需要在请求头中加入<code>Range</code>首部来指示服务器应该返回文件的哪一部分，例如使用<code>Range: bytes=0-1023</code>返回某个资源的前1024个字节，在代码中体现为：<code>httpcon.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + startPos + &quot;-&quot; + endPos);</code>，这时候服务器会返回状态码为<code>206 Partial Content</code>的响应表示成功。</p><p>项目中还使用了多线程进行分块下载，要注意的是并非线程数越多下载就越快（受限于带宽），一般开十个线程就差不多了，多线程之所以能提高下载速度的原因也很复杂，具体可以参考<a href="https://www.zhihu.com/question/19914902" target="_blank" rel="noopener">为什么多线程下载能加速？</a>以及<a href="https://www.zhihu.com/question/21813579" target="_blank" rel="noopener">为什么多 TCP 连接分块下载比单连接下载快？</a>。简单来说就是当链路存在争用的情况下，由于传输网络的带宽有限，每个TCP连接可以得到均等的带宽。在多用户环境下，一个用户拥有越多TCP连接，获得的带宽越大。除此之外，由于TCP的拥塞控制机制被设计的十分友好，只要丢了点包就会极大的减慢速率，而此时可能并没有发生拥塞，导致单个连接没法最大化的利用带宽。</p><p>下图为该项目的执行流程：</p><p><img src="http://blog.algorithms.nanwulife.com/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0.jpg" alt=""></p><p>以下为项目源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Project</span>: breakpoint</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Cenjie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 2019/2/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String urlStr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> String filename_tmp;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lenPerThread;  <span class="comment">//每个线程的下载大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] start;    <span class="comment">//保留每个线程下载的起始位置。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] end;      <span class="comment">//保留每个线程下载的结束位置。</span></span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Downloader</span><span class="params">(String urlStr, <span class="keyword">int</span> threadNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.urlStr = urlStr;</span><br><span class="line">        <span class="keyword">this</span>.threadNum = threadNum;</span><br><span class="line">        start = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="keyword">this</span>.threadNum];</span><br><span class="line">        end = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="keyword">this</span>.threadNum];</span><br><span class="line">        latch = <span class="keyword">new</span> CountDownLatch(<span class="keyword">this</span>.threadNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        File file_tmp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从文件链接中获取文件名</span></span><br><span class="line">        filename = urlStr.substring(urlStr.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, urlStr</span><br><span class="line">                .contains(<span class="string">"?"</span>) ? urlStr.lastIndexOf(<span class="string">'?'</span>) : urlStr.length());</span><br><span class="line">        <span class="comment">//设置临时文件的文件名</span></span><br><span class="line">        filename_tmp = filename + <span class="string">"_tmp"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建url</span></span><br><span class="line">            url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打开下载链接，并且得到一个HttpURLConnection的一个对象httpcon</span></span><br><span class="line">            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            httpcon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取请求资源的总长度，为Long型</span></span><br><span class="line">            fileLength = httpcon.getContentLengthLong();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下载文件和临时文件</span></span><br><span class="line">            file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            file_tmp = <span class="keyword">new</span> File(filename_tmp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每个线程需下载的资源大小；由于文件大小不确定，为避免数据丢失</span></span><br><span class="line">            lenPerThread = fileLength % threadNum == <span class="number">0</span> ? fileLength / threadNum : fileLength / threadNum + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//打印下载信息</span></span><br><span class="line">            System.out.println(<span class="string">"文件名: "</span> + filename + <span class="string">"，"</span> + <span class="string">"文件大小："</span></span><br><span class="line">                    + fileLength + <span class="string">"字节，每个线程下载大小："</span> + lenPerThread + <span class="string">"字节"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (file.exists() &amp;&amp; file.length() == fileLength) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件已存在"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setBreakPoint(file_tmp);</span><br><span class="line">                ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    exec.execute(<span class="keyword">new</span> DownLoadThread(start[i], end[i],</span><br><span class="line">                            <span class="keyword">this</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">                latch.await();  <span class="comment">//当所有线程下载完毕后，才会从此阻塞中返回</span></span><br><span class="line">                System.out.println(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下载完成后，判断文件是否完整，并删除临时文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.length() == fileLength) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file_tmp.exists()) &#123;</span><br><span class="line">                file_tmp.delete();</span><br><span class="line">                System.out.println(<span class="string">"删除临时文件完成，下载结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该文件不完整"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取临时文件中记录的断点，加载每个线程的任务区间，若临时文件不存在，则重新分配每个线程的任务区间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file_tmp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBreakPoint</span><span class="params">(File file_tmp)</span> </span>&#123;</span><br><span class="line">        RandomAccessFile random_file_tmp = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"开始分配任务区间："</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果存在临时文件，则从临时文件记录的位置继续下载</span></span><br><span class="line">            <span class="keyword">if</span> (file_tmp.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"找到临时文件，将从断点处恢复下载..."</span>);</span><br><span class="line">                random_file_tmp = <span class="keyword">new</span> RandomAccessFile(file_tmp, <span class="string">"rw"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    random_file_tmp.seek(i * <span class="number">8</span>);</span><br><span class="line">                    start[i] = random_file_tmp.readLong();</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(<span class="number">1000</span> + i * <span class="number">8</span>);</span><br><span class="line">                    end[i] = random_file_tmp.readLong();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + i + <span class="string">" 起始位置："</span></span><br><span class="line">                            + start[i] + <span class="string">"，结束位置："</span> + end[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"未找到临时文件，开始一个新的下载..."</span>);</span><br><span class="line">                random_file_tmp = <span class="keyword">new</span> RandomAccessFile(file_tmp, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    <span class="comment">//设置线程i的下载起始位置</span></span><br><span class="line">                    start[i] = lenPerThread * i;</span><br><span class="line">                    <span class="keyword">if</span> (i == threadNum - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//当线程i为最后一个线程时，设置线程i的下载结束位置为文件长度</span></span><br><span class="line">                        end[i] = fileLength - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        end[i] = lenPerThread * (i + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(i * <span class="number">8</span>);</span><br><span class="line">                    random_file_tmp.writeLong(start[i]);</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(<span class="number">1000</span> + i * <span class="number">8</span>);</span><br><span class="line">                    random_file_tmp.writeLong(end[i]);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + i + <span class="string">" 起始位置："</span></span><br><span class="line">                            + start[i] + <span class="string">"，结束位置："</span> + end[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (random_file_tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    random_file_tmp.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownLoadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;         <span class="comment">//线程id</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> startPos;  <span class="comment">//线程下载起始位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> endPos;    <span class="comment">//线程下载结束位置</span></span><br><span class="line">        <span class="keyword">private</span> Downloader task;</span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile rand_file;</span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile rand_file_tmp;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownLoadThread</span><span class="params">(<span class="keyword">long</span> startPos, <span class="keyword">long</span> endPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Downloader task, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rand_file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.task.filename, <span class="string">"rw"</span>);</span><br><span class="line">                <span class="keyword">this</span>.rand_file_tmp = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.task.filename_tmp, <span class="string">"rw"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            HttpURLConnection httpcon;</span><br><span class="line">            InputStream is = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 开始下载..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    httpcon = (HttpURLConnection) task.url.openConnection();</span><br><span class="line">                    httpcon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//防止网络阻塞，设置指定的超时时间；单位都是ms。超过指定时间，就会抛出异常</span></span><br><span class="line">                    httpcon.setReadTimeout(<span class="number">20000</span>);<span class="comment">//读取数据的超时设置</span></span><br><span class="line">                    httpcon.setConnectTimeout(<span class="number">20000</span>);<span class="comment">//连接的超时设置</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (startPos &lt; endPos) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//向服务器请求指定区间段的数据，这是实现断点续传的根本。</span></span><br><span class="line">                        httpcon.setRequestProperty(<span class="string">"Range"</span>, <span class="string">"bytes="</span> + startPos + <span class="string">"-"</span> + endPos);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 长度："</span> + (endPos - startPos + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        rand_file.seek(startPos);</span><br><span class="line"></span><br><span class="line">                        is = httpcon.getInputStream();<span class="comment">//获取服务器返回的资源流</span></span><br><span class="line">                        <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> ((length = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            count += length;</span><br><span class="line">                            rand_file.write(buf, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//不断更新每个线程下载资源的起始位置，并写入临时文件</span></span><br><span class="line">                            startPos += length;</span><br><span class="line">                            rand_file_tmp.seek(id * <span class="number">8</span>);</span><br><span class="line">                            rand_file_tmp.writeLong(startPos);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + id</span><br><span class="line">                                + <span class="string">" 总下载大小: "</span> + count);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//关闭流</span></span><br><span class="line">                        is.close();</span><br><span class="line">                        httpcon.disconnect();</span><br><span class="line">                        rand_file.close();</span><br><span class="line">                        rand_file_tmp.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 下载完成"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            is.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line">        String url = <span class="string">"http://blog.default.nanwulife.com/pexels-photo-640947.jpeg"</span>;</span><br><span class="line"></span><br><span class="line">        Downloader load = <span class="keyword">new</span> Downloader(url, threadNum);</span><br><span class="line">        load.download();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究多线程的断点续传下载。断点续传的原理其实很简单，就是在下载时将下载进度保存到一个临时文件中，如果下载过程遇到什么意外中断了，下次下载同一个文件时就可以从临时文件中读取到上次下载发生中断时的进度，然后从这个进度开始继续下载。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="断点续传" scheme="http://yoursite.com/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池与Executor框架</title>
    <link href="http://yoursite.com/2019/02/10/Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/02/10/Executor框架/</id>
    <published>2019-02-10T10:27:00.000Z</published>
    <updated>2019-02-15T12:25:56.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，使用线程池可以进行统一分配、调优和监控。</li></ul><a id="more"></a><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p><img src="http://blog.default.nanwulife.com/1787733-248f411a83669fff.webp" alt=""></p><ol><li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（这一步需获取全局锁）。</li><li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>如果队列已满，则创建新的线程来处理任务（这一步需获取全局锁）。</li><li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并使用相关饱和策略进行处理，默认是直接抛出异常。</li></ol><p>之所以采用这个步骤，是因为在执行<code>execute()</code>方法时，尽可能地避免获取全局锁。在线程池完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor框架内部使用了线程池机制，它在<code>java.util.cocurrent</code>包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，通过<code>Executor</code>来启动线程比使用<code>Thread</code>的<code>start()</code>方法更易管理且效率更好。</p><h2 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h2><p><img src="http://blog.default.nanwulife.com/6021163-4e29a753826e7d23.webp" alt=""></p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>是Executor框架的最核心的类，是线程池的实现类，用来执行被提交的任务，通常使用工厂类<code>Executors</code>来创建，有以下三种类型：</p><ul><li><code>FixedThreadPool</code>：线程数固定。适用于为了满足资源管理而需要限制线程数的场景，适用于负载比较重的服务器。</li><li><code>SingleThreadExecutor</code>：只有一个线程。适用于需要保证顺序地执行各个任务，并且在任意时间点不会有多个线程是活动的场景。</li><li><code>CachedThreadPool</code>：根据需要创建新线程。空闲线程等待新任务超过60秒就会被终止。适用于执行很多短期异步任务的小程序，或者是负载较轻的服务器。</li></ul><p><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列。<code>CachedThreadPool</code>使用没有容量的<code>SynchronousQueue</code>作为线程池的工作队列。</p><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>，主要用来在给定的延迟之后运行任务，或者定期执行任务。<code>ScheduledThreadPoolExecutor</code>的功能与<code>Timer</code>类似，但<code>ScheduledThreadPoolExecutor</code>功能更强大、更灵活，<code>Timer</code>对应的是单个后台线程，而<code>ScheduledThreadPoolExecutor</code>可以在构造函数中指定多个对应的后台线程数。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果。<code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。可以把<code>FutureTask</code>交给<code>Executor</code>执行，也可以通过<code>submit()</code>方法返回一个<code>FutureTask</code>，然后执行<code>FutureTask.get()</code>方法。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用<code>execute()</code>方法提交任务，但是<code>execute()</code>方法没有返回值，所以无法判断任务是否被线程池执行成功。也可以使用<code>submit()</code>方法来提交任务，它会返回一个<code>future</code>，可以通过这个<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞直到任务完成。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的<code>shutdown()</code>或<code>shutdownNow()</code>方法来关闭线程池。</p><ul><li><code>shutdown()</code>先将线程池状态置为<code>SHUTDOWN</code>，停止接受外部提交的新任务，而等到正在执行的任务以及队列中等待的任务执行完才真正停止。</li><li><code>shutdownNow()</code>先将线程池状态置为<code>STOP</code>，停止接受外部提交的新任务，忽略队列里等待的任务，使用<code>interrupt()</code>方法尝试将正在跑的任务中断，然后返回未执行的任务列表。</li></ul><p>注意，如果线程中没有<code>sleep</code>、<code>wait</code>、<code>Condition</code>等应用，<code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>shutdownNow()</code>并不代表线程池一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/java-threadpool/" target="_blank" rel="noopener">聊聊并发（三）Java线程池的分析和使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用线程池&quot;&gt;&lt;a href=&quot;#为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池&quot;&gt;&lt;/a&gt;为什么要使用线程池&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性：线程是稀缺资源，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Executor" scheme="http://yoursite.com/tags/Executor/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的并发工具类</title>
    <link href="http://yoursite.com/2019/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/10/Java中的并发工具类/</id>
    <published>2019-02-10T06:27:00.000Z</published>
    <updated>2019-02-10T09:00:32.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p><code>CountDownLatch</code>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p><a id="more"></a><p><code>CountDownLatch</code>是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过创建一个初始计数为1的<code>CountDownLatch</code>，并让所有线程都在这个锁上等待，随后调用<code>countDown()</code>方法来同时启动多个线程。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>同步屏障<code>CyclicBarrier</code>可以让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><p><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。所以<code>CyclicBarrier</code>能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<code>Semaphore</code>的构造方法接受一个整型的数字，表示可用的许可证数量，线程使用<code>acquire()</code>方法获取一个许可证，如果没有许可证能够获得则被阻塞，使用完后调用<code>release()</code>方法归还许可证。还可以使用<code>tryAcquire()</code>方法尝试获取许可证，若获取成功，则立即返回true，若获取失败，则立即返回false。</p><p><code>Semaphore</code>可以用于流量控制，特别是公用资源有限的应用场景，比如数据库连接。如果线程数有几十个，而数据库的连接只有十个，那么就可以使用<code>Semaphore</code>控制同时获取数据库连接的个数。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java并发编程的艺术》</li><li><a href="http://www.importnew.com/15731.html" target="_blank" rel="noopener">什么时候使用CountDownLatch</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CountdownLatch&quot;&gt;&lt;a href=&quot;#CountdownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountdownLatch&quot;&gt;&lt;/a&gt;CountdownLatch&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程基础</title>
    <link href="http://yoursite.com/2019/02/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/09/Java并发编程基础/</id>
    <published>2019-02-09T02:24:00.000Z</published>
    <updated>2019-02-10T06:02:05.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>Java线程在运行的生命周期中可能处于以下6种不同的状态：</p><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态，线程被构建，但是还没调用<code>start()</code>方法</td></tr><tr><td>RUNNABLE</td><td>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td></tr><tr><td>BLOCKED</td><td>阻塞状态，表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>无限期等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>限期等待状态，可以在指定的时间自行返回</td></tr><tr><td>TERMINATED</td><td>终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><a id="more"></a><p><img src="http://blog.default.nanwulife.com/212748_11NT_1789589.jpg" alt=""></p><p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入<code>synchronized</code>关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在<code>Lock</code>接口的线程状态是等待状态。</p><h2 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h2><p>用户线程是我们平常创建的普通线程，而守护线程则是用来服务于用户线程的一种支持型线程。当一个Java虚拟机中只存在守护线程的时候，Java虚拟机将会退出。可以在启动线程之前通过调用<code>Thread.setDaemon(true)</code>将该线程设置为守护线程。</p><p>守护线程可用于实时监控和管理系统中的可回收资源。例如，Java垃圾回收线程就是一个典型的守护线程，当我们的程序中不再有任何运行中的Thread，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动退出。</p><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>有三种使用线程的方法：</p><ol><li>实现<code>Runnable</code>接口；</li><li>实现<code>Callable</code>接口；</li><li>继承<code>Thread</code>类。</li></ol><p>实现<code>Runnable</code>和<code>Callable</code>接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过<code>Thread</code>来调用。可以说任务是通过线程驱动从而执行的。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>需要实现<code>run()</code>方法。通过<code>Thread</code>调用<code>start()</code>方法来启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与<code>Runnable</code>相比，<code>Callable</code>可以有返回值，返回值通过<code>FutureTask</code>进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>同样也是需要实现<code>run()</code>方法，因为<code>Thread</code>类也实现了<code>Runable</code>接口。</p><p>当调用<code>start()</code>方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的<code>run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>实现接口会更好一些，因为：</p><ul><li>Java不支持多重继承，因此继承了<code>Thread</code>类就无法继承其它类，但是可以实现多个接口。</li><li>类可能只要求可执行就行，继承整个<code>Thread</code>类开销过大。</li></ul><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>等待/通知机制是指一个线程A调用了对象O的<code>wait()</code>方法进入等待状态，而另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，进而执行后续操作。以下为等待/通知的经典范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待方</span></span><br><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"><span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">    对象.wait();</span><br><span class="line">   &#125;</span><br><span class="line">   对应的处理逻辑;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知方</span></span><br><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">   对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>方法只能用在同步方法或者同步控制块中使用，否则会在运行时抛出<code>IllegalMonitorStateException</code>。使用<code>wait()</code>挂起期间，线程会释放锁，这是因为如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行<code>notify()</code>或者<code>notifyAll()</code>来唤醒挂起的线程，造成死锁。</p><p>注意，<code>wait()</code>是<code>Object</code>的方法，而<code>sleep()</code>是<code>Thread</code>的静态方法；<code>wait()</code>会释放锁，<code>sleep()</code>不会。</p><h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><p>在线程中调用另一个线程的<code>join()</code>方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p><code>java.util.concurrent</code>类库中提供了<code>Condition</code>类来实现线程之间的协调，可以在<code>Condition</code>上调用<code>await()</code>方法使线程等待，其它线程调用<code>signal()</code>或<code>signalAll()</code>方法唤醒等待的线程。</p><p>相比于<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">      AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">      executorService.execute(() -&gt; example.after());</span><br><span class="line">      executorService.execute(() -&gt; example.before());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code>即线程变量，是一个以<code>ThreadLocal</code>对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值。可以通过<code>set(T)</code>方法来设置一个值，在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java并发编程的艺术》</li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">CS-Notes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;&gt;&lt;/a&gt;线程状态&lt;/h2&gt;&lt;p&gt;Java线程在运行的生命周期中可能处于以下6种不同的状态：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NEW&lt;/td&gt;
&lt;td&gt;初始状态，线程被构建，但是还没调用&lt;code&gt;start()&lt;/code&gt;方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUNNABLE&lt;/td&gt;
&lt;td&gt;运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOCKED&lt;/td&gt;
&lt;td&gt;阻塞状态，表示线程阻塞于锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WAITING&lt;/td&gt;
&lt;td&gt;无限期等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定动作（通知或中断）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME_WAITING&lt;/td&gt;
&lt;td&gt;限期等待状态，可以在指定的时间自行返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TERMINATED&lt;/td&gt;
&lt;td&gt;终止状态，表示当前线程已经执行完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>final域的内存语义</title>
    <link href="http://yoursite.com/2019/02/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/02/09/深入分析final关键字/</id>
    <published>2019-02-09T01:26:00.000Z</published>
    <updated>2019-02-09T02:12:20.152Z</updated>
    
    <content type="html"><![CDATA[<p>对于<code>final</code>域，编译器和处理器要遵守两个重排序规则。</p><ol><li>在构造函数内对一个<code>final</code>域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序。</li></ol><a id="more"></a><p>以上规则保证只要对象是正确构造的，那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个<code>final</code>域在构造函数中被初始化之后的值。要实现这个效果，还需要保证在构造函数内部，不能让这个被构造对象的引用为其它线程所见，也就是对象引用不能在构造函数中“逸出”，因为此时的<code>final</code>域由于重排序等原因可能还没被初始化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于&lt;code&gt;final&lt;/code&gt;域，编译器和处理器要遵守两个重排序规则。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在构造函数内对一个&lt;code&gt;final&lt;/code&gt;域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。&lt;/li&gt;
&lt;li&gt;初次读一个包含&lt;code&gt;final&lt;/code&gt;域的对象的引用，与随后初次读这个&lt;code&gt;final&lt;/code&gt;域，这两个操作之间不能重排序。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="final" scheme="http://yoursite.com/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>顺序一致性模型与happens-before原则</title>
    <link href="http://yoursite.com/2019/02/09/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E4%B8%8Ehappens-before%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2019/02/09/顺序一致性模型与happens-before规则/</id>
    <published>2019-02-09T00:27:00.000Z</published>
    <updated>2019-02-09T01:09:44.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行并且立刻对所有线程可见。</li></ul><p>JMM保证如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p><a id="more"></a><p>而对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有的冒出来。为了实现最小安全性，JVM在堆上分配内存时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。</p><p>注意：对于未同步程序，JMM不保证对64位的long型和double型变量的写操作具有原子性。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before原则定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java并发编程的艺术》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序一致性模型&quot;&gt;&lt;a href=&quot;#顺序一致性模型&quot; class=&quot;headerlink&quot; title=&quot;顺序一致性模型&quot;&gt;&lt;/a&gt;顺序一致性模型&lt;/h2&gt;&lt;p&gt;顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。顺序一致性内存模型有两大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个线程中的所有操作必须按照程序的顺序来执行。&lt;/li&gt;
&lt;li&gt;不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行并且立刻对所有线程可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JMM保证如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="happens-before" scheme="http://yoursite.com/tags/happens-before/"/>
    
  </entry>
  
  <entry>
    <title>深入分析synchronized关键字</title>
    <link href="http://yoursite.com/2019/02/08/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/02/08/深入分析synchronized关键字/</id>
    <published>2019-02-08T02:27:00.000Z</published>
    <updated>2019-02-16T01:13:57.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>synchronized</code>是Java中的关键字，是一种同步锁，可作用于一段代码或方法，既可以保证可见性，又能够保证原子性。Java中的每一个对象都可以作为锁：</p><ul><li>对于同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前对象的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><p>当一个线程试图访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁，而没获取到锁的线程将被阻塞。</p><a id="more"></a><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>每个对象有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态。</p><p>代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，线程执行<code>monitorenter</code>指令时尝试获取monitor的所有权，过程如下：</p><ol><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li></ol><p>而对于<code>monitorexit</code>指令，指令执行时monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。 </p><p>方法同步不是使用<code>monitorenter</code>和<code>monitorexit</code>指令来完成，但同样是基于进入和退出monitor对象来实现，在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><p>JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的加锁解锁开销，因为轻量级锁的获取及释放依赖多次CAS操作，而偏向锁只需要在置换线程ID的时候依赖一次CAS操作。</p><p><strong>偏向锁获取过程：</strong></p><ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，以此确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</li><li>如果线程ID并未指向当前线程，则通过CAS操作获取锁。如果获取成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果获取失败，执行（4）。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>执行同步代码。</li></ol><p>线程不会主动去释放偏向锁，只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>轻量级锁的加锁过程：</strong></p><ol><li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，拷贝对象头中的Mark Word到锁记录中，官方称之为Displaced Mark Word。</li><li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针，并将锁记录里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。</li><li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态，而当前线程便尝试使用自旋来获取锁。</li></ol><p>在最后一步线程获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的，由于自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。JDK采用适应性自旋的方式解决这个问题，指定自旋的次数，如果超过次数如果还没获取到锁就进入阻塞状态。线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p><strong>轻量级锁的解锁过程：</strong></p><ol><li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</li><li>如果替换成功，整个同步过程就完成了。</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h2 id="锁的对比"><a href="#锁的对比" class="headerlink" title="锁的对比"></a>锁的对比</h2><table><thead><tr><th style="text-align:center">锁</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td style="text-align:center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td style="text-align:center">只有一个线程执行同步块。</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高了程序的响应速度。</td><td style="text-align:center">如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td style="text-align:center">多个线程交替执行同步块。</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">线程竞争不使用自旋，不会消耗CPU。</td><td style="text-align:center">线程阻塞，响应时间缓慢。</td><td style="text-align:center">多个线程同时执行同步块。</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/java-synchronized/" target="_blank" rel="noopener">聊聊并发（二）Java SE1.6中的Synchronized</a></li><li><a href="https://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">Java并发编程：Synchronized及其实现原理</a></li><li><a href="https://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是Java中的关键字，是一种同步锁，可作用于一段代码或方法，既可以保证可见性，又能够保证原子性。Java中的每一个对象都可以作为锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于同步方法，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;对于静态同步方法，锁是当前对象的Class对象。&lt;/li&gt;
&lt;li&gt;对于同步方法块，锁是Synchonized括号里配置的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个线程试图访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁，而没获取到锁的线程将被阻塞。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>深入分析volatile关键字</title>
    <link href="http://yoursite.com/2019/02/08/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/02/08/深入分析volatile关键字/</id>
    <published>2019-02-08T00:28:00.000Z</published>
    <updated>2019-02-15T12:30:03.806Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>volatile</code>是轻量级的<code>synchronized</code>，如果使用恰当的话，它会比<code>synchronized</code>的使用成本更低，因为它不会引起线程上下文的切换和调度。如果一个字段被声明成<code>volatile</code>，它将具有以下两个特性：</p><ul><li>可见性：对一个<code>volatile</code>变量的读，总是能看到任意线程对这个<code>volatile</code>变量最后的写入。</li><li>原子性：对任意单个<code>volatile</code>变量的读/写具有原子性，但类似于<code>volatile++</code>这种复合操作不具有原子性。</li></ul><a id="more"></a><h2 id="volatile的实现原理"><a href="#volatile的实现原理" class="headerlink" title="volatile的实现原理"></a>volatile的实现原理</h2><p>如果对声明了<code>volatile</code>的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p><p>简单来说就是Lock前缀指令会引起处理器缓存回写到内存，而一个处理器的缓存回写到内存会导致其它处理器的缓存无效。</p><h2 id="volatile的内存语义"><a href="#volatile的内存语义" class="headerlink" title="volatile的内存语义"></a>volatile的内存语义</h2><ul><li><code>volatile</code>写的内存语义：当写一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li><li><code>volatile</code>读的内存语义：当读一个<code>volatile</code>变量时，JMM会把该线程对应的本地内存设置为无效。线程接下来将从主内存中读取共享变量。</li></ul><p>为了实现<code>volatile</code>内存语义，JMM会分别限制编译器重排序和处理器重排序。</p><p>对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。以下是针对编译器制定的重排序规则：</p><ul><li>当第二个操作是<code>volatile</code>写时，不管第一个操作是什么，都不能重排序。</li><li>当第一个操作是<code>volatile</code>读时，不管第二个操作是什么，都不能重排序。</li><li>当第一个操作是<code>volatile</code>写，第二个操作是<code>volatile</code>读时，都不能重排序。</li></ul><p>对于处理器，JMM的处理器重排序规则会要求编译器在生成字节码时，在指令序列中插入内存屏障来禁止特定类型的处理器重排序。以下是基于保守策略的JVM内存屏障插入策略：</p><ul><li>在每个<code>volatile</code>写操作的前面插入一个<code>StoreStore</code>屏障。</li><li>在每个<code>volatile</code>写操作的后面插入一个<code>StoreLoad</code>屏障。</li><li>在每个<code>volatile</code>读操作的后面插入一个<code>LoadLoad</code>屏障。</li><li>在每个<code>volatile</code>读操作的后面插入一个<code>LoadStore</code>屏障。</li></ul><p>此策略可以保证在任意处理器平台，任意程序中都能得到正确的<code>volatile</code>内存语义。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/volatile/" target="_blank" rel="noopener">聊聊并发（一）深入分析Volatile的实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;volatile&lt;/code&gt;是轻量级的&lt;code&gt;synchronized&lt;/code&gt;，如果使用恰当的话，它会比&lt;code&gt;synchronized&lt;/code&gt;的使用成本更低，因为它不会引起线程上下文的切换和调度。如果一个字段被声明成&lt;code&gt;volatile&lt;/code&gt;，它将具有以下两个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可见性：对一个&lt;code&gt;volatile&lt;/code&gt;变量的读，总是能看到任意线程对这个&lt;code&gt;volatile&lt;/code&gt;变量最后的写入。&lt;/li&gt;
&lt;li&gt;原子性：对任意单个&lt;code&gt;volatile&lt;/code&gt;变量的读/写具有原子性，但类似于&lt;code&gt;volatile++&lt;/code&gt;这种复合操作不具有原子性。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="volatile" scheme="http://yoursite.com/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>支付宝的支付流程（当面付）</title>
    <link href="http://yoursite.com/2019/02/07/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%AF%B9%E6%8E%A5%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/07/支付宝对接流程/</id>
    <published>2019-02-07T08:19:00.000Z</published>
    <updated>2019-02-07T09:08:14.236Z</updated>
    
    <content type="html"><![CDATA[<p>由于在之前的项目中使用到了用支付宝完成订单支付这一功能，因此在此篇文章中对支付宝的整个支付流程以及背后的细节做一个简单的总结。具体接入指南以及开发文档参考<a href="https://docs.open.alipay.com/194/106078/" target="_blank" rel="noopener">蚂蚁金服 扫码支付接入指引</a> 。</p><a id="more"></a><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>整体来说前期准备工作有下面两步：</p><ol><li>创建应用并获取APPID</li><li>配置密钥</li></ol><p>其中配置密钥需要交换双方的公钥，在交易过程中会对交易数据进行双方校验。我们知道公钥加密过的内容只有私钥才可以解密，同样，私钥加签过的内容也只有公钥才能验签。商户系统在发起支付时会使用自己的私钥进行加签，由于私钥只有自己持有（因此要妥善保管），支付宝就可以确认支付是由商户系统发起的而非他人；同样支付宝也会使用自己的私钥对支付结果进行加签，这样商户系统使用支付宝的公钥验签后也就能确定该结果是支付宝返回的了。</p><p><img src="http://blog.default.nanwulife.com/LB1VVMbOFXXXXbKXXXXXXXXXXXX.png" alt=""></p><h2 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h2><ol><li>用户选中购物车的商品，创建一个待支付订单，商户系统生成唯一订单号。</li><li>用户点击支付，商户系统调用支付宝的预下单接口发送订单信息，接口返回一个二维码串。</li><li>商户系统通过二维码串自行生成订单二维码并显示给用户。</li><li>用户扫描二维码并付款。</li><li>支付成功后，支付宝根据预先配置的回调接口将支付结果异步通知给商户系统。</li><li>商户系统收到支付结果，验签确保是支付宝发出后，告知用户支付完成并更新相关数据库表。</li></ol><p><img src="http://blog.default.nanwulife.com/LB1QKdBLXXXXXcvXXXXXXXXXXXX.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于在之前的项目中使用到了用支付宝完成订单支付这一功能，因此在此篇文章中对支付宝的整个支付流程以及背后的细节做一个简单的总结。具体接入指南以及开发文档参考&lt;a href=&quot;https://docs.open.alipay.com/194/106078/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;蚂蚁金服 扫码支付接入指引&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="支付宝" scheme="http://yoursite.com/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架知识点总结</title>
    <link href="http://yoursite.com/2019/02/06/Spring%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/06/Spring框架知识点总结/</id>
    <published>2019-02-06T03:44:00.000Z</published>
    <updated>2019-02-17T00:02:30.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h1><p>Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。</p><a id="more"></a><p>Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。</p><p><img src="http://blog.default.nanwulife.com/3d0f7edba3a9b3689a28e9243f052ab5.png" alt=""></p><p>使用Spring的好处有以下几点：</p><ul><li>Spring是轻量的，基本的版本大约2MB。</li><li>Spring通过控制反转实现了松散耦合。</li><li>Spring支持面向切面编程，把应用业务逻辑和系统服务分开。</li><li>Spring包含并管理应用中对象的生命周期和配置。</li><li>Spring的Web框架是一个精心设计的Web MVC框架，是其它WEB框架的很好的替代品。</li><li>Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。</li></ul><h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><p>Spring框架的核心就是IoC容器，要掌握Spring框架，就必须要理解控制反转的思想以及依赖注入的实现方式。</p><h2 id="DI与IOC"><a href="#DI与IOC" class="headerlink" title="DI与IOC"></a>DI与IOC</h2><p>控制反转（Inversion of Control）就是将原本在程序中手动创建对象的控制权，交由Spring框架管理，根据配置文件在运行时动态的去创建对象，并调用对象的方法。作用是实现了程序的解耦合。</p><p>依赖注入（Dependency Injection）就是将实例变量传入到一个对象中去，非自己主动初始化依赖，而是通过外部来传入依赖。比如以前可能会在构造函数中自己<code>new</code>一个对象赋给成员变量，依赖注入则是将已经初始化好的对象作为构造函数的一个参数传入。Spring的依赖注入有3种方式：</p><ul><li>setter方法注入。</li><li>构造函数注入。</li><li>注解方式注入。</li></ul><p>控制反转与依赖注入有着本质的不同：</p><ul><li>控制反转是一种思想。</li><li>依赖注入是一种实现方式。</li></ul><p>IoC容器使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，例如说<code>ServiceLocator</code>，所以不能将控制反转和依赖注入等同。</p><h2 id="BeanFactory和ApplicationContext"><a href="#BeanFactory和ApplicationContext" class="headerlink" title="BeanFactory和ApplicationContext"></a>BeanFactory和ApplicationContext</h2><p><code>BeanFactory</code>是Spring框架最核心、最底层的接口，是Spring IoC容器的具体实现。<code>BeanFactory</code>负责读取bean配置文件实例化Bean并建立Bean之间的依赖关系，提供Bean实例缓存、生命周期管理等服务。</p><p><code>ApplicationContext</code>建立在<code>BeanFactory</code>基础之上，称为应用上下文，提供了更多面向应用的功能。例如提供了支持国际化的文本消息、统一的资源文件读取方式和框架事件体系等，更易于创建实际应用。以下是三种较常见的<code>ApplicationContext</code>实现方式：</p><ul><li><code>FileSystemXmlApplicationContext</code>：由文件系统中的XML配置文件中读取上下文。</li><li><code>ClassPathXmlApplicationContext</code>：由类路径的XML配置文件中读取上下文。</li><li><code>WebXmlApplicationContext</code>：由Web应用的XML文件读取上下文。</li></ul><p>除了以上的区别外，<code>BeanFactroy</code>采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时（调用<code>getBean()</code>），才对该Bean进行加载实例化，这样我们就不能发现一些存在的Spring的配置问题。而<code>ApplicationContext</code>则相反，它是在容器启动时一次性创建了所有的Bean，这样在容器启动时我们就可以发现Spring中存在的配置错误。</p><h2 id="Spring-Beans"><a href="#Spring-Beans" class="headerlink" title="Spring Beans"></a>Spring Beans</h2><p>Spring beans是那些形成Spring应用的主干java对象。它们被Spring IOC容器初始化，装配和管理。这些beans通过容器中配置的元数据创建，比如以XML文件中<code>&lt;bean/&gt;</code>的形式定义。装配Bean总共有三种方式：</p><ul><li>XML配置文件。</li><li>基于java的配置。</li><li>基于注解的配置。</li></ul><h3 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h3><p>当定义一个<code>&lt;bean&gt;</code>时，我们能通过定义中的<code>scope</code>属性来给这个bean声明一个作用域。Spring框架支持以下五种bean的作用域：</p><ul><li><code>singleton</code> : bean在每个Spring Ioc 容器中只有一个实例。</li><li><code>prototype</code>：一个bean的定义可以有多个实例。</li><li><code>request</code>：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><code>session</code>：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><code>global-session</code>：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><p>其中，单例bean不是线程安全的，Spring框架并没有对单例bean进行任何多线程的封装处理，关于单例bean的线程安全和并发问题需要开发者自行去搞定。</p><h3 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h3><p>在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不再被调用时需要进行相关的析构操作，并从bean容器中移除。</p><p><img src="http://blog.default.nanwulife.com/Spring-bean-life-cycle.png" alt=""></p><ul><li>Spring容器从XML文件中读取bean的定义并实例化bean。</li><li>Spring根据bean的定义填充所有的属性。</li><li>调用<code>BeanNameAware</code>的<code>setBeanName</code>方法。</li><li>调用<code>BeanFactoryAware</code>的<code>setBeanFactory</code>方法。</li><li>调用<code>BeanPostProcessor</code>的<code>postProcesserBeforeInitialization</code>方法。</li><li>调用<code>InitializingBean</code>的<code>afterPropertiesSet</code>方法。</li><li>调用<code>&lt;bean&gt;</code>的<code>init-method</code>属性指定的初始化方法。</li><li>调用<code>BeanPostProcessor</code>的<code>postProcesserAfterInitialization</code>方法。</li><li>容器初始化成功，程序执行，业务逻辑调用后，下面销毁容器。</li><li>调用<code>DisposableBean</code>的<code>destroy</code>方法。</li><li>调用<code>&lt;bean&gt;</code>的<code>destroy-method</code>属性指定的销毁方法。</li></ul><p><code>&lt;bean&gt;</code>有两个重要的属性<code>init-method</code>和<code>destroy-method</code>用来定制初始化和注销方法，它们也有相应的注解<code>@PostConstruct</code>和<code>@PreDestroy</code>。</p><h3 id="Inner-Bean"><a href="#Inner-Bean" class="headerlink" title="Inner Bean"></a>Inner Bean</h3><p>当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，内部bean通常是匿名的，它们的作用域一般是<code>prototype</code>。</p><h3 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h3><p>Spring引入自动装配机制就是为了解决<code>&lt;bean&gt;</code>标签下<code>&lt;property&gt;</code>标签过多导致可维护性差的问题，Spring容器能够自动装配相互合作的bean，这意味着容器不需要<code>&lt;constructor-arg&gt;</code>和<code>&lt;property&gt;</code>配置，能通过<code>BeanFactory</code>自动处理bean之间的依赖关系。在Spring框架中共有以下5种自动装配：</p><ul><li>no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。</li><li>byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。</li><li>byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到或找到多个相同类型的话就报错。</li><li>constructor：构造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。</li><li>autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。</li></ul><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><p>面向切面编程（AOP）就是在运行时，动态地将代码切入到类的指定方法、指定位置上的一种编程思想。</p><h2 id="通知（Advice）"><a href="#通知（Advice）" class="headerlink" title="通知（Advice）"></a>通知（Advice）</h2><p>就是想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下。Spring可以应用五种类型的通知：</p><ul><li>before：前置通知，在一个方法执行前被调用。</li><li>after：在方法执行之后调用的通知，无论方法执行是否成功。</li><li>after-returning：仅当方法成功完成后执行的通知。</li><li>after-throwing：在方法抛出异常退出时执行的通知。</li><li>around：在方法执行之前和之后调用的通知。</li></ul><h2 id="连接点（JoinPoint）"><a href="#连接点（JoinPoint）" class="headerlink" title="连接点（JoinPoint）"></a>连接点（JoinPoint）</h2><p>就是Spring允许是通知（Advice）的地方，基本每个方法的前、后（两者都有也行），或抛出异常时都可以是连接点，Spring只支持方法连接点。</p><h2 id="切入点（Pointcut）"><a href="#切入点（Pointcut）" class="headerlink" title="切入点（Pointcut）"></a>切入点（Pointcut）</h2><p>上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有十几个连接点了对吧，但是你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切入点来筛选连接点，选中那几个你想要的方法。</p><h2 id="切面（Aspect）"><a href="#切面（Aspect）" class="headerlink" title="切面（Aspect）"></a>切面（Aspect）</h2><p>切面是通知和切入点的结合。通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p><h2 id="织入（weaving）"><a href="#织入（weaving）" class="headerlink" title="织入（weaving）"></a>织入（weaving）</h2><p>把切面应用到目标对象来创建新的代理对象的过程。</p><h2 id="引入（introduction）"><a href="#引入（introduction）" class="headerlink" title="引入（introduction）"></a>引入（introduction）</h2><p>允许我们在已存在的类中增加新的方法和属性。</p><h2 id="代理（proxy）"><a href="#代理（proxy）" class="headerlink" title="代理（proxy）"></a>代理（proxy）</h2><p>通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。</p><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><p>Spring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一个模块。在web模型中，MVC是一种很流行的架构，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。</p><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p><img src="http://blog.default.nanwulife.com/20180708224853769.png" alt=""></p><ol><li>用户发送请求至前端控制器DispatcherServlet；</li><li>DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle；</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet；</li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器；</li><li>执行处理器(Handler，也叫后端控制器)；</li><li>Handler执行完成返回ModelAndView；</li><li>HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet；</li><li>DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析；</li><li>ViewResolver解析后返回具体View；</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet响应用户。</li></ol><h2 id="SpringMVC如何和AJAX相互调用"><a href="#SpringMVC如何和AJAX相互调用" class="headerlink" title="SpringMVC如何和AJAX相互调用"></a>SpringMVC如何和AJAX相互调用</h2><p>通过Jackson框架就可以把Java里面的对象直接转化成js可以识别的Json对象。具体步骤如下 ：</p><ol><li>加入<code>Jackson.jar</code></li><li>在配置文件中配置json的映射</li><li>在方法前面要加上<code>@ResponseBody</code>注解。</li></ol><h1 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h1><ul><li><p><code>@Required</code>：该注解表明bean的属性必须在配置的时候设置，若@Required注解的bean属性未被设置，容器将抛出<code>BeanInitializationException</code>。注意@Required只能设置在setter方法上。</p></li><li><p><code>@Autowired</code>：该注解可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，默认是按类型进行装配。在类成员变量上加上该注解时，就可以去掉相应的getter和setter方法了，Spring将直接采用Java反射机制对成员变量进行自动注入。</p></li><li><p><code>@Qualifier</code>：当有多个相同类型的bean却只有一个需要自动装配时，将<code>@Qualifier</code>注解和<code>@Autowired</code>注解结合使用以消除这种混淆，指定需要装配的确切的bean。</p></li><li><p><code>@Resource</code>：与<code>@Autowired</code>不同的是该注解默认按照名称装配，当找不到与名称匹配的bean时才会按照类型装配。注意如果没有指定name属性，并且按照默认的名称仍然找不到依赖的对象时候，会回退到按照类型装配，但一旦指定了name属性，就只能按照名称 装配了。</p></li></ul><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="Spring框架中都用到了哪些设计模式？"><a href="#Spring框架中都用到了哪些设计模式？" class="headerlink" title="Spring框架中都用到了哪些设计模式？"></a>Spring框架中都用到了哪些设计模式？</h2><p>待更。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring概述&quot;&gt;&lt;a href=&quot;#Spring概述&quot; class=&quot;headerlink&quot; title=&quot;Spring概述&quot;&gt;&lt;/a&gt;Spring概述&lt;/h1&gt;&lt;p&gt;Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="IOC" scheme="http://yoursite.com/tags/IOC/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>电商项目优化实践</title>
    <link href="http://yoursite.com/2019/02/05/mmall%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97/"/>
    <id>http://yoursite.com/2019/02/05/mmall电商项目优化日志/</id>
    <published>2019-02-05T13:24:00.000Z</published>
    <updated>2019-02-24T09:55:02.218Z</updated>
    
    <content type="html"><![CDATA[<p>本篇日志将记录之前做过的mmall项目的一些优化过程，主要包括JVM调优和数据库优化两个方面，通过不断动手实践并总结心得，希望能在此积累起许多经验，为以后能更得心应手的写出高效而又稳健的代码打好基础。</p><a id="more"></a><h2 id="商品表的优化"><a href="#商品表的优化" class="headerlink" title="商品表的优化"></a>商品表的优化</h2><p>在实际应用中我们往往都会遇到根据名称来查询某个商品或者根据昵称查询某个用户，如果返回的行数较多则要使用分页，而之前项目一直都是使用的PageHelper这个框架来完成分页功能的，这么做自然简单方便，但是当数据量达到几十万甚至百万时就会遇到性能瓶颈，尽管能够使用一些索引进行优化，但一个查询仍然需要十几二十秒才能完成，显然还远不能达标。在阅读PageHelper源码后可以发现，之所以会发生这种情况是因为PageHelper主要是通过拼接<code>LIMIT</code>语句来实现分页功能的，我们知道<code>LIMIT</code>在偏移量很大的时候会扫描很多不必要的行，因此需要对查询进行改进才能更好的应用在数据量比较大的场景下。</p><p>我们先建立一张商品表，还未在上面建立任何索引（除主键外）：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`mmall_product`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`mmall_product`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'商品id'</span>,</span><br><span class="line">  <span class="string">`category_id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'分类id,对应mmall_category表的主键'</span>,</span><br><span class="line">  <span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品名称'</span>,</span><br><span class="line">  <span class="string">`subtitle`</span> <span class="built_in">varchar</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'商品副标题'</span>,</span><br><span class="line">  <span class="string">`main_image`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'产品主图,url相对地址'</span>,</span><br><span class="line">  <span class="string">`sub_images`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'图片地址,json格式,扩展用'</span>,</span><br><span class="line">  <span class="string">`detail`</span> <span class="built_in">text</span> <span class="keyword">COMMENT</span> <span class="string">'商品详情'</span>,</span><br><span class="line">  <span class="string">`price`</span> <span class="built_in">decimal</span>(<span class="number">20</span>,<span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'价格,单位-元保留两位小数'</span>,</span><br><span class="line">  <span class="string">`stock`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'库存数量'</span>,</span><br><span class="line">  <span class="string">`status`</span> <span class="built_in">int</span>(<span class="number">6</span>) <span class="keyword">DEFAULT</span> <span class="string">'1'</span> <span class="keyword">COMMENT</span> <span class="string">'商品状态.1-在售 2-下架 3-删除'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> AUTO_INCREMENT=<span class="number">30</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>接着使用存储过程往里面插入100万条数据，为了提高插入时的速度，需要先修改<code>my.ini</code>配置文件的以下两处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">innodb_flush_log_at_trx_commit=0</span><br><span class="line">max_allowed_packet=100M</span><br></pre></td></tr></table></figure><p>重启MySQL后再执行以下代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">if</span> <span class="keyword">exists</span> product_insert;</span><br><span class="line">DELIMITER ;; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> product_insert() </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> y <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>;</span><br><span class="line">WHILE y &lt; 100000</span><br><span class="line"><span class="keyword">DO</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> mmall_product(category_id, <span class="keyword">name</span>, subtitle, main_image, sub_images, detail, price, stock, <span class="keyword">status</span>, create_time, update_time) </span><br><span class="line"><span class="keyword">values</span>(y%<span class="number">30</span>+<span class="number">100001</span>, <span class="string">'ab'</span>, <span class="keyword">substring</span>(<span class="keyword">MD5</span>(<span class="keyword">RAND</span>()),<span class="number">15</span>,<span class="number">20</span>), </span><br><span class="line"><span class="string">'241997c4-9e62-4824-b7f0-7425c3c28917.jpeg'</span>, </span><br><span class="line"><span class="string">'241997c4-9e62-4824-b7f0-7425c3c28917.jpeg,b6c56eb0-1748-49a9-98dc-bcc4b9788a54.jpeg,92f17532-1527-4563-aa1d-ed01baa0f7b2.jpeg,3adbe4f7-e374-4533-aa79-cc4a98c529bf.jpeg'</span>, </span><br><span class="line"><span class="string">'&lt;p&gt;&lt;img alt="miaoshu.jpg" src="http://img.happymmall.com/9c5c74e6-6615-4aa0-b1fc-c17a1eff6027.jpg" width="790" height="444"&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img alt="miaoshu2.jpg" src="http://img.happymmall.com/31dc1a94-f354-48b8-a170-1a1a6de8751b.jpg" width="790" height="1441"&gt;&lt;img alt="miaoshu3.jpg" src="http://img.happymmall.com/7862594b-3063-4b52-b7d4-cea980c604e0.jpg" width="790" height="1442"&gt;&lt;img alt="miaoshu4.jpg" src="http://img.happymmall.com/9a650563-dc85-44d6-b174-d6960cfb1d6a.jpg" width="790" height="1441"&gt;&lt;br&gt;&lt;/p&gt;'</span>,</span><br><span class="line"><span class="keyword">RAND</span>() * <span class="number">10000</span>,</span><br><span class="line"><span class="keyword">RAND</span>() * <span class="number">100</span>,</span><br><span class="line"><span class="number">1</span>, <span class="keyword">now</span>(), <span class="keyword">now</span>()); </span><br><span class="line"><span class="keyword">SET</span> y=y+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">WHILE</span> ; </span><br><span class="line"><span class="keyword">commit</span>; </span><br><span class="line"><span class="keyword">END</span>;; </span><br><span class="line"><span class="keyword">CALL</span> product_insert();</span><br></pre></td></tr></table></figure><p>这里的商品名、子标题等都使用的随机字符串，没有太多考究。此时就可以根据商品名<code>name</code>按价格<code>price</code>排序后进行查询了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mmall_product <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'ab'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">LIMIT</span> <span class="number">100</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mmall_product <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'ab'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">LIMIT</span> <span class="number">1000</span>, <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mmall_product <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'ab'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">LIMIT</span> <span class="number">10000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>执行时间如下：</p><p><img src="http://blog.default.nanwulife.com/3%29G5S7ZTBRINMZQEQ_%29ZLZH.png" alt=""></p><p>可以看出，在不断增大<code>LIMIT</code>的偏移量后，查询时间着实吓人，通过<code>EXPLAIN</code>分析执行计划发现<code>type</code>那列显示<code>ALL</code>，说明要全表扫描一百多万行，并且还有<code>Using filesort</code>。我们先根据<code>WHERE</code>语句和<code>ORDER BY</code>语句建立如下组合索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mmall_product <span class="keyword">ADD</span> <span class="keyword">INDEX</span> index_name_price (<span class="keyword">name</span>, price);</span><br></pre></td></tr></table></figure><p>执行<code>SHOW INDEX FROM mmall_product;</code>查看索引是否添加如下：</p><p><img src="http://blog.default.nanwulife.com/%288R%5D%29J%5BT2B16EP87J6%60%7D%289V.png" alt=""></p><p>这时在初步优化后分析执行计划可以看到查询不再是全表扫描，而是使用到了上面的索引，效率有所提升，但此时增大偏移量后查询依然会变得十分缓慢，还需要进一步优化。这里就可以用到“延迟关联”的技巧，由于LIMIT每扫描一行时都要去主索引拿到许多不必要的数据再丢弃，那么可以让其先在二级索引覆盖扫描得到满足条件的id，然后再与原表关联得到最终结果，代码如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> mmall_product </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> mmall_product <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'ab'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> price <span class="keyword">LIMIT</span> <span class="number">100000</span>, <span class="number">10</span>) <span class="keyword">AS</span> mmall_product_id <span class="keyword">USING</span>(<span class="keyword">id</span>);</span><br></pre></td></tr></table></figure><p>此时，就算偏移量为一百万时，查询也可以很轻松的在0.5S内完成，效果还是令人满意的。</p><p><img src="http://blog.default.nanwulife.com/%7D6%7BS@%25E2MGMXK_%29%29~JPZ6BT.png" alt=""></p><blockquote><p>PageHelper原理：PageHelper实现了MyBatis提供的<code>Interceptor</code>接口得到分页拦截器<code>PageInterceptor</code>，使用分页查询的时候，先调用<code>PageHelper.startPage</code>在当前线程上下文中设置一个<code>ThreadLocal</code>变量，分页拦截器拦截到SQL后会从<code>ThreadLocal</code>中拿到分页的信息，拼接分页语句并进行分页查询，最后再把<code>ThreadLocal</code>中的东西清除掉。</p></blockquote><h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><p>看了《深入理解Java虚拟机》也有一段时间了，书本的知识虽然都能理解，但实际的优化却从来没试过，这方面可以说是毫无经验。都说读万卷书不如行万里路，在网上看了一些GC优化的实际案例后，决定亲自动手在这个项目中尝试一下。</p><p>这次实践使用的垃圾收集器为ParNew+CMS（CMS失败时Serial Old替补）。首先通过以下参数设置垃圾收集器并打开GC日志：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC</span><br><span class="line">-XX:+UseParNewGC</span><br><span class="line">-XX:+PrintGC</span><br><span class="line">-Xloggc:C:\Users\canjie\Desktop\gc.log</span><br><span class="line">-XX:+PrintHeapAtGC</span><br><span class="line">-XX:+PrintGCDateStamps</span><br></pre></td></tr></table></figure></p><p>然后使用jmeter工具模拟多用户持续请求接口的场景，这里设置的一分钟的用户数5000人。jemeter的聚合报告显示如下，主要关注TP99这一指标：</p><p><img src="http://blog.default.nanwulife.com/GB44HLUCJSFK~%28HS%290%60M%7B9E.png" alt=""></p><p>请求结束后分析GC日志发现Minor GC执行的十分频繁，而Major GC仅仅五分钟内就执行了好几次，每次耗时约0.2s，频繁且耗时的STW对接口响应时间造成了很大的影响，对于追求低延时的服务来说肯定是不可取的。要想优化就必须得先知其原因，首先JVM的默认内存为64M，这肯定是不够的，其次频繁的Major GC主要是因为老年代的空间不够，那接下来就是通过调整总堆大小以及年轻代和老年代的比例来减少GC的频率和STW的时间。当然，这里的内存不是调的越大越好，调的过小会导致GC频率过高，而调的过大虽然GC频率降低了，但每次GC的耗时也会变长。</p><p>先通过GC日志得到活跃数据的大小（活跃数据的大小是指Full GC后堆中老年代占用空间的大小），然后通过以下策略设置基本参数：</p><table><thead><tr><th style="text-align:center">空间</th><th style="text-align:center">倍数</th></tr></thead><tbody><tr><td style="text-align:center">总堆</td><td style="text-align:center">3-4 倍活跃数据的大小</td></tr><tr><td style="text-align:center">新生代</td><td style="text-align:center">1-1.5 活跃数据的大小</td></tr><tr><td style="text-align:center">老年代</td><td style="text-align:center">2-3 倍活跃数据的大小</td></tr><tr><td style="text-align:center">永久代</td><td style="text-align:center">1.2-1.5 倍Full GC后的永久代空间占用</td></tr></tbody></table><p>我在这个例子中经过计算后设置的参数如下：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-Xmx640m</span><br><span class="line">-Xms640m</span><br><span class="line">-XX:NewSize=240m</span><br><span class="line">-XX:MaxNewSize=240m</span><br></pre></td></tr></table></figure><p>此时再启动项目并用jmeter模拟真实环境进行测试，可以发现调大总堆大小并设置合适的年轻代与老年代的比例后，Minor GC每分钟的频率已经降到了70-80次，而Major GC十分钟才会出现一次，每次的耗时在100ms以下，TP95下降了约10ms，TP99下降了约100ms。</p><p><img src="http://blog.default.nanwulife.com/0Y%5D$ZI%60U6X6J052%25CSB2VTU.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇日志将记录之前做过的mmall项目的一些优化过程，主要包括JVM调优和数据库优化两个方面，通过不断动手实践并总结心得，希望能在此积累起许多经验，为以后能更得心应手的写出高效而又稳健的代码打好基础。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java阻塞队列实现生产者-消费者模型</title>
    <link href="http://yoursite.com/2019/02/03/Java%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/02/03/Java实现生产者-消费者模型/</id>
    <published>2019-02-03T03:57:00.000Z</published>
    <updated>2019-02-03T05:00:43.124Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>阻塞队列（BlockingQueue）是一个支持阻塞的插入和移除的队列。阻塞插入即当队列满时，队列会阻塞插入元素的线程，直到队列不满；阻塞移除即当队列为空时，获取元素的线程会等待队列变为非空。</p><p>阻塞队列提供了四种处理方法：</p><table><thead><tr><th style="text-align:center">方法\处理方式</th><th style="text-align:center">抛出异常</th><th style="text-align:center">返回特殊值</th><th style="text-align:center">一直阻塞</th><th style="text-align:center">超时退出</th></tr></thead><tbody><tr><td style="text-align:center">插入方法</td><td style="text-align:center">add(e)</td><td style="text-align:center">offer(e)</td><td style="text-align:center">put(e)</td><td style="text-align:center">offer(e,time,unit)</td></tr><tr><td style="text-align:center">移除方法</td><td style="text-align:center">remove()</td><td style="text-align:center">poll()</td><td style="text-align:center">take()</td><td style="text-align:center">poll(time,unit)</td></tr><tr><td style="text-align:center">检查方法</td><td style="text-align:center">element()</td><td style="text-align:center">peek()</td><td style="text-align:center">不可用</td><td style="text-align:center">不可用</td></tr></tbody></table><a id="more"></a><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。可以用于设计缓存系统和定时任务调度。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。</li><li>LinkedBlockingDeque：LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>JDK是使用通知模式（<code>await()</code>/<code>signal()</code>）实现的阻塞队列：当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。下面是<code>ArrayBlockingQueue</code>的部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//省略其他代码</span></span><br><span class="line">        notEmpty = lock.newCondition();</span><br><span class="line">        notFull =  lock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == items.length)</span><br><span class="line">                notFull.await();</span><br><span class="line">            insert(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            <span class="keyword">return</span> extract();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">        items[putIndex] = x;</span><br><span class="line">        putIndex = inc(putIndex);</span><br><span class="line">        ++count;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><p>下面通过阻塞队列来实现一个经典的生产者-消费者模式，由于已经将底层封装的很好了，所以代码十分简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;Task&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger increTaskNo = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Task task = <span class="keyword">new</span> Task(increTaskNo.getAndIncrement());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                queue.put(task);</span><br><span class="line">                System.out.println(<span class="string">"produce: "</span> + task.no);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Task task = queue.take();</span><br><span class="line">                System.out.println(<span class="string">"consume: "</span> + task.no);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> no;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.no = no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里要注意，<code>put()</code>与<code>take()</code>方法与输出语句不是原子的，这会导致日志的输出顺序与实际任务的入队/出队顺序不一定匹配。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/java-blocking-queue/" target="_blank" rel="noopener">聊聊并发（七）——Java中的阻塞队列</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;阻塞队列（BlockingQueue）是一个支持阻塞的插入和移除的队列。阻塞插入即当队列满时，队列会阻塞插入元素的线程，直到队列不满；阻塞移除即当队列为空时，获取元素的线程会等待队列变为非空。&lt;/p&gt;
&lt;p&gt;阻塞队列提供了四种处理方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;方法\处理方式&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;抛出异常&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;返回特殊值&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;一直阻塞&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;超时退出&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;插入方法&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;add(e)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offer(e)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;put(e)&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;offer(e,time,unit)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;移除方法&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;remove()&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;poll()&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;take()&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;poll(time,unit)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;检查方法&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;element()&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;peek()&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不可用&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不可用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Fork/join框架分析与实战</title>
    <link href="http://yoursite.com/2019/02/02/Fork-join%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/02/02/Fork-join框架分析与实战/</id>
    <published>2019-02-02T09:36:00.000Z</published>
    <updated>2019-02-02T11:24:28.817Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Fork/Join框架是Java7提供了的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</p><a id="more"></a><h2 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h2><p>工作窃取算法（work-stealing）是指当一个队列所对应的线程先执行完队列中的所有任务后，从其他线程的队列里窃取一个任务来执行。为了减少竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</p><h2 id="Fork-join的使用"><a href="#Fork-join的使用" class="headerlink" title="Fork/join的使用"></a>Fork/join的使用</h2><ul><li><p><code>ForkJoinTask</code>：我们要使用Fork/Join框架，必须首先创建一个ForkJoin任务。它提供在任务中执行<code>fork()</code>和<code>join()</code>操作的机制，通常情况下我们不需要直接继承<code>ForkJoinTask</code>类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类：</p><ul><li><code>RecursiveAction</code>：用于没有返回结果的任务。</li><li><code>RecursiveTask</code> ：用于有返回结果的任务。</li></ul></li><li><p><code>ForkJoinPool</code> ：<code>ForkJoinTask</code>需要通过<code>ForkJoinPool</code>来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。</p></li></ul><p>接下来我们看一个问题：如何充分利用多核 CPU 计算很大 List 中所有整数的和？</p><p>这里就可以用到Fork/join框架将求和任务分成许多子任务来完成，再将子任务的计算结果相加即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinLargeListSum</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100000000</span>];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            array[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="keyword">long</span> begintime = System.currentTimeMillis();</span><br><span class="line">        CountSumTask task = <span class="keyword">new</span> CountSumTask(<span class="number">100000</span>, <span class="number">0</span>, array.length-<span class="number">1</span>, array);</span><br><span class="line">        Future&lt;Long&gt; future = forkJoinPool.submit(task);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"计算结果为："</span> + future.get());</span><br><span class="line">            <span class="keyword">long</span> endtime=System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"耗时："</span> + (endtime - begintime) + <span class="string">"ms"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSumTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> hi, lo;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] array;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CountSumTask</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.hi = hi;</span><br><span class="line">            <span class="keyword">this</span>.lo = lo;</span><br><span class="line">            <span class="keyword">this</span>.array = array;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> sum = <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果任务足够小就计算任务</span></span><br><span class="line">            <span class="keyword">boolean</span> canCompute = (hi - lo) &lt;= threshold;</span><br><span class="line">            <span class="keyword">if</span>(canCompute)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt;= hi; i++)&#123;</span><br><span class="line">                    sum += array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果任务大于阈值，就分裂成两个子任务计算</span></span><br><span class="line">                <span class="keyword">int</span> middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">                CountSumTask leftTask = <span class="keyword">new</span> CountSumTask(threshold, lo, middle, array);</span><br><span class="line">                CountSumTask rightTask = <span class="keyword">new</span> CountSumTask(threshold, middle+<span class="number">1</span>, hi, array);</span><br><span class="line">                <span class="comment">//执行子任务</span></span><br><span class="line">                leftTask.fork();</span><br><span class="line">                rightTask.fork();</span><br><span class="line">                <span class="comment">//等待子任务执行完，并得到结果</span></span><br><span class="line">                <span class="keyword">long</span> leftResult = leftTask.join();</span><br><span class="line">                <span class="keyword">long</span> rightResult = rightTask.join();</span><br><span class="line">                <span class="comment">//合并子任务</span></span><br><span class="line">                sum = leftResult + rightResult;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算结果为：5000000050000000</span><br><span class="line">耗时：69ms</span><br></pre></td></tr></table></figure><p>当我们调大阈值<code>threshold</code>时，意味着分割任务的次数减少，直接计算的次数增多，此时计算的效率也有可能降低。例如，当把阈值增大为100000000时，输出结果为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">计算结果为：5000000050000000</span><br><span class="line">耗时：110ms</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/talk-concurrency-forkjoin/" target="_blank" rel="noopener">聊聊并发（八）——Fork/Join框架介绍</a></li><li><a href="https://juejin.im/post/59be875e5188257e6b6d91c1" target="_blank" rel="noopener">重做一道Java面试题（Fork/Join）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Fork/Join框架是Java7提供了的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Fork/join" scheme="http://yoursite.com/tags/Fork-join/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="http://yoursite.com/2019/02/01/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/02/01/ConcurrentHashMap源码分析/</id>
    <published>2019-02-01T06:05:00.000Z</published>
    <updated>2019-02-02T11:25:06.767Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用ConcurrentHashMap"><a href="#为什么要使用ConcurrentHashMap" class="headerlink" title="为什么要使用ConcurrentHashMap"></a>为什么要使用ConcurrentHashMap</h2><ul><li><p>HashMap线程不安全。在JDK1.8之前的版本中，HashMap的实现在并发执行put操作时会导致HashMap的<code>Entry</code>链表形成环形数据结构，<code>Entry</code>的<code>next</code>节点永远不为空，就会产生死循环获取<code>Entry</code>。在之后的版本中这个死循环的问题不再发生，但仍然无法保证并发环境下的线程安全。</p></li><li><p>HashTable使用<code>synchronized</code>来保证线程安全，因此当一个线程访问HashTable的同步方法时，其它线程也访问同步方法就会被阻塞，在线程竞争激烈时效率很低。</p></li></ul><p>基于以上两点，我们在并发环境中应该选择线程安全且高效的<code>ConcurrentHashMap</code>。</p><a id="more"></a><h2 id="版本演进"><a href="#版本演进" class="headerlink" title="版本演进"></a>版本演进</h2><ul><li><p>jdk1.7采用分段锁技术，整个哈希表被分成多个段，每个段中会对应一个Segment段锁，段与段之间可以并发访问，但是多线程想要操作同一个段是需要获取锁的。所有的put，get，remove等方法都是根据键的哈希值对应到相应的段中，然后尝试获取锁进行访问。</p></li><li><p>jdk1.8取消了基于Segment的分段锁思想，改用CAS + synchronized控制并发操作，在某些方面提升了性能。并且追随1.8版本的 HashMap 底层实现，使用数组+链表+红黑树进行数据存储。</p></li></ul><h2 id="JDK1-8分析"><a href="#JDK1-8分析" class="headerlink" title="JDK1.8分析"></a>JDK1.8分析</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;<span class="comment">//哈希表，第一次put时才进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;<span class="comment">//扩容时新生成的数组，其大小为原数组的两倍。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;<span class="comment">//哈希表中存储的所有的结点的个数总和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用来控制table的初始化和扩容操作，默认为0。</span></span><br><span class="line"><span class="comment"> * 当为-1时代表table正在初始化，-N代表N-1个线程正在进行扩容操作，其余情况：</span></span><br><span class="line"><span class="comment"> * 如果table未初始化，表示table需要初始化的大小。</span></span><br><span class="line"><span class="comment"> * 如果table初始化完成，表示table的容量。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>这是一个特殊的<code>Node</code>节点，用来占位表示扩容时该桶的所有节点已完成迁移，hash值为-1，<code>key</code>和<code>value</code>都为null，并且内部存储着扩容后的表<code>nextTable</code>的引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">    ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">        <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h3><ol><li><p>在计算键所对应的哈希值后，如果哈希表还未初始化，那么初始化它。此时只允许一个线程对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出CPU等待下次系统调度。</p></li><li><p>初始化完后，获取table中对应索引的元素f，如果f为null，说明table中这个位置第一次插入元素，利用<code>Unsafe.compareAndSwapObject</code>方法插入Node节点。如果CAS成功，说明Node节点已经插入，随后<code>addCount()</code>方法会检查当前容量是否需要进行扩容。如果CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。</p></li><li><p>如果f的hash值等于<code>MOVED</code>也就是-1时，说明当前f是<code>ForwardingNode</code>节点，意味着有其它线程正在扩容，于是调用<code>helpTransfer()</code>方法让当前线程去协助扩容。</p></li><li><p>其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发。</p></li></ol><h3 id="transfer"><a href="#transfer" class="headerlink" title="transfer()"></a>transfer()</h3><p>ConcurrentHashMap的扩容是高度并发的，执行逻辑如下：</p><ol><li><p>通过计算CPU核心数和Map数组的长度得到每个线程要帮助处理多少个桶，并且这里每个线程处理都是平均的。默认每个线程处理16个桶，因此，当长度是16的时候，扩容的时候只会有一个线程扩容。</p></li><li><p>初始化<code>nextTable</code>，将其在原有基础上扩容两倍。</p></li><li><p>进入一个while循环，每个线程会先领取自己的任务区间，然后开始<code>--i</code>来遍历自己的任务区间，对每个桶进行处理。</p></li><li><p>如果遇到桶的头结点是空的，那么使用<code>ForwardingNode</code>标识该桶已经被处理完成了。如果遇到已经处理完成的桶，直接跳过进行下一个桶的处理。如果是正常的桶，对桶首节点加锁，正常的迁移即可，迁移结束后依然会将原表的该位置标识位已经处理。</p></li><li><p><code>finnish</code>如果为true 则说明整张表的迁移操作已经全部完成了，我们只需要重置table的引用并将nextTable赋为空即可。否则，CAS式的将<code>sizeCtl</code>减一，表示当前线程已经完成了任务，退出扩容操作。</p></li></ol><h3 id="addCount"><a href="#addCount" class="headerlink" title="addCount()"></a>addCount()</h3><p>当我们成功的添加完成一个结点，最后是需要判断添加操作后是否会导致哈希表达到它的阈值，并针对不同情况决定是否需要进行扩容，还有CAS式更新哈希表实际存储的键值对数量，这些操作都封装在<code>addCount</code>这个方法中，当然<code>putVal</code>方法的最后必然会调用该方法进行处理。该方法主要做两个事情：一是更新 <code>baseCount</code>，二是判断是否需要扩容。</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p>ConcurrentHashMap的并发删除过程：首先遍历整张表的桶结点，如果表还未初始化或者无法根据参数的哈希值定位到桶结点，那么将返回null。如果定位到的桶结点类型是<code>ForwardingNode</code>结点，调用<code>helpTransfer</code>协助扩容。否则给桶加锁，删除一个节点，最后调用<code>addCount()</code>方法CAS式更新<code>baseCount</code>的值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener">为并发而生的 ConcurrentHashMap（Java 8）</a></li><li><a href="https://www.jianshu.com/p/c0642afe03e0" target="_blank" rel="noopener">深入浅出ConcurrentHashMap1.8</a></li><li><a href="https://juejin.im/post/5b00160151882565bd2582e0" target="_blank" rel="noopener">并发编程——ConcurrentHashMap#transfer() 扩容逐行分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用ConcurrentHashMap&quot;&gt;&lt;a href=&quot;#为什么要使用ConcurrentHashMap&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用ConcurrentHashMap&quot;&gt;&lt;/a&gt;为什么要使用ConcurrentHashMap&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;HashMap线程不安全。在JDK1.8之前的版本中，HashMap的实现在并发执行put操作时会导致HashMap的&lt;code&gt;Entry&lt;/code&gt;链表形成环形数据结构，&lt;code&gt;Entry&lt;/code&gt;的&lt;code&gt;next&lt;/code&gt;节点永远不为空，就会产生死循环获取&lt;code&gt;Entry&lt;/code&gt;。在之后的版本中这个死循环的问题不再发生，但仍然无法保证并发环境下的线程安全。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;HashTable使用&lt;code&gt;synchronized&lt;/code&gt;来保证线程安全，因此当一个线程访问HashTable的同步方法时，其它线程也访问同步方法就会被阻塞，在线程竞争激烈时效率很低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于以上两点，我们在并发环境中应该选择线程安全且高效的&lt;code&gt;ConcurrentHashMap&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="JDK" scheme="http://yoursite.com/categories/JDK/"/>
    
    
      <category term="ConcurrentHashMap" scheme="http://yoursite.com/tags/ConcurrentHashMap/"/>
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://yoursite.com/2019/01/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/29/设计模式/</id>
    <published>2019-01-29T15:34:00.000Z</published>
    <updated>2019-02-12T01:11:04.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="七大设计原则"><a href="#七大设计原则" class="headerlink" title="七大设计原则"></a>七大设计原则</h1><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p><p>用抽象构建框架，用实现扩展细节。</p><h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象。</p><p>做到针对接口编程，不要针对实现编程。</p><a id="more"></a><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>定义：不要存在多于一个导致类变更的原因。一个类/接口/方法只负责一项职责。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。</p><p>建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量少；接口中不要存在子类用不到却必须实现的方法。</p><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>定义：一个对象应该对其它对象保持最少的了解。又叫最少知道原则。</p><p>只与朋友说话，而不和陌生人说话。这里的朋友指的是出现在成员变量，方法输入、输出参数中的类，而出现在方法体内部的不属于朋友。</p><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>定义：如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。</p><ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法</li><li>子类中可以增加自己特有的方法</li><li>当子类的方法重载（注意不是覆盖）父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松</li><li>当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等</li></ul><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>定义：尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。</p><h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p><strong>简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例，而不向客户暴露内部细节。</strong></p><p>简单工厂不属于23种设计模式，但是之后的工厂方法模式、抽象工厂模式都是由其演化而来，并且在实际场景中也有应用，因此有必要了解。</p><p>适用场景：工厂类负责创建的对象比较少。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：只需要传入一个正确的参数，就可以获取所需要的对象而无须知道其创建细节。</p><p>缺点：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>创建五个类：Video、JavaVideo、PythonVideo、VideoFactory、Test：</p><p><img src="http://blog.designpattern.nanwulife.com/simplefactory.png" alt="UML"></p><p>抽象产品类<code>Video</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体产品类<code>JavaVideo</code>、<code>PythonVideo</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVideo</span> <span class="keyword">extends</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Java课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonVideo</span> <span class="keyword">extends</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Python课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端类<code>Test</code>，这里可以传入字符串参数或者Class类参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VideoFactory videoFactory = <span class="keyword">new</span> VideoFactory();</span><br><span class="line">        Video video = videoFactory.getVideo(<span class="string">"java"</span>);</span><br><span class="line">        <span class="keyword">if</span>(video == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        video.produce();</span><br><span class="line"></span><br><span class="line">        VideoFactory videoFactory2 = <span class="keyword">new</span> VideoFactory();</span><br><span class="line">        Video video2 = videoFactory2.getVideo(JavaVideo.class);</span><br><span class="line">        <span class="keyword">if</span>(video2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        video2.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在简单工厂中，客户端不应该直接创建出具体的产品类，而应交给工厂类去创建，下面看看工厂类<code>VideoFactory</code>，使用了if-else判断参数或者使用使用反射技术从而决定创建哪个具体子类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Video <span class="title">getVideo</span><span class="params">(Class c)</span></span>&#123;</span><br><span class="line">        Video video = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            video = (Video) Class.forName(c.getName()).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> video;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Video <span class="title">getVideo</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"java"</span>.equalsIgnoreCase(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> JavaVideo();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"python"</span>.equalsIgnoreCase(type))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PythonVideo();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过简单工厂，客户端类就不需要自己去实例化具体的产品类，做到了客户端类和产品类的解耦。</p><h3 id="Calendar类的应用"><a href="#Calendar类的应用" class="headerlink" title="Calendar类的应用"></a>Calendar类的应用</h3><p>java.util下的<code>Calendar</code>类是一个抽象类，我们看看其中的<code>getInstance</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Locale aLocale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createCalendar(zone, aLocale);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Locale aLocale)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CalendarProvider provider =</span><br><span class="line">        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)</span><br><span class="line">                             .getCalendarProvider();</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> provider.getInstance(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">            <span class="comment">// fall back to the default instantiation</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Calendar cal = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">        String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">        <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cal == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">"th"</span> &amp;&amp; aLocale.getCountry() == <span class="string">"TH"</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">"JP"</span> &amp;&amp; aLocale.getLanguage() == <span class="string">"ja"</span></span><br><span class="line">                   &amp;&amp; aLocale.getCountry() == <span class="string">"JP"</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后半段中可以看出其根据参数通过<code>switch</code>和<code>if-else</code>创建了相应的具体子类对象，与之前的应用场景十分类似。在这里，<code>Calendar</code>既作为抽象产品类，也作为一个工厂类。</p><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><p>定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，<strong>工厂方法让类的实例化推迟到子类中进行</strong>。</p><p>适用场景：</p><ul><li>创建对象需要大量重复的代码</li><li>客户端不依赖于产品类示例如何被创建、实现等细节</li><li>一个类通过其子类来指定创建哪个对象</li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：用户只需要关心所需产品对应的工厂，无需关心创建细节；加入新产品符合开闭原则，提高可扩展性。</p><p>缺点：类的个数容易过多，增加复杂度。</p><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p><img src="http://blog.designpattern.nanwulife.com/factorymethod.png" alt="UML"></p><p>抽象产品类<code>Video</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体产品类<code>JavaVideo</code>、<code>PythonVideo</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVideo</span> <span class="keyword">extends</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Java课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonVideo</span> <span class="keyword">extends</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Python课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂类<code>VideoFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Video <span class="title">getVideo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂类<code>JavaVideoFactory</code>、<code>PythonVideo</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVideoFactory</span> <span class="keyword">extends</span> <span class="title">VideoFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Video <span class="title">getVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaVideo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonVideoFactory</span> <span class="keyword">extends</span> <span class="title">VideoFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Video <span class="title">getVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PythonVideo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类<code>Test</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VideoFactory videoFactory = <span class="keyword">new</span> PythonVideoFactory();</span><br><span class="line">        VideoFactory videoFactory2 = <span class="keyword">new</span> JavaVideoFactory();</span><br><span class="line">        Video video = videoFactory.getVideo();</span><br><span class="line">        video.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://blog.designpattern.nanwulife.com/factorymethod2.png" alt="UML"></p><p>这时如果需要增加一个新的产品时，只需要添加一个新的具体产品类和具体工厂类，而无需像简单工厂一样修改工厂类里面的判断逻辑，即满足了开闭原则。</p><p>例如，如果要增加新产品FEVideo，我们需要先加入一个具体产品类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FEVideo</span> <span class="keyword">extends</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制FE课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再增加这个具体产品所对应的具体工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FEVideoFactory</span> <span class="keyword">extends</span> <span class="title">VideoFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Video <span class="title">getVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FEVideo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后在应用层就可以直接使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VideoFactory videoFactory = <span class="keyword">new</span> PythonVideoFactory();</span><br><span class="line">        VideoFactory videoFactory2 = <span class="keyword">new</span> JavaVideoFactory();</span><br><span class="line">        VideoFactory videoFactory3 = <span class="keyword">new</span> FEVideoFactory();</span><br><span class="line">        Video video = videoFactory.getVideo();</span><br><span class="line">        video.produce();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的UML类图：</p><p><img src="http://blog.designpattern.nanwulife.com/factorymethod3.png" alt="UML"></p><h3 id="Java集合接口Collection中的应用"><a href="#Java集合接口Collection中的应用" class="headerlink" title="Java集合接口Collection中的应用"></a>Java集合接口Collection中的应用</h3><p><code>java.util.Collection</code>接口下的<code>iterator()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure></p><p>查看该接口的其中一个实现类<code>ArrayList</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> cursor != size;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; consumer)</span> </span>&#123;</span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在这里，<code>Collection</code>相当于一个抽象工厂，而<code>ArrayList</code>相当于一个具体工厂，这个具体工厂实现了工厂方法<code>iterator()</code>实例化具体产品<code>Itr</code>，而这个具体产品实现了抽象产品<code>Iterator</code>。</p><h3 id="logback中的应用"><a href="#logback中的应用" class="headerlink" title="logback中的应用"></a>logback中的应用</h3><p><img src="http://blog.designpattern.nanwulife.com/ILoggerFactory.png" alt="UML"></p><p>由UML可以看出<code>ILoggerFactory</code>作为抽象的工厂类，实现有三个具体的工厂类，以其中的<code>NOPLoggerFactory</code>为例，实现了抽象方法<code>getLogger</code>来实例化具体产品类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NOPLoggerFactory</span> <span class="keyword">implements</span> <span class="title">ILoggerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NOPLoggerFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> NOPLogger.NOP_LOGGER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h2><p><strong>抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口</strong>。</p><p>抽象工厂是面向产品族的，而工厂方法是面向产品等级结构的，这是两者的主要区别。</p><p>适用场景：</p><ul><li>客户端不依赖于产品类实例如何被创建、实现等细节</li><li>强调一系列相关的产品对象（属于同一产品族）一起使用创建对象时需要大量重复的代码</li><li>提供一个产品类的库，所有的产品以同样的接口出现</li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：具体产品在应用层代码隔离，无须关心创建细节；将一个系列的产品族统一到一起创建。</p><p>缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。</p><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于一个课程，既包含课程视频，也包含课程笔记：</p><p><img src="http://blog.designpattern.nanwulife.com/abstractfactory.png" alt="UML"></p><p>抽象视频产品<code>Video</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体视频产品<code>JavaVideo</code>、<code>PythonVideo</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVideo</span> <span class="keyword">extends</span> <span class="title">Video</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Java课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonVideo</span> <span class="keyword">extends</span>  <span class="title">Video</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"录制Python课程视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，也有抽象笔记产品<code>Article</code>和具体笔记产品<code>JavaArticle</code>、<code>PythonArticle</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Artical</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaArticle</span> <span class="keyword">extends</span> <span class="title">Artical</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"编写Java课程手记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonArticle</span> <span class="keyword">extends</span>  <span class="title">Artical</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"编写Python课程手记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>课程的抽象工厂<code>CourseFactory</code>，生产视频和笔记两类产品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Video <span class="title">getVideo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Artical <span class="title">getArtical</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java课程的具体工厂<code>JavaCourseFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourseFactory</span> <span class="keyword">implements</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Video <span class="title">getVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Artical <span class="title">getArtical</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JavaArticle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Python课程的具体工厂<code>PythonCourseFactory</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourseFactory</span> <span class="keyword">implements</span> <span class="title">CourseFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Video <span class="title">getVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PythonVideo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Artical <span class="title">getArtical</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PythonArticle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端<code>Test</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CourseFactory courseFactory = <span class="keyword">new</span> JavaCourseFactory();</span><br><span class="line">        Video video = courseFactory.getVideo();</span><br><span class="line">        Artical artical = courseFactory.getArtical();</span><br><span class="line">        video.produce();</span><br><span class="line">        artical.produce();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，每一个具体工厂中都只会生产同一产品族下的产品。如果要扩展新的产品族，例如要添加一个算法课程，则添加一个<code>AlgorithmCourseFactory</code>工厂类即可，十分简单；但是如果要增加新的产品等级，比如在课程中除了视频和笔记外还要添加源码，那么就要修改抽象工厂中的实现，并且每一个具体工厂的实现也都要修改，抽象工厂模式在这种场景下就不适用了。</p><p><img src="http://blog.designpattern.nanwulife.com/abstractfactory2.png" alt="UML"></p><h3 id="Connection中的应用"><a href="#Connection中的应用" class="headerlink" title="Connection中的应用"></a>Connection中的应用</h3><p><code>java.sql.Connection</code>接口定义了与指定数据库的连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Connection</span>  <span class="keyword">extends</span> <span class="title">Wrapper</span>, <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="function">Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="function">PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>Statement</code>、<code>PreparedStatement</code>等也都为接口。我们查看<code>Connection</code>的其中一个实现类<code>ConnectionImpl</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionImpl</span> <span class="keyword">extends</span> <span class="title">ConnectionPropertiesImpl</span> <span class="keyword">implements</span> <span class="title">Connection</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createStatement(<span class="number">1003</span>, <span class="number">1007</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">(<span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.checkClosed();</span><br><span class="line">        StatementImpl stmt = <span class="keyword">new</span> StatementImpl(<span class="keyword">this</span>, <span class="keyword">this</span>.database);</span><br><span class="line">        stmt.setResultSetType(resultSetType);</span><br><span class="line">        stmt.setResultSetConcurrency(resultSetConcurrency);</span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>createStatement</code>方法中实例化了<code>Statement</code>接口的一个具体实现类，也就是<code>com.mysql.jdbc.StatementImpl</code>。</p><p>由此可见，在这个场景中<code>Connection</code>相当于一个抽象工厂，而<code>ConnectionImpl</code>是一个具体工厂，抽象产品为<code>Statement</code>，具体产品为<code>StatementImpl</code>。在这个例子中，mysql产品族的工厂只会生产mysql的Statement、PreparedStatement等产品。</p><h2 id="建造者（Builder）"><a href="#建造者（Builder）" class="headerlink" title="建造者（Builder）"></a>建造者（Builder）</h2><p><strong>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</strong></p><p>工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象。</p><p>适用场景：</p><ul><li>如果一个对象有非常复杂的内部结构（很多属性）</li><li>想把复杂对象的创建和使用分离</li></ul><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：封装性好，创建和使用分离；扩展性好、建造类之间独立、一定程度上解耦。</p><p>缺点：产生多余的Builder对象；产品内部发生变化，建造者都要修改，成本较大。</p><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>CourseBuilder</code>作为抽象建造者类，<code>CourseActualBuilder</code>作为具体建造者类，<code>Coach</code>作为教练类根据传入的建造者类安排复杂对象的建造次序（非必需），而<code>Course</code>作为产品类。</p><p><img src="http://blog.designpattern.nanwulife.com/builder2.png" alt="UML"></p><p>抽象建造者<code>CourseBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseName</span><span class="params">(String courseName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCoursePPT</span><span class="params">(String coursePPT)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseVideo</span><span class="params">(String courseVideo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseArticle</span><span class="params">(String courseArticle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseQA</span><span class="params">(String courseQA)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Course <span class="title">makeCourse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体建造者<code>CourseActualBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseActualBuilder</span> <span class="keyword">extends</span> <span class="title">CourseBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Course course = <span class="keyword">new</span> Course();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCourseName</span><span class="params">(String courseName)</span> </span>&#123;</span><br><span class="line">        course.setCourseName(courseName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCoursePPT</span><span class="params">(String coursePPT)</span> </span>&#123;</span><br><span class="line">        course.setCoursePPT(coursePPT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCourseVideo</span><span class="params">(String courseVideo)</span> </span>&#123;</span><br><span class="line">        course.setCourseVideo(courseVideo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCourseArticle</span><span class="params">(String courseArticle)</span> </span>&#123;</span><br><span class="line">        course.setCourseArticle(courseArticle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCourseQA</span><span class="params">(String courseQA)</span> </span>&#123;</span><br><span class="line">        course.setCourseQA(courseQA);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Course <span class="title">makeCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>教练<code>Coach</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseBuilder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseName</span><span class="params">(String courseName)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCoursePPT</span><span class="params">(String coursePPT)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseVideo</span><span class="params">(String courseVideo)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseArticle</span><span class="params">(String courseArticle)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCourseQA</span><span class="params">(String courseQA)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Course <span class="title">makeCourse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>产品<code>Course</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line">    <span class="keyword">private</span> String coursePPT;</span><br><span class="line">    <span class="keyword">private</span> String courseVideo;</span><br><span class="line">    <span class="keyword">private</span> String courseArticle;</span><br><span class="line">    <span class="keyword">private</span> String courseQA;    <span class="comment">//question &amp; answer</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> courseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseName</span><span class="params">(String courseName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseName = courseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoursePPT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coursePPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCoursePPT</span><span class="params">(String coursePPT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coursePPT = coursePPT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> courseVideo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseVideo</span><span class="params">(String courseVideo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseVideo = courseVideo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseArticle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> courseArticle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseArticle</span><span class="params">(String courseArticle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseArticle = courseArticle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseQA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> courseQA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseQA</span><span class="params">(String courseQA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseQA = courseQA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Course&#123;"</span> +</span><br><span class="line">                <span class="string">"courseName='"</span> + courseName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", coursePPT='"</span> + coursePPT + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", courseVideo='"</span> + courseVideo + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", courseArticle='"</span> + courseArticle + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", courseQA='"</span> + courseQA + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端<code>Test</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CourseBuilder courseBuilder = <span class="keyword">new</span> CourseActualBuilder();</span><br><span class="line">        Coach coach = <span class="keyword">new</span> Coach();</span><br><span class="line">        coach.setCourseBuilder(courseBuilder);</span><br><span class="line">        Course course = coach.makeCourse(<span class="string">"Java设计模式"</span>, <span class="string">"Java设计模式PPT"</span>,</span><br><span class="line">                <span class="string">"Java设计模式视频"</span>, <span class="string">"Java设计模式笔记"</span>, <span class="string">"Java设计模式问答"</span>);</span><br><span class="line">        System.out.println(course);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端创建了一个建造者和一个教练，并将这个建造者作为参数传给教练，之后直接通过教练进行产品的创建，而对客户端隐藏了具体的创建细节。在教练内部，实际上是通过建造者一步步构造出复杂的产品的。</p><p><img src="http://blog.designpattern.nanwulife.com/builder.png" alt="UML"></p><p>我们对以上的场景做进一步演化，省略了教练类，并且将建造者放在产品类的内部。这种做法在实际场景中更为常见，利于维护与扩展，并且支持链式调用。</p><p>产品类<code>Course</code>以及作为建造者的内部类<code>CourseBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line">    <span class="keyword">private</span> String coursePPT;</span><br><span class="line">    <span class="keyword">private</span> String courseVideo;</span><br><span class="line">    <span class="keyword">private</span> String courseArticle;</span><br><span class="line">    <span class="keyword">private</span> String courseQA;    <span class="comment">//question &amp; answer</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(CourseBuilder courseBuilder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseName = courseBuilder.courseName;</span><br><span class="line">        <span class="keyword">this</span>.coursePPT = courseBuilder.coursePPT;</span><br><span class="line">        <span class="keyword">this</span>.courseVideo = courseBuilder.courseVideo;</span><br><span class="line">        <span class="keyword">this</span>.courseArticle = courseBuilder.courseArticle;</span><br><span class="line">        <span class="keyword">this</span>.courseQA = courseBuilder.courseQA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Course&#123;"</span> +</span><br><span class="line">                <span class="string">"courseName='"</span> + courseName + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", coursePPT='"</span> + coursePPT + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", courseVideo='"</span> + courseVideo + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", courseArticle='"</span> + courseArticle + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", courseQA='"</span> + courseQA + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseBuilder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String courseName;</span><br><span class="line">        <span class="keyword">private</span> String coursePPT;</span><br><span class="line">        <span class="keyword">private</span> String courseVideo;</span><br><span class="line">        <span class="keyword">private</span> String courseArticle;</span><br><span class="line">        <span class="keyword">private</span> String courseQA;    <span class="comment">//question &amp; answer</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">buildCourseName</span><span class="params">(String courseName)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.courseName = courseName;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">buildCoursePPT</span><span class="params">(String coursePPT)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.coursePPT = coursePPT;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">buildCourseVideo</span><span class="params">(String courseVideo)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.courseVideo = courseVideo;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">buildCourseArticle</span><span class="params">(String courseArticle)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.courseArticle = courseArticle;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> CourseBuilder <span class="title">buildCourseQA</span><span class="params">(String courseQA)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.courseQA = courseQA;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Course <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Course(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CourseBuilder</code>中的每一个构建方法都返回对象自身，使得其支持链式调用，而<code>build()</code>方法将建造者作为参数传给产品类的构造函数，其根据建造者初始化产品各属性值，并将构建完毕的产品返回。</p><p>客户端<code>Test</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course.CourseBuilder().buildCourseName(<span class="string">"Java设计模式"</span>).buildCoursePPT(<span class="string">"Java设计模式PPT"</span>).</span><br><span class="line">                buildCourseVideo(<span class="string">"Java设计模式视频"</span>).build();</span><br><span class="line">        System.out.println(course);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，演进之后的建造过程更为简洁明了。</p><p><img src="http://blog.designpattern.nanwulife.com/builder3.png" alt="UML"></p><h3 id="StringBuilder中的应用"><a href="#StringBuilder中的应用" class="headerlink" title="StringBuilder中的应用"></a>StringBuilder中的应用</h3><p><code>Java.util.StringBuilder</code>类下的<code>append</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(sb);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(s);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(s, start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看出，这里使用了建造者模式，<code>append</code>方法总是返回建造者自身。<code>StringBuilder</code>既担任建造者，又担任产品，而建造方法的实现由父类<code>AbstractStringBuilder</code>完成。</p><p><code>StringBuffer</code>的实现与上面类似，区别在于<code>StringBuffer</code>中的<code>append</code>方法加了<code>synchronized</code>关键字，因而是线程安全的。</p><h3 id="mybatis中的应用"><a href="#mybatis中的应用" class="headerlink" title="mybatis中的应用"></a>mybatis中的应用</h3><p>查看<code>org.apache.ibatis.session</code>包下的<code>SqlSessionFactoryBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlSessionFactoryBuilder</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.build((Reader)reader, (String)<span class="keyword">null</span>, (Properties)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.build((Reader)reader, environment, (Properties)<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, Properties properties)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.build((Reader)reader, (String)<span class="keyword">null</span>, properties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">        SqlSessionFactory var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(reader, environment, properties);</span><br><span class="line">            var5 = <span class="keyword">this</span>.build(parser.parse());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var14) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, var14);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ErrorContext.instance().reset();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var13) &#123;</span><br><span class="line">                ;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里面两个参数的<code>build</code>方法大多直接调用后面三个参数的<code>build</code>方法，返回值都为<code>SqlSessionFactory</code>，而这个方法中又有另一个建造者<code>XMLConfigBuilder</code>构建出一个<code>Configuration</code>对象，我们查看<code>XMLConfigBuilder</code>中的相关方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parsed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.parsed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.parseConfiguration(<span class="keyword">this</span>.parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.configuration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Properties settings = <span class="keyword">this</span>.settingsAsPropertiess(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">        <span class="keyword">this</span>.propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">        <span class="keyword">this</span>.loadCustomVfs(settings);</span><br><span class="line">        <span class="keyword">this</span>.typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">        <span class="keyword">this</span>.pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">        <span class="keyword">this</span>.objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">        <span class="keyword">this</span>.objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">        <span class="keyword">this</span>.reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">        <span class="keyword">this</span>.settingsElement(settings);</span><br><span class="line">        <span class="keyword">this</span>.environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">        <span class="keyword">this</span>.databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">        <span class="keyword">this</span>.typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">        <span class="keyword">this</span>.mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception var3) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + var3, var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建出一个<code>Configuration</code>对象的过程都在<code>parseConfiguration</code>方法中，而<code>parse</code>方法主要用来标记是否已经parse过并且返回构建好的<code>Configuration</code>对象。</p><h2 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h2><p><strong>保证一个类仅有一个实例，并提供一个全局访问点</strong></p><p>适用场景：想确保任何情况下都绝对只有一个实例。</p><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：在内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问。</p><p>缺点：可扩展性较差。</p><h3 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h3><ul><li>私有构造器</li><li>线程安全</li><li>延迟加载</li><li>序列化和反序列化</li><li>反射</li></ul><h3 id="懒汉式实现"><a href="#懒汉式实现" class="headerlink" title="懒汉式实现"></a>懒汉式实现</h3><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><p>以下实现中延迟了lazySingleton的实例化，因此如果没有使用该类，那么就不会实例化lazySingleton，从而节约了资源。</p><p>但这种实现是线程不安全的，在多线程的环境下多个线程有可能同时判断<code>if(lazySingleton == null)</code>为<code>true</code>而进行实例化，导致多次实例化lazySingleton。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton lazySingleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazySingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><p>要想其变为线程安全的，第一种方式是在<code>getInstance()</code>方法加上<code>synchronized</code>关键字，使这个方法变为同步方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(lazySingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">        lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这个方法是静态方法，因此这个锁将锁住这个类，等效于以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="keyword">synchronized</span> (LazySingleton.class)&#123;</span><br><span class="line">     <span class="keyword">if</span>(lazySingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">         lazySingleton = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lazySingleton;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，虽然解决了懒汉式在多线程环境下的同步问题，但由于同步锁消耗的资源较多，且锁的范围较大，对性能有一定影响，因此还需要进行演进。</p><h4 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h4><p>当lazyDoubleCheckSingleton就算没有被实例化时，<code>synchronized</code>关键字也保证了不会出现同步问题，例如，如果两个线程同时判断第一个<code>if(lazyDoubleCheckSingleton == null)</code>为<code>true</code>，其中一个线程会进入到第二个<code>if(lazyDoubleCheckSingleton == null)</code>并开始实例化lazyDoubleCheckSingleton，而另一个线程则被阻塞直到前一个进程释放锁。一旦前一个线程实例化完并释放锁，被阻塞的线程将进入第二个<code>if(lazyDoubleCheckSingleton == null)</code>且判断为<code>false</code>。之后，由于lazyDoubleCheckSingleton已经被实例化过，再有线程调用此方法都会在第一个<code>if(lazyDoubleCheckSingleton == null)</code>就判断为<code>false</code>，不会再进行加锁操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lazyDoubleCheckSingleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyDoubleCheckSingleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lazyDoubleCheckSingleton = <span class="keyword">new</span> LazyDoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyDoubleCheckSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现依然存在问题，对于<code>lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();</code>这一行代码其实是分为以下三步执行的：</p><ol><li>分配内存给这个对象</li><li>初始化对象</li><li>设置lazyDoubleCheckSingleton指向刚分配的内存地址</li></ol><p>但是JVM为了优化指令，提高程序运行效率，会进行指令重排序，指令顺序有可能由1-&gt;2-&gt;3变为1-&gt;3-&gt;2，这在单线程下不会出现问题，但是在多线程下会导致一个线程获得还没有被初始化的实例。例如，一个线程已经执行到了<code>lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();</code>这一行，且完成了1-&gt;3这两步，即lazyDoubleCheckSingleton已经不为null，但还没有进行初始化，此时另一个线程在第一个<code>if(lazyDoubleCheckSingleton == null)</code>判断为<code>false</code>后便将还未被初始化的lazyDoubleCheckSingleton返回，从而产生问题。</p><p>要解决指令重排序导致的问题，第一种方式是使用<code>volatile</code>关键字禁止JVM进行指令重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyDoubleCheckSingleton lazyDoubleCheckSingleton = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyDoubleCheckSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>另一种解决指令重排序所导致的问题的方式是使用静态内部类让其它线程看不到这个线程的指令重排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> StaticInnerClassSingleton staticInnerClassSingleton = <span class="keyword">new</span> StaticInnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.staticInnerClassSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当StaticInnerClassSingleton类加载时，静态内部类InnerClass还不会加载进内存，只有调用<code>getInstance()</code>方法使用到了<code>InnerClass.staticInnerClassSingleton</code>时才会加载。在多线程环境下，只有一个线程能获得Class对象的初始化锁，从而加载StaticInnerClassSingleton类，也就是这时候完成staticInnerClassSingleton的实例化，另一个线程此时只能在这个Class对象的初始化锁上等待。因此，由于等待的线程是看不见指令重排序的过程的，所以指令重排的顺序不会有任何影响。</p><h3 id="饿汉式实现"><a href="#饿汉式实现" class="headerlink" title="饿汉式实现"></a>饿汉式实现</h3><p>饿汉式即当类加载的时候就完成实例化，避免了同步问题，但同时也因为没有延迟实例化的特性而导致资源的浪费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码与以下代码等效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> HungrySingleton hungrySingleton;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        hungrySingleton = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单例模式存在的问题"><a href="#单例模式存在的问题" class="headerlink" title="单例模式存在的问题"></a>单例模式存在的问题</h3><h4 id="序列化破坏单例模式"><a href="#序列化破坏单例模式" class="headerlink" title="序列化破坏单例模式"></a>序列化破坏单例模式</h4><p>通过对Singleton的序列化与反序列化得到的对象是一个新的对象，这就破坏了Singleton的单例性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line"></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"singleton_file"</span>));</span><br><span class="line">        oos.writeObject(instance);</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"singleton_file"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        HungrySingleton newInstance = (EnumInstance) ois.readObject();</span><br><span class="line">        </span><br><span class="line">        System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance == newInstance);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之所以会如此，是因为序列化会通过反射调用无参数的构造方法创建一个新的对象。要解决这个问题很简单：只要在Singleton类中定义readResolve即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="反射攻击"><a href="#反射攻击" class="headerlink" title="反射攻击"></a>反射攻击</h4><p>通过反射可以打开Singleton的构造器权限，由此实例化一个新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class objectClass = HungrySingleton.class;</span><br><span class="line">        Class objectClass = LazySingleton.class;</span><br><span class="line">        Constructor constructor = objectClass.getDeclaredConstructor();</span><br><span class="line">        constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        HungrySingleton instance = HungrySingleton.getInstance();</span><br><span class="line">        HungrySingleton newInstance = (HungrySingleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">System.out.println(instance);</span><br><span class="line">        System.out.println(newInstance);</span><br><span class="line">        System.out.println(instance == newInstance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于饿汉式，由于是在类加载的时候就实例化对象了，因此要解决反射攻击问题，可以在构造器内部加一个判断用来防御，这样当反射调用构造器的时候hungrySingleton已经存在，不会再进行实例化并抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hungrySingleton != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"单例构造器禁止反射调用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于懒汉式，即使加上了上面的防御代码，依然可以通过调整顺序即先使用反射创建实例，再调用<code>getInstance()</code>创建实例来得到不止一个该类的对象。</p><h3 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h3><p>枚举类是实现单例的最佳方式，其在多次序列化再进行反序列化之后不会得到多个实例，也可以防御反射攻击。这部分的处理是由<code>ObjectInputStream</code>和<code>Constructor</code>这两个类实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumInstance &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器实现"><a href="#容器实现" class="headerlink" title="容器实现"></a>容器实现</h3><p>如果系统中单例对象特别多，则可以考虑使用一个容器把所有单例对象统一管理，但是是线程不安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; singletonMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putInstance</span><span class="params">(String key, Object instance)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isNotBlank(key) &amp;&amp; instance != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!singletonMap.containsKey(key))&#123;</span><br><span class="line">                singletonMap.put(key, instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getInstance</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singletonMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Runtime中的应用"><a href="#Runtime中的应用" class="headerlink" title="Runtime中的应用"></a>Runtime中的应用</h3><p>查看<code>java.lang</code>包下的<code>Runtime</code>类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的currentRuntime在类加载的时候就实例化好了，属于饿汉式单例模式。</p><h3 id="Spring中的应用"><a href="#Spring中的应用" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h3><p>查看<code>org.springframework.beans.factory.config</code>包下的<code>AbstractFactoryBean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isSingleton()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : <span class="keyword">this</span>.getEarlySingletonInstance();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.createInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">getEarlySingletonInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] ifcs = <span class="keyword">this</span>.getEarlySingletonInterfaces();</span><br><span class="line">        <span class="keyword">if</span> (ifcs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> FactoryBeanNotInitializedException(<span class="keyword">this</span>.getClass().getName() + <span class="string">" does not support circular references"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.earlySingletonInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.earlySingletonInstance = Proxy.newProxyInstance(<span class="keyword">this</span>.beanClassLoader, ifcs, <span class="keyword">new</span> AbstractFactoryBean.EarlySingletonInvocationHandler());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.earlySingletonInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>getObject()</code>方法中，先判断这个对象是否为单例的，如果不是则直接创建；如果是单例的，那么判断是否被初始化过，如果被初始化了则直接返回，没有的话则调用<code>getEarlySingletonInstance()</code>方法获取早期的单例对象，如果早期的单例对象不存在，则通过代理来获取。</p><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="外观（Facade）"><a href="#外观（Facade）" class="headerlink" title="外观（Facade）"></a>外观（Facade）</h2><p>外观模式又叫门面模式，<strong>提供了一个统一的接口，用来访问子系统中的一群接口。</strong></p><p>外观模式定义了一个高层接口，让子系统更容易使用。</p><p>适用场景：</p><ul><li>子系统越来越复杂，增加外观模式提供简单调用接口</li><li>构建多层系统接口，利用外观对象作为每层的入口，简化层间调用</li></ul><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：简化了调用过程，无需了解子系统，防止带来风险；减少系统依赖、松散耦合；更好的划分访问层次；符合迪米特法则，即最少知道原则。</p><p>缺点：增加子系统、扩展子系统行为容易引入风险，不符合开闭原则。</p><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p>我们考虑一个用积分兑换礼物的场景，积分兑换礼物需要校验积分是否符合资格、扣减积分以及对接物流系统三个模块，这三个模块也可以理解为三个子系统。</p><p>校验资格子系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QualifyService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(PointsGift pointsGift)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"校验"</span> + pointsGift.getName() + <span class="string">" 积分资格通过，库存通过"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扣减积分子系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointsPaymentService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pay</span><span class="params">(PointsGift pointsGift)</span></span>&#123;</span><br><span class="line">        <span class="comment">//扣减积分</span></span><br><span class="line">        System.out.println(<span class="string">"支付"</span> + pointsGift.getName() + <span class="string">" 积分成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对接物流系统的子系统：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShippingService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">shipGift</span><span class="params">(PointsGift pointsGift)</span></span>&#123;</span><br><span class="line">        <span class="comment">//物流系统的对接逻辑</span></span><br><span class="line">        System.out.println(pointsGift.getName() + <span class="string">"进入物流系统"</span>);</span><br><span class="line">        String shippingOrderNo = <span class="string">"666"</span>;</span><br><span class="line">        <span class="keyword">return</span> shippingOrderNo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>积分礼物类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointsGift</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointsGift</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>外观类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftExchangeService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> QualifyService qualifyService = <span class="keyword">new</span> QualifyService();</span><br><span class="line">    <span class="keyword">private</span> PointsPaymentService pointsPaymentService = <span class="keyword">new</span> PointsPaymentService();</span><br><span class="line">    <span class="keyword">private</span> ShippingService shippingService = <span class="keyword">new</span> ShippingService();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QualifyService <span class="title">getQualifyService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> qualifyService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQualifyService</span><span class="params">(QualifyService qualifyService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.qualifyService = qualifyService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PointsPaymentService <span class="title">getPointsPaymentService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pointsPaymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPointsPaymentService</span><span class="params">(PointsPaymentService pointsPaymentService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pointsPaymentService = pointsPaymentService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ShippingService <span class="title">getShippingService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> shippingService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setShippingService</span><span class="params">(ShippingService shippingService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.shippingService = shippingService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giftExchange</span><span class="params">(PointsGift pointsGift)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(qualifyService.isAvailable(pointsGift))&#123;</span><br><span class="line">            <span class="comment">//资格校验通过</span></span><br><span class="line">            <span class="keyword">if</span>(pointsPaymentService.pay(pointsGift))&#123;</span><br><span class="line">                <span class="comment">//如果支付积分成功</span></span><br><span class="line">                String shippingOrderNo = shippingService.shipGift(pointsGift);</span><br><span class="line">                System.out.println(<span class="string">"物流系统下单成功，订单号是："</span>+shippingOrderNo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PointsGift pointsGift = <span class="keyword">new</span> PointsGift(<span class="string">"衣服"</span>);</span><br><span class="line">        GiftExchangeService giftExchangeService = <span class="keyword">new</span> GiftExchangeService();</span><br><span class="line">        giftExchangeService.giftExchange(pointsGift);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">校验衣服 积分资格通过，库存通过</span><br><span class="line">支付衣服 积分成功</span><br><span class="line">衣服进入物流系统</span><br><span class="line">物流系统下单成功，订单号是：666</span><br></pre></td></tr></table></figure><p>客户端创建一个衣服作为积分商品，然后使用积分兑换系统来完成积分兑换，这个积分兑换系统作为一个外观类整合了各个子系统，而客户端无需知道具体的子系统。</p><p><img src="http://blog.designpattern.nanwulife.com/Package%20facade.png" alt="外观类"></p><h3 id="Spring中的应用-1"><a href="#Spring中的应用-1" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h3><p>查看<code>org.springframework.jdbc.support</code>下的<code>JdbcUtils</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(Connection con)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">con.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">logger.debug(<span class="string">"Could not close JDBC Connection"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// We don't trust the JDBC driver: It might throw RuntimeException or Error.</span></span><br><span class="line">logger.debug(<span class="string">"Unexpected exception on closing JDBC Connection"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getResultSetValue</span><span class="params">(ResultSet rs, <span class="keyword">int</span> index, Class&lt;?&gt; requiredType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (requiredType == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> getResultSetValue(rs, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object value = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> wasNullCheck = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Explicitly extract typed value, as far as possible.</span></span><br><span class="line"><span class="keyword">if</span> (String.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getString(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">boolean</span>.class.equals(requiredType) || Boolean.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getBoolean(index);</span><br><span class="line">wasNullCheck = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">byte</span>.class.equals(requiredType) || Byte.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getByte(index);</span><br><span class="line">wasNullCheck = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">short</span>.class.equals(requiredType) || Short.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getShort(index);</span><br><span class="line">wasNullCheck = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">int</span>.class.equals(requiredType) || Integer.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getInt(index);</span><br><span class="line">wasNullCheck = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">long</span>.class.equals(requiredType) || Long.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getLong(index);</span><br><span class="line">wasNullCheck = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">float</span>.class.equals(requiredType) || Float.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getFloat(index);</span><br><span class="line">wasNullCheck = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">double</span>.class.equals(requiredType) || Double.class.equals(requiredType) ||</span><br><span class="line">Number.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getDouble(index);</span><br><span class="line">wasNullCheck = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">byte</span>[].class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getBytes(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (java.sql.Date.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getDate(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (java.sql.Time.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getTime(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getTimestamp(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (BigDecimal.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getBigDecimal(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Blob.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getBlob(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Clob.class.equals(requiredType)) &#123;</span><br><span class="line">value = rs.getClob(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Some unknown type desired -&gt; rely on getObject.</span></span><br><span class="line">value = getResultSetValue(rs, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Perform was-null check if demanded (for results that the</span></span><br><span class="line"><span class="comment">// JDBC driver returns as primitives).</span></span><br><span class="line"><span class="keyword">if</span> (wasNullCheck &amp;&amp; value != <span class="keyword">null</span> &amp;&amp; rs.wasNull()) &#123;</span><br><span class="line">value = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，该工具类主要是对jdbc的封装，向外提供一个隐藏了具体实现细节的接口，对访问屏蔽复杂的子系统调用。</p><h3 id="SLF4J中的应用"><a href="#SLF4J中的应用" class="headerlink" title="SLF4J中的应用"></a>SLF4J中的应用</h3><p>SLF4J是简单的日志外观模式框架，抽象了各种日志框架例如Logback、Log4j、Commons-logging和JDK自带的logging实现接口。它使得用户可以在部署时使用自己想要的日志框架。</p><p>SLF4J没有替代任何日志框架，它仅仅是标准日志框架的外观模式。如果在类路径下除了SLF4J再没有任何日志框架，那么默认状态是在控制台输出日志。</p><h2 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h2><p><strong>将一个类的接口转换成客户期望的另一个接口。</strong></p><p>适配器模式使原本接口不兼容的类可以一起工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是组合关系，使用的是委托机制；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p><p>适用场景：</p><ul><li>已经存在的类，它的方法和需求不匹配时（方法结果相同或相似）。</li><li>不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造功能类似而接口不相同情况下的解决方案。</li></ul><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：能提高类的透明性和复用；目标类和适配器类解耦，提高程序扩展性；符合开闭原则。</p><p>缺点：增加了系统的复杂性；增加系统代码可读的难度。</p><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>被适配者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被适配者的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标接口实现（非必需的，只是待会用来做对比）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"concreteTarget目标方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器类，既实现了目标接口又继承了被适配者类，因此直接在实现的<code>request()</code>中调用父类的<code>adapteeRequest()</code>方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target target = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">        target.request();</span><br><span class="line"></span><br><span class="line">        Target adapterTarget = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapterTarget.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过适配器，我们就将被适配者类<code>Adaptee</code>的<code>adapteeRequest()</code>方法适配成了目标接口<code>Target</code>的<code>request()</code>方法。</p><p><img src="http://blog.designpattern.nanwulife.com/Package%20classadapter.png" alt="adapter"></p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>在对象适配器模式中，被适配者类<code>Adaptee</code>、目标接口与实现类<code>Target</code> <code>ConcreteTarget</code>、客户端类<code>Test</code> 都不需要改变，唯一需要改变的就是适配器类<code>Adapter</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，对象适配器与类适配器不同之处在于类适配器是通过继承来完成适配，而对象适配器则组合被适配者并将请求委托给被适配者来完成。</p><p><img src="http://blog.designpattern.nanwulife.com/Package%20objectadapter.png" alt="adapter"></p><h4 id="变压器的例子"><a href="#变压器的例子" class="headerlink" title="变压器的例子"></a>变压器的例子</h4><p>这里考虑一个生活中常见的变压器的场景，我们把220V交流电压适配成5V直流电压，其中220V交流电压就是被适配者类，而5V直流电压则是目标接口，我们需要一个适配器来完成这个变压操作。</p><p>被适配者类（220V交流电压）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"输出交流电"</span> + output + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标接口（5V直流电压）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器类，这里使用的是对象适配器模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PowerAdapter</span> <span class="keyword">implements</span> <span class="title">DC5</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AC220 ac220 = <span class="keyword">new</span> AC220();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将220V交流电压作为输入电压</span></span><br><span class="line">        <span class="keyword">int</span> adapterInput = ac220.outputAC220V();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟变压器，得到5V直流电压</span></span><br><span class="line">        <span class="keyword">int</span> adapterOutput = adapterInput / <span class="number">44</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"使用PowerAdapter输入AC："</span> + adapterInput +<span class="string">"V "</span> + <span class="string">"输出DC："</span> + adapterOutput + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">return</span> adapterOutput;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DC5 dc5 = <span class="keyword">new</span> PowerAdapter();</span><br><span class="line">        dc5.outputDC5V();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过适配器将220V交流电压转换成了5V直流电压，此时输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输出交流电220V</span><br><span class="line">使用PowerAdapter输入AC：220V 输出DC：5V</span><br></pre></td></tr></table></figure></p><h3 id="Spring-AOP中的应用"><a href="#Spring-AOP中的应用" class="headerlink" title="Spring AOP中的应用"></a>Spring AOP中的应用</h3><p>在Spring的AOP中，使用的<code>Advice (通知)</code>来增强被代理类的功能。<code>Advice</code>的类型有：<code>MethodBeforeAdvice</code>、<code>AfterReturningAdvice</code>、<code>ThrowsAdvice</code>，而每个类型的<code>Advice</code>都有对应的拦截器<code>MethodBeforeAdviceInterceptor</code>、<code>AfterReturningAdviceInterceptor</code>、<code>ThrowsAdviceInterceptor</code>。</p><p>Spring需要将每个<code>Advice</code>都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 <code>Advice</code>进行转换。</p><p>三个适配者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodBeforeAdvice</span> <span class="keyword">extends</span> <span class="title">BeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">before</span><span class="params">(Method var1, Object[] var2, @Nullable Object var3)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AfterReturningAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">(@Nullable Object var1, Method var2, Object[] var3, @Nullable Object var4)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ThrowsAdvice</span> <span class="keyword">extends</span> <span class="title">AfterAdvice</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器接口，其中<code>supportsAdvice</code>方法判断<code>Advice</code>类型是否匹配，另一个是创建对应的拦截器的工厂方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AdvisorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice var1)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个适配器类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodBeforeAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (advice <span class="keyword">instanceof</span> MethodBeforeAdvice);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MethodBeforeAdviceInterceptor(advice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AfterReturningAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (advice <span class="keyword">instanceof</span> AfterReturningAdvice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line">AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AfterReturningAdviceInterceptor(advice);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThrowsAdviceAdapter</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapter</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsAdvice</span><span class="params">(Advice advice)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (advice <span class="keyword">instanceof</span> ThrowsAdvice);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodInterceptor <span class="title">getInterceptor</span><span class="params">(Advisor advisor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ThrowsAdviceInterceptor(advisor.getAdvice());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdvisorAdapterRegistry</span> <span class="keyword">implements</span> <span class="title">AdvisorAdapterRegistry</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdvisorAdapter&gt; adapters = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAdvisorAdapterRegistry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里注册了适配器</span></span><br><span class="line">        <span class="keyword">this</span>.registerAdvisorAdapter(<span class="keyword">new</span> MethodBeforeAdviceAdapter());</span><br><span class="line">        <span class="keyword">this</span>.registerAdvisorAdapter(<span class="keyword">new</span> AfterReturningAdviceAdapter());</span><br><span class="line">        <span class="keyword">this</span>.registerAdvisorAdapter(<span class="keyword">new</span> ThrowsAdviceAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> MethodInterceptor[] getInterceptors(Advisor advisor) <span class="keyword">throws</span> UnknownAdviceTypeException &#123;</span><br><span class="line">        List&lt;MethodInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList(<span class="number">3</span>);</span><br><span class="line">        Advice advice = advisor.getAdvice();</span><br><span class="line">        <span class="keyword">if</span> (advice <span class="keyword">instanceof</span> MethodInterceptor) &#123;</span><br><span class="line">            interceptors.add((MethodInterceptor)advice);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Iterator var4 = <span class="keyword">this</span>.adapters.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">            AdvisorAdapter adapter = (AdvisorAdapter)var4.next();</span><br><span class="line">            <span class="keyword">if</span> (adapter.supportsAdvice(advice)) &#123;   <span class="comment">// 这里调用适配器方法</span></span><br><span class="line">                interceptors.add(adapter.getInterceptor(advisor));  <span class="comment">// 这里调用适配器方法</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interceptors.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnknownAdviceTypeException(advisor.getAdvice());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (MethodInterceptor[])interceptors.toArray(<span class="keyword">new</span> MethodInterceptor[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码在while循环里逐个取出注册的适配器，调用<code>supportsAdvice()</code>方法来判断<code>Advice</code>对应的类型，然后调用 getInterceptor() 创建对应类型的拦截器。</p><p><img src="http://blog.designpattern.nanwulife.com/20180919_2217.jpg" alt="advice"></p><p>这里应该属于对象适配器模式，不过这里的<code>Advice</code>对象是从外部传进来，而不是成员属性。</p><h2 id="组合（Composite）"><a href="#组合（Composite）" class="headerlink" title="组合（Composite）"></a>组合（Composite）</h2><p><strong>将对象组合成树形结构来表示“整体-部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。</strong></p><p>适用场景：</p><ul><li>希望客户端可以忽略组合对象与单个对象的差异时。</li><li>处理一个树形结构时。</li></ul><h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：客户端不必关心处理的是单个对象还是整个组合结构，简化了客户端代码；增加新的构件无须对现有类库进行任何修改，符合开闭原则。</p><p>缺点：限制类型时会较为复杂；使设计变得更加抽象。</p><h3 id="应用场景-6"><a href="#应用场景-6" class="headerlink" title="应用场景"></a>应用场景</h3><p>一个在线学习网站下有许多目录以及学习视频，而目录下可能还会存在子目录，这里就可以使用组合模式。</p><p>抽象构件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CatalogComponent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CatalogComponent catalogComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持添加操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CatalogComponent catalogComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持删除操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(CatalogComponent catalogComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持获取名称操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(CatalogComponent catalogComponent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持获取价格操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"不支持打印操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>叶子构件（课程视频）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword">extends</span> <span class="title">CatalogComponent</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(CatalogComponent catalogComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">(CatalogComponent catalogComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Course Name: "</span> + name + <span class="string">" Price: "</span> + price);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>容器构件（课程目录）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CourseCatalog</span> <span class="keyword">extends</span>  <span class="title">CatalogComponent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;CatalogComponent&gt; items = <span class="keyword">new</span> ArrayList&lt;CatalogComponent&gt;();</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer level;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CourseCatalog</span><span class="params">(String name, Integer level)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">(CatalogComponent catalogComponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(CatalogComponent catalogComponent)</span> </span>&#123;</span><br><span class="line">        items.add(catalogComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(CatalogComponent catalogComponent)</span> </span>&#123;</span><br><span class="line">        items.remove(catalogComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);</span><br><span class="line">        <span class="keyword">for</span>(CatalogComponent catalogComponent : items)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.level != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.level; i++)</span><br><span class="line">                    System.out.print(<span class="string">"  "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            catalogComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CatalogComponent linuxCourse = <span class="keyword">new</span> Course(<span class="string">"linux课程"</span>, <span class="number">11</span>);</span><br><span class="line">        CatalogComponent windowsCourse = <span class="keyword">new</span> Course(<span class="string">"Windows课程"</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        CatalogComponent javaCourseCatalog = <span class="keyword">new</span> CourseCatalog(<span class="string">"Java课程目录"</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        CatalogComponent mallCourse1 = <span class="keyword">new</span> Course(<span class="string">"Java电商一期"</span>, <span class="number">55</span>);</span><br><span class="line">        CatalogComponent mallCourse2 = <span class="keyword">new</span> Course(<span class="string">"Java电商二期"</span>, <span class="number">66</span>);</span><br><span class="line">        CatalogComponent designPattern = <span class="keyword">new</span> Course(<span class="string">"Java设计模式"</span>, <span class="number">77</span>);</span><br><span class="line"></span><br><span class="line">        javaCourseCatalog.add(mallCourse1);</span><br><span class="line">        javaCourseCatalog.add(mallCourse2);</span><br><span class="line">        javaCourseCatalog.add(designPattern);</span><br><span class="line"></span><br><span class="line">        CatalogComponent mainCourseCatalog = <span class="keyword">new</span> CourseCatalog(<span class="string">"课程主目录"</span>, <span class="number">1</span>);</span><br><span class="line">        mainCourseCatalog.add(linuxCourse);</span><br><span class="line">        mainCourseCatalog.add(windowsCourse);</span><br><span class="line">        mainCourseCatalog.add(javaCourseCatalog);</span><br><span class="line">        mainCourseCatalog.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。</p><p><img src="http://blog.designpattern.nanwulife.com/Package%20composite.png" alt="compo"></p><h2 id="装饰者（Decorator）"><a href="#装饰者（Decorator）" class="headerlink" title="装饰者（Decorator）"></a>装饰者（Decorator）</h2><p><strong>在不改变原有对象的基础之上，将功能附加到对象上。</strong></p><p>提供了比继承更有弹性的替代方案（扩展原有对象功能）。</p><p>适用场景：</p><ul><li>扩展一个类的功能或给一个类添加附加职责。</li><li>动态的给一个对象添加功能，这些功能可以再动态的撤销。</li></ul><h3 id="优缺点-8"><a href="#优缺点-8" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能；通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果；符合开闭原则。</p><p>缺点：会出现更多的代码，更多的类，增加程序复杂性；动态装饰时、多层装饰时会更复杂。</p><h3 id="应用场景-7"><a href="#应用场景-7" class="headerlink" title="应用场景"></a>应用场景</h3><p>我们考虑一个买煎饼的例子，人们可以自由地选择是否要在煎饼上加鸡蛋或者火腿，每次要加多少个，而总共价格是多少。</p><p>煎饼抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ABattercake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getDesc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>煎饼类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Battercake</span> <span class="keyword">extends</span> <span class="title">ABattercake</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"煎饼"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象装饰类（并不是真正的抽象类，因为这个场景中不需要抽象方法），这个类将抽象煎饼类作为成员属性，并且也继承了抽象煎饼类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDecorator</span> <span class="keyword">extends</span> <span class="title">ABattercake</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ABattercake aBattercake;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractDecorator</span><span class="params">(ABattercake aBattercake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aBattercake = aBattercake;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.aBattercake.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.aBattercake.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加鸡蛋的装饰类，继承了抽象装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EggDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EggDecorator</span><span class="params">(ABattercake aBattercake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aBattercake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">" 加一个鸡蛋"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost()+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加火腿的装饰类，继承了抽象装饰类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SausageDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SausageDecorator</span><span class="params">(ABattercake aBattercake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(aBattercake);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">" 加一根香肠"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost()+<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ABattercake aBattercake;</span><br><span class="line">        aBattercake = <span class="keyword">new</span> Battercake();</span><br><span class="line">        aBattercake = <span class="keyword">new</span> EggDecorator(aBattercake);</span><br><span class="line">        aBattercake = <span class="keyword">new</span> EggDecorator(aBattercake);</span><br><span class="line">        aBattercake = <span class="keyword">new</span> SausageDecorator(aBattercake);</span><br><span class="line"></span><br><span class="line">        System.out.println(aBattercake.getDesc() + <span class="string">" 销售价格："</span> + aBattercake.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠 销售价格：12</span><br></pre></td></tr></table></figure><p>装饰类和具体组件类都继承了抽象组件类。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能，装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。</p><p><img src="http://blog.designpattern.nanwulife.com/Package%20v2.png" alt="装饰者"></p><h3 id="Java-I-O中的应用"><a href="#Java-I-O中的应用" class="headerlink" title="Java I/O中的应用"></a>Java I/O中的应用</h3><p>在Java中应用程序通过输入流（InputStream）的Read方法从源地址处读取字节，然后通过输出流（OutputStream）的Write方法将流写入到目的地址。</p><p>流的来源主要有三种：本地的文件（File）、控制台、通过socket实现的网络通信。</p><p><img src="http://blog.designpattern.nanwulife.com/java-io-flow.png" alt="Java I/O中的应用"></p><p>下面查看其中InputStream的类图，而关于OutputStream、Reader、Writer等都与此类似：</p><p><img src="http://blog.designpattern.nanwulife.com/20180918InputStream.png" alt="InputStream"></p><p>由上图可以看出只要继承了FilterInputStream的类就是装饰者类，可以用于包装其他的流，装饰者类还可以对装饰者和类进行再包装。以下是对其中部分类的简要介绍：</p><table><thead><tr><th>流名称</th><th>简介</th></tr></thead><tbody><tr><td>ByteArrayInputStream</td><td>字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中</td></tr><tr><td>PipedInputStream</td><td>访问管道，主要在线程中使用，一个线程通过管道输出流发送数据，而另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯</td></tr><tr><td>FileInputStream</td><td>访问文件，把一个文件作为 InputStream ，实现对文件的读取操作</td></tr><tr><td>PushBackInputStream</td><td>推回输入流，可以把读取进来的某些数据重新回退到输入流的缓冲区之中</td></tr><tr><td>BufferedInputStream</td><td>带缓冲的输入流一次读很多字节先放到内存中，等缓冲区满的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，因此效率很高</td></tr><tr><td>DataInputStream</td><td>允许应用程序以与机器无关方式从底层输入流中读取基本Java数据类型</td></tr></tbody></table><h3 id="Spring中的应用-2"><a href="#Spring中的应用-2" class="headerlink" title="Spring中的应用"></a>Spring中的应用</h3><p>查看<code>org.springframework.cache.transaction</code>下的<code>TransactionAwareCacheDecorator</code>：</p><p><img src="http://blog.designpattern.nanwulife.com/20180918Cache.png" alt="Cache"></p><p>该类实现了<code>Cache</code>接口，同时将<code>Cache</code>组合到类中成为了成员属性，所以可以大胆猜测<code>TransactionAwareCacheDecorator</code>是一个装饰类，不过这里并没有抽象装饰类，且<code>TransactionAwareCacheDecorator</code>没有子类，这里的装饰类关系并没有Java I/O中的装饰关系那么复杂。</p><p>实际上，Spring cache是对缓存使用的抽象，通过它我们可以在不侵入业务代码的基础上让现有代码即刻支持缓存。通过Spring的<code>TransactionSynchronizationManager</code>将其缓存操作与Spring管理的事务同步，仅在成功事务的提交之后执行实际的缓存操作。</p><h3 id="MyBatis中的应用"><a href="#MyBatis中的应用" class="headerlink" title="MyBatis中的应用"></a>MyBatis中的应用</h3><p>查看包<code>org.apache.ibatis.cache</code>：</p><p><img src="http://blog.designpattern.nanwulife.com/20180918Cache.png" alt="cache"></p><h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><p><strong>代理模式为其它对象提供一种代理，以控制对这个对象的访问</strong>，代理对象在客户端和目标对象之间起到中介的作用。</p><p>我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话， 可以分为两种：静态代理、动态代理。静态代理是由程序员创建或特定工具自动生成源代码，再对其编译，在运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。</p><p>适用场景：</p><ul><li>保护目标对象</li><li>增强目标对象</li></ul><h3 id="优缺点-9"><a href="#优缺点-9" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：能将代理对象与真实被调用的目标对象分离；保护目标对象；增强目标对象。</p><p>缺点：会造成系统设计中类的数目增加；在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢；增加系统的复杂度。</p><h3 id="应用场景-8"><a href="#应用场景-8" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>使用静态代理可以做到在符合开闭原则的情况下对目标对象进行功能扩展，但我们得为每一个服务都创建代理类，工作量太大，不易管理。</p><p>服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyHouseImpl</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我要买房"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyHouseProxy</span> <span class="keyword">implements</span> <span class="title">BuyHouse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BuyHouse buyHouse;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyHouseProxy</span><span class="params">(BuyHouse buyHouse)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyHouse = buyHouse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyHosue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        beforeMethod();</span><br><span class="line">        buyHouse.buyHosue();</span><br><span class="line">        afterMethod();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买房前准备"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买房后装修"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyHouse buyHouse = <span class="keyword">new</span> BuyHouseImpl();</span><br><span class="line">        buyHouse.buyHosue();</span><br><span class="line">        BuyHouseProxy buyHouseProxy = <span class="keyword">new</span> BuyHouseProxy(buyHouse);</span><br><span class="line">        buyHouseProxy.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>在动态代理中我们不再需要手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。</p><p>动态处理器，实现了<code>InvocationHandler</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(<span class="keyword">final</span> Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        beforeMethod();</span><br><span class="line">        Object result = method.invoke(object, args);</span><br><span class="line">        afterMethod();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">beforeMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买房前准备"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">afterMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"买房后装修"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BuyHouse buyHouse = <span class="keyword">new</span> BuyHouseImpl();</span><br><span class="line">        BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(buyHouse .getClass().getClassLoader(), buyHouse.getClass().getInterfaces(), <span class="keyword">new</span> DynamicProxyHandler(buyHouse));</span><br><span class="line">        proxyBuyHouse.buyHosue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>Proxy.newProxyInstance()</code>方法接受三个参数：</p><ul><li><code>ClassLoader loader</code>：指定当前目标对象使用的类加载器，获取加载器的方法是固定的</li><li><code>Class&lt;?&gt;[] interfaces</code>：指定目标对象实现的接口的类型，使用泛型方式确认类型</li><li><code>InvocationHandler</code>：指定动态处理器，执行目标对象的方法时，会触发事件处理器的方法</li></ul><p>动态代理虽然不需要自己手动实现代理类和目标方法，但动态代理目标对象必须有接口，没有接口不能实现JDK版动态代理。</p><h4 id="CGLIB代理"><a href="#CGLIB代理" class="headerlink" title="CGLIB代理"></a>CGLIB代理</h4><p>JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</p><p>CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。</p><h3 id="Spring的代理选择"><a href="#Spring的代理选择" class="headerlink" title="Spring的代理选择"></a>Spring的代理选择</h3><ul><li>当Bean有实现接口时，Spring就会用JDK的动态代理。</li><li>当Bean没有实现接口时，Spring使用CGlib。</li><li>可以强制使用CGLib。</li></ul><h2 id="桥接（Bridge）"><a href="#桥接（Bridge）" class="headerlink" title="桥接（Bridge）"></a>桥接（Bridge）</h2><p><strong>将抽象部分与它的具体实现部分分离，使它们都可以独立地变化。</strong></p><p>通过组合的方式建立两个类之间联系，而不是继承。</p><p>适用场景：</p><ul><li>抽象和具体实现之间增加更多的灵活性。</li><li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。</li><li>不希望使用继承，或因为多层继承导致系统类的个数剧增。</li></ul><h3 id="优缺点-10"><a href="#优缺点-10" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：分离抽象部分及其具体实现部分；提高了系统的可扩展性；符合开闭原则与合成复用原则。</p><p>缺点：增加了系统的设计难度；需要正确地识别出系统中两个独立变化的维度。</p><h3 id="应用场景-9"><a href="#应用场景-9" class="headerlink" title="应用场景"></a>应用场景</h3><p>画图时可以画正方形、长方形、圆形三种形状，而每种形状又可以画白色、灰色、黑色三种颜色，因此我们可以很自然地想出以下的继承关系：</p><p><img src="http://blog.designpattern.nanwulife.com/5IX6B62T02RYYGFSX.png" alt="1"></p><p>对于这种方案，假如我们要添加一个椭圆形状，我们又要增加三种颜色，也就是白椭圆、灰椭圆和黑椭圆。假如我们要添加一个绿色，我们就要增加绿正方形、绿椭圆和绿长方形。每次增加都会增加若干个类（如果增加颜色则会增加形状个数个类，若增加形状则会增加颜色个数个类），这会导致系统类的个数剧增，且不利于系统的扩展。</p><p>对于这种有几个变化维度的场景，我们就可以使用桥接模式来减少系统中的类个数。这里提供两个父类一个是颜色、一个形状，颜色父类和形状父类两个类都包含了相应的子类，然后根据需要对颜色和形状进行组合：</p><p><img src="http://blog.designpattern.nanwulife.com/3YEN8T28SWN5CC6.png" alt="2"></p><p>形状抽象类，将颜色接口设为其成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColor</span><span class="params">(Color color)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体形状类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        color.bepaint(<span class="string">"圆形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        color.bepaint(<span class="string">"长方形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        color.bepaint(<span class="string">"正方形"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bepaint</span><span class="params">(String shape)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体颜色类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">White</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bepaint</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"白色的"</span> + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gray</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bepaint</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"灰色的"</span> + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Black</span> <span class="keyword">implements</span> <span class="title">Color</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bepaint</span><span class="params">(String shape)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"黑色的"</span> + shape);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//白色</span></span><br><span class="line">        Color white = <span class="keyword">new</span> White();</span><br><span class="line">        <span class="comment">//正方形</span></span><br><span class="line">        Shape square = <span class="keyword">new</span> Square();</span><br><span class="line">        <span class="comment">//白色的正方形</span></span><br><span class="line">        square.setColor(white);</span><br><span class="line">        square.draw();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//长方形</span></span><br><span class="line">        Shape rectange = <span class="keyword">new</span> Rectangle();</span><br><span class="line">        rectange.setColor(white);</span><br><span class="line">        rectange.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在实现时要注意，抽象类的方法要调用组合的实现类的方法（如类<code>Square</code>中的<code>color.bepaint(&quot;正方形&quot;)</code>这行代码），这样才能体现出桥接的意义。</p><h3 id="JDBC的应用"><a href="#JDBC的应用" class="headerlink" title="JDBC的应用"></a>JDBC的应用</h3><p>jdbc的类族设计是由sun公司设计了一套接口，再由各个数据库公司实现接口，我们在调用的过程中只需要使用接口去定义，然后在加载Driver的过程中底层代码会给我们选择好接口真正的实现类，以此来实现真正的数据库连接，此后所有的方法，包括获取statement等等，都是由接口声明调用，但是底层返回的是接口实现类。用这种桥接的模式，我们可以很轻松地在不同的数据库连接中进行转化，只需要修改Driver加载的类，如果把加载类的声明放入配置文件中，更是不需要重新去编译，可以很方便地在不同数据库间进行转化。</p><h2 id="享元（Flyweight）"><a href="#享元（Flyweight）" class="headerlink" title="享元（Flyweight）"></a>享元（Flyweight）</h2><p><strong>享元模式提供了减少对象数量从而改善应用所需的对象结构的方式。</strong></p><p>适用场景：</p><ul><li>常常应用于系统底层的开发，以便解决系统的性能问题。</li><li>系统有大量相似对象、需要缓冲池的场景。</li></ul><h3 id="优缺点-11"><a href="#优缺点-11" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率；减少内存之外的其它资源占用（比如创建对象所需的时间）。</p><p>缺点：关注内外部状态以及线程安全问题；使系统的逻辑复杂化。</p><h3 id="应用场景-10"><a href="#应用场景-10" class="headerlink" title="应用场景"></a>应用场景</h3><p>在年底的时候公司的老总、副总等许多高层经常需要将部门经理叫去办公室汇报工作，而汇报的往往都是同样的内容，部门经理没有必要每次汇报前都准备一份全新的相同报告，而可以直接使用之前的报告，在这里可以应用享元模式。</p><p>雇员接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">report</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>部门经理类，在创建部门经理的时候需要指定部门<code>department</code>，这个部门就是外部状态，而职位<code>title</code>是固定设为<code>部门经理</code>的，因此就是内部状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> <span class="keyword">implements</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">report</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(reportContent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String title = <span class="string">"部门经理"</span>;</span><br><span class="line">    <span class="keyword">private</span> String department;</span><br><span class="line">    <span class="keyword">private</span> String reportContent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReportContent</span><span class="params">(String reportContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.reportContent = reportContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Manager</span><span class="params">(String department)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.department = department;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>雇员工厂类，用于创建并管理享元对象。这里使用了一个<code>HashMap</code>作为缓存池，如果某个部门经理没有做过汇报，那么就创建这个部门经理，并且设置汇报内容，然后将其加入到缓存池中。如果以后再叫到了这个部门经理，就直接从缓存池中取出而不必再创建一遍了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Employee&gt; EMPLOYEE_MAP = <span class="keyword">new</span> HashMap&lt;String, Employee&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Employee <span class="title">getManager</span><span class="params">(String department)</span></span>&#123;</span><br><span class="line">        Manager manager = (Manager) EMPLOYEE_MAP.get(department);</span><br><span class="line">        <span class="keyword">if</span>(manager == <span class="keyword">null</span>)&#123;</span><br><span class="line">            manager = <span class="keyword">new</span> Manager(department);</span><br><span class="line">            System.out.print(<span class="string">"创建部门经理: "</span> + department);</span><br><span class="line">            String repportContent = department + <span class="string">"部门汇报: 此次报告的主要内容是..."</span>;</span><br><span class="line">            manager.setReportContent(repportContent);</span><br><span class="line">            System.out.println(<span class="string">" 创建报告: "</span> + repportContent);</span><br><span class="line">            EMPLOYEE_MAP.put(department, manager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> manager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类，随机取出一个部门的部门经理做汇报：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String departments[] = &#123;<span class="string">"RD"</span>, <span class="string">"QA"</span>, <span class="string">"PM"</span>, <span class="string">"BD"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            String department = departments[(<span class="keyword">int</span>) (Math.random() * departments.length)];</span><br><span class="line">            Manager manager = (Manager) EmployeeFactory.getManager(department);</span><br><span class="line">            manager.report();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">创建部门经理: BD 创建报告: BD部门汇报: 此次报告的主要内容是...</span><br><span class="line">BD部门汇报: 此次报告的主要内容是...</span><br><span class="line">BD部门汇报: 此次报告的主要内容是...</span><br><span class="line">创建部门经理: QA 创建报告: QA部门汇报: 此次报告的主要内容是...</span><br><span class="line">QA部门汇报: 此次报告的主要内容是...</span><br><span class="line">QA部门汇报: 此次报告的主要内容是...</span><br><span class="line">创建部门经理: RD 创建报告: RD部门汇报: 此次报告的主要内容是...</span><br><span class="line">RD部门汇报: 此次报告的主要内容是...</span><br><span class="line">BD部门汇报: 此次报告的主要内容是...</span><br><span class="line">RD部门汇报: 此次报告的主要内容是...</span><br><span class="line">RD部门汇报: 此次报告的主要内容是...</span><br><span class="line">创建部门经理: PM 创建报告: PM部门汇报: 此次报告的主要内容是...</span><br><span class="line">PM部门汇报: 此次报告的主要内容是...</span><br><span class="line">QA部门汇报: 此次报告的主要内容是...</span><br></pre></td></tr></table></figure><p>可以发现每个部门经理只创建过一次报告，之后都使用的同一份报告做汇报。</p><h3 id="Integer中的应用"><a href="#Integer中的应用" class="headerlink" title="Integer中的应用"></a>Integer中的应用</h3><p>我们查看jdk中<code>Integer</code>类下的<code>valueOf</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">       <span class="keyword">static</span> &#123;</span><br><span class="line">           <span class="comment">// high value may be configured by property</span></span><br><span class="line">           <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">           String integerCacheHighPropValue =</span><br><span class="line">               sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">           <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                   i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                   <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                   h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                   <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           high = h;</span><br><span class="line"></span><br><span class="line">           cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">           <span class="keyword">int</span> j = low;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">               cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">           <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">           <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>可以看出，在使用<code>valueOf</code>方法时，如果传入的参数在缓存范围内（这个范围在<code>IntegerCache</code>中设置为-128~127），那么直接从缓存中读取并返回，否则就创建一个新的对象返回。</p><p>我们可以通过一个实验来加以验证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer t1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">    Integer t2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">    System.out.println(t1 == t2);</span><br><span class="line"></span><br><span class="line">    Integer t3 = <span class="number">100</span>;</span><br><span class="line">    Integer t4 = <span class="number">100</span>;</span><br><span class="line">    System.out.println(t3 == t4);</span><br><span class="line"></span><br><span class="line">    Integer t5 = <span class="number">128</span>;</span><br><span class="line">    Integer t6 = <span class="number">128</span>;</span><br><span class="line">    System.out.println(t5 == t6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>使用new创建的Integer对象用<code>==</code>比较的是对象地址，因为对象不同所以地址也不相同，故输出<code>false</code>；而像<code>Integer t = xxx</code> 这种形式的定义实际会变成<code>Integer t = Integer.valueOf(xxx)</code>，先判断是否能直接从缓存中取出，100是在缓存范围内的也加入过缓存，因此可以直接取出；而128超出了缓存范围，所以在<code>valueOf</code>方法中会创建一个新的对象返回。</p><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="模板方法（Template-Method）"><a href="#模板方法（Template-Method）" class="headerlink" title="模板方法（Template Method）"></a>模板方法（Template Method）</h2><p><strong>定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现</strong>。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。</p><p>适用场景：</p><ul><li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复。</li></ul><h3 id="优缺点-12"><a href="#优缺点-12" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：提高复用性；提高扩展性；符合开闭原则。</p><p>缺点：类数目增加，增加了系统实现的复杂度；继承关系自身缺点，即如果父类添加新的抽象方法，所有子类都要改一遍。</p><h3 id="应用场景-11"><a href="#应用场景-11" class="headerlink" title="应用场景"></a>应用场景</h3><p>制作一节网课的步骤可以简化为4个步骤：制作PPT；录制视频；编写笔记；提供课程资料。</p><p>所有课程都需要制作PPT、录制视频，但不是每个课程都需要编写笔记，而提供的课程资料在每个课程都不尽不同（有些课程需要提供源代码，有些需要提供图片文件等）。</p><p>我们可以在抽象父类中确定整个流程的模板，并实现固定不变的步骤，而把不固定的步骤留给子类实现。除此之外，对于类似编写笔记这个不一定有的步骤，我们可以通过一个钩子方法，让子类来决定流程中其执行与否。</p><p>抽象父类，由于制作PPT、录制视频对于每节课都是必须且相同的，因此声明为<code>final</code>使得子类无法对其修改，而编写笔记虽然可有可无，但是具体的操作对于所有课程也是相同的因此不需要修改，所以也声明为<code>final</code>，而提供课程资料(<code>packageCourse</code>方法)这一步骤则交由具体子类实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ACourse</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">makeCourse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.makePPT();</span><br><span class="line">        <span class="keyword">this</span>.makeVideo();</span><br><span class="line">        <span class="keyword">if</span>(needWriteArticle())&#123;</span><br><span class="line">            <span class="keyword">this</span>.writeArticle();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.packageCourse();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">makePPT</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"制作PPT"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">makeVideo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"制作视频"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeArticle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"编写笔记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needWriteArticle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">packageCourse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端课程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FECourse</span> <span class="keyword">extends</span> <span class="title">ACourse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">packageCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提供课程的前端代码"</span>);</span><br><span class="line">        System.out.println(<span class="string">"提供课程的图片等多媒体素材"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计模式课程，覆盖了钩子方法，让其可以编写笔记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignPatternCourse</span> <span class="keyword">extends</span> <span class="title">ACourse</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">packageCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提供课程Java源码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needWriteArticle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"后端设计模式课程start---"</span>);</span><br><span class="line">        ACourse designPatternCourse = <span class="keyword">new</span> DesignPatternCourse();</span><br><span class="line">        designPatternCourse.makeCourse();</span><br><span class="line">        System.out.println(<span class="string">"后端设计模式课程end---"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"前端设计模式课程start---"</span>);</span><br><span class="line">        ACourse feCourse = <span class="keyword">new</span> FECourse();</span><br><span class="line">        feCourse.makeCourse();</span><br><span class="line">        System.out.println(<span class="string">"前端设计模式课程end---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://blog.default.nanwulife.com/Package%20templatemethod.png" alt="templ"></p><h3 id="JDK中的应用"><a href="#JDK中的应用" class="headerlink" title="JDK中的应用"></a>JDK中的应用</h3><p>我们查看<code>java.util</code>下的<code>AbstractList</code>抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">            add(index++, e);</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><p>这里面的<code>addAll</code>方法就相当于一个模板方法，它定义了这个算法的整体流程，而其具体的步骤如<code>rangeCheckForAdd</code>、<code>add</code>则交由子类如<code>ArrayList</code>等来完成。</p><h3 id="Servlet中的应用"><a href="#Servlet中的应用" class="headerlink" title="Servlet中的应用"></a>Servlet中的应用</h3><p>Servlet是用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p><p>每一个Servlet都必须要实现<code>Servlet</code>接口，<code>GenericServlet</code>是个通用的、不特定于任何协议的Servlet，它实现了<code>Servlet</code>接口，而<code>HttpServlet</code>继承于<code>GenericServlet</code>，实现了<code>Servlet</code>接口，为<code>Servlet</code>接口提供了处理HTTP协议的实现，所以我们定义的<code>Servlet</code>只需要继承<code>HttpServlet</code>即可。</p><p><img src="http://blog.default.nanwulife.com/20181010_214703.png" alt="Servlet"></p><p>在<code>HttpServlet</code>的<code>service</code>方法中，首先获得到请求的方法名，然后根据方法名调用对应的<code>doXXX</code>方法，比如说请求方法为GET，那么就去调用<code>doGet</code>方法；请求方法为POST，那么就去调用<code>doPost</code>方法。</p><p><code>HttpServlet</code>相当于定义了一套处理HTTP请求的模板。<code>service</code>方法为模板方法，定义了处理HTTP请求的基本流程，<code>doXXX</code>等方法为基本步骤，根据请求方法做相应的处理，编写自定义的<code>Servlet</code>时可以重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpServlet</span> <span class="keyword">extends</span> <span class="title">GenericServlet</span> </span>&#123;</span><br><span class="line"><span class="comment">//,,,</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String method = req.getMethod();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (method.equals(METHOD_GET)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">                <span class="comment">// to go through further expensive logic</span></span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                    <span class="comment">// Invalid date header - proceed as if none was set</span></span><br><span class="line">                    ifModifiedSince = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; (lastModified / <span class="number">1000</span> * <span class="number">1000</span>)) &#123;</span><br><span class="line">                    <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                    <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                    <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                    maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) &#123;</span><br><span class="line">            <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">            maybeSetLastModified(resp, lastModified);</span><br><span class="line">            doHead(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) &#123;</span><br><span class="line">            doPost(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) &#123;</span><br><span class="line">            doPut(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) &#123;</span><br><span class="line">            doDelete(req, resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) &#123;</span><br><span class="line">            doOptions(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) &#123;</span><br><span class="line">            doTrace(req,resp);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// Note that this means NO servlet supports whatever</span></span><br><span class="line">            <span class="comment">// method was requested, anywhere on this server.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line"></span><br><span class="line">            String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">            errArgs[<span class="number">0</span>] = method;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line"></span><br><span class="line">            resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="策略模式（Strategy）"><a href="#策略模式（Strategy）" class="headerlink" title="策略模式（Strategy）"></a>策略模式（Strategy）</h2><p><strong>定义了算法家族，分别封装起来，让它们之间可以互相替代，此模式让算法的辩护权啊不会影响到使用算法的用户。</strong></p><p>适用场景：</p><ul><li>系统有很多类，而他们的区别仅仅在于他们的行为不同。</li><li>一个系统需要动态地在几种算法中选择一种。</li></ul><h3 id="优缺点-13"><a href="#优缺点-13" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：符合开闭原则；避免使用多重条件转移语句；提高算法的保密性和安全性。</li><li>缺点：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li></ul><h3 id="应用场景-12"><a href="#应用场景-12" class="headerlink" title="应用场景"></a>应用场景</h3><p>在促销期间商家有不同的促销策略：返现、立减和满减。</p><p>策略抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返现策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FanXianPromotionStrategy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"返现促销，返回的金额存放到用户余额中"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>立减策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LiJianPromotionStrategy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"立减促销，课程的价格直接减去配置的价格"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>满减策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManJianPromotionStratehy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"满减促销，满200-20元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>促销活动，将促销策略作为成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PromotionStrategy promotionStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PromotionActivity</span><span class="params">(PromotionStrategy promotionStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.promotionStrategy = promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executePromotionStrategy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        promotionStrategy.doPromotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PromotionActivity promotionActivity618 = <span class="keyword">new</span> PromotionActivity(<span class="keyword">new</span> LiJianPromotionStrategy());</span><br><span class="line">        PromotionActivity promotionActivity1111 = <span class="keyword">new</span> PromotionActivity(<span class="keyword">new</span> FanXianPromotionStrategy());</span><br><span class="line">        promotionActivity618.executePromotionStrategy();</span><br><span class="line">        promotionActivity1111.executePromotionStrategy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当要新增一个促销策略的时候，直接增加一个策略实现即可，十分方便。</p><h2 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h2><p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。</p><h3 id="优缺点-14"><a href="#优缺点-14" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>优点：观察者和被观察者之间建立一个抽象的耦合；支持广播通信。</li><li>缺点：观察者之间有过多的细节依赖、提高时间消耗及程序复杂度。</li></ul><h3 id="应用场景-13"><a href="#应用场景-13" class="headerlink" title="应用场景"></a>应用场景</h3><p>每个课程有一名老师，而课程的学生可能提出许多问题，因此创建三个类<code>Course</code>、<code>Question</code>、<code>Teacher</code>。其中课程应该作为被观察者，而老师由于要回答学生们的问题，因此作为观察者时刻观察着。</p><p>课程类<code>Course</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Course</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String courseName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Course</span><span class="params">(String courseName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseName = courseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCourseName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> courseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCourseName</span><span class="params">(String courseName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.courseName = courseName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceQuestion</span><span class="params">(Course course, Question question)</span></span>&#123;</span><br><span class="line">        System.out.println(question.getUserName() + <span class="string">"在"</span> + course.getCourseName() + <span class="string">"提交了一个问题"</span>);</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers(question);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>问题类<code>Question</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Question</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String questionContent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getQuestionContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> questionContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setQuestionContent</span><span class="params">(String questionContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.questionContent = questionContent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>教师类<code>Teacher</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String teacherName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">(String teacherName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.teacherName = teacherName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        Course course = (Course)o;</span><br><span class="line">        Question question = (Question) arg;</span><br><span class="line">        System.out.println(teacherName + <span class="string">"老师的"</span> + course.getCourseName() + <span class="string">"课程接收到一个"</span> + question.getUserName() + <span class="string">"提交的问答："</span> + question.getQuestionContent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，以上代码通过继承<code>Observable</code>类和实现<code>Observer</code>接口实现了观察者模式。</p><p><code>Observable</code>中有两个方法对<code>Observer</code>特别重要，一个是<code>setChanged()</code>方法用来设置一个内部标志位表示数据发生了变化，一个是<code>notifyObservers()</code>方法会去调用一个列表中所有的<code>Observer</code>的<code>update()</code>方法，通知它们数据发生了变化。</p><p>客户端类<code>Test</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Course course = <span class="keyword">new</span> Course(<span class="string">"Java设计模式课程"</span>);</span><br><span class="line">        Teacher teacher1 = <span class="keyword">new</span> Teacher(<span class="string">"Alpha"</span>);</span><br><span class="line">        Teacher teacher2 = <span class="keyword">new</span> Teacher(<span class="string">"Belta"</span>);</span><br><span class="line"></span><br><span class="line">        course.addObserver(teacher1);</span><br><span class="line">        course.addObserver(teacher2);</span><br><span class="line">        Question question = <span class="keyword">new</span> Question();</span><br><span class="line">        question.setUserName(<span class="string">"cenjie"</span>);</span><br><span class="line">        question.setQuestionContent(<span class="string">"Java的主函数如何编写"</span>);</span><br><span class="line"></span><br><span class="line">        course.produceQuestion(course, question);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Observable</code>通过<code>addObserver()</code>方法把任意多个<code>Observer</code>添加到这个列表中。</p><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cenjie在Java设计模式课程提交了一个问题</span><br><span class="line">Belta老师的Java设计模式课程课程接收到一个cenjie提交的问答：Java的主函数如何编写</span><br><span class="line">Alpha老师的Java设计模式课程课程接收到一个cenjie提交的问答：Java的主函数如何编写</span><br></pre></td></tr></table></figure><p>可以看出，当被观察者<code>course</code>对象发生变化时，<code>teacher1</code>和<code>teacher2</code>这两个观察者都得到了通知。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007.</li><li>慕课网java设计模式精讲 Debug 方式+内存分析</li><li><a href="https://cloud.tencent.com/developer/article/1337162" target="_blank" rel="noopener">SLF4J和Logback日志框架详解</a></li><li><a href="https://www.cnblogs.com/daniels/p/8242592.html" target="_blank" rel="noopener">设计模式—代理模式</a></li><li><a href="https://www.cnblogs.com/chenssy/p/3317866.html" target="_blank" rel="noopener">设计模式读书笔记–桥接模式</a></li><li><a href="https://blog.csdn.net/qq_28241149/article/details/78548178" target="_blank" rel="noopener">JDBC源码分析&amp;桥接模式</a></li><li><a href="https://blog.csdn.net/wwwdc1012/article/details/83005717" target="_blank" rel="noopener">模板方法模式及典型应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;七大设计原则&quot;&gt;&lt;a href=&quot;#七大设计原则&quot; class=&quot;headerlink&quot; title=&quot;七大设计原则&quot;&gt;&lt;/a&gt;七大设计原则&lt;/h1&gt;&lt;h2 id=&quot;开闭原则&quot;&gt;&lt;a href=&quot;#开闭原则&quot; class=&quot;headerlink&quot; title=&quot;开闭原则&quot;&gt;&lt;/a&gt;开闭原则&lt;/h2&gt;&lt;p&gt;定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。&lt;/p&gt;
&lt;p&gt;用抽象构建框架，用实现扩展细节。&lt;/p&gt;
&lt;h2 id=&quot;依赖倒置原则&quot;&gt;&lt;a href=&quot;#依赖倒置原则&quot; class=&quot;headerlink&quot; title=&quot;依赖倒置原则&quot;&gt;&lt;/a&gt;依赖倒置原则&lt;/h2&gt;&lt;p&gt;定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象。&lt;/p&gt;
&lt;p&gt;做到针对接口编程，不要针对实现编程。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>《剑指Offer》题解与笔记</title>
    <link href="http://yoursite.com/2019/01/29/%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/01/29/《剑指Offer》题解与笔记/</id>
    <published>2019-01-29T11:16:00.000Z</published>
    <updated>2019-01-29T11:17:55.378Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-1-找出数组中重复的数字"><a href="#3-1-找出数组中重复的数字" class="headerlink" title="3.1 找出数组中重复的数字"></a>3.1 找出数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><a id="more"></a><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>对数组进行移位，判断i下标的数字等于i，如果不等则对其进行交换，eg:</p><p>{<strong>1</strong>，<strong>3</strong>，4，6，5，2，5} –&gt;  {3，1，4，6，5，2，5}  //下标为0的数字为1，因此将下标为1的数字即3与1换位，使得1到了其应在的地方</p><p>{<strong>3</strong>，1，4，<strong>6</strong>，5，2，5}  –&gt; {6，1，4，3，5，2，5}  //此时下标为0的数字为3，依然不等于其下标，因此找到下标为3的数字6与其交换，使3到了其应在的地方</p><p>{<strong>6</strong>，1，4，3，5，2，<strong>5</strong>} –&gt; {5，1，4，3，5，2，6}     //同理</p><p>{<strong>5</strong>，1，4，3，5，<strong>2</strong>，6} –&gt; {2，1，4，3，5，5，6} </p><p>{<strong>2</strong>，1，<strong>4</strong>，3，5，5，6} –&gt; {4，1，2，3，5，5，6}</p><p>{<strong>4</strong>，1，2，3，<strong>5</strong>，5，6} –&gt; {5，1，2，3，4，5，6}</p><p>{<strong>5</strong>，1，2，3，4，<strong>5</strong>，6}     //此时，要交换的两个数字相等，则证明该数字重复</p><p>可以看出，其时间复杂度为O(n)，且不需要额外分配空间，空间复杂度为O(1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">           <span class="keyword">while</span>(numbers[i] != i)&#123;</span><br><span class="line">               <span class="keyword">if</span>(numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                   duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               swap(numbers, numbers[i], i);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = numbers[a];</span><br><span class="line">        numbers[a] = numbers[b];</span><br><span class="line">        numbers[b] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-不修改数组找出重复的数字"><a href="#3-2-不修改数组找出重复的数字" class="headerlink" title="3.2 不修改数组找出重复的数字"></a>3.2 不修改数组找出重复的数字</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p>此道题与上题类似，但有不同的几点：</p><p>1、题目要求不能修改输入的数组，因此可能要考虑创建辅助数组，这里的一个思路是将原数组的数字m移动到辅助数组中下标为m的位置，因此当移动时检测到辅助数组该下标已经有数字时，表示此数字重复了。这里的的空间复杂度为O(n)，时间复杂度为O(n)。</p><p>2、题目中提到“在一个长度为n+1的数组里的所有数字都在1-n的范围内”，例如，若有个包含5个数的数组，但里面的数字只有1、2、3、4，那么必然有一个是重复的。这时候另一个思路则是在1、2、3、4、5中找出中间数3，以此将数组分割成两块，左半块是1-3（注意不是1-2），右半块是4-5，之后遍历整个数组，若数字在左半边的范围内，则将计数器加一。结束遍历时，若计数器的值大于这边块包含的个数，就说明重复的数字在这边块里，否则其就在右半块。紧接着把范围缩小到其中一边，继续重复以上操作。此操作类似二分查找法，需要的时间为O(nlogn)，空间复杂度为o(1)，相当于以时间换空间。下面给出的代码将根据此种思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Parameters:</span></span><br><span class="line">    <span class="comment">//    numbers:     an array of integers</span></span><br><span class="line">    <span class="comment">//    length:      the length of array numbers</span></span><br><span class="line">    <span class="comment">//    duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation;</span></span><br><span class="line">    <span class="comment">//                  Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++</span></span><br><span class="line">    <span class="comment">//    这里要特别注意~返回任意重复的一个，赋值duplication[0]</span></span><br><span class="line">    <span class="comment">// Return value:       true if the input is valid, and there are some duplications in the array number</span></span><br><span class="line">    <span class="comment">//                     otherwise false</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length,<span class="keyword">int</span> [] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> end = length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(end &gt;= start)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = (end - start) / <span class="number">2</span> + start;</span><br><span class="line">            <span class="keyword">int</span> count = countRange(numbers, length, start, middle);</span><br><span class="line">            <span class="keyword">if</span>(end == start)&#123;</span><br><span class="line">                <span class="keyword">if</span>(count &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    duplication[<span class="number">0</span>] = start;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt; middle - start + <span class="number">1</span>)</span><br><span class="line">                end = middle;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                start = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span> numbers[],<span class="keyword">int</span> length, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4.二维数组中的查找"></a>4.二维数组中的查找</h2><h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; array[<span class="number">0</span>].length &amp;&amp; len &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[len][i] &gt; target)&#123;</span><br><span class="line">                len--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[len][i] &lt; target)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h2><h3 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p>先遍历一次字符串，得到空格的总数，然后将字符串的长度设置为字符串的原长度加上空格数的两倍。将原始字符串末尾的值不断复制给新新字符串的末尾，每次遇到空格的时候在新字符串前插入%20。此算法中所有字符都只复制了一次，因此时间复杂度为O(n)。</p><p>在合并两个数组时，如果从前往后复制每个数字（或字符）则需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> spaceNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(i) == <span class="string">' '</span>)&#123;</span><br><span class="line">                spaceNum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> oldIndex = str.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> newLength = str.length() + spaceNum * <span class="number">2</span>;</span><br><span class="line">        str.setLength(newLength);</span><br><span class="line">        <span class="keyword">int</span> newIndex = newLength - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; oldIndex &gt;= <span class="number">0</span> &amp;&amp; oldIndex &lt;= newIndex; oldIndex--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str.charAt(oldIndex) == <span class="string">' '</span>) &#123;</span><br><span class="line">                str.setCharAt(newIndex--, <span class="string">'0'</span>);</span><br><span class="line">                str.setCharAt(newIndex--, <span class="string">'2'</span>);</span><br><span class="line">                str.setCharAt(newIndex--, <span class="string">'%'</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str.setCharAt(newIndex--, str.charAt(oldIndex));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h2><h3 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><h4 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h4><p>每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            arrayList.addAll(printListFromTailToHead(listNode.nextNode));</span><br><span class="line">            arrayList.add(listNode.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用栈"><a href="#使用栈" class="headerlink" title="使用栈"></a>使用栈</h4><p>利用栈“先进后出”的特性，实现最先入栈的节点值最后输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    Stack stack = <span class="keyword">new</span> Stack();</span><br><span class="line">    <span class="keyword">while</span>(listNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">        stack.push(listNode.val);</span><br><span class="line">        listNode = listNode.nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        arrayList.add((Integer) stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arrayList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树"></a>7.重建二叉树</h2><h3 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for binary tree</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p>对于前序遍历，第一个数字即为根节点的值；对于中序遍历，根据根节点值将序列划分为左右子树。接下来使用递归分别继续进行如上操作，便可不断构建出左右子树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="keyword">null</span> || in == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> reConstructBinaryTree(pre, <span class="number">0</span>, pre.length-<span class="number">1</span>, in, <span class="number">0</span>, in.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(startPre &gt; endPre || startIn &gt; endIn)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(in[i] == pre[startPre])&#123;</span><br><span class="line">                root.left = reConstructBinaryTree(pre, startPre+<span class="number">1</span>, i-startIn+startPre, in, startIn, i-<span class="number">1</span>);</span><br><span class="line">                root.right = reConstructBinaryTree(pre, startPre+i-startIn+<span class="number">1</span>, endPre, in, i+<span class="number">1</span>, endIn);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-二叉树的下一个节点"><a href="#8-二叉树的下一个节点" class="headerlink" title="8.二叉树的下一个节点"></a>8.二叉树的下一个节点</h2><h3 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class TreeLinkNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeLinkNode left = null;</span><br><span class="line">    TreeLinkNode right = null;</span><br><span class="line">    TreeLinkNode next = null;</span><br><span class="line"></span><br><span class="line">    TreeLinkNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p>此题可分为两种情况：一种是一个节点有右子树，那么它的下一个节点就是它的右子树中的最左子节点；另一种是没有右子树，那么就判断它是否为父节点的左节点，如果是，则父结点为其下一个节点，如果不是，则向上遍历其父结点，找到为其祖先节点左节点的父结点，这个祖先节点就是它的下一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1、一个节点有右子树，那么找到右子树的最左子节点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeLinkNode node = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                node = node.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、一个节点没有右子树</span></span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(pNode.next.left == pNode) <span class="keyword">return</span> pNode.next;</span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9.用两个栈实现队列"></a>9.用两个栈实现队列</h2><h3 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h3><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p>此题思路较为简单，主要就是利用栈“先入后出”和队列“先入先出”的特性，每次push的时候将值存到栈1中，pop的时候先将栈1的值放入栈2从而实现逆序，然后再对栈2进行pop操作，就实现了队列的“先进先出”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack1.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10.1 斐波那契数列"></a>10.1 斐波那契数列</h2><h3 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h3><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。</p><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p>传统的做法是使用递归：return Fibonacci(n-1)+Fibonacci(n-2)。但是这种做法画出树形图就能看出有许多重复的节点，而且容易导致内存溢出，因而不建议使用。</p><h4 id="使用循环"><a href="#使用循环" class="headerlink" title="使用循环"></a>使用循环</h4><p>使用循环是一个较好的做法，不仅提高了时间效率，也解决了内存溢出的问题。实际上，任何递归都可以用循环来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num1 = num2;</span><br><span class="line">            num2 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用尾递归"><a href="#使用尾递归" class="headerlink" title="使用尾递归"></a>使用尾递归</h4><p>尾递归是递归的一种特殊形式，本质上和递归没有什么区别，但优化后可以重复利用同一个栈帧，大幅提高效率，具体介绍在我的博客中有介绍：。由于java没有对尾递归进行优化，所以在此题中用java解题时依旧无法解决内存溢出的问题，主要提供一种答题思路。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        return Fibonacci(n, 0, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private static int Fibonacci(int n, int num1, int num2)&#123;</span><br><span class="line">        if(n == 0)</span><br><span class="line">            return 0;</span><br><span class="line">        if(n == 1)</span><br><span class="line">            return num2;</span><br><span class="line">        else</span><br><span class="line">            return Fibonacci(n - 1, num2, num1 + num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-跳台阶"><a href="#10-2-跳台阶" class="headerlink" title="10.2 跳台阶"></a>10.2 跳台阶</h2><h3 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p>如果只有1级台阶，则只有一种跳法；如果有2级台阶，则可以一次跳两阶，或者一次跳一阶；如果有n级台阶，第一次跳就有两种不同的选择：当第一次只跳一阶时，总的跳法数等于后面n-1级台阶的跳法数，而如果第一次跳两阶的话，总的跳法数就等于后面n-2级台阶的跳法数。根据此规律可以得到以下公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f(n) = 0, 当n=0时</span><br><span class="line">f(n) = 1, 当n=1时</span><br><span class="line">f(n) = 2, 当n=2时</span><br><span class="line">f(n) = f(n-1) + f(n-2), 当n&gt;2时</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num1 = num2;</span><br><span class="line">            num2 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-变态跳台阶"><a href="#10-3-变态跳台阶" class="headerlink" title="10.3 变态跳台阶"></a>10.3 变态跳台阶</h2><h3 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h3><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><h4 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h4><p>此题和上题类似，但是一次可以跳多级台阶，依旧可以根据“第一次跳多少台阶，则跳法数等于剩下多少台阶的跳法数目”的思路进行分析，因此我们可以如下分析：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果有1级台阶，则有f(1) = 1 种跳法</span><br><span class="line">如果有2级台阶，则有f(2) = f(2-1) + f(2-2) = 2 种跳法</span><br><span class="line">如果有3级台阶，则有f(3) = f(3-1) + f(3-2) + f(3-3) = 4 种跳法</span><br><span class="line">···</span><br><span class="line">如果有n级台阶，则有f(n) = f(n-1) + f(n-2) + f(n-3) + ··· + f(0) 种跳法</span><br><span class="line">              又 f(n-1) = f(n-2) + f(n-3) + f(n-4) + ··· + f(0)</span><br><span class="line">     进行相减可得，f(n) - f(n-1) = f(n-1)</span><br><span class="line">              即，f(n) = 2f(n-1)</span><br><span class="line">              </span><br><span class="line">由此得出，</span><br><span class="line">f(n) = 1, 当n=0时</span><br><span class="line">f(n) = 1, 当n=1时</span><br><span class="line">f(n) = f(n-1) + f(n-2), 当n&gt;=2时</span><br></pre></td></tr></table></figure><p>此题一个比较难理解的部分是，在公式中当n=0时，f(n)应当等于1而不是0。因为如果第一次就跳完了所有台阶，这也算一种跳法，此时f(n-n)=f(0)应当等于1而非0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;   <span class="comment">//初始值应为1而非0</span></span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num2 = num1;</span><br><span class="line">            num1 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h4><p>在跳台阶的整个过程中，除了最后一阶是必须要跳的，其它每个台阶都有跳或者不跳两种可能性，因此f(n) = 2^(n-1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, n-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-4-矩形覆盖"><a href="#10-4-矩形覆盖" class="headerlink" title="10.4 矩形覆盖"></a>10.4 矩形覆盖</h2><h3 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h3><p>我们可以用2 <em> 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 </em> 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？</p><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(n) = 1, 当n=0时</span><br><span class="line">f(n) = 1, 当n=1时</span><br><span class="line">f(n) = f(n-1) + f(n-2), 当n&gt;=2时</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            num = num1 + num2;</span><br><span class="line">            num2 = num1;</span><br><span class="line">            num1 = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14 剪绳子"></a>14 剪绳子</h2><h3 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h3><p>一根长度为n的绳子，将绳子剪为m段（剪m-1次），每段绳子的长度为k[0] - k[m]；要求k[0] <em> k[1] </em> k[2] <em> ··· </em> k[m]的乘积为最大。n &gt;1 且 m&gt; 1。</p><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p>这道题可以采用动态规划来做。在剪第一刀的时候，我们有n-1种可能的选择，因此f(n)=max(f(i) * f(n-i))。由于递归会产生很多重复的子问题，因此采用由下而上的循环方式，将每个子问题的最优解放到数组dp里。最终的答案就是dp[n]。</p><p>在刚开始看书的时候并不理解为什么要对dp[1], dp[2], [dp3]逐一初始化，后来经过反复调试并思考，发现当n&gt;3时dp[3]也就是当绳子长度为3时，不应该对其进行切割，因为切割后理论应得问题最优解就是2，而它的父问题要想得到最优解，应该直接使用整段未切割绳子也就是3。而当n&lt;=3时，将在方法最开始就进行了一个正确的返回，即当绳子长度为3时，对其进行切割得到最优解为2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> []dp = <span class="keyword">new</span> <span class="keyword">int</span>[n +<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">//把长度为i的绳子切成若干段</span></span><br><span class="line">            <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> p = dp[j] * dp[i-j];</span><br><span class="line">                <span class="keyword">if</span>(max &lt; p)</span><br><span class="line">                    max = p;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15 二进制中1的个数"></a>15 二进制中1的个数</h2><h3 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数，输出该数二进制表示中1的个数。</p><h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><h4 id="常规解法"><a href="#常规解法" class="headerlink" title="常规解法"></a>常规解法</h4><p>将输入的数字n与1做与运算，如果得出的结果是1，说明n的最低位是1，从而将计数器加一，并将1左移，进行n的次低位的判断，如此反复。这种做法整数为多少位就要循环多少次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(flag != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>((n &amp; flag) != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h4><p>对输入的数字n减1再与自身进行与运算，即(n-1)&amp;n可以将n最低位的1变成0：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n:       11101100</span><br><span class="line">n-1:     11101011</span><br><span class="line">n&amp;(n-1): 11101000</span><br></pre></td></tr></table></figure></p><p>基于以上，n中有多少个1，就可以进行多少次这样的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16 数值的整数次方"></a>16 数值的整数次方</h2><h3 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p>此题的关键在于对base、exponent为正数、负数和零的考虑。</p><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= exponent; i++)&#123;</span><br><span class="line">            result = base * result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>a的n次方可以通过如下公式求解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a^n = a^(n/2) * a^(n/2),              n为偶数</span><br><span class="line">a^n = a^((n-1)/2) * a^((n-1)/2) * a,  n为奇数</span><br></pre></td></tr></table></figure><p>每次计算n都会变为原来的1/2，因此通过递归算法可以使时间复杂度降到logn，效率得到提升。除此之外，可以用右移运算和位与运算代替除2和求余运算两个操作，从而得到进一步优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        <span class="keyword">boolean</span> isNegative = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            isNegative = <span class="keyword">true</span>;</span><br><span class="line">            exponent = -exponent;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> result = Power(base, exponent &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        result *= result;</span><br><span class="line">        <span class="keyword">if</span>((exponent &amp; <span class="number">0x1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            result *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            result = <span class="number">1</span> / result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNegative ? <span class="number">1</span> / result : result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17 打印从1到最大的n位数"></a>17 打印从1到最大的n位数</h2><h3 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。</p><h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p>这道题可以使用递归对n位数进行全排列，在每一次递归调用之前都设置好下一位，当index为最后一位时，结束递归并打印。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintToMaxOfNDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">char</span>[] nums = <span class="keyword">new</span> <span class="keyword">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            nums[<span class="number">0</span>] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + i);</span><br><span class="line">            PrintToMaxOfNDigits(nums, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintToMaxOfNDigits</span><span class="params">(<span class="keyword">char</span>[] nums, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            nums[index+<span class="number">1</span>] = (<span class="keyword">char</span>) (<span class="string">'0'</span> + i);</span><br><span class="line">            PrintToMaxOfNDigits(nums, index+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-1-在O-1-时间内删除链表节点"><a href="#18-1-在O-1-时间内删除链表节点" class="headerlink" title="18.1 在O(1)时间内删除链表节点"></a>18.1 在O(1)时间内删除链表节点</h2><h3 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p>对于一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5，如果要删除节点4，</p><p>首先想到的思路是找到节点4前面的节点（此处也就是节点3），将3的下一个节点重新设置为要删除的节点的下一个节点（此处也就是5），此时链表就变为了1-&gt;2-&gt;3-&gt;5。但由于链表是单向链表，不能从要删除的节点直接得到上一个节点，因此只能从头开始顺序查找，时间复杂度就为O(n)了。</p><p>另一种思路则是将要删除的节点的下一个节点的值赋值给要删除的节点，再将要删除的节点的下一个节点重新设置为下下个节点：<br>1-&gt;2-&gt;3-&gt;5-&gt;5<br>1-&gt;2-&gt;3-&gt;5<br>此时，时间复杂度就为O(1)了。</p><p>但如果要删除的节点为尾节点，则没有下一个节点，此种情况依然要使用顺序查找的方式删除节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteNode</span><span class="params">(ListNode head, ListNode tobeDelete)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span> || tobeDelete == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要删除的节点不是尾节点</span></span><br><span class="line"><span class="keyword">if</span>(tobeDelete.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">tobeDelete.val = tobeDelete.next.val;</span><br><span class="line">tobeDelete.next = tobeDelete.next.next;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//要删除的节点是尾节点</span></span><br><span class="line">ListNode node = head;</span><br><span class="line"><span class="keyword">if</span>(node == tobeDelete) &#123;</span><br><span class="line"><span class="comment">//如果链表中只有要删除的这一个节点</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(node.next != tobeDelete) &#123;</span><br><span class="line">node = node.next;</span><br><span class="line">&#125;</span><br><span class="line">node.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-2-删除链表中重复的结点"><a href="#18-2-删除链表中重复的结点" class="headerlink" title="18.2 删除链表中重复的结点"></a>18.2 删除链表中重复的结点</h2><h3 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p>如果当前节点的值与下一个节点的值相同，那么它们就是重复的节点，都可以被删除。为了保证删除之后的链表仍然是相连的，我们要把当前节点的前一个节点和后面值比当前节点的值大的节点相连。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果链表中只存在一个节点，则不存在重复的节点</span></span><br><span class="line"><span class="keyword">if</span>(pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> pHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">ListNode node = pHead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">ListNode nextNode = node.next;</span><br><span class="line"><span class="keyword">if</span>(nextNode != <span class="keyword">null</span> &amp;&amp; !(nextNode.val == node.val)) &#123;</span><br><span class="line"><span class="comment">//当前节点与下一个节点不同</span></span><br><span class="line">preNode = node;</span><br><span class="line">node = nextNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前节点与下一个相同</span></span><br><span class="line"><span class="keyword">int</span> value = node.val;</span><br><span class="line">ListNode toBeDel = node;</span><br><span class="line"><span class="keyword">while</span>(toBeDel != <span class="keyword">null</span> &amp;&amp; toBeDel.val == value) &#123;</span><br><span class="line">nextNode = toBeDel.next;</span><br><span class="line">toBeDel = nextNode;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(preNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">pHead = nextNode;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">preNode.next = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">node = nextNode;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19 正则表达式匹配"></a>19 正则表达式匹配</h2><h3 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配.</p><h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || pattern == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> strIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> patternIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern, strIndex, patternIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> strIndex, <span class="keyword">int</span> patternIndex)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字符串与模式完全匹配</span></span><br><span class="line">    <span class="keyword">if</span>(strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字符串未到达末尾，而模式已到达末尾，则匹配失败</span></span><br><span class="line">    <span class="keyword">if</span>(strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(patternIndex + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[patternIndex + <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">    <span class="comment">//模式的第二个字符为*</span></span><br><span class="line">    <span class="keyword">if</span>(strIndex &lt; str.length &amp;&amp; str[strIndex] == pattern[patternIndex] || strIndex &lt; str.length &amp;&amp; pattern[patternIndex] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    <span class="comment">//*前的字符与字符串中的字符相等时</span></span><br><span class="line">    <span class="comment">//可能的情况：匹配0位，模式向后移动两位跳过*；匹配一位，模式向后移动两位跳过*；匹配一位，模式不移动，下次继续匹配。</span></span><br><span class="line">    <span class="keyword">return</span> matchCore(str, pattern, strIndex, patternIndex+<span class="number">2</span>) || matchCore(str, pattern, strIndex+<span class="number">1</span>, patternIndex+<span class="number">2</span>)</span><br><span class="line">    || matchCore(str, pattern, strIndex+<span class="number">1</span>, patternIndex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//*前的字符与字符串中的字符不相等时，匹配0位，跳过*</span></span><br><span class="line">    <span class="keyword">return</span> matchCore(str, pattern, strIndex, patternIndex+<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(pattern[patternIndex] == <span class="string">'.'</span> &amp;&amp; strIndex &lt; str.length || strIndex &lt; str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) &#123;</span><br><span class="line">    <span class="comment">//模式的第二个字符不为*</span></span><br><span class="line">    <span class="keyword">if</span>(str[strIndex] == pattern[patternIndex] || pattern[patternIndex] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    <span class="comment">//如果字符相匹配,则接续操作</span></span><br><span class="line">    <span class="keyword">return</span> matchCore(str, pattern, strIndex+<span class="number">1</span>, patternIndex+<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//字符不匹配，直接返回false</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20 表示数值的字符串"></a>20 表示数值的字符串</h2><h3 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p><h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p>表示数值的字符串遵循模式：A[.[b]][e|EC]或者.B[e|EC]。A和C都可以带有符号’+’或’-‘，B则不行，且A、B、C都必须为整数。因此，可以根据模式的顺序去依次匹配A、B、C。如果字符串中包含’.’，则’.’左右至少要有一方有数字，而如果字符串中包含’e’或’E’，则’e’或’E’两方都必须要有数字，且右方必须为整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> flag;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    flag = scanInteger(str);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(index &lt; str.length &amp;&amp; str[index] == <span class="string">'.'</span>) &#123;</span><br><span class="line">    index++;</span><br><span class="line">    flag = scanUnsignedInteger(str) || flag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; str.length &amp;&amp; (str[index] == <span class="string">'e'</span> || str[index] == <span class="string">'E'</span>)) &#123;</span><br><span class="line">    index++;</span><br><span class="line">    flag = scanInteger(str) &amp;&amp; flag;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> flag &amp;&amp; (index == str.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scanUnsignedInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> before = index;</span><br><span class="line">    <span class="keyword">while</span>(index &lt; str.length &amp;&amp; str[index] &gt;= <span class="string">'0'</span> &amp;&amp; str[index] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">    index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index &gt; before;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">scanInteger</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; str.length &amp;&amp; (str[index] == <span class="string">'+'</span> || str[index] == <span class="string">'-'</span>))</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">return</span> scanUnsignedInteger(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21 调整数组顺序使奇数位于偶数前面"></a>21 调整数组顺序使奇数位于偶数前面</h2><h3 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分（拓展：并保证奇数和奇数，偶数和偶数之间的相对位置不变）。</p><h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><h4 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h4><p>一前一后扫描数组，若发现有偶数在前，奇数在后，则交换它们两的位置。此算法的时间复杂度为O(n)，但是算法是不稳定的，也就是没法保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tail = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; tail) &#123;</span><br><span class="line">    <span class="keyword">while</span>(head &lt; array.length &amp;&amp; array[head] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//正向遍历不为偶数的时候</span></span><br><span class="line">    head++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(tail &gt;= <span class="number">0</span> &amp;&amp; array[tail] % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//反向遍历不为奇数的时候</span></span><br><span class="line">    tail--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(head &lt; tail) &#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[head];</span><br><span class="line">    array[head] = array[tail];</span><br><span class="line">    array[tail] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拓展解法"><a href="#拓展解法" class="headerlink" title="拓展解法"></a>拓展解法</h4><p>要保证奇数和奇数，偶数和偶数之间的相对位置不变，则需要使用一个辅助数组，首先计算出奇数的个数，以此作为将偶数插入辅助数组的起始坐标。然后遍历原数组，将奇数放置于辅助数组的奇数起始坐标（也就是0），将偶数放置于辅助数组的偶数起始坐标，最后再将调整完毕的辅助数组中的元素依次放回原数组。此算法的时间复杂度为O(n)，空间复杂度为O(n)，相当于以空间换时间。另一种思路是可以使用插入排序的思想，在此不再阐述。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] copy = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="comment">//统计奇数个数</span></span><br><span class="line">        <span class="keyword">if</span>(array[i] % <span class="number">2</span> != <span class="number">0</span>) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> even = count;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(index &lt; array.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[index] % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果是奇数</span></span><br><span class="line">        copy[odd] = array[index];</span><br><span class="line">        odd++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果是偶数</span></span><br><span class="line">        copy[even] = array[index];</span><br><span class="line">        even++;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        array[i] = copy[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-链表中倒数第K个节点"><a href="#22-链表中倒数第K个节点" class="headerlink" title="22 链表中倒数第K个节点"></a>22 链表中倒数第K个节点</h2><h3 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，输出该链表中倒数第k个结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure><h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p>传统的思路是先遍历一遍链表，计算出节点数n，则倒数第k个节点就是从头开始的第n-k+1个节点。但此种做法要遍历链表两边，效率不高。</p><p>另一种思路是定义两个指针，让两个指针之间的距离保持在k-1，则当第一个指针到达链表的尾节点时，第二个指针则指向倒数第k个节点。这种实现只需要遍历链表一次即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode node1 = head;</span><br><span class="line">    ListNode node2 = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k-<span class="number">1</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node1.next == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    node1 = node1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(node1.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node1 = node1.next;</span><br><span class="line">    node2 = node2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23 链表中环的入口节点"></a>23 链表中环的入口节点</h2><h3 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h3><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure><h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p>要找到链表中环的入口节点，整体思路与上一题类似。例如，如果环中有4个节点，则第二个指针要比第一个指针先走四步，然后同时向前走，当两个指针相遇时，所指向的节点就是入口节点。</p><p>根据此思路，要解决的问题是：如何计算环的节点数？这里可以先使用一快一慢两个指针，得到相遇时的节点（若第一个指针走到了null，说明链表中没有环，返回null），此节点必然在环内，然后从此节点开始绕环一圈，每走一步计数器加一，当回到原点时便得到了环的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode meetingNode = MeetingNode(head);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(meetingNode == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode node1 = head;</span><br><span class="line">        ListNode node2 = head;</span><br><span class="line">        ListNode node = meetingNode.next;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(node != meetingNode) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(node1 != node2) &#123;</span><br><span class="line">        node1 = node1.next;</span><br><span class="line">        node2 = node2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">MeetingNode</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode node1 = head;</span><br><span class="line">    ListNode node2 = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(node1.next != <span class="keyword">null</span> &amp;&amp; node1.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">    node1 = node1.next.next;</span><br><span class="line">    node2 = node2.next;</span><br><span class="line">    <span class="keyword">if</span>(node1 == node2)</span><br><span class="line">    <span class="keyword">return</span> node1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24 反转链表"></a>24 反转链表</h2><h3 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个链表，反转链表后，输出新链表的表头。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure><h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p>定义三个指针分别指向前一个节点，当前节点和后一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode preNode = <span class="keyword">null</span>;</span><br><span class="line">    ListNode currNode = head;</span><br><span class="line">    ListNode nextNode = head.next;</span><br><span class="line">    ListNode reNode = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(currNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(nextNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">    reNode = currNode;</span><br><span class="line">    currNode.next = preNode;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    currNode.next = preNode;</span><br><span class="line">    preNode = currNode;</span><br><span class="line">    currNode = nextNode;</span><br><span class="line">    nextNode  = currNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> reNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25 合并两个排序的链表"></a>25 合并两个排序的链表</h2><h3 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;*/</span><br></pre></td></tr></table></figure><h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">if</span>(list2 == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list1;</span><br><span class="line">        </span><br><span class="line">        ListNode head = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(list1.val &lt; list2.val) &#123;</span><br><span class="line">        head = list1;</span><br><span class="line">        head.next = Merge(list1.next, list2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">        head = list2;</span><br><span class="line">        head.next = Merge(list1, list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26 树的子结构"></a>26 树的子结构</h2><h3 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p>第一步是在树A中查找与根节点的值一样的节点，第二步是判断以此节点为根节点的子树是不是和树B具有相同的结构。此题要特别注意由于计算机表示小数含有误差，不能直接使用==进行double类型的等值判断，而是判断两个小数的差的绝对值是否小于某一个可忽略的数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root1 != <span class="keyword">null</span> &amp;&amp; root2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(Equal(root1.val, root2.val))</span><br><span class="line">        result = DoesTree1HaveTree2(root1, root2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">        result = HasSubtree(root1.left, root2);</span><br><span class="line">        <span class="keyword">if</span>(!result)</span><br><span class="line">        result = HasSubtree(root1.right, root2);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">DoesTree1HaveTree2</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root2 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(root1 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!Equal(root1.val, root2.val))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> DoesTree1HaveTree2(root1.left, root2.left) &amp;&amp; DoesTree1HaveTree2(root1.right, root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Equal</span><span class="params">(<span class="keyword">double</span> num1, <span class="keyword">double</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num1- num2 &gt; -<span class="number">0.0000001</span> &amp;&amp; num1 - num2 &lt; <span class="number">0.0000001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27 二叉树的镜像"></a>27 二叉树的镜像</h2><h3 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">二叉树的镜像定义：</span><br><span class="line"></span><br><span class="line">源二叉树 </span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      6   10</span><br><span class="line">     / \  / \</span><br><span class="line">    5  7 9 11</span><br><span class="line"></span><br><span class="line">    镜像二叉树</span><br><span class="line">        8</span><br><span class="line">       /  \</span><br><span class="line">      10   6</span><br><span class="line">     / \  / \</span><br><span class="line">    11 9 7  5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    TreeNode temp;</span><br><span class="line">    temp = root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">    Mirror(root.left);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">    Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28 对称的二叉树"></a>28 对称的二叉树</h2><h3 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  对称的二叉树 </span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6    6</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 7   5</span><br><span class="line"></span><br><span class="line"> 非对称的二叉树</span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6    9</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 7   5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p>对于上图的非对称的二叉树，可以发现前序序列为{8, 6, 5, 7, 6, 7, 5}，对称前序序列为{8, 9, 5, 7, 6, 7, 5}。<br>而对于对称的二叉树，前序序列与对称前序序列都为{8, 6, 5, 7, 6, 7, 5}。<br>因此，通过比较二叉树的前序序列和对称前序序列即可判断出二叉树是否对称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot1, TreeNode pRoot2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="keyword">null</span> &amp;&amp; pRoot2 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(pRoot1 == <span class="keyword">null</span> || pRoot2 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(pRoot1.val != pRoot2.val)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(pRoot1.left, pRoot2.right) &amp;&amp; isSymmetrical(pRoot1.right, pRoot2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29 顺时针打印矩阵"></a>29 顺时针打印矩阵</h2><h3 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p><h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> columns = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> rows = matrix.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(columns == <span class="number">0</span> || rows == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(columns &gt; start*<span class="number">2</span> &amp;&amp; rows &gt; start*<span class="number">2</span>) &#123;</span><br><span class="line">        arr.addAll(PrintMatrixInCircle(matrix, columns, rows, start));</span><br><span class="line">        start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintMatrixInCircle</span><span class="params">(<span class="keyword">int</span> [][]matrix, <span class="keyword">int</span> columns, <span class="keyword">int</span> rows, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> endX = columns - <span class="number">1</span> - start;</span><br><span class="line">    <span class="keyword">int</span> endY = rows - <span class="number">1</span> - start;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从左到右打印一行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= endX; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> number = matrix[start][i];</span><br><span class="line">    arr.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从上到下打印一列</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endY) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= endY; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> number = matrix[i][endX];</span><br><span class="line">    arr.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从右到左打印一行</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = endX - <span class="number">1</span>; i &gt;= start; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> number = matrix[endY][i];</span><br><span class="line">    arr.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从下到上打印一行</span></span><br><span class="line">    <span class="keyword">if</span>(start &lt; endX &amp;&amp; start &lt; endY - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start + <span class="number">1</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> number = matrix[i][start];</span><br><span class="line">    arr.add(number);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30 包含min函数的栈"></a>30 包含min函数的栈</h2><h3 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p>使用一个辅助栈。第一次压入的时候，把该元素同时也压入到辅助栈中。以后每次压入新元素的时候，如果新元素比辅助栈栈顶的元素小，就把新元素也压入到辅助栈中，否则，就把辅助栈栈顶的元素再次压入。这么做可以使辅助栈的每个元素对应着数据栈中该位置元素之前的最小元素，即每次从数据栈和辅助栈中弹出一个元素时，辅助栈的栈顶都保存着数据栈的最小元素。由此我们也可以发现，在辅助栈中，新元素的值要么比上一层的值小，要么等于上一层的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Stack&lt;Integer&gt; dataHelper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">    data.push(node);</span><br><span class="line">    <span class="keyword">if</span>(dataHelper.isEmpty()) &#123;</span><br><span class="line">    dataHelper.push(node);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(node &lt; dataHelper.peek()) &#123;</span><br><span class="line">        dataHelper.push(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dataHelper.push(dataHelper.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data.pop();</span><br><span class="line">        dataHelper.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dataHelper.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31 栈的压入、弹出序列"></a>31 栈的压入、弹出序列</h2><h3 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p><h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p>使用一个栈来模拟压入、弹出的操作，可以得到以下规律：</p><ul><li>如果下一个弹出的数字刚好是栈顶数字，直接弹出</li><li>否则，把压栈序列中还没有入栈的数字压入栈中，直到把下一个需要弹出的数字压入栈顶为止</li><li>压栈序列为空还没找到，离开循环</li><li>判断栈是否为空，为空则说明弹出序列匹配，否则，不匹配</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;Integer&gt; helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span> [] pushA,<span class="keyword">int</span> [] popA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushA.length; i++) &#123;</span><br><span class="line">    helper.push(pushA[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!helper.isEmpty() &amp;&amp; j &lt; popA.length &amp;&amp; helper.peek() == popA[j]) &#123;</span><br><span class="line">    helper.pop();</span><br><span class="line">    j++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-1-从上往下打印二叉树"><a href="#32-1-从上往下打印二叉树" class="headerlink" title="32.1 从上往下打印二叉树"></a>32.1 从上往下打印二叉树</h2><h3 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p>每次打印一个节点的时候，如果该节点有子节点，就把子节点加入到队列中，然后再从队列头取首元素并打印，重复以上操作，直至队列为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.add(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-2-把二叉树打印成多行"><a href="#32-2-把二叉树打印成多行" class="headerlink" title="32.2 把二叉树打印成多行"></a>32.2 把二叉树打印成多行</h2><h3 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h3><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p><h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p>用两个变量分别记录当前行还剩余的节点与下一行需要打印的节点。每打印完一行，都将下一行需要打印的节点数赋给当前剩余节点数，并将自身置0，以便重新开始新的一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">        <span class="keyword">int</span> toBePrinted = <span class="number">1</span>;<span class="comment">//当前层中还没打印的节点数</span></span><br><span class="line">        <span class="keyword">int</span> nextLevel = <span class="number">0</span>;<span class="comment">//下一层的节点数</span></span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        TreeNode node = queue.poll();</span><br><span class="line">        list.add(node.val);</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.add(node.left);</span><br><span class="line">        nextLevel++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        queue.add(node.right);</span><br><span class="line">        nextLevel++;</span><br><span class="line">        &#125;</span><br><span class="line">        toBePrinted--;</span><br><span class="line">        <span class="keyword">if</span>(toBePrinted == <span class="number">0</span>) &#123;</span><br><span class="line">                listAll.add(list);</span><br><span class="line">                list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        toBePrinted = nextLevel;</span><br><span class="line">        nextLevel = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-3-按之字形顺序打印二叉树"><a href="#32-3-按之字形顺序打印二叉树" class="headerlink" title="32.3 按之字形顺序打印二叉树"></a>32.3 按之字形顺序打印二叉树</h2><h3 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p><h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p>如果当前节点在奇数层，则将子节点以从左往右的顺序入栈；如果当前节点在偶数层，则将子节点以从右往左的顺序入栈。更简单地说：子节点入栈的方向与当前层节点弹出的方向一致。</p><p>在下面的算法中，用一个Stack数组保存当前层的栈与下一层的栈，用1和0表示奇数层和偶数层。当前层栈的节点弹出时，下一层栈的节点压入。如果当前层栈为空，则说明该行已经打印完成，将current与next置换（奇偶置换）后开始新的一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">       Stack&lt;TreeNode&gt;[] stack = <span class="keyword">new</span> Stack[<span class="number">2</span>];</span><br><span class="line">        stack[<span class="number">0</span>] = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        stack[<span class="number">1</span>] = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> listAll;</span><br><span class="line">    <span class="keyword">int</span> current = <span class="number">1</span>;<span class="comment">//表示奇数层</span></span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;<span class="comment">//表示偶数层</span></span><br><span class="line">    stack[current].push(root);</span><br><span class="line">    <span class="keyword">while</span>(stack[current].size() != <span class="number">0</span> || stack[next].size() != <span class="number">0</span>) &#123;</span><br><span class="line">    TreeNode node = stack[current].pop();</span><br><span class="line">    </span><br><span class="line">    list.add(node.val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(current == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//如果在奇数层，则子节点从左往右入栈</span></span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stack[next].push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stack[next].push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//如果在偶数层，则子节点从右往左入栈</span></span><br><span class="line">    <span class="keyword">if</span>(node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stack[next].push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stack[next].push(node.left);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(stack[current].size() == <span class="number">0</span>) &#123;</span><br><span class="line">    listAll.add(list);</span><br><span class="line">    list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    current = <span class="number">1</span> - current;</span><br><span class="line">    next = <span class="number">1</span> - next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33 二叉搜索树的后序遍历序列"></a>33 二叉搜索树的后序遍历序列</h2><h3 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p>先以以下二叉树为例，其输入数组为{5, 7, 6, 9, 11, 10, 8}。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6    10</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 9   11</span><br></pre></td></tr></table></figure><p>我们可以发现，数组的最后一个数字8就是二叉树的根节点，然后从数组开始进行遍历，凡是比8小的都属于根节点的左子树，其余的就是根节点的右子树，即{5, 7, 6, /9, 11, 10,/ 8}。我们在看看根节点的左子树，同样最后一个数字6是左子树的根节点，而5、7分别属于左子树根节点的左右子树。</p><p>再看看另一个例子：{7, 4, 6, 5}，由以上分析的规律可以发现，5为二叉树的根节点，而7、4、6都比5大，说明此二叉树没有左子树，而在右子树{7, 4, 6}中，7比6大，说明7在根节点的右子树中，而4却又比6小，这有违二叉树的定义，说明此数组不属于任何一个二叉树。</p><p>因此，我们可以使用递归来解决这个问题，先找到二叉树的根节点，再基于此根节点将数组拆分成左右子树，然后对左右子树分别进行递归。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence == <span class="keyword">null</span> || sequence.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> VerifySquenceOfBST(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(end-begin&lt;<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> root = sequence[end];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> i = begin;</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; end; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence[i] &gt; root)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = i;</span><br><span class="line">    <span class="keyword">for</span>(;j &lt; end; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sequence[j] &lt; root)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> left = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; <span class="number">0</span>)</span><br><span class="line">    left = VerifySquenceOfBST(sequence, begin, i-<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> right = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; end)</span><br><span class="line">    right = VerifySquenceOfBST(sequence, i, end - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> (right &amp;&amp; left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34 二叉树中和为某一值的路径"></a>34 二叉树中和为某一值的路径</h2><h3 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p>此题运用深度优先搜索的思想。从左开始向下深度遍历，遇到叶节点之后，判断其值是否等于target，如果相等则将此路径加入到所有路径的列表中。每次回退的时候，都要将路径最后一个节点删除。</p><p>此题需要注意，将某一路径加入到所有路径列表时，必须新建一个ArrayList，否则每次都是将对同一个对象的引用加入到listAll中，而java中通过引用是可以改变对象内部的属性的，所以每次对list进行remove操作都会影响到listAll中已加入的所有list，最后由于list会回退到根节点并把根节点remove掉，导致listAll的路径数目虽然正确，但每条路径列表都为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">        findPath(listAll, list, root, target);</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll, ArrayList&lt;Integer&gt; list, TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    list.add(root.val);</span><br><span class="line">    <span class="comment">//如果为叶节点</span></span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val == target) &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; newList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    newList.addAll(list);</span><br><span class="line">    listAll.add(newList);</span><br><span class="line">    &#125;</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">    findPath(listAll, list, root.left, target-root.val);</span><br><span class="line">    <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">    findPath(listAll, list, root.right, target-root.val);</span><br><span class="line">    list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35 复杂链表的复制"></a>35 复杂链表的复制</h2><h3 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">public class RandomListNode &#123;</span><br><span class="line">    int label;</span><br><span class="line">    RandomListNode next = null;</span><br><span class="line">    RandomListNode random = null;</span><br><span class="line"></span><br><span class="line">    RandomListNode(int label) &#123;</span><br><span class="line">        this.label = label;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p>解决此题大体有以下两个步骤：</p><p>1、根据原始链表的每个节点创建对应的复制节点</p><p>2、设置复制出来的节点的random节点</p><p>此题的关键在于定位random节点，需保证算法的时间复杂度在O(n)。</p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p>在第一步创建每个复制节点时，使用哈希表保存原节点与复制节点，之后设置random节点时，每当通过查找哈希表原节点的random节点便可以在O(1)的时间找到该复制节点应指向的random节点。此算法相当于以空间换时间，空间复杂度为O(n)。</p><p>这里需要注意，java中的map是不能直接使用iterator遍历的，因此需要先通过entrySet()方法获取set视图。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Map.Entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        RandomListNode cloneNodeHead = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">        RandomListNode cloneNode = cloneNodeHead;</span><br><span class="line">        map.put(head, cloneNode);</span><br><span class="line">        <span class="keyword">while</span>(head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode nextNode = <span class="keyword">new</span> RandomListNode(head.next.label);</span><br><span class="line">        cloneNode.next = nextNode;</span><br><span class="line">        cloneNode = cloneNode.next;</span><br><span class="line">        head = head.next;</span><br><span class="line">        map.put(head, cloneNode);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Iterator&lt;Entry&lt;RandomListNode, RandomListNode&gt;&gt; it = map.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">        Entry&lt;RandomListNode, RandomListNode&gt; entry = it.next();</span><br><span class="line">        <span class="comment">//时间复杂度为O(1)，相当于以空间换时间</span></span><br><span class="line">        RandomListNode sib = map.get(entry.getKey().random);</span><br><span class="line">        entry.getValue().random = sib;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cloneNodeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更好的解法"><a href="#更好的解法" class="headerlink" title="更好的解法"></a>更好的解法</h4><p>思路：在旧链表中创建新链表-&gt;根据旧链表的random节点初始化新链表的random节点-&gt;把新链表从旧链表中拆分出来。</p><p>此算法的时间复杂度为O(n)，且不需要辅助空间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    CloneNodes(head);</span><br><span class="line">    ConnectSiblingNodes(head);</span><br><span class="line">    <span class="keyword">return</span> ReconnectNodes(head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">CloneNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode test = head;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    RandomListNode cloneNode = <span class="keyword">new</span> RandomListNode(head.label);</span><br><span class="line">    RandomListNode next = head.next;</span><br><span class="line">    head.next = cloneNode;</span><br><span class="line">    cloneNode.next = next;</span><br><span class="line">    head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConnectSiblingNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    RandomListNode cloneNode = head.next;</span><br><span class="line">    <span class="keyword">if</span>(head.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">    cloneNode.random = head.random.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head = head.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">ReconnectNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode cloneNode = head.next;</span><br><span class="line">    RandomListNode cloneNodeHead = cloneNode;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">    RandomListNode next = head.next.next;</span><br><span class="line">    RandomListNode cloneNext;</span><br><span class="line">    <span class="comment">//防止在最后一个节点处报空指针异常</span></span><br><span class="line">    <span class="keyword">if</span>(next == <span class="keyword">null</span>) &#123;</span><br><span class="line">    cloneNext = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cloneNext = cloneNode.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    head.next = next;</span><br><span class="line">    cloneNode.next = cloneNext;</span><br><span class="line">    head = next;</span><br><span class="line">    cloneNode = cloneNext;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cloneNodeHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36 二叉搜索树与双向链表"></a>36 二叉搜索树与双向链表</h2><h3 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode left = Convert(root.left);</span><br><span class="line">    TreeNode p = left;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    p = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left != <span class="keyword">null</span>) &#123;</span><br><span class="line">    root.left = p;</span><br><span class="line">    p.right = root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode right = Convert(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right != <span class="keyword">null</span>) &#123;</span><br><span class="line">    root.right = right;</span><br><span class="line">    right.left = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left != <span class="keyword">null</span> ? left : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37 序列化二叉树"></a>37 序列化二叉树</h2><h3 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h3 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        str.append(<span class="string">"$,"</span>);</span><br><span class="line">        <span class="keyword">return</span> str.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        str.append(root.val+<span class="string">","</span>);</span><br><span class="line">        str.append(Serialize(root.left));</span><br><span class="line">        str.append(Serialize(root.right));</span><br><span class="line">        <span class="keyword">return</span> str.toString();  </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">       String[] newStr = str.split(<span class="string">","</span>);</span><br><span class="line">       index++;</span><br><span class="line">       <span class="keyword">if</span>(index &lt; str.length() &amp;&amp; !newStr[index].equals(<span class="string">"$"</span>)) &#123;</span><br><span class="line">       TreeNode root = <span class="keyword">new</span> TreeNode(Integer.valueOf(newStr[index]));</span><br><span class="line">       root.left = Deserialize(str);</span><br><span class="line">       root.right = Deserialize(str);</span><br><span class="line">       <span class="keyword">return</span> root;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38 字符串的排列"></a>38 字符串的排列</h2><h3 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><h3 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h3><p>回溯法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        Permutation(str.toCharArray(), <span class="number">0</span>, list);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Permutation</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, ArrayList&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i == c.length) &#123;</span><br><span class="line">    String str = String.valueOf(c);</span><br><span class="line">    <span class="keyword">if</span>(!list.contains(str))</span><br><span class="line">    list.add(String.valueOf(c));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; c.length; j++) &#123;</span><br><span class="line">    swap(c, i, j);</span><br><span class="line">    Permutation(c, i+<span class="number">1</span>, list);</span><br><span class="line">    swap(c, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] c, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp;</span><br><span class="line">    temp = c[i];</span><br><span class="line">    c[i] = c[j];</span><br><span class="line">    c[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39 数组中出现次数超过一半的数字"></a>39 数组中出现次数超过一半的数字</h2><h3 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h3><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p><h3 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h3><h4 id="基于辅助数组的解法"><a href="#基于辅助数组的解法" class="headerlink" title="基于辅助数组的解法"></a>基于辅助数组的解法</h4><p>此种解法利用了辅助数组，在辅助数组中以原始数组的值为索引存储该值出现的次数，一旦次数超过原始数组的一半，则跳出循环返回该值。该解法空间复杂度为O(n)，相当于以空间换时间，且由于数组的限制，事先必须要知道原始数组中值的范围，若要克服后者，可以使用其它数据结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = array.length;</span><br><span class="line">    <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    helper[array[i]]++;</span><br><span class="line">    <span class="keyword">if</span>(helper[array[i]] &gt; length / <span class="number">2</span>) &#123;</span><br><span class="line">    result = array[i];</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多数投票算法"><a href="#多数投票算法" class="headerlink" title="多数投票算法"></a>多数投票算法</h4><p>多数投票算(摩尔投票算法)：定义一个结果变量和一个计数器，初始化的情况下计数器为0. 算法依次扫描序列中的元素，当处理某元素的时候，如果计数器为0，那么将该元素赋值给结果变量，然后将计数器设置为1，如果计数器不为0，那么将结果变量和该元素比较，如果相等，那么计数器加1，如果不等，那么计数器减1。处理之后，最后存储的结果变量就是这个数组中超过一半以上的元素。</p><p>需注意：如果一个元素的出现次数超过数组长度的一半，那么结果变量肯定为该元素，但结果变量元素的出现次数不一定超过数组长度的一半，因此需要进行第二次遍历确认。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> result = array[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">    result = array[i];</span><br><span class="line">    n = <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(array[i] == result) </span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    n--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(array[i] == result) &#123;</span><br><span class="line">    n++;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(n &lt;= array.length / <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40 最小的k个数"></a>40 最小的k个数</h2><h3 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p><h3 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span> [] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input == <span class="keyword">null</span> || input.length &lt;= <span class="number">0</span> || k &lt; <span class="number">1</span> || k &gt; input.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(k+<span class="number">1</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">        heap.add(input[i]);</span><br><span class="line">        <span class="keyword">if</span>(heap.size() &gt; k) &#123;</span><br><span class="line">        heap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : heap) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41 数据流中的中位数"></a>41 数据流中的中位数</h2><h3 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h3><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p><h3 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h3><p>用最大堆与最小堆来实现，插入的时间复杂度为O(log(n))。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    PriorityQueue&lt;Integer&gt; max = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; min = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((min.size()+max.size() &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前总数是偶数，则插入到最大堆</span></span><br><span class="line">        <span class="keyword">if</span>(min.size() != <span class="number">0</span> &amp;&amp; num &gt; min.peek()) &#123;</span><br><span class="line">        <span class="comment">//如果最小堆的数目不为0，且新插入的数字比最小堆的头要大</span></span><br><span class="line">        <span class="keyword">int</span> temp = min.poll();</span><br><span class="line">        max.add(temp);</span><br><span class="line">        min.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//插入到最大堆</span></span><br><span class="line">        max.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果当前总数是奇数，则插入到最小堆</span></span><br><span class="line">        <span class="keyword">if</span>(max.size() != <span class="number">0</span> &amp;&amp; num &lt; max.peek()) &#123;</span><br><span class="line">        <span class="comment">//同理</span></span><br><span class="line">        <span class="keyword">int</span> temp = max.poll();</span><br><span class="line">        min.add(temp);</span><br><span class="line">        max.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        min.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = max.size() + min.size();</span><br><span class="line">    Double d;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((size &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">    d = Double.valueOf(max.peek());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    d = (<span class="keyword">double</span>) (max.peek() + min.peek()) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42 连续子数组的最大和"></a>42 连续子数组的最大和</h2><h3 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h3><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p><h3 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="keyword">null</span> ||data.length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> sum=data[<span class="number">0</span>], max=data[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                sum = data[i];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                sum += data[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="44-数字序列中某一位的数字"><a href="#44-数字序列中某一位的数字" class="headerlink" title="44 数字序列中某一位的数字"></a>44 数字序列中某一位的数字</h2><h3 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h3><p>数字以 0123456789101112131415… 的格式序列化到一个字符串中，求这个字符串的第 index 位。</p><h3 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> digits = <span class="number">1</span>;<span class="comment">//digits表示有几位数，初始为一位数</span></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> numbers = countOfIntegers(digits);<span class="comment">//返回当前位数共有多少个数</span></span><br><span class="line"><span class="keyword">if</span>(index &lt; numbers * digits) &#123;<span class="comment">//数字的个数乘位数能得到具体的某一位数字的下标</span></span><br><span class="line"><span class="keyword">return</span> digitAtIndex(index, digits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">index -= digits * numbers;<span class="comment">//如果要查找的数字不在这位数里面，则跳过这些数字</span></span><br><span class="line">digits++;<span class="comment">//位数加一</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在n位数中的第index个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">digitAtIndex</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> number = beginNumber(digits) + index / digits;</span><br><span class="line"><span class="keyword">int</span> indexFromRight = digits - index % digits;<span class="comment">//得到在查找到的数字中具体从右数的哪一位</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; indexFromRight; i++) &#123;</span><br><span class="line">number /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> number % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算n位的数字总共有多少，如二位数有10~99这90个数，三位数有100~999这900个数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countOfIntegers</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = (<span class="keyword">int</span>) Math.pow(<span class="number">10</span>, digits-<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> count * <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 计算n位数的第一个数字，如二位数的第一个数字是10，三位数的第一个数字是100</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">beginNumber</span><span class="params">(<span class="keyword">int</span> digits)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(digits == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)Math.pow(<span class="number">10</span>, digits-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45 把数组排成最小的数"></a>45 把数组排成最小的数</h2><h3 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p><h3 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h3><p>本题的关键在于定义一个规则判断两个数中谁应该排在前面，应该排在前面的数我们称其“小于”另一个数。例如，令m=32，n=2，则mn=322，nm=232，因为nm&lt;mn，我们就称n小于m。之后我们便可使用这个比较方法（比较器）对数组中的所有元素进行排序即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    </span><br><span class="line">    StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">    String[] str = <span class="keyword">new</span> String[len];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    str[i] = numbers[i] + <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(str, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">    String str1 = o1 + o2;</span><br><span class="line">    String str2 = o2 + o1;</span><br><span class="line">    <span class="keyword">return</span> str1.compareTo(str2);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(String s : str) &#123;</span><br><span class="line">    res.append(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46 把数字翻译成字符串"></a>46 把数字翻译成字符串</h2><h3 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”… 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><h3 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h3><p>如果用递归方法从上往下求解，必然会遇到许多重复的计算，因此可以从下往上进行求解。</p><p>我们可以先得到方程f(i) = f(i+1) + af(i+2)，当第i个数与第i+1个数组成的数字在10-25的范围内，则a=1，否则a=0。以字符串“13225”为例，下标为0和1的数分别是1和3，组成的13是在10-25的范围内的，因此可以将其看成剩下的3225或者225这两种组合方式。以上是自顶向下的分析，再看看自底向上的实现，以下标为2的数2为例，首先就单独把这个数进行翻译，则加上上一个数的计算结果，又因为上一个数2和它组成的22是在10-25的范围内的，所以可以把它们组合在一起翻译，基于这种情况则再加上上上个数的结果，这两种情况的结果相加就是自底到这一个数的计算结果。一直循环到第一个数，dp[0]便是最终答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i == n) &#123;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count += dp[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> num1 = s.charAt(i)-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> num2 = s.charAt(i+<span class="number">1</span>)-<span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">int</span> num = num1 * <span class="number">10</span> + num2;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">10</span> &amp;&amp; num &lt;= <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n-<span class="number">1</span>) &#123;</span><br><span class="line">        count += dp[i+<span class="number">2</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        count++;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        dp[i] = count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47 礼物的最大价值"></a>47 礼物的最大价值</h2><h3 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h3><p>小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个6*6的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。</p><p>给定一个6*6的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。</p><h3 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h3><p>使用动态规划的思路：f(i,j) = max(f(i-1,j), f(i,j-1))，每一个坐标(i,j)的解只需要依赖其左边与上边的坐标，且最左边坐标的解只依赖上边的坐标，因此只需要一个一维数组作为缓存即可，该数组存有i行j列左边的所有解以及i-1行j列右边的所有解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMost</span><span class="params">(<span class="keyword">int</span>[][] values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(values == <span class="keyword">null</span> || values.length == <span class="number">0</span> || values[<span class="number">0</span>].length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = values[<span class="number">0</span>].length;</span><br><span class="line"><span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>[] value : values) &#123;</span><br><span class="line">dp[<span class="number">0</span>] += value[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">dp[i] = Math.max(dp[i], dp[i-<span class="number">1</span>]) + value[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48 最长不含重复字符的子字符串"></a>48 最长不含重复字符的子字符串</h2><h3 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。</p><h3 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LongestSubstringWithoutDupSolution</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> curLen = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] position = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">position[i] = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="comment">//当前字母在position的下标index</span></span><br><span class="line"><span class="keyword">int</span> index = str.charAt(i) - <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">if</span>(position[index] &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">//如果这个字母之前没出现过</span></span><br><span class="line">curLen += <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(i-position[index] &lt;= curLen) &#123;</span><br><span class="line">curLen = i-position[index];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">curLen += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">position[index] = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(curLen &gt; maxLen)</span><br><span class="line">maxLen = curLen;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49 丑数"></a>49 丑数</h2><h3 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h3><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p><h3 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt;= <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span>[] ugly = <span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">    ugly[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> t2=<span class="number">0</span>, t3=<span class="number">0</span>, t5=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; index; i++) &#123;</span><br><span class="line">    ugly[i] = Math.min(ugly[t2]*<span class="number">2</span>, Math.min(ugly[t3]*<span class="number">3</span>, ugly[t5]*<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">while</span>(ugly[t2] * <span class="number">2</span> &lt;= ugly[i])</span><br><span class="line">    t2++;</span><br><span class="line">    <span class="keyword">while</span>(ugly[t3] * <span class="number">3</span> &lt;= ugly[i])</span><br><span class="line">    t3++;</span><br><span class="line">    <span class="keyword">while</span>(ugly[t5] * <span class="number">5</span> &lt;= ugly[i])</span><br><span class="line">    t5++;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">return</span> ugly[ugly.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="50-1-第一个只出现一次的字符"><a href="#50-1-第一个只出现一次的字符" class="headerlink" title="50.1 第一个只出现一次的字符"></a>50.1 第一个只出现一次的字符</h2><h3 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.</p><h3 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> curr = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(!map.containsKey(curr)) &#123;</span><br><span class="line">        map.put(curr, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> value = map.get(curr);</span><br><span class="line">        map.put(curr, ++value);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> curr = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(map.get(curr) == <span class="number">1</span>) &#123;</span><br><span class="line">        index = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="50-2-字符流中第一个不重复的字符"><a href="#50-2-字符流中第一个不重复的字符" class="headerlink" title="50.2 字符流中第一个不重复的字符"></a>50.2 字符流中第一个不重复的字符</h2><h3 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h3><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><h3 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] map = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">map[i] = -<span class="number">1</span>;<span class="comment">//-1代表从未出现过</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(map[ch] == -<span class="number">1</span>) &#123;</span><br><span class="line">        map[ch] = index;<span class="comment">//从未出现过，将它的下标赋值给它</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map[ch] = -<span class="number">2</span>;<span class="comment">//出现过，则值为-2</span></span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> result = <span class="string">'#'</span>;</span><br><span class="line">    <span class="keyword">int</span> minIndex = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; map.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(map[i] &gt;= <span class="number">0</span> &amp;&amp; map[i] &lt; minIndex) &#123;</span><br><span class="line">    minIndex = map[i];</span><br><span class="line">    result = (<span class="keyword">char</span>)i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51 数组中的逆序对"></a>51 数组中的逆序对</h2><h3 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><h3 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h3><p>统计逆序对的过程：先把数组分隔成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行归并排序，而计算逆序对数目其实就是在进行归并排序的时候完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] tmp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    tmp = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">        <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (cnt % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(hi &lt;= lo)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> m = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    mergeSort(a, lo, m);</span><br><span class="line">    mergeSort(a, m+<span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, m, hi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> lo, <span class="keyword">int</span> m, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = m+<span class="number">1</span>, k = lo;</span><br><span class="line">    <span class="keyword">while</span>(k &lt;= hi) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt; m) &#123;</span><br><span class="line">    tmp[k] = a[j++];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; hi) &#123;</span><br><span class="line">    tmp[k] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a[i] &lt; a[j]) &#123;</span><br><span class="line">    tmp[k] = a[i++];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    tmp[k] = a[j++];</span><br><span class="line">    cnt += m - i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">    a[k] = tmp[k];</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="52-两个链表的第一个公共结点"><a href="#52-两个链表的第一个公共结点" class="headerlink" title="52 两个链表的第一个公共结点"></a>52 两个链表的第一个公共结点</h2><h3 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入两个链表，找出它们的第一个公共结点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class ListNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    ListNode next = null;</span><br><span class="line"></span><br><span class="line">    ListNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h3><p>此题大体有两种思路：</p><p>1、如果从后往前遍历两条链表，那么最后一个相同的节点就是我们要找的节点。这种思路要解决的问题在于链表是单向链表，该怎么逆序遍历链表。</p><p>2、如果从前往后遍历两条链表，那么第一个相同的节点就是我们要找的节点。这种思路要解决的问题在于如果两条链表的长度不同，便无法同时到达第一个公共节点，进而也就无法比较是否相等。</p><h4 id="思路一：以空间换时间"><a href="#思路一：以空间换时间" class="headerlink" title="思路一：以空间换时间"></a>思路一：以空间换时间</h4><p>将两个链表分别装到两个栈中，每次取出链表尾部的一个节点判断是否相等，最后一个相等的节点即为两个链表的第一个公共节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    Stack&lt;ListNode&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;ListNode&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    ListNode h1 = pHead1;</span><br><span class="line">    ListNode h2 = pHead2;</span><br><span class="line">    ListNode common = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span>(h1!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    stack1.push(h1);</span><br><span class="line">    h1 = h1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(h2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stack2.push(h2);</span><br><span class="line">    h2 = h2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stack1.empty() &amp;&amp; !stack2.empty()) &#123;</span><br><span class="line">    ListNode node1 = stack1.pop();</span><br><span class="line">    ListNode node2 = stack2.pop();</span><br><span class="line">    <span class="keyword">if</span>(node1 == node2) &#123;</span><br><span class="line">    common = node1;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> common;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="思路二：进一步优化"><a href="#思路二：进一步优化" class="headerlink" title="思路二：进一步优化"></a>思路二：进一步优化</h4><p>上一种思路需要两个栈作为辅助空间，其实完全可以不用辅助空间，先分别遍历两个链表并记录他们的长度，长链表先走几步以此和短链表在同一起点出发，之后便可以同时遍历直至找出相同的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> len1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> diff;<span class="comment">//两条链表的长度差</span></span><br><span class="line">    ListNode listLong;<span class="comment">//标识链表的长短</span></span><br><span class="line">    ListNode listShort;</span><br><span class="line">    ListNode h1 = pHead1;<span class="comment">//用于遍历的节点</span></span><br><span class="line">    ListNode h2 = pHead2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(h1!=<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    len1++;</span><br><span class="line">    h1 = h1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(h2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">    len2++;</span><br><span class="line">    h2 = h2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len1 &gt; len2) &#123;</span><br><span class="line">    listLong = pHead1;</span><br><span class="line">    listShort = pHead2;</span><br><span class="line">    diff = len1 - len2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    listLong = pHead2;</span><br><span class="line">    listShort = pHead1;</span><br><span class="line">    diff = len2 - len1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++) &#123;</span><br><span class="line">    listLong = listLong.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(listLong != <span class="keyword">null</span> &amp;&amp; listShort != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(listLong == listShort)</span><br><span class="line">    <span class="keyword">return</span> listLong;</span><br><span class="line">    listLong = listLong.next;</span><br><span class="line">    listShort = listShort.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-1-数字在排序数组中出现的次数"><a href="#53-1-数字在排序数组中出现的次数" class="headerlink" title="53.1 数字在排序数组中出现的次数"></a>53.1 数字在排序数组中出现的次数</h2><h3 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h3><p>统计一个数字在排序数组中出现的次数。</p><h3 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h3><p>最直观的做法是顺序扫描，时间复杂度为O(n)，不是最优解。由于输入的数组是排序的，那么就可以用二分查找的思路，找到第一个要查找的数字和最后一个要查找的数字，其坐标差即为该数字出现的次数。此时时间复杂度为O(logn)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array ==  <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = getFirstK(array, k);</span><br><span class="line">        <span class="keyword">int</span> end = getLastK(array, k);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(start != -<span class="number">1</span> &amp;&amp; end != -<span class="number">1</span>) &#123;</span><br><span class="line">        num = end - start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(array[middle] &lt; k) &#123;</span><br><span class="line">    lo = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[middle] &gt; k) &#123;</span><br><span class="line">    hi = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(middle - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[middle - <span class="number">1</span>] == k) &#123;</span><br><span class="line">     hi = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastK</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(array[middle] &lt; k) &#123;</span><br><span class="line">    lo = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[middle] &gt; k) &#123;</span><br><span class="line">    hi = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(middle + <span class="number">1</span> &lt; array.length &amp;&amp; array[middle + <span class="number">1</span>] == k) &#123;</span><br><span class="line">     lo = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-2-0至n-1中缺失的数字"><a href="#53-2-0至n-1中缺失的数字" class="headerlink" title="53.2 0至n-1中缺失的数字"></a>53.2 0至n-1中缺失的数字</h2><h3 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h3><p>在范围0~n-1内的n个数字中有且只有一个数字不在长度为n-1的递增排序数组（数字唯一）中，请找出这个数字。例如，{1,2,3,4}中少了0，{0,1,2,3}中少了4，{0,1,3,4}中少了2。</p><h3 id="题解-55"><a href="#题解-55" class="headerlink" title="题解"></a>题解</h3><p>用二分查找法找到第一个数字与下标不同的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array ==  <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(array[middle] == middle) &#123;</span><br><span class="line">    lo = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(middle - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[middle - <span class="number">1</span>] != middle - <span class="number">1</span>) &#123;</span><br><span class="line">     hi = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> array.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-3-数组中数值和下标相等的元素"><a href="#53-3-数组中数值和下标相等的元素" class="headerlink" title="53.3 数组中数值和下标相等的元素"></a>53.3 数组中数值和下标相等的元素</h2><h3 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编写实现一个函数，找出数组中任意一个数值等于其下标的元素。</p><h3 id="题解-56"><a href="#题解-56" class="headerlink" title="题解"></a>题解</h3><p>由于每个数都是唯一的，如果第i个数字的值大于i，那么它右边的数字都大于对应的下标；如果第i个数字的值小于i，那么它左边的数字都小于对应的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IntegerIdenticalToIndex</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array ==  <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> middle;</span><br><span class="line">    <span class="keyword">while</span>(lo &lt;= hi) &#123;</span><br><span class="line">    middle = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(array[middle] &gt; middle) &#123;</span><br><span class="line">    hi = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[middle] &lt; middle) &#123;</span><br><span class="line">    lo = middle + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(middle - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; array[middle - <span class="number">1</span>] == middle - <span class="number">1</span>) &#123;</span><br><span class="line">    hi = middle - <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> middle;</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="54-二叉搜索树的第k个结点"><a href="#54-二叉搜索树的第k个结点" class="headerlink" title="54 二叉搜索树的第k个结点"></a>54 二叉搜索树的第k个结点</h2><h3 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-57"><a href="#题解-57" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">private</span> TreeNode target;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        KthNodeCore(pRoot, k);</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">KthNodeCore</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRoot == <span class="keyword">null</span> || target != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    KthNodeCore(pRoot.left, k);</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="keyword">if</span>(cnt == k)</span><br><span class="line">    target = pRoot;</span><br><span class="line">    KthNodeCore(pRoot.right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55.1 二叉树的深度"></a>55.1 二叉树的深度</h2><h3 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class TreeNode &#123;</span><br><span class="line">    int val = 0;</span><br><span class="line">    TreeNode left = null;</span><br><span class="line">    TreeNode right = null;</span><br><span class="line"></span><br><span class="line">    public TreeNode(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="题解-58"><a href="#题解-58" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> left &gt; right ? (left+<span class="number">1</span>):(right+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55.2 平衡二叉树"></a>55.2 平衡二叉树</h2><h3 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><h3 id="题解-59"><a href="#题解-59" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> IsBalanced(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">IsBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = IsBalanced(root.left);</span><br><span class="line">    <span class="keyword">if</span>(left == -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">int</span> right = IsBalanced(root.right);</span><br><span class="line">    <span class="keyword">if</span>(right == -<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(left-right) &gt; <span class="number">1</span> ? -<span class="number">1</span> : <span class="number">1</span>+Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="56-1-数组中只出现一次的数字"><a href="#56-1-数组中只出现一次的数字" class="headerlink" title="56.1 数组中只出现一次的数字"></a>56.1 数组中只出现一次的数字</h2><h3 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h3><p>一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。</p><h3 id="题解-60"><a href="#题解-60" class="headerlink" title="题解"></a>题解</h3><p>因为任何一个数字异或它自己都等于0，而0异或任何一个数字都等于其本身，所以可以将数组中的所有数字都异或，例如对于含有一个数字只出现一次的数组{3,3,4,4,6}：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    3 ^ 3 ^ 4 ^ 4 ^ 6</span><br><span class="line">-&gt;  0 ^ 0 ^ 6</span><br><span class="line">-&gt;  6</span><br></pre></td></tr></table></figure></p><p>而在此题中，数组里有两个数字只出现了一次，所以从头到尾异或数组中的每个数字会得到这两个数字的异或结果，由于这两个数字肯定不同，所以异或结果至少会包含一个1，我们以最右侧的1为标准将这两个数分到两个子数组中，于此同时这一位为1或0的出现两次的数字也会分别到这两个子数组中，然后再对两个子数组运用最上面的思路。</p><p>在这里，diff &amp;= -diff可以得到只有最右侧为1的数，以此作为分割标准。（在计算机中，负数以其正值的补码形式表达，补码=反码+1）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">            diff ^= num;</span><br><span class="line">        diff &amp;= -diff;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((num &amp; diff) == <span class="number">0</span>)</span><br><span class="line">                num1[<span class="number">0</span>] ^= num;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                num2[<span class="number">0</span>] ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="56-2-数组中唯一只出现一次的数字"><a href="#56-2-数组中唯一只出现一次的数字" class="headerlink" title="56.2 数组中唯一只出现一次的数字"></a>56.2 数组中唯一只出现一次的数字</h2><h3 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h3><p>在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><h3 id="题解-61"><a href="#题解-61" class="headerlink" title="题解"></a>题解</h3><p>把数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位是0，否则就是1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberAppearingOnce</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> numbers[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line"><span class="keyword">int</span> bit = numbers[i] &amp; bitMask;</span><br><span class="line"><span class="keyword">if</span>(bit != <span class="number">0</span>)</span><br><span class="line">bitSum[j] += <span class="number">1</span>;</span><br><span class="line">bitMask = bitMask &lt;&lt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">result = result &lt;&lt; <span class="number">1</span>;</span><br><span class="line">result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="57-1-和为s的两个数字"><a href="#57-1-和为s的两个数字" class="headerlink" title="57.1 和为s的两个数字"></a>57.1 和为s的两个数字</h2><h3 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><h3 id="题解-62"><a href="#题解-62" class="headerlink" title="题解"></a>题解</h3><p>定义两个指针，一个指向数组头，一个指向数组末尾，如果指针指向的这两个数字相加小于S，则将头指针向后移动一位，否则将尾指针向前移动一位。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">        <span class="keyword">int</span> curSum = array[lo] + array[hi];</span><br><span class="line">        <span class="keyword">if</span>(curSum &lt; sum) &#123;</span><br><span class="line">         lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum) &#123;</span><br><span class="line">        hi--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result.add(array[lo]);</span><br><span class="line">        result.add(array[hi]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="57-2-和为s的连续正数序列"><a href="#57-2-和为s的连续正数序列" class="headerlink" title="57.2 和为s的连续正数序列"></a>57.2 和为s的连续正数序列</h2><h3 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h3><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><h3 id="题解-63"><a href="#题解-63" class="headerlink" title="题解"></a>题解</h3><p>首先把lo和hi分别初始化为1和2（因为连续序列为正，且至少含有两个数字），如果lo和hi之间的数字相加大于S，将lo加一，而如果lo和hi之间的数字相加小于S，则将hi加一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(sum &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> middle = sum / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> curSum = lo + hi;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt;= middle) &#123;</span><br><span class="line">        <span class="keyword">if</span>(curSum &lt; sum) &#123;</span><br><span class="line">        hi++;</span><br><span class="line">        curSum += hi;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(curSum &gt; sum) &#123;</span><br><span class="line">        curSum -= lo;</span><br><span class="line">        lo++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = lo;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= hi)</span><br><span class="line">        list.add(i++);</span><br><span class="line">        listAll.add(list);</span><br><span class="line">        curSum += ++hi;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listAll;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="58-1-翻转单词序列"><a href="#58-1-翻转单词序列" class="headerlink" title="58.1 翻转单词序列"></a>58.1 翻转单词序列</h2><h3 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h3><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p><h3 id="题解-64"><a href="#题解-64" class="headerlink" title="题解"></a>题解</h3><p>进行两次翻转：首先将整体进行翻转，得到<code>.tneduts a ma I</code>，再将每个单词进行局部翻转，得到<code>student. a am I</code>即为答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">char</span>[] data = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = data.length-<span class="number">1</span>;</span><br><span class="line">        reverse(data, i, j);</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; data.length) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j == data.length || data[j] == <span class="string">' '</span>) &#123;</span><br><span class="line">        reverse(data, i, j-<span class="number">1</span>);</span><br><span class="line">        i = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">char</span> temp = data[i];</span><br><span class="line">    data[i] = data[j];</span><br><span class="line">    data[j] = temp;</span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="58-2-左旋转字符串"><a href="#58-2-左旋转字符串" class="headerlink" title="58.2 左旋转字符串"></a>58.2 左旋转字符串</h2><h3 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h3><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p><h3 id="题解-65"><a href="#题解-65" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str,<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str == <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n &gt;= str.length())</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">char</span>[] data = str.toCharArray();</span><br><span class="line">        reverse(data, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">        reverse(data, n, data.length-<span class="number">1</span>);</span><br><span class="line">        reverse(data, <span class="number">0</span>, data.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] data, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">char</span> temp = data[i];</span><br><span class="line">    data[i] = data[j];</span><br><span class="line">    data[j] = temp;</span><br><span class="line">    i++;</span><br><span class="line">    j--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60 n个骰子的点数"></a>60 n个骰子的点数</h2><h3 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h3><p>把 n 个骰子仍在地上，求点数和为 s 的概率。</p><h3 id="题解-66"><a href="#题解-66" class="headerlink" title="题解"></a>题解</h3><p>我们以n表示要扔的骰子数，s为所有骰子的点数之和，f(n, s)表示扔n个骰子时所有骰子的点数之和为s的排列情况总数。例如，n=2，s=5时，f(n, s) = f(2, 5) = 4 （4种情况即<code>{1, 4}, {4, 1}, {2, 3}, {3, 2}</code>）</p><p>因为一个骰子有六个点数，那么第n个骰子可能出现1到6的点数，当第n个骰子点数为1的话，f(n,s) = f(n-1, s-1)，当第n个骰子点数为2的话，f(n,s) = f(n-1, s-2)，…，依次类推。</p><p>由以上分析我们便可以得到状态转移方程：<code>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)</code></p><h4 id="使用递归-1"><a href="#使用递归-1" class="headerlink" title="使用递归"></a>使用递归</h4><p>得到状态方程后，最直观的就是使用递归求解。点数和的最小值为骰子数n，而最大值为6 * n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">List&lt;Map.Entry&lt;Integer, Double&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> minSum = n;</span><br><span class="line"><span class="keyword">int</span> maxSum = <span class="number">6</span> * n;</span><br><span class="line"><span class="keyword">double</span> totalCase = Math.pow(<span class="number">6</span>, n);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = minSum; i &lt;= maxSum; i++) &#123;</span><br><span class="line">result.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(i, dicesSumCore(n, i) / totalCase));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dicesSumCore</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||sum&lt;n||sum&gt;<span class="number">6</span>*n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> resCount=<span class="number">0</span>;</span><br><span class="line">    resCount=dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">1</span>)+dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">2</span>)+</span><br><span class="line">    dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">3</span>)+dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">4</span>)+</span><br><span class="line">    dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">5</span>)+dicesSumCore(n-<span class="number">1</span>,sum-<span class="number">6</span>);</span><br><span class="line">    <span class="keyword">return</span> resCount;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>使用递归求解会产生大量重复的计算，所以使用动态规划更好。</p><p>在以下代码中使用了一个二维数组dp[2][maxSum+1]，dp[0]和dp[1]表示当前状态和前一个状态（由状态转移方程<code>f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)</code>可以看出当前状态仅依赖前一个状态，所以只用两个一维数组即可），而这两个状态的数组使用flag变量进行旋转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(<span class="keyword">int</span> n) &#123;</span><br><span class="line">List&lt;Map.Entry&lt;Integer, Double&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span>(n &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line"><span class="keyword">int</span> face = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> minSum = n;</span><br><span class="line"><span class="keyword">int</span> maxSum = face * n;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">double</span> totalCase = Math.pow(face, n);    <span class="comment">//总共有6的n次方种排列情况</span></span><br><span class="line"><span class="keyword">long</span>[][] dp = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">2</span>][maxSum+<span class="number">1</span>]; <span class="comment">//dp[flag][j]表示当前状态下产生点数和为j的排列次数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置初始状态，即f(1,1) = f(1,2) = f(1,3) = f(1,4) = f(1,5) = f(1,6) = 1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= face; i++)</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i表示当前扔出的骰子数，骰子数为1的情况在上面已经有过初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++, flag = <span class="number">1</span> - flag) &#123;</span><br><span class="line"><span class="comment">//将表示当前状态的数组清零</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= maxSum; j++)</span><br><span class="line">            dp[flag][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= maxSum; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= face &amp;&amp; k &lt;= j; k++)</span><br><span class="line">    <span class="comment">//此处即体现出状态转移方程</span></span><br><span class="line">                dp[flag][j] += dp[<span class="number">1</span> - flag][j - k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = minSum; i &lt;= maxSum; i++) &#123;</span><br><span class="line">result.add(<span class="keyword">new</span> AbstractMap.SimpleEntry&lt;&gt;(i, dp[<span class="number">1</span> - flag][i] / totalCase));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="61-扑克牌顺子"><a href="#61-扑克牌顺子" class="headerlink" title="61 扑克牌顺子"></a>61 扑克牌顺子</h2><h3 id="题目描述-67"><a href="#题目描述-67" class="headerlink" title="题目描述"></a>题目描述</h3><p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。大小王可看成任意数字。</p><h3 id="题解-67"><a href="#题解-67" class="headerlink" title="题解"></a>题解</h3><p>把大小王看成0，首先把数组排序，其次统计数组中0的个数，最后统计排序后的数组中相邻数字之间的空缺总数。如果空缺总数小于或者等于0的个数，那么这个数组就是连续的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers == <span class="keyword">null</span> || numbers.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> numOfZero = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numOfGap = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    Arrays.sort(numbers);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length &amp;&amp; numbers[i] == <span class="number">0</span>; i++) &#123;</span><br><span class="line">    numOfZero++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = numOfZero+<span class="number">1</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(numbers[i] == numbers[i-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    numOfGap += numbers[i] - numbers[i-<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfZero &gt;= numOfGap ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62 圆圈中最后剩下的数字"></a>62 圆圈中最后剩下的数字</h2><h3 id="题目描述-68"><a href="#题目描述-68" class="headerlink" title="题目描述"></a>题目描述</h3><p>首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><h3 id="题解-68"><a href="#题解-68" class="headerlink" title="题解"></a>题解</h3><h4 id="环形链表法"><a href="#环形链表法" class="headerlink" title="环形链表法"></a>环形链表法</h4><p>采用链表来模拟整个过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(list.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        index = (index + m - <span class="number">1</span>) % list.size();</span><br><span class="line">        list.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h4><p>我们可以根据此公式使用递归或者循环来做：<code>f(n,m) = [f(n-1,m) + m] % n</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (LastRemaining_Solution(n - <span class="number">1</span>, m) + m) % n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63 股票的最大利润"></a>63 股票的最大利润</h2><h3 id="题目描述-69"><a href="#题目描述-69" class="headerlink" title="题目描述"></a>题目描述</h3><p>假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？</p><h3 id="题解-69"><a href="#题解-69" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximalProfit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices == <span class="keyword">null</span> || prices.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; minPrice)</span><br><span class="line">        minPrice = prices[i];</span><br><span class="line">        <span class="keyword">int</span> currProfit = prices[i] - minPrice;</span><br><span class="line">        <span class="keyword">if</span>(currProfit &gt; maxProfit)</span><br><span class="line">        maxProfit = currProfit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxProfit;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="64-求1-2-···-n"><a href="#64-求1-2-···-n" class="headerlink" title="64 求1+2+···+n"></a>64 求1+2+···+n</h2><h3 id="题目描述-70"><a href="#题目描述-70" class="headerlink" title="题目描述"></a>题目描述</h3><h3 id="题解-70"><a href="#题解-70" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">    <span class="keyword">boolean</span> flag = (sum &gt; <span class="number">0</span>) &amp;&amp; ((sum += Sum_Solution(--n)) &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65 不用加减乘除做加法"></a>65 不用加减乘除做加法</h2><h3 id="题目描述-71"><a href="#题目描述-71" class="headerlink" title="题目描述"></a>题目描述</h3><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p><h3 id="题解-71"><a href="#题解-71" class="headerlink" title="题解"></a>题解</h3><p>十进制加法三步走：<br>1、只做各位相加不进位<br>2、求出进位值<br>3、把前面两个结果加起来</p><p>而对于二进制也正是如此。使用异或完成相加的操作，而使用位与运算再左移完成进位的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum, carry;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">     sum = num1 ^ num2;</span><br><span class="line">     carry = (num1 &amp; num2) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">     num1 = sum;</span><br><span class="line">     num2 = carry;</span><br><span class="line">    &#125; <span class="keyword">while</span>(carry != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>不使用新变量交换两个变量的值:</p><table><thead><tr><th>基于加减法</th><th>基于异或运算</th></tr></thead><tbody><tr><td>a = a + b</td><td>a = a ^ b</td></tr><tr><td>b = a - b</td><td>a = a ^ b</td></tr><tr><td>a = a - b</td><td>a = a ^ b</td></tr></tbody></table><h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66 构建乘积数组"></a>66 构建乘积数组</h2><h3 id="题目描述-72"><a href="#题目描述-72" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] <em> A[1] </em> … <em> A[i-1] </em> A[i+1] <em> … </em> A[n-1]。不能使用除法。</p><h3 id="题解-72"><a href="#题解-72" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">    <span class="keyword">int</span>[] B = <span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">    <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">    </span><br><span class="line">    B[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">    B[i] = B[i-<span class="number">1</span>] * A[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = B.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">    temp = A[i+<span class="number">1</span>] * temp;</span><br><span class="line">    B[i] = temp * B[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67 把字符串转换成整数"></a>67 把字符串转换成整数</h2><h3 id="题目描述-73"><a href="#题目描述-73" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。</p><h3 id="题解-73"><a href="#题解-73" class="headerlink" title="题解"></a>题解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> neg = str.charAt(<span class="number">0</span>) == <span class="string">'-'</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = num;</span><br><span class="line">        num = num * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">            <span class="keyword">if</span>((num - c + <span class="string">'0'</span>) / <span class="number">10</span> != temp) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> neg ? -num : num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="68-1-二叉查找树中两个节点的最低公共祖先"><a href="#68-1-二叉查找树中两个节点的最低公共祖先" class="headerlink" title="68.1 二叉查找树中两个节点的最低公共祖先"></a>68.1 二叉查找树中两个节点的最低公共祖先</h2><h3 id="题目描述-74"><a href="#题目描述-74" class="headerlink" title="题目描述"></a>题目描述</h3><p>找到二叉查找树中两个节点的最低公共祖先</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="题解-74"><a href="#题解-74" class="headerlink" title="题解"></a>题解</h3><p>从根节点开始向下查找直到找到满足<code>root.val &gt;= p.val</code>且<code>root.val &lt;= q.val</code>的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(root != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)</span><br><span class="line">    root = root.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val)</span><br><span class="line">        root = root.right;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="68-2-普通二叉树中两个节点的最低公共祖先"><a href="#68-2-普通二叉树中两个节点的最低公共祖先" class="headerlink" title="68.2 普通二叉树中两个节点的最低公共祖先"></a>68.2 普通二叉树中两个节点的最低公共祖先</h2><h3 id="题目描述-75"><a href="#题目描述-75" class="headerlink" title="题目描述"></a>题目描述</h3><p>找到普通二叉树中两个节点的最低公共祖先</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><h3 id="题解-75"><a href="#题解-75" class="headerlink" title="题解"></a>题解</h3><p>深度优先搜索的思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span> || root.val == p.val || root.val == q.val)</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    </span><br><span class="line">    TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">    TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    <span class="keyword">return</span> left == <span class="keyword">null</span> ? right : right == <span class="keyword">null</span> ? left : root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;3-1-找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#3-1-找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;3.1 找出数组中重复的数字&quot;&gt;&lt;/a&gt;3.1 找出数组中重复的数字&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h3&gt;&lt;p&gt;在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询性能优化</title>
    <link href="http://yoursite.com/2019/01/28/MySQL%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/01/28/MySQL查询性能优化/</id>
    <published>2019-01-28T14:33:00.000Z</published>
    <updated>2019-01-28T14:34:09.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优化数据访问"><a href="#优化数据访问" class="headerlink" title="优化数据访问"></a>优化数据访问</h1><h2 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h2><ul><li>只返回必要的行：使用<code>LIMIT</code>语句来限制返回的数据。</li><li>只返回必要的列：最好不要使用<code>SELECT *</code>语句。</li><li>缓存重复查询的数据。</li></ul><a id="more"></a><h2 id="减少服务器端扫描的行数"><a href="#减少服务器端扫描的行数" class="headerlink" title="减少服务器端扫描的行数"></a>减少服务器端扫描的行数</h2><p>最有效的方式是使用索引来覆盖查询。</p><h1 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h1><h2 id="切分查询"><a href="#切分查询" class="headerlink" title="切分查询"></a>切分查询</h2><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。因此可以将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。</p><h2 id="分解关联查询"><a href="#分解关联查询" class="headerlink" title="分解关联查询"></a>分解关联查询</h2><p>可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。这么做有如下优势：</p><ul><li>让缓存的效率更高。对于关联查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>将查询分解后，执行单个查询可以减少锁的竞争。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li></ul><h1 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h1><p><img src="http://blog.default.nanwulife.com/201759140033188.jpg" alt=""></p><ol><li>客户端发送一条查询给服务器。</li><li>服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li><li>服务器端进行SQL解析、预处理再由优化器生成对应的执行计划。</li><li>MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。</li><li>将结果返回给客户端。</li></ol><p>MySQL解析器将使用MySQL语法规则验证和解析查询；预处理器则根据一些MySQL规则进一步检查解析树是否合法，例如检查数据表和数据列是否存在，之后会验证权限；查询优化器的作用是根据存储引擎提供的统计信息找出一个最优的执行计划。</p><h1 id="优化-Limit-分页"><a href="#优化-Limit-分页" class="headerlink" title="优化 Limit 分页"></a>优化 Limit 分页</h1><p>在偏移量特别大的时候，例如可能是<code>LIMIT 1000, 20</code>这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面10000条记录都将被抛弃，这样的代价非常高。可以通过延迟关联和书签两个技巧进行优化。</p><h2 id="延迟关联"><a href="#延迟关联" class="headerlink" title="延迟关联"></a>延迟关联</h2><p>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。考虑下面的查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film_id, description <span class="keyword">FROM</span> sakila.film <span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>, <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>此时没有覆盖索引，因此要回表获取记录55条，而只返回最后5条1。这时候可以用延迟关联的技巧改写成如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> film.film_id, film.description</span><br><span class="line"><span class="keyword">FROM</span> sakila.film</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span>(</span><br><span class="line"><span class="keyword">SELECT</span> film_id <span class="keyword">FROM</span> sakala.film</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> title <span class="keyword">LIMIT</span> <span class="number">50</span>, <span class="number">5</span></span><br><span class="line">) <span class="keyword">AS</span> lim <span class="keyword">USING</span>(film_id);</span><br></pre></td></tr></table></figure><p>这时候子查询中能使用覆盖索引，因此在索引结构中就能获取到需要访问的记录而无需回表，之后再根据关联列回表查询需要的所有列。</p><h2 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h2><p><code>LIMIT</code>和<code>OFFSET</code>的问题，其实是<code>OFFSET</code>的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用<code>OFFSET</code>。例如，若需要按照租借记录做翻页，那么可以根据最新一条租借记录向后追溯，首先使用下面的查询获得第一组结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sakila.rental</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>会返回49到30的记录，那么下一页查询就可以从30这个点开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> sakila.rental</span><br><span class="line"><span class="keyword">WHERE</span> rental_id &lt; <span class="number">30</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> rental_id <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>该技术的好处是无论翻页到多么后面，其性能都会很好。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>高性能 MySQL[M]. 电子工业出版社, 2013.</li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%E4%B8%83%E3%80%81juc-aqs" target="_blank" rel="noopener">CS-Notes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;优化数据访问&quot;&gt;&lt;a href=&quot;#优化数据访问&quot; class=&quot;headerlink&quot; title=&quot;优化数据访问&quot;&gt;&lt;/a&gt;优化数据访问&lt;/h1&gt;&lt;h2 id=&quot;减少请求的数据量&quot;&gt;&lt;a href=&quot;#减少请求的数据量&quot; class=&quot;headerlink&quot; title=&quot;减少请求的数据量&quot;&gt;&lt;/a&gt;减少请求的数据量&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;只返回必要的行：使用&lt;code&gt;LIMIT&lt;/code&gt;语句来限制返回的数据。&lt;/li&gt;
&lt;li&gt;只返回必要的列：最好不要使用&lt;code&gt;SELECT *&lt;/code&gt;语句。&lt;/li&gt;
&lt;li&gt;缓存重复查询的数据。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
</feed>
