<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-22T12:32:14.001Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Simple IoC开发日志：加载Bean</title>
    <link href="http://yoursite.com/2019/05/21/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9AgetBean/"/>
    <id>http://yoursite.com/2019/05/21/Simple-IoC开发日志：getBean/</id>
    <published>2019-05-21T10:43:00.000Z</published>
    <updated>2019-05-22T12:32:14.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>在之前加载注册<code>BeanDefinition</code>完成后，Spring已经存在一组<code>beanName</code> - &gt;<code>BeanDefinition</code>的映射了，接下来我们就可以根据名称或类型实例化并获取我们想要的Bean，而和这个实例化Bean相关的则是整个<code>BeanFactory</code>体系。接下来我们从<code>doGetBean()</code>这个方法开始分析起，这个方法涵盖了实例化Bean的总流程，大致步骤如下：</p><ol><li>将 alias name、FactoryBean name 转换为对应的<code>beanName</code></li><li>尝试从缓存中获取单例Bean</li><li>如果缓存中不存在，则从父类容器中加载</li><li>合并父类的属性，获取<code>RootBeanDefinition</code></li><li>加载所依赖的Bean</li><li>根据不同的<code>scope</code>实例化Bean</li><li>类型转换处理，如果传递的<code>requiredType</code>不为<code>null</code>，则需要检测所得到的Bean的类型是否与该<code>requiredType</code>一致。</li></ol><p>首先，如果名称是以<code>&amp;</code>开头的，则去掉<code>&amp;</code>，并且根据别名获取到<code>beanName</code>，然后尝试从单例缓存中获取Bean，这也正是解决循环依赖的关键，第一次获取时是没有效果的，继续往下走。此时判断是否发生原型模式的循环依赖，如果发生了，则抛出异常。接下来根据<code>beanName</code>从映射中获取到<code>BeanDefinition</code>（其实是<code>RootBeanDefinition</code>），然后优先加载所依赖的Bean（<code>depends-on</code>标签），然后根据不同的<code>scope</code>分别实例化Bean，完成<code>FactoryBean</code>的相关处理，最后做类型转换即可，不过目前不会去关心这个类型转换。下面开始分析比较重要的几个步骤。</p><h3 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h3><p>Bean会根据不同的<code>scope</code>采取不同的实例化策略，总共有五种<code>scope</code>：<code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code>、<code>global session</code>，其实比较常用的也就<code>singleton</code>和<code>prototype</code>，而<code>prototype</code>不需要解决循环依赖的问题，直接反射创建就好了，重点需要关注的是<code>singleton</code>的实例化过程。</p><p>接下来从<code>getSingleton()</code>这个方法进入Bean实例化的正戏。这个方法的开始可以看到用到了双重校验锁，因为多个线程可能在之前同时判断缓存中没有Bean，就都进入到了这里，但为了保证不重复实例化Bean（单例模式），在获取锁之后还会再判断一次是否能从缓存中获取，这里是要注意的。接下来通过<code>ObjectFactory#getObject()</code>方法开始实例化，里面会调用<code>doCreateBean()</code>方法，然后经历以下几个步骤：</p><ol><li>使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化。此时Bean已经被创建出来了，只是没有进行属性填充和初始化</li><li>如果为单例模式、允许循环依赖且当前单例Bean正在被创建，那么将其加入到三级缓存<code>singletonFactories</code>中</li><li>属性填充</li><li>调用初始化方法<br> 4.1. 激活<code>Aware</code>方法，对特殊的Bean处理<br>4.2. 调用<code>postProcessBeforeInitialization()</code><br>4.3. 如果实现了<code>InitializingBean</code>接口，调用其<code>afterPropertiesSet()</code>方法；如果指定了<code>init-method</code>，则调用指定的<code>init-method</code><br>4.4. 调用<code>postProcessAfterInitialization()</code></li><li>注册Bean的销毁方法。与<code>InitializingBean</code>和<code>init-method</code>用于对象的自定义初始化工作相似，<code>DisposableBean</code>和<code>destroy-method</code>用于对象的自定义销毁工作。但这里并不是立刻执行，而是先注册，等到Spring容器关闭的时候才去调用，并且需要我们主动去告知Spring容器，对于<code>BeanFactory</code>容器需要调用<code>destroySingletons()</code>方法，对于<code>ApplicationContext</code>容器需要调用<code>registerShutdownHook()</code>方法。</li></ol><p>到这里，我们就获取到一个Bean了，下面对其中的一些细节进行解释。</p><h3 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h3><p>在这个方法中，完成了Bean的实例化（注意，此时还没填充属性等等），Spring提供了四种实例化策略：</p><ol><li><code>Supplier</code>回调：从<code>BeanDefinition</code>中获取<code>Supplier</code>对象，如果不为空，则调用<code>obtainFromSupplier()</code>方法完成Bean的初始化</li><li>工厂方法初始化</li><li>构造函数自动注入初始化</li><li>默认构造函数注入</li></ol><p>工厂方法初始化的工厂分为静态工厂和实例工厂，静态工厂的配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eat"</span> <span class="attr">class</span>=<span class="string">"it.spring.liao.com.EatFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>实例工厂的配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eatFactory"</span> <span class="attr">class</span>=<span class="string">"it.spring.liao.com.EatFactory "</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eat"</span> <span class="attr">factory-bean</span>=<span class="string">"eatFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果配置了构造函数的自动注入或者配置了构造函数参数，则调用带参的构造函数去实例化Bean。因为一个类有多个构造函数，每个构造函数都有不同的构造参数，需要根据参数个数和类型确定最精确匹配的构造函数，这部分的源码还是十分复杂的。</p><p>对于带参构造函数或默认构造函数，都会先判断是否有覆盖方法，如果有的话则使用CGLIB创建代理对象，否则通过反射来创建Bean（核心代码其实就是<code>constructorToUse.newInstance()</code>）。</p><p>而对于工厂方法，其实也就是通过该<code>Method</code>反射创建Bean（核心代码其实就是<code>factoryMethod.invoke(factoryBean, args)</code>）。</p><h3 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h3><p>先看一下Spring中关于这块的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() <span class="comment">// 如果为单例模式</span></span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">// 允许循环依赖</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName));<span class="comment">// 当前单例 Bean 正在被创建</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法的调用发生在 createBeanInstance() 方法之后，也就是说这个 bean 其实已经创建出来了，但是没有进行属性填充和初始化，</span></span><br><span class="line"><span class="comment">// 但是此时已经可以根据对象引用定位到堆中该对象了，所以将该对象提前曝光出来，加入到三级缓存 singletonFactories 中</span></span><br><span class="line"><span class="comment">// 这里是为了后期避免循环依赖</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring IoC是通过三级缓存这么个机制解决循环依赖的问题的，每次在调用<code>createBeanInstance()</code>方法实例化一个Bean后，就将这个Bean加入到三级缓存<code>singletonFactories</code>中，而此时如果依赖的属性又依赖于自己，即发生循环依赖的话，那么就会直接从三级缓存中拿到这个Bean，并将其升级到二级缓存中去，如果后续还有循环依赖的话，直接从二级缓存就能获取到结果。需要注意的是，这时候的Bean仅仅只是实例化了出来，并没有进行属性填充等操作，只有当一切都完成后，才会将这个Bean升级到一级缓存中去。</p><h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>上面已经实例化出了Bean，并且加入到三级缓存中了，但是这个Bean还有许多事没做完，接下来第一件事就是对其进行属性填充，也就是<code>populateBean()</code>这个方法，它的大体步骤如下：</p><ol><li>获取Bean的属性值，也就是<code>PropertyValues</code></li><li>根据名称或类型解析依赖（此时并未注入到Bean中，仅仅将属性放到了`pvs中）</li><li>调用<code>applyPropertyValues()</code>真正注入属性：<br> 3.1. 检测属性值列表是否已经转换过，若转换过，则直接填充属性，无需再次转换<br>3.2. 遍历属性值列表<code>pvs</code>，解析原始值<code>originalValue</code>，得到解析值<code>resolvedValue</code><br>3.3. 对解析后的属性值<code>resolvedValue</code>进行类型转换<br>3.4. 将类型转换后的属性值设置到<code>PropertyValue</code>对象中，并将<code>PropertyValue</code>对象存入<code>deepCopy</code>集合中<br>3.5. 将<code>deepCopy</code>中的属性信息注入到Bean对象中</li></ol><p>首先讲讲根据名称或类型解析依赖。<code>autowireByName()</code>方法主要完成了以下几件事：</p><ol><li>获取Bean对象中的非简单属性名，即类型为对象类型的属性，<code>String</code>、<code>Enum</code>、<code>Date</code>、<code>URI/URL</code>、<code>Number</code>的继承类如<code>Integer/Long</code>、<code>byte/short/int</code>等基本类型、<code>Locale</code>、以上所有类型的数组形式。</li><li>遍历那些非简单属性名，如果容器中包含该名称对应的Bean，则递归实例化该Bean（也就是调用<code>getBean()</code>方法）</li><li>将递归获取到的Bean存入到属性值列表<code>PropertyValues</code>中</li><li>注册依赖（就是建立映射关系）</li></ol><p><code>autowireByType()</code>方法比<code>autowireByName()</code>方法复杂一些，因为相同类型的Bean可能有多个，它最核心的思路如下：</p><ol><li>根据类型查找所有合适的候选Bean。比如说我们的成员变量是<code>Dao</code>类型的，那么此时<code>MongoDao</code>和<code>MySQLDao</code>这两个Bean可能都属于合适的候选项，因为它们都实现了<code>Dao</code>接口。</li><li>如果没有找到合适的候选Bean，并且<code>autowire</code>的<code>require</code>属性为<code>true</code>，则直接抛出异常</li><li>当候选者不唯一时，则依次根据<code>Primary</code>、<code>Priority</code>决定最终的候选Bean（此时拿到了<code>autowiredBeanName</code>和<code>instanceCandidate</code>）</li><li>当候选者唯一时，可以直接决定候选Bean（此时拿到了<code>autowiredBeanName</code>和<code>instanceCandidate</code>）</li><li>候选Bean可能并没有实例化，也就是<code>instanceCandidate</code>仅仅为<code>Class</code>类型，比如说是<code>MySQLDao.class</code>，此时根据<code>beanFactory.getBean(autowiredBeanName)</code>方法实例化该Bean</li><li>返回已实例化好的Bean</li></ol><p>接下来就和<code>autowireByName()</code>方法一样了，将获取到的Bean存入到属性值列表<code>PropertyValues</code>中，并且注册这个依赖关系。此时，<code>&lt;property&gt;</code>标签表示的属性和自动注入的属性都已经解析到<code>PropertyValues</code>中了，调用<code>applyPropertyValues()</code>开始真正的属性注入，该方法核心步骤如下：</p><ol><li>将<code>ref</code>（在之前解析标签时将其封装成了<code>RuntimeBeanReference</code>）解析为具体的对象，将<code>&lt;list&gt;</code>标签转换为<code>List</code>对象，还会解析<code>&lt;set/&gt;</code>、<code>&lt;map/&gt;</code>、<code>&lt;array/&gt;</code>等标签。</li><li>对属性值的类型进行转换，比如将<code>String</code>类型的属性值<code>&quot;123&quot;</code>转换为<code>Integer</code>类型的<code>123</code></li><li>反射设置<code>PropertyValues</code>中的所有属性</li></ol><p>至此，属性值已经注入到Bean中了。</p><h3 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h3><p>填充完属性，接下来就是调用初始化方法，该方法的步骤如下：</p><ol><li>激活<code>Aware</code>方法：Bean可以实现<code>Aware</code>接口，从而对当前环境进行感知（就是实现了<code>setXXX()</code>方法）。在这里，会针对<code>BeanNameAware</code>、<code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code>三种<code>Aware</code>接口进行判断，将一些值设置到当前Bean中。</li><li>调用<code>postProcessBeforeInitialization()</code>方法</li><li>调用<code>invokeInitMethods()</code>方法：<br> 3.1. 如果Bean实现了<code>InitializingBean</code>接口，那么会先调用该接口的<code>afterPropertiesSet()</code>方法<br>3.2. 检查是否指定了<code>init-method</code>，如果指定了则通过反射机制调用<code>init-method</code>方法</li><li>调用<code>postProcessAfterInitialization()</code>方法</li></ol><p>至此，几个核心步骤就都介绍完了。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><p>Simple IoC的实现大体思路上与Spring IoC一致，但是尚不支持<code>&lt;list/&gt;</code>等一些集合标签，并且不像Spring实现了一套类型转换体系，这里直接使用了<code>apache</code>的<code>BeanUtils</code>完成类型转换相关的操作。除此之外，暂时还未实现<code>initializeBean()</code>相关的逻辑。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>第一个测试是模拟登陆接口的场景，分为<code>Controller</code>、<code>Service</code>、<code>Dao</code>三层，XML配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginController"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.LoginController"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginService"</span> <span class="attr">ref</span>=<span class="string">"loginService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginService"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.LoginServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.UserDao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\login.xml"</span>);</span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line">    LoginController loginController = (LoginController) factory.getBean(<span class="string">"loginController"</span>);</span><br><span class="line">    assertEquals(loginController.login(<span class="string">"Lihua"</span>, <span class="string">"123456789"</span>), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个测试是针对循环依赖问题的，XML配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.persons.Person"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Lihua"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idCard"</span> <span class="attr">ref</span>=<span class="string">"idCard"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idCard"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.persons.IdCard"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"441301188875468912"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"owner"</span> <span class="attr">ref</span>=<span class="string">"person"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCyclicDependence</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\persons.xml"</span>);</span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line">    Person person = (Person) factory.getBean(<span class="string">"person"</span>);</span><br><span class="line">    IdCard idCard = (IdCard) factory.getBean(<span class="string">"idCard"</span>);</span><br><span class="line">    assertEquals(person.getName(), <span class="string">"Lihua"</span>);</span><br><span class="line">    assertEquals(person.getAge(), <span class="number">18</span>);</span><br><span class="line">    assertEquals(person.getIdCard(), idCard);</span><br><span class="line">    assertEquals(idCard.getId(), <span class="number">441301188875468912L</span>);</span><br><span class="line">    assertEquals(idCard.getOwner(), person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;在之前加载注册&lt;code&gt;BeanDefinition&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：注册BeanDefinitions</title>
    <link href="http://yoursite.com/2019/05/19/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9ABeanDefinition%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/19/Simple-IoC开发日志：BeanDefinition加载/</id>
    <published>2019-05-19T14:29:00.000Z</published>
    <updated>2019-05-20T08:04:26.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>在之前已经介绍过Spring IoC对资源的抽象了，也就是<code>Resource</code>接口。当我们加载了指定的资源后，接下来需要做的就是将资源（也就是XML文件）解析成<code>Document</code>实例，并解析成<code>BeanDefinition</code>然后注册。这个过程的整体流程如下：</p><ol><li><code>loadBeanDefinitions(Resource resource)</code>作为方法入口。</li><li><code>doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code>方法实现了真正的加载逻辑，它首先根据XML获取<code>Document</code>实例，然后根据<code>Document</code>实例注册Bean信息。<br> 2.1. <code>doLoadDocument()</code>方法根据XML获取<code>Document</code>实例，其中会牵扯到获取验证模式和错误处理等过程。<br> 2.2. <code>registerBeanDefinitions()</code>遍历XML的每一个节点并注册它们的<code>BeanDefinition</code>。</li></ol><p>接下来就上面获取<code>Document</code>实例和注册<code>BeanDefinition</code>进行分析。</p><h3 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h3><p>解析XML有两种方式，一种是DOM解析，另一种则是SAX解析，关于这两个解析方式在网上也有比较充足的资料，就不在这赘述了。在这一个过程还有两个方面是需要关心的，一个是验证模式，另一个是错误处理（还有一个是Spring实现的<code>EntityResolver</code>，自定义了验证文件的获取方式，在本地建立了一个映射而不需要从网络中获取）。</p><p>首先，验证模式同样也有两种，一种是DTD验证模式，另一种是XSD验证模式。因此，在这里需要根据XML文件中的一些信息来探测决定具体使用哪种验证模式，比如说如果内容中包含<code>DOCTYPE</code>则肯定为DTD验证模式，而如果探测不出的话，最终会使用XSD验证模式。错误处理就是当加载<code>Document</code>发生错误时需要做出的反应，简单的实现就是输出错误日志。当以上两个都准备好了后，就先通过<code>DocumentBuilderFactory</code>创建一个<code>DocumentBuilder</code>，再调用<code>DocumentBuilder</code>的<code>parse()</code>方法直接解析并返回一个<code>Document</code>实例即可。</p><h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>注册<code>BeanDefinition</code>实际上就是通过上面获取到的<code>Document</code>的根节点开始逐个遍历子节点（要先判断根节点是否使用的默认命名空间），然后根据<code>&lt;import/&gt;</code>、<code>&lt;alias/&gt;</code>、<code>&lt;bean/&gt;</code>、<code>&lt;beans/&gt;</code>这四种标签分别进行解析，其中<code>&lt;beans/&gt;</code>标签的处理是一个递归的过程，而<code>&lt;bean/&gt;</code>标签的处理则是需要重点关注的，在这个过程中主要分为两步：解析出<code>BeanDefinition</code>并且完成注册。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><h3 id="获取Document-1"><a href="#获取Document-1" class="headerlink" title="获取Document"></a>获取Document</h3><p>目前仅支持XSD格式的验证，并且没有实现<code>EntityResolver</code>，也就是说无法根据自定义的策略从本地拿到验证文件，还是默认的从网络中获取。</p><h3 id="注册BeanDefinition-1"><a href="#注册BeanDefinition-1" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>在目前的实现中，并没有像Spring IoC一样支持四种标签的解析，这里只解析了<code>&lt;bean/&gt;</code>标签。之后，需要重点关注的一个方法就是<code>parseBeanDefinitionElement()</code>，这是解析<code>&lt;bean/&gt;</code>标签的核心逻辑，主要完成了从<code>&lt;bean/&gt;</code>标签的<code>id</code>属性和<code>name</code>属性还有一些别的属性以及子元素中获取到值并组装成一个<code>BeanDefinition</code>（实际上还会包装一层<code>BeanDefinitionHolder</code>，其中保存了<code>beanName</code>和<code>aliases</code>），下面对这一部分的细节进行分析。</p><h4 id="parseBeanDefinitionElement"><a href="#parseBeanDefinitionElement" class="headerlink" title="parseBeanDefinitionElement"></a>parseBeanDefinitionElement</h4><p>这个方法主要完成以下这些事：</p><ol><li>解析出<code>&lt;bean&gt;</code>标签中的<code>id</code>属性和<code>name</code>属性，在Spring中是以<code>,</code>作为分隔符取得多个别名，但在这里的实现中只考虑一种别名的情况，也就是没有使用<code>,</code>进行分割。</li><li>优先使用id作为<code>beanName</code>，但如果并没有设置<code>id</code>属性的话，就使用第一个别名作为<code>beanName</code>，那么在这里就只有唯一的一个别名，当id没设置时它就是<code>beanName</code>。</li><li>检查<code>beanName</code>和别名的唯一性，如果不唯一，则抛出异常，唯一的话则加入到集合中去。（注意，别名也是需要唯一的）</li><li>解析别的属性以及子元素，开始构造<code>AbstractBeanDefinition</code>。上面几步只是对名称做一些解析，这一步的工作量则相对要大很多，下面是一些比较常见的属性：<br> 4.1. 解析<code>class</code>属性，最重要的了<br>4.2. 解析<code>parent</code>属性，未实现<br>4.3. 解析<code>scope</code>属性<br>4.4. 解析<code>autowire</code>属性<br>4.5. 解析<code>init-method</code>属性<br>4.6. 解析<code>destroy-method</code>属性<br>4.7. 解析<code>factory-bean</code>属性<br>4.8. 解析<code>factory-method</code>属性<br>4.9. 解析<code>&lt;lookup-method/&gt;</code>子元素，未实现<br>4.10. 解析<code>&lt;replaced-method/&gt;</code>子元素，未实现<br>4.11. 解析<code>&lt;property/&gt;</code>子元素，这一步也很重要，它将属性名和属性值封装到了<code>PropertyValue</code>中，并且用<code>PropertyValues</code>封装所有属性（也就是每个<code>BeanDefinition</code>都有一个<code>PropertyValues</code>类型的成员变量）。<br>4.12. 解析<code>&lt;constructor-arg/&gt;</code>子元素，未实现</li><li>此时已经构造出了一个相对完整的<code>BeanDefinition</code>了，这时候将其和<code>beanName</code>与别名一起封装成<code>BeanDefinitionHolder</code>对象。</li><li>注册<code>beanName</code> -&gt; <code>BeanDefinition</code>以及<code>alias</code> -&gt; <code>beanName</code>的映射关系（个人认为，这正是IoC的本质所在，通过一个映射表维护一个名称到<code>BeanDefinition</code>的关系，而这个<code>BeanDefinition</code>中封装了这个Bean的各种信息）。这里要注意的是，在注册<code>alias</code> -&gt; <code>beanName</code>的映射关系时，Spring考虑了别名循环指向的问题，它是通过递归来进行判断的。</li><li>此时，这个<code>BeanDefinition</code>已经注册成功，可以等待使用了</li></ol><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>针对根据XML获取<code>Document</code>实例并注册<code>BeanDefinition</code>的过程做一些简单的测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadBeanDefinitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\simple.xml"</span>);</span><br><span class="line">    BeanDefinitionRegistry registry = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);</span><br><span class="line">    assertEquals(beanDefinitionReader.loadBeanDefinitions(resource), <span class="number">2</span>);</span><br><span class="line">    assertEquals(((DefaultListableBeanFactory) registry).getBeanDefinition(<span class="string">"first"</span>).getBeanClassName(),</span><br><span class="line">            <span class="string">"beans.First"</span>);</span><br><span class="line">    assertEquals(((DefaultListableBeanFactory) registry).getBeanDefinition(<span class="string">"second"</span>).getBeanClassName(),</span><br><span class="line">            <span class="string">"beans.Second"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;在之前已经介绍过Spring IoC对资源的抽象了，也就是&lt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="IoC" scheme="http://yoursite.com/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：资源加载</title>
    <link href="http://yoursite.com/2019/05/19/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9A%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/19/Simple-IoC开发日志：资源加载/</id>
    <published>2019-05-19T13:51:40.000Z</published>
    <updated>2019-05-19T14:04:00.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>Spring对资源文件和资源的加载都做了统一的抽象，以下是资源文件的继承体系：<br><img src="http://blog.default.nanwulife.com/spring-201805091003.jpg" alt=""></p><p>其中，顶层接口<code>InputStreamSource</code>只包含一个<code>getInputStream()</code>方法用于返回指定资源的<code>InputStream</code>；而<code>Resource</code>是对资源的一个抽象，里面提供了判断资源是否存在、资源是否可读、资源大小等常见接口，并且大部分接口由抽象子类<code>AbstractResource</code>提供了默认实现，而一些方法则由具体的子类如<code>FileSystemResource</code>、<code>ClassPathResource</code>等覆写，以满足特定的场景需求。</p><p>接下来看看Spring对资源加载的统一抽象，同样从它的继承体系说起：<br><img src="http://blog.default.nanwulife.com/FileSystemResourceLoader.png" alt=""></p><p>与<code>AbstractResource</code>相似，<code>DefaultResourceLoader</code>是<code>ResourceLoader</code>的默认实现。其中<code>getResource()</code>方法是其核心（两个子类都没覆盖该方法），它根据方法参数<code>location</code>的内容来决定到底是返回<code>ClassPathResource</code>还是<code>FileSystemResource</code>还是<code>Resource</code>其它的一些子类。由于在默认的实现策略中，凡是以<code>/</code>开头的都会返回<code>ClassPathContextResource</code>类型的资源，但对于<code>/user/hecenjie/test.xml</code>这样的路径我们更加希望是<code>FileSystemResource</code>类型的资源，因此在子类<code>FileSystemResourceLoader</code>中覆写了相关方法，使之可以从文件系统中获取资源；而另一个子类<code>ClassRelativeResourceLoader</code>则扩展了功能，可以根据给定的Class所在包或者所在包的子包下加载资源。</p><p><code>ResourceLoader</code>的另一个重要实现是<code>ResourcePatternResolver</code>，与上面的<code>ResourceLoader</code>实现类不同的是，它支持根据指定的资源路径匹配模式每次返回多个<code>Resource</code>实例（也就是<code>Resource</code>数组），并且它也新增了一种新的协议前缀<code>classpath*:</code>，该前缀表示可以加载多个jar包中相同的资源文件，而<code>classpath:</code>只能加载找到的第一个文件。</p><p><code>PathMatchingResourcePatternResolver</code>除了支持<code>ResourceLoader</code>和<code>ResourcePatternResolver</code>新增的<code>classpath*:</code>前缀外，还支持Ant风格的路径匹配模式（类似于<code>**/*.xml</code>）。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><p>目前自己实现的IoC容器中，只实现了文件系统的资源与加载抽象，以下为它们各自的类图：<br><img src="http://blog.default.nanwulife.com/FileSystemResource.png" alt=""> </p><p><img src="http://blog.default.nanwulife.com/FileSystemResourceLoader1.png" alt=""></p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>我们可以尝试写一些简单的单元测试从文件系统中加载指定的资源，并对该资源做一些基本操作。首先，准备一个<code>test.xml</code>文件，然后编写以下测试方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSystemResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> FileSystemResource(<span class="string">"C:\\Users\\canjie\\Desktop\\test.xml"</span>);</span><br><span class="line">    assertTrue(resource.exists());</span><br><span class="line">    assertEquals(resource.contentLength(), <span class="number">992</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSystemResourceLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\test.xml"</span>);</span><br><span class="line">    assertTrue(resource.exists());</span><br><span class="line">    assertEquals(resource.contentLength(), <span class="number">992</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;Spring对资源文件和资源的加载都做了统一的抽象，以下是资
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis之Mapper接口</title>
    <link href="http://yoursite.com/2019/05/19/Mybatis%E4%B9%8BMapper%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/05/19/Mybatis之Mapper接口/</id>
    <published>2019-05-19T11:26:00.000Z</published>
    <updated>2019-05-19T11:27:08.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MyBatis有两种方式能和数据库打交道，一种是直接调用<code>SqlSession</code>的<code>select()</code>、<code>update()</code>等方法，传入statementId参数即可；另一种则是通过Mapper接口，这种方式在实际应用中更加常见，因为它使我们可以使用面向接口编程的方式操作数据库。</p><h2 id="XML映射文件"><a href="#XML映射文件" class="headerlink" title="XML映射文件"></a>XML映射文件</h2><p>Mybatis将所有XML配置信息都封装到<code>Configuration</code>内部，在XML映射文件中：</p><ul><li><code>&lt;parameterMap&gt;</code>标签，会被解析为<code>ParameterMap</code>对象，其每个子元素会被解析为<code>ParameterMapping</code>对象</li><li><code>&lt;resultMap&gt;</code>标签，会被解析为<code>ResultMap</code>对象，其每个子元素会被解析为<code>ResultMapping</code>对象</li><li>每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，均会被解析为一个<code>MappedStatement</code>对象，标签内的SQL会被解析为一个<code>BoundSql</code>对象</li></ul><h2 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h2><p>在MyBatis中，Mapper接口是与XML映射文件相对应的，它们之间的对应关系如下：</p><ul><li>接口的全限名，就是映射文件中的<code>namespace</code>的值</li><li>接口的方法名，就是映射文件中<code>MappedStatement</code>的<code>id</code>值</li><li>接口方法内的参数，就是传递给SQL的参数</li></ul><p>当调用接口方法时，通过接口全限名+方法名可唯一定位一个对应的<code>MappedStatement</code>，MyBatis会使用JDK动态代理自动为该Mapper接口生成代理对象，而这个代理对象会拦截接口的方法，从而调用对应的<code>MappedStatement</code>方法，最终执行SQL语句并返回执行结果。</p><p>也正因为是全限名+方法名的保存和寻找策略，所以Mapper接口里的方法是不能重载的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://svip.iocoder.cn/MyBatis/Interview/" target="_blank" rel="noopener">精尽 MyBatis 面试题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MyBatis有两种方式能和数据库打交道，一种是直接调用&lt;code&gt;SqlSession&lt;/code&gt;的&lt;code&gt;select()&lt;/co
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Spring MVC：请求处理流程</title>
    <link href="http://yoursite.com/2019/05/19/Spring-MVC%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/19/Spring-MVC：请求处理流程/</id>
    <published>2019-05-19T09:12:00.000Z</published>
    <updated>2019-05-19T10:01:03.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p><img src="http://blog.default.nanwulife.com/20180708224853769.png" alt=""></p><h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>虽然在上面的整体流程图中，我们看到请求首先是被<code>DispatcherServlet</code>所处理，但是实际上，<code>FrameworkServlet</code>才是真正的入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// &lt;1&gt; 获得请求方法</span></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="comment">// &lt;2.1&gt; 处理 PATCH 请求</span></span><br><span class="line"><span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="comment">// &lt;2.2&gt; 调用父类，处理其它请求</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当不是<code>PATCH</code>请求时，会调用父类<code>HttpServlet</code>的<code>service()</code>方法，在这个方法中调用由子类<code>FrameworkServlet</code>实现的<code>doGet()</code>、<code>doPost()</code>、<code>doPut()</code>、<code>doDelete()</code>等各种方法上，而这些方法最终会调用<code>processRequest()</code>方法，处理请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doService(request, response);   <span class="comment">// 执行真正的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法，交由子类 DispatcherServlet 实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p><code>DispatcherServlet</code>实现了<code>FrameworkServlet</code>的<code>doService()</code>方法，这个方法中会调用到<code>doDispatch()</code>执行请求的分发，而这个过程正是处理请求的核心逻辑，也对应着本文最开始的流程图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);<span class="comment">// 检查是否是上传请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取可处理当前请求的处理器</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果获取不到，则调用 noHandlerFound 根据配置抛出异常或返回 404</span></span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取可执行处理器逻辑的适配器</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">String method = request.getMethod();    <span class="comment">// 处理 last-modified 消息头</span></span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行拦截器 preHandle 方法</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 真正调用处理器逻辑（一般就是在这里调用我们的 Controller 方法）</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 controller 未返回 view 名称，这里生成默认的 view 名称</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行拦截器 postHandle 方法</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 解析并渲染视图</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line"><span class="comment">// 如果是上传请求，清理资源</span></span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个过程涉及以下几个核心组件：</p><ul><li><code>DispatcherServlet</code>：请求入口，负责协调各个组件工作</li><li><code>HandlerMapping</code>：内部维护了一些&lt;访问路径，处理器&gt;映射，负责为请求找到合适的处理器</li><li><code>HandlerAdapter</code>：处理器的适配器。Spring中的处理器的实现多变，比如用户处理器可以实现<code>Controller</code>接口，也可以用<code>@RequestMapping</code>注解将方法作为一个处理器等，这就导致 Spring 不止到怎么调用用户的处理器逻辑。所以这里需要一个处理器适配器，由处理器适配器去调用处理器的逻辑</li><li><code>ViewResolver</code>：根据视图名查找获得视图对象<code>View</code></li><li><code>View</code>：视图对象用于将模板渲染成html或其他类型的文件。比如<code>InternalResourceView</code>可将jsp渲染成 html。</li></ul><p>完整流程虽然像上面那样，但在目前主流的架构中，前后端已经彻底分离了，所以也就将View移交给了前端，上面的视图解析与渲染步骤已不再需要，而是当Handler（Controller）执行完后，判断方法是否有<code>@ResponseBody</code>注解，有的话则直接将结果写回给用户。但是由于HTTP是不支持返回Java POJO对象的，所以还需要将结果使用<code>HttpMessageConverter</code>进行转换后才能返回。</p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>根据请求获得相应的处理器和拦截器们（<code>HandlerInterceptor</code>数组 )，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerMapping.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".bestMatchingPattern"</span>;</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".uriTemplateVariables"</span>;</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".matrixVariables"</span>;</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".producibleMediaTypes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得请求对应的处理器和拦截器们</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的对象类型是<code>HandlerExecutionChain</code>，它包含处理器（<code>handler</code>）和拦截器们（<code>HandlerInterceptor</code>数组），简单代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerExecutionChain.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 处理器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 拦截器数组 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是处理器的类型是<code>Object</code>。</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>因为处理器<code>handler</code>的类型是<code>Object</code>类型，需要有一个调用者来实现<code>handler</code>是怎么被使用，怎么被执行，而<code>HandlerAdapter</code>的用途就在于此：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 是否支持该处理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 执行处理器，返回 ModelAndView 结果 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回请求的最新更新时间。如果不支持该操作，则返回 -1 即可 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><p><code>HandlerInterceptor</code>是Spring MVC中的拦截器接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter&#125; 执行完之后，无论成功还是失败，</span></span><br><span class="line"><span class="comment"> * 并且，只有 &#123;<span class="doctag">@link</span> #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结来说：</p><ul><li><code>preHandle()</code>方法，按拦截器定义顺序调用，若任一拦截器返回<code>false</code>，则后面的拦截器不再执行，且Controller方法不再调用，处理请求流程结束</li><li><code>postHandle()</code>方法，按拦截器定义逆序调用，在调用Controller方法成功之后执行</li><li><code>afterCompletion()</code>方法，按拦截器定义逆序调用，只有该拦截器在<code>preHandle()</code>方法返回<code>true</code>，Controller方法执行完后才能够被调用（不管是否执行成功），且一定会被调用（过程中出现的异常仅会记录到日志中，不会打断下一个拦截器的<code>afterCompletion()</code>执行）。</li></ul><h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2><p>在Spring MVC中，可以使用<code>@RequestBody</code>和<code>@ResponseBody</code>两个注解，分别完成请求报文到对象和对象到响应报文的转换，底层这种灵活的消息转换机制就是通过<code>HttpMessageConverter</code>完成的。</p><p>我们知道，在Servlet标准中，可以用<code>javax.servlet.ServletRequest</code>接口中的以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>来得到一个<code>ServletInputStream</code>，从这个<code>ServletInputStream</code>中，可以读取到一个原始请求报文的所有内容。同样的，在<code>javax.servlet.ServletResponse</code>接口中，可以用以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>来得到一个<code>ServletOutputStream</code>，从这个<code>ServletOutputSteam</code>中，可以输出Http的响应报文内容。</p><p>当请求报文来到Java世界，它会被封装成为一个<code>ServletInputStream</code>的输入流，供我们读取报文，而响应报文则是通过一个<code>ServletOutputStream</code>的输出流，来输出响应报文。由于从输入流中只能读取到原始的字符串报文，同样，往输出流中也只能写原始的字符，但在处理业务逻辑时更多都是以一个个对象作为处理维度的，因此在SpringMVC中，由<code>HttpMessageConverter</code>完成这中间的一个转换工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMessageNotReadableException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T t, MediaType contentType, HttpOutputMessage outputMessage)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMessageNotWritableException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpMessageConverter</code>接口的定义出现了成对的<code>canRead()</code>+<code>read()</code> 和<code>canWrite()</code>+<code>write()</code> 方法，而参数中的<code>HttpInputMessage</code>和<code>HttpOutputMessage</code>则分别是Spring MVC内部对Http请求报文和响应报文的抽象。下面通过一个例子解释消息转换的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/string"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">readString</span><span class="params">(@RequestBody String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Read string '"</span> + string + <span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在SpringMVC进入<code>readString(@RequestBody String string)</code>方法前，会根据<code>@RequestBody</code>注解选择适当的<code>HttpMessageConverter</code>实现类来将请求参数解析到<code>string</code>变量中，具体来说是使用了<code>StringHttpMessageConverter</code>类，它的<code>canRead()</code>方法返回<code>true</code>，然后它的<code>read()</code>方法会从请求中读出请求参数，绑定到<code>readString(@RequestBody String string)</code>方法的<code>string</code>变量中。</p><p>当Spring MVC执行<code>readString(@RequestBody String string)</code>方法后，由于返回值标识了<code>@ResponseBody</code>注解，Spring MVC将使用<code>StringHttpMessageConverter</code>的<code>write()</code>方法，将结果作为<code>String</code>值写入响应报文，当然，此时<code>canWrite()</code>方法返回<code>true</code>。</p><h3 id="RequestResponseBodyMethodProcessor"><a href="#RequestResponseBodyMethodProcessor" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h3><p><code>RequestResponseBodyMethodProcessor</code>同时实现了<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>两个接口，前者是将请求报文绑定到处理方法形参的策略接口，后者则是对处理方法返回值进行处理的策略接口。</p><p>对<code>HandlerMethodArgumentResolver</code>接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestResponseBodyMethodProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object argument = readWithMessageConverters(webRequest, parameter, parameter.getGenericParameterType());</span><br><span class="line"></span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, argument, name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argument != <span class="keyword">null</span>) &#123;</span><br><span class="line">validate(binder, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> argument;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对<code>HandlerMethodReturnValueHandler</code>接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestResponseBodyMethodProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> returnType.getMethodAnnotation(ResponseBody.class) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (returnValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">writeWithMessageConverters(returnValue, returnType, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个接口的实现，分别是以是否有<code>@RequestBody</code>和<code>@ResponseBody</code>为条件，然后分别调用<code>HttpMessageConverter</code>来进行消息的读写。</p><h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><p>Spring MVC提供了异常解析器<code>HandlerExceptionResolver</code>接口，将处理器执行时发生的异常，转换成对应的<code>ModelAndView</code>结果。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析异常，转换成对应的 ModelAndView 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，如果异常被解析成功，则会返回<code>ModelAndView</code>对象。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tianxiaobo.com/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 一个请求的旅行过程</a></li><li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/#3-3-processDispatchResult" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 请求处理一览</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;处理流程&quot;&gt;&lt;a href=&quot;#处理流程&quot; class=&quot;headerlink&quot; title=&quot;处理流程&quot;&gt;&lt;/a&gt;处理流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blog.default.nanwulife.com/20180708224853769.
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC" scheme="http://yoursite.com/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Spring MVC：WebApplicationContext容器初始化</title>
    <link href="http://yoursite.com/2019/05/19/WebApplicationContext%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/19/WebApplicationContext容器初始化/</id>
    <published>2019-05-19T04:39:00.000Z</published>
    <updated>2019-05-19T09:13:07.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略非关键的配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [1] Spring配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Spring Bean的配置文件所在目录，默认配置在WEB-INF目录下。该 &lt;context-param&gt; 标签会被设置到 ServletContext 中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ====================================== --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [2] Spring MVC配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以自定义servlet.xml配置文件的位置和名称，默认为WEB-INF目录下，名称为[&lt;servlet-name&gt;]-servlet.xml，如spring-servlet.xml</span></span><br><span class="line"><span class="comment">    &lt;init-param&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt; // 默认</span></span><br><span class="line"><span class="comment">    &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[1]</code>处配置了<code>org.springframework.web.context.ContextLoaderListener</code>对象，它实现了<code>javax.servlet.ServletContextListener</code>接口，会初始化一个Root WebApplicationContext容器；</li><li><code>[2]</code>处配置了<code>org.springframework.web.servlet.DispatcherServlet</code>对象，它实现了<code>javax.servlet.http.HttpServlet</code>，除了拦截我们制定的<code>*.do</code>请求外，也会初始化一个属于它的 Servlet WebApplicationContext 容器，并且这个容器是以 [1] 处的 Root 容器作为父容器。</li></ul><p>下面就以上两个容器进行分析，一个是业务容器，一个是Web容器。</p><h2 id="Root-WebApplicationContext"><a href="#Root-WebApplicationContext" class="headerlink" title="Root WebApplicationContext"></a>Root WebApplicationContext</h2><p>Root WebApplicationContext也就是业务容器，用于加载业务逻辑相关的类，比如service、dao层的一些类。它的初始化是通过<code>ContextLoaderListener</code>来实现，在Servlet容器启动时，例如Tomcat、Jetty启动，则会被<code>ContextLoaderListener</code>监听到，从而调用<code>contextInitialized(ServletContextEvent event)</code>方法，初始化Root WebApplicationContext容器。它的核心配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [1] Spring配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上，<code>ContextLoaderListener</code>可通过<code>ServletContext</code>获取到<code>contextConfigLocation</code>配置。这样，业务容器就可以加载<code>application.xml</code>配置文件了。</p><h3 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h3><p><code>org.springframework.web.context.ContextLoaderListener</code>，实现<code>ServletContextListener</code>接口，继承<code>ContextLoader</code>类，上面说过，它实现了Servlet容器启动和关闭时，分别初始化和销毁<code>WebApplicationContext</code>容器。</p><p><img src="http://blog.default.nanwulife.com/01.png" alt=""></p><p>对于<code>ContextLoaderListener</code>，它的初始化和销毁的真正逻辑其实是由父类<code>ContextLoader</code>实现的。</p><ul><li><p>初始化<code>WebApplicationContext</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextLoaderListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 WebApplicationContext，调用父类实现的方法</span></span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁<code>WebApplicationContext</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextLoaderListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    closeWebApplicationContext(event.getServletContext());</span><br><span class="line">    ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Servlet-WebApplicationContext"><a href="#Servlet-WebApplicationContext" class="headerlink" title="Servlet WebApplicationContext"></a>Servlet WebApplicationContext</h2><p>Servlet WebApplicationContext也就是Web容器，它的初始化是在<code>DispatcherServlet</code>初始化的过程中执行，并且会将业务容器作为父容器，之所以这样是因为Web容器中的一些Bean会依赖于业务容器中的Bean，比如我们的controller层接口通常会依赖service层的业务逻辑类。</p><p><img src="http://blog.default.nanwulife.com/01%20%281%29.png" alt=""></p><p>以下是这个继承体系中各个类负责的任务，结构还是比较清晰的：</p><ul><li><p><code>HttpServletBean</code>：覆写了父类<code>HttpServlet</code>中的<code>init()</code>方法，是创建Web容器的入口，负责将<code>ServletConfig</code>设置到<code>HttpServletBean</code>的子类对象中（比如<code>DispatcherServlet</code>）。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServletBean.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple extension of &#123;<span class="doctag">@link</span> javax.servlet.http.HttpServlet&#125; which treats</span></span><br><span class="line"><span class="comment"> * its config parameters (&#123;<span class="doctag">@code</span> init-param&#125; entries within the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> servlet&#125; tag in &#123;<span class="doctag">@code</span> web.xml&#125;) as bean properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>FrameworkServlet</code>：覆写了父类<code>HttpServletBean</code>中的<code>initServletBean()</code>方法，负责初始化Servlet WebApplicationContext容器。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base servlet for Spring's web framework. Provides integration with</span></span><br><span class="line"><span class="comment"> * a Spring application context, in a JavaBean-based overall solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>DispatcherServlet</code>：负责初始化Spring MVC的各个组件，以及处理客户端的请求。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central dispatcher for HTTP request handlers/controllers, e.g. for web UI controllers</span></span><br><span class="line"><span class="comment"> * or HTTP-based remote service exporters. Dispatches to registered handlers for processing</span></span><br><span class="line"><span class="comment"> * a web request, providing convenient mapping and exception handling facilities.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Root-WebApplicationContext/" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 容器的初始化（一）之 Root WebApplicationContext 容器</a></li><li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Servlet-WebApplicationContext/#5-SourceFilteringListener" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 容器的初始化（二）之 Servlet WebApplicationContext 容器</a></li><li><a href="https://www.tianxiaobo.com/2018/06/30/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 容器的创建过程</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web-xml&quot;&gt;&lt;a href=&quot;#web-xml&quot; class=&quot;headerlink&quot; title=&quot;web.xml&quot;&gt;&lt;/a&gt;web.xml&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC" scheme="http://yoursite.com/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis插件机制</title>
    <link href="http://yoursite.com/2019/05/17/MyBatis%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/17/MyBatis插件机制/</id>
    <published>2019-05-17T14:31:00.000Z</published>
    <updated>2019-05-17T14:33:27.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。MyBatis所允许拦截的接口与方法如下：</p><ul><li><code>Executor</code> </li><li><code>ParameterHandler</code> </li><li><code>ResultSetHandler</code> </li><li><code>StatementHandler</code> </li></ul><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>如果我们要实现一个插件，比如我们想要拦截<code>Executor</code>的<code>query</code>方法，那么可以这样定义插件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">    <span class="meta">@Signature</span>(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = <span class="string">"query"</span>,</span><br><span class="line">        args =&#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="meta">@Signature</span>(...),</span><br><span class="line">    <span class="meta">@Signature</span>(...)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的注解是必须的，<code>@Intercepts</code>注解装载一个<code>@Signature</code>列表，一个<code>@Signature</code>其实就是一个需要拦截的方法封装。那么，当一个拦截器要拦截多个方法，自然就是一个<code>@Signature</code>列表。</p><p>除此之外，我们还需将插件配置到相关文件中，这样MyBatis在启动时可以加载插件，并保存插件实例到拦截器链<code>InterceptorChain</code>中。待准备工作做完后，MyBatis处于就绪状态。我们在执行SQL时，需要先通过<code>DefaultSqlSessionFactory</code>创建<code>SqlSession</code>。<code>Executor</code>实例会在创建<code>SqlSession</code>的过程中被创建，<code>Executor</code>实例创建完毕后，MyBatis会通过JDK动态代理为实例生成代理类。这样，插件逻辑即可在<code>Executor</code>相关方法被调用前执行。配置示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.mybatis3.interceptor.ExamplePlugin"</span>&gt;</span></span><br><span class="line">                // ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h2><p><code>Executor</code>实例是在开启<code>SqlSession</code>时被创建的，<code>Executor</code>的创建过程封装在<code>Configuration</code>中，注册插件也正是这个时候：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 executorType 创建相应的 Executor 实例</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册插件</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面创建好<code>Executor</code>后，紧接着通过拦截器链<code>interceptorChain</code>为<code>Executor</code>实例注册代理逻辑（注意是注册而非执行）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历拦截器集合</span></span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">          <span class="comment">// 调用拦截器的 plugin 方法植入相应的插件逻辑</span></span><br><span class="line">          target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>它的<code>pluginAll()</code>方法会调用具体插件的<code>plugin()</code>方法注册相应的插件逻辑。如果有多个插件，则会多次调用<code>plugin()</code>方法，最终生成一个层层嵌套的代理类。<code>plugin()</code>方法是由具体的插件类实现，以下是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取插件类 @Signature 注解内容</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 获取目标类实现的接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>plugin</code>方法在内部调用了<code>Plugin</code>类的<code>wrap()</code>方法，用于为目标对象生成代理。<code>Plugin</code>类实现了<code>InvocationHandler</code>接口，因此它可以作为参数传给<code>Proxy</code>的<code>newProxyInstance()</code>方法。</p><h2 id="执行插件"><a href="#执行插件" class="headerlink" title="执行插件"></a>执行插件</h2><p>在上面注册插件的过程中，我们在<code>wrap()</code>方法中看到了如下代码，它传入了一个<code>Plugin</code>对象作为参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">    type.getClassLoader(),</span><br><span class="line">    interfaces,</span><br><span class="line">    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br></pre></td></tr></table></figure></p><p><code>Plugin</code>实现了<code>InvocationHandler</code>接口，因此它的<code>invoke()</code>方法会拦截所有的方法调用。<code>invoke()</code>方法会对所拦截的方法进行检测，以决定是否执行插件逻辑。该方法的逻辑如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取被拦截方法列表</span></span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">     <span class="comment">// 检测方法列表是否包含当前被拦截的方法</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="comment">// 执行插件逻辑，在 ExamplePlugin 实现中仅仅为执行被拦截的方法</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 执行被拦截的方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tianxiaobo.com/2018/08/26/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">MyBatis 源码分析 - 插件机制</a></li><li><a href="https://my.oschina.net/zudajun/blog/738973" target="_blank" rel="noopener">Mybatis3.4.x技术内幕（十九）：Mybatis之plugin插件设计原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis缓存机制</title>
    <link href="http://yoursite.com/2019/05/17/MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/17/MyBatis缓存机制/</id>
    <published>2019-05-17T04:10:00.000Z</published>
    <updated>2019-05-17T04:11:42.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓存机制是MyBatis的一大特性，它分为一级和二级缓存，其中一级缓存是<code>SqlSession</code>级别的缓存，其实现较为简单，而二级缓存是mapper级别的缓存，并且多个<code>SqlSession</code>之间可以共享。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个<code>SqlSession</code>对象表示一次数据库会话，对于这种会话级别的数据缓存，我们就称之为一级缓存。通过一级缓存，每次查询时都将结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</p><p><img src="http://blog.default.nanwulife.com/20141121213425390.jpg" alt=""></p><p>我们知道，<code>SqlSession</code>只是一个MyBatis对外的接口，<code>SqlSession</code>将它的工作交给了<code>Executor</code>执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个<code>SqlSession</code>对象时，MyBatis会为这个<code>SqlSession</code>对象创建一个新的<code>Executor</code>执行器，而缓存信息就被维护在这个<code>Executor</code>执行器中，MyBatis将缓存和对缓存相关的操作封装到了<code>Cache</code>接口中。</p><h3 id="PerpetualCache"><a href="#PerpetualCache" class="headerlink" title="PerpetualCache"></a>PerpetualCache</h3><p><code>Executor</code>接口的实现类<code>BaseExecutor</code>中拥有一个<code>Cache</code>接口的实现类<code>PerpetualCache</code>，则对于<code>BaseExecutor</code>对象而言，它将使用<code>PerpetualCache</code>对象维护缓存，下面看一下它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，<code>PerpetualCache</code>实现原理其实很简单，其内部就是通过一个简单的<code>HashMap</code>来实现的，没有其他的任何限制。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>关于一级缓存的生命周期，有以下几条规则：</p><ul><li>MyBatis在开启一个数据库会话时，会创建一个新的<code>SqlSession</code>对象，<code>SqlSession</code>对象中会有一个新的<code>Executor</code>对象，<code>Executor</code>对象中持有一个新的<code>PerpetualCache</code>对象；当会话结束时，<code>SqlSession</code>对象及其内部的<code>Executor</code>对象还有<code>PerpetualCache</code>对象也一并释放掉。</li><li>如果<code>SqlSession</code>调用了<code>close()</code>方法，会释放掉一级缓存<code>PerpetualCache</code>对象，一级缓存将不可用；</li><li>如果<code>SqlSession</code>调用了<code>clearCache()</code>，会清空<code>PerpetualCache</code>对象中的数据，但是该对象仍可使用；</li><li><code>SqlSession</code>中执行了任何一个update操作(<code>update()</code>、<code>delete()</code>、<code>insert()</code>) ，都会清空<code>PerpetualCache</code>对象的数据，但是该对象可以继续使用；</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>对于某个查询，会构建一个key值，根据这个key值去缓存<code>Cache</code>中取出对应的缓存结果</li><li>判断从<code>Cache</code>中根据特定的key值取的数据数据是否为空，即是否命中</li><li>如果命中，则直接将缓存结果返回</li><li>如果没命中：<br> 4.1  去数据库中查询数据，得到查询结果<br> 4.2  将key和查询到的结果分别作为key-value对存储到<code>Cache</code>中<br> 4.3. 将查询结果返回</li><li>结束</li></ol><p><img src="http://blog.default.nanwulife.com/20141120133247125.jpg" alt=""></p><h3 id="CacheKey"><a href="#CacheKey" class="headerlink" title="CacheKey"></a>CacheKey</h3><p>在上面的工作流程中已经看到，<code>Cache</code>中的<code>Map</code>是根据一个key来查询缓存的，这个key的决定因素具体如下：</p><ol><li>传入的<code>statementId</code> （比如为<code>com.xxx.mapper.selectUserName</code>）</li><li>查询时要求的结果集中的结果范围 （结果的范围通过<code>rowBounds.offset</code>和<code>rowBounds.limit</code>表示）</li><li>这次查询所产生的最终要传递给JDBC <code>Preparedstatement</code>的SQL语句（<code>boundSql.getSql()</code>）</li><li>要设置的参数值（只用这个SQL语句所需要的参数）</li></ol><p>因此，CacheKey其实就是由<code>statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值</code>这四个条件并生成哈希构建而成的。MyBatis认为，对于两次查询，只要构建出的CacheKey一样，就认为它们是完全相同的查询，也就可以根据这个CacheKey去缓存中查找已有的缓存结果。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>MyBatis的一级缓存就是简单的使用了<code>HashMap</code>，MyBatis只负责将查询数据库的结果存储到缓存中去，不会去判断缓存存放的时间是否过长、是否过期，并且也没有对缓存的大小进行限制，因此对于准确性要求比较高的数据来说，要控制好<code>SqlSession</code>的生存时间，其生存时间越长，它缓存的数据有可能就越旧，从而造成与真实数据库的误差较大。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>当开一个会话时，一个<code>SqlSession</code>对象会使用一个<code>Executor</code>对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个<code>Executor</code>对象做文章。如果用户配置了<code>cacheEnabled=true</code>，那么MyBatis在为<code>SqlSession</code>对象创建<code>Executor</code>对象时，会对<code>Executor</code>对象加上一个装饰者：<code>CachingExecutor</code>，这时<code>SqlSession</code>使用<code>CachingExecutor</code>对象来完成操作请求。<code>CachingExecutor</code>对于查询请求，会先判断该查询请求在二级缓存中是否有缓存结果，如果有缓存结果，则直接返回该结果；如果缓存中没有，再交给真正的<code>Executor</code>对象来完成查询操作，之后<code>CachingExecutor</code>会将真正<code>Executor</code>返回的查询结果放置到缓存中，然后在返回给用户。</p><p><img src="http://blog.default.nanwulife.com/20141123125640998.jpg" alt=""></p><h3 id="缓存粒度"><a href="#缓存粒度" class="headerlink" title="缓存粒度"></a>缓存粒度</h3><p>MyBatis并不是简单地对整个Application就只有一个<code>Cache</code>缓存对象，它将缓存划分的更细，即是Mapper级别的，每一个Mapper都可以拥有一个<code>Cache</code>对象，具体如下：</p><ul><li>为每一个Mapper分配一个<code>Cache</code>缓存对象（使用<code>&lt;cache&gt;</code>节点配置）</li><li>多个Mapper共用一个<code>Cache</code>缓存对象（使用<code>&lt;cache-ref&gt;</code>节点配置）</li></ul><p><img src="http://blog.default.nanwulife.com/20141123125741812.jpg" alt=""></p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>虽然在Mapper中配置了<code>&lt;cache&gt;</code>，并且为此Mapper分配了<code>Cache</code>对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到<code>Cache</code>对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即在<code>&lt;select&gt;</code>节点中配置<code>useCache=&quot;true&quot;</code>，如 <code>&lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&gt;</code> ，Mapper才会对此Select的查询支持缓存特性。</p><p>总结来说，要想使某条<code>select</code>查询支持二级缓存，需要保证：</p><ol><li>MyBatis支持二级缓存的总开关：全局配置变量参数<code>cacheEnabled=true</code></li><li>该<code>select</code>语句所在的Mapper，配置了<code>&lt;cache&gt;</code>或<code>&lt;cached-ref&gt;</code>节点，并且有效</li><li>该<code>select</code>语句的参数<code>useCache=true</code></li></ol><h3 id="二级缓存实现的选择"><a href="#二级缓存实现的选择" class="headerlink" title="二级缓存实现的选择"></a>二级缓存实现的选择</h3><p>MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的<code>Cache</code>缓存实现类，有大量的<code>Cache</code>的装饰器来增强<code>Cache</code>缓存的功能。另外，MyBatis还允许用户自定义<code>Cache</code>接口实现，用户只需要实现<code>org.apache.ibatis.cache.Cache</code>接口，然后将<code>Cache</code>实现类配置在<code>&lt;cache  type=&quot;&quot;&gt;</code>节点的<code>type</code>属性上即可。除此之外，MyBatis还支持跟第三方内存缓存库如Memecached的集成。总之，使用MyBatis的二级缓存有三个选择:</p><ol><li>MyBatis自身提供的缓存实现</li><li>用户自定义的<code>Cache</code>接口实现</li><li>跟第三方内存缓存库的集成</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/luanlouis/article/details/41280959" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的一级缓存实现详解 及使用注意事项</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/41408341" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的二级缓存的设计原理</a>08341)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;缓存机制是MyBatis的一大特性，它分为一级和二级缓存，其中一级缓存是&lt;code&gt;SqlSession&lt;/code&gt;级别的缓存，其实现较为
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之#{}和${}的区别</title>
    <link href="http://yoursite.com/2019/05/16/MyBatis%E4%B9%8B-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/16/MyBatis之-和-的区别/</id>
    <published>2019-05-16T09:58:00.000Z</published>
    <updated>2019-05-16T10:00:29.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态SQL是MyBatis的强大特性之一，我们在使用MyBatis作为持久层框架时，经常需要动态传递参数，例如我们需要根据用户的姓名来筛选用户时，SQL如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"Lihua"</span>;</span><br></pre></td></tr></table></figure></p><p>上述SQL中，我们希望<code>name</code>是动态可变的，即不同的时刻根据不同的姓名来查询用户，那么在MyBatis的xml中可以如下配置：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = #&#123;<span class="keyword">name</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'$&#123;name&#125;'</span>;</span><br></pre></td></tr></table></figure></p><p>这两种方式的本质是不同的，如果不了解其原理，在某些场景下会导致意想不到的后果。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>MyBatis在对SQL语句进行预编译之前，会对SQL进行动态解析，解析为一个<code>BoundSql</code>对象，也正是在这个阶段<code>#{}</code>和<code>${}</code>会有不同的表现。</p><h3 id=""><a href="#" class="headerlink" title="#{}"></a>#{}</h3><p>在动态SQL解析阶段，<code>#{}</code>解析为一个JDBC预编译（<code>PreparedStatement</code>）的参数标记符。例如，如下的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = #&#123;<span class="keyword">name</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>会被解析为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ?;</span><br></pre></td></tr></table></figure></p><p>也就是说，一个<code>#{}</code>被解析为一个参数占位符<code>?</code>。</p><h3 id="-1"><a href="#-1" class="headerlink" title="${}"></a>${}</h3><p>在动态SQL解析阶段，<code>${}</code>仅仅为一个纯粹的字符串替换。例如，如下的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'$&#123;name&#125;'</span>;</span><br></pre></td></tr></table></figure></p><p>当我们传递的参数为<code>Lihua</code>时，上述SQL解析为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"Lihua"</span>;</span><br></pre></td></tr></table></figure></p><p>也就是说，预编译前的SQL语句已经不包含变量<code>name</code>了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于<code>#{}</code>，它其实就对应着JDBC中的<code>PreparedStatement</code>的<code>?</code>，因此一旦MySQL服务器对SQL模板进行了编译，并且存储了函数，<code>PreparedStatement</code>做的就是把参数进行转义后直接传入参数到数据库，然后让函数执行，也就避免了SQL注入的问题；而<code>${}</code>的变量替换是在动态SQL解析阶段，也就是预编译之前，相当于这个SQL语句已经是个常量了，因此会产生SQL注入的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000004617028" target="_blank" rel="noopener">mybatis深入理解(一)之 # 与 $ 区别以及 sql 预编译</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;动态SQL是MyBatis的强大特性之一，我们在使用MyBatis作为持久层框架时，经常需要动态传递参数，例如我们需要根据用户的姓名来筛选用
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis架构设计</title>
    <link href="http://yoursite.com/2019/05/16/MyBatis%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/05/16/MyBatis架构设计/</id>
    <published>2019-05-16T08:28:00.000Z</published>
    <updated>2019-05-16T08:29:08.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="http://blog.default.nanwulife.com/20180314192452838.jpg" alt=""></p><p>MyBatis和数据库交互有两种方式：</p><ol><li>使用传统的MyBatis提供的API：传递Statement Id和查询参数给<code>SqlSession</code>对象，使用<code>SqlSession</code>对象完成和数据库的交互：<br><img src="http://blog.default.nanwulife.com/20141103155203576.jpg" alt=""></li><li>使用Mapper接口：MyBatis将配置文件中的每一个<code>&lt;mapper&gt;</code>节点抽象为一个<code>Mapper</code>接口，而这个接口中声明的方法和<code>&lt;mapper&gt;</code>节点中的<code>&lt;select | update | delete | insert&gt;</code>节点项对应，即<code>select | update | delete | insert</code>节点的id值为<code>Mapper</code>接口中的方法名称，<code>parameterType</code>值表示<code>Mapper</code>对应方法的入参类型，而<code>resultMap</code>值则对应了<code>Mapper</code>接口表示的返回值类型：<br><img src="http://blog.default.nanwulife.com/20141103163301421.jpg" alt=""></li></ol><p>使用<code>Mapper</code>接口的方式并配置好相关信息后，通过<code>SqlSession.getMapper(XXXMapper.class)</code>方法，MyBatis会根据相应的接口声明的方法信息，通过动态代理机制生成一个<code>Mapper</code>实例，我们使用<code>Mapper</code>接口的某一个方法时，MyBatis会根据这个方法的方法名，确定<code>Statement Id</code>，底层还是通过<code>SqlSession.select(&quot;statementId&quot;,parameterObject);</code>或者<code>SqlSession.update(&quot;statementId&quot;,parameterObject);</code>等等来实现对数据库的操作。</p><h2 id="主要构件"><a href="#主要构件" class="headerlink" title="主要构件"></a>主要构件</h2><p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p><ul><li><code>SqlSession</code>：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li><li><code>Executor</code>：MyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护</li><li><code>StatementHandler</code>：封装了JDBC Statement操作，负责对JDBC Statement的操作，如设置参数、将Statement结果集转换成<code>List</code>集合</li><li><code>ParameterHandler</code>：负责对用户传递的参数转换成JDBC Statement所需要的参数</li><li><code>ResultSetHandler</code>：负责将JDBC返回的<code>ResultSet</code>结果集对象转换成<code>List</code>类型的集合</li><li><code>TypeHandler</code>：负责java数据类型和jdbc数据类型之间的映射和转换</li><li><code>MappedStatement</code>：<code>MappedStatement</code>维护了一条<code>&lt;select | update | delete | insert&gt;</code>节点的封装</li><li><code>SqlSource</code>：负责根据用户传递的<code>parameterObject</code>，动态地生成SQL语句，将信息封装到<code>BoundSql</code>对象中，并返回</li><li><code>BoundSql</code>：表示动态生成的SQL语句以及相应的参数信息</li><li><code>Configuration</code>：MyBatis所有的配置信息都维持在<code>Configuration</code>对象之中。</li></ul><p>它们的关系如下图所示：</p><p><img src="http://blog.default.nanwulife.com/20141028140852531.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的架构设计以及实例分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blog.default.nanwulife.com/20180314192452838.
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>JDBC：PreparedStatement和Statement</title>
    <link href="http://yoursite.com/2019/05/16/JDBC%EF%BC%9APreparedStatement%E5%92%8CStatement/"/>
    <id>http://yoursite.com/2019/05/16/JDBC：PreparedStatement和Statement/</id>
    <published>2019-05-16T06:49:00.000Z</published>
    <updated>2019-05-16T06:49:49.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL支持预编译"><a href="#MySQL支持预编译" class="headerlink" title="MySQL支持预编译"></a>MySQL支持预编译</h2><p>在不使用预编译时，客户端每发送一条sql语句给服务器后，服务器总是需要校验sql语句的语法格式是否正确，然后把sql语句编译成可执行函数，最后才是执行sql语句。其中，校验语法和编译所花的时间可能比执行sql语句花的时间还要多。因此，如果我们需要执行多次<code>insert</code>语句，但每次只是插入的值不同，MySQL都要校验语法和编译，会浪费许多时间，而如果使用预编译功能，那么就只用对sql语句进行一次语法校验和编译，所以效率要高。</p><p>MySQL本身是支持预编译的，MySQL执行预编译分为如下三步：</p><ol><li>执行预编译语句，例如：<code>prepare myFunc from &#39;select * from user where username like ?&#39;</code></li><li>设置变量，例如：<code>set @username=&#39;%小明%&#39;</code></li><li>执行语句，例如：<code>execute myFunc using @username</code></li></ol><p>如果需要再次执行<code>myFunc</code>，那就不再需要第一步，即不需要再编译语句了：</p><ol><li>设置变量，例如：<code>set @username=&#39;%小宋%&#39;</code></li><li>执行语句，例如：<code>execute myFunc using @username</code></li></ol><h2 id="PreparedStatement使用预编译"><a href="#PreparedStatement使用预编译" class="headerlink" title="PreparedStatement使用预编译"></a>PreparedStatement使用预编译</h2><p>JDBC的<code>PreparedStatement</code>接口是有预编译功能的，但是在JDBC MySQL驱动5.0.5以后的版本默认是关闭预编译功能的，因此如果我们不手动开启的话，其实并没有使用到预编译，只是用到了防止sql注入的功能。要开启预编译功能，我们需要设置MySQL连接URL参数：<code>useServerPrepStmts=true</code>，这样才能保证MySQL驱动会先把sql语句发送给服务器进行预编译，然后在执行<code>executeQuery()</code>时只是把参数发送给服务器。</p><p>注意：通过设置MySQL连接参数，目的是告诉MySQL<code>PreparedStatement</code>使用预编译功能，但不管我们是否使用预编译功能，MySQL Server4.1版本以后都是支持预编译功能的。</p><p>当使用不同的<code>PreparedStatement</code>对象来执行相同的sql语句时，还是会出现编译两次的现象，这是因为驱动没有缓存编译后的函数key，导致二次编译。但在实际的应用场景中，我们不可能保持同一个<code>PreparedStatement</code>，此时如果希望缓存编译后的函数的key，那么就要设置MySQL连接参数<code>cachePrepStmts=true</code>。</p><h2 id="在持久层框架中存在的问题"><a href="#在持久层框架中存在的问题" class="headerlink" title="在持久层框架中存在的问题"></a>在持久层框架中存在的问题</h2><p>很多主流持久层框架其实都没有真正的用上预编译，预编译是要我们自己在连接参数上配置的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>MySQL主流版本是支持预编译的，但<code>PremaredStatement</code>在JDBC MySQL驱动5.0.5以后需要手动配置连接参数才可以使用预编译功能，如果同时也开启了缓存，那么MySQL服务器是会缓存编译后的函数，而编译后的函数key缓存在<code>PreparedStatement</code>中，此时不同的<code>PreparedStatement</code>执行相同的sql语句时不会重复编译，也就提高了效率。</li><li><code>Statement</code>对于MySQL数据库是不会对编译后的函数进行缓存的，数据库不会缓存函数，<code>Statement</code>也不会缓存函数的key，所以多次执行相同的sql语句时，还是会先检查sql语句语法是否正确，然后编译sql语句成函数，最后执行函数。</li><li>因为<code>PreparedStatement</code>已经对sql模板进行了编译，并且存储了函数，所以<code>PreparedStatement</code>做的就是把参数进行转义后直接传入参数到数据库，然后让函数执行，这也就是为什么<code>PreparedStatement</code>能够防止sql注入攻击的原因。</li><li><code>PreparedStatement</code>还有一点要注意的是，在数据库端存储的函数和<code>PreparedStatement</code>中存储的函数key，都是建立在数据库连接的基础上的，如果当前数据库连接断开了，数据库端的函数会清空，建立在连接上的<code>PreparedStatement</code>里面的函数key也会被清空。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/Marvel__Dead/article/details/69486947" target="_blank" rel="noopener">JDBC：深入理解PreparedStatement和Statement</a></li><li><a href="https://cs-css.iteye.com/blog/1847772" target="_blank" rel="noopener">探究mysql预编译</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL支持预编译&quot;&gt;&lt;a href=&quot;#MySQL支持预编译&quot; class=&quot;headerlink&quot; title=&quot;MySQL支持预编译&quot;&gt;&lt;/a&gt;MySQL支持预编译&lt;/h2&gt;&lt;p&gt;在不使用预编译时，客户端每发送一条sql语句给服务器后，服务器总是需要校验s
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="PreparedStatement" scheme="http://yoursite.com/tags/PreparedStatement/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池源码分析</title>
    <link href="http://yoursite.com/2019/05/12/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/12/Java线程池源码分析/</id>
    <published>2019-05-12T13:51:00.000Z</published>
    <updated>2019-05-12T13:52:24.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java中实现异步任务的处理，我们通常会使用Executor框架，而它的子类<code>ThreadPoolExecutor</code>则提供了线程池的实现，避免了线程频繁创建与销毁所带来的性能开销，为线程做了统一的管理与监控。因此，本文将从<code>Executor</code>接口开始逐层向下分析，重点关注<code>ThreadPoolExecutor</code>，这也是我们平时使用最多的一个类，深入理解它的原理还是很重要的。</p><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><code>Executor</code>接口位于整个体系的最顶层，它只包含一个<code>execute()</code>方法；<code>ExecutorService</code>也是接口，它在<code>Executor</code>接口的基础上添加了很多的接口方法，所以一般我们会使用这个接口；<code>AbstractExecutorService</code>是抽象类，实现了部分的方法，而把其它一些核心方法交给了子类去实现；<code>ThreadPoolExecutor</code>是最核心的一个类，它真正的实现了线程池的相关功能，是重点需要分析的一个类；<code>ScheduledExecutorService</code>是定时任务相关的接口，本文不会去分析该类。</p><p><img src="http://blog.default.nanwulife.com/ScheduledThreadPoolExecutor.png" alt=""></p><p>除此之外，该体系还涉及一个<code>Executors</code>工具类，它提供了很多创建线程池的静态方法，为我们省去了创建线程池时需要关心的参数细节。</p><h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Executor</code>接口非常简单，只有一个<code>execute()</code>方法，用来提交一个任务去执行。注意参数是<code>Runnable</code>类型的，表示一个任务。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>由于<code>Executor</code>接口只有提交任务的功能，我们更多使用的是<code>ExecutorService</code>，它定义的方法比较丰富，大部分情况下已经能满足我们的需求了。例如 ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(args...);</span><br><span class="line">ExecutorService executor = Executors.newCachedThreadPool(args...);</span><br></pre></td></tr></table></figure></p><p>下面看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭线程池：停止接受外部提交的新任务，而等到正在执行的任务以及队列中等待的任务执行完才真正关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池：停止接受外部提交的新任务，忽略队列里等待的任务，尝试将正在跑的任务中断，然后返回未执行的任务列表</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池是否关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回 true</span></span><br><span class="line">    <span class="comment">// 这个方法必须在调用 shutdown() 或 shutdownNow() 方法之后调用才会返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池后等待所有任务完成，并设置超时时间：调用 shutdown() 或 shutdownNow() 方法后，调用该方法阻塞直到所有任务执行完毕或发生了超时，返回 false 表示发生了超时</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Callable 任务，返回一个 Future</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务，返回一个 Future，第二个参数会放到 Future 中作为返回值</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个接口提供了大部分我们需要的功能，一些不太常用的如<code>invokeAll()</code>、<code>invokeAny()</code>等上面将其省略了，不进行分析。</p><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p><code>AbstractExecutorService</code>抽象类实现了几个实用的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 Runnable 包装成 FutureTask，内部其实会通过 Executors#callable 方法将这个 Runnable 转换成 Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务，和 execute() 不同的是这个会返回一个 Future</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);    <span class="comment">// 将 Runnable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);     <span class="comment">// 将 Runnable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);         <span class="comment">// 将Callable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个抽象类封装了一些基本的方法如<code>submit()</code>，但是都没有真正开启线程来执行任务，它们都只是在方法内部调用了<code>execute()</code>方法，而将该方法交由子类去实现。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是JDK中的线程池实现，这个类实现了一个线程池需要的各个方法，比如任务提交、线程管理、监控等等。关于这个方法内容比较多，因此将会拆开来分析。</p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><p>我们先看看该类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心参数的作用分别如下：</p><ul><li><code>corePoolSize</code>：核心线程数，当线程数小于该值时，线程池会创建新线程来执行新任务</li><li><code>maximumPoolSize</code>：线程池允许创建的最大线程数</li><li><code>keepAliveTime</code>：空闲线程的存活时间，但要注意这个值不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数<code>corePoolSize</code>，那么这些线程不会因为空闲太长时间而被关闭，但也可以通过调用<code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</li><li><code>workQueue</code>：任务队列，用来存储未执行的任务，是<code>BlockingQueue</code>接口的某个实现</li><li><code>threadFactory</code>：线程工厂，可通过工厂为新建的线程设置更有意义的名字</li><li><code>handler</code>：拒绝策略，当线程池和任务队列均处于饱和状态时该使用的处理方式，默认为抛出异常</li></ul><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p><code>ThreadPoolExecutor</code>采用一个32位的整数来存放线程池的状态和当前池中的线程数，其中高3位用于存放线程池状态，低29位表示线程数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 状态控制变量，该变量用于表示线程池的状态和线程数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">/** 该方法用于组合线程池的状态和线程数，通过按位或的方式 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 就是29 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">/** 线程池的最大线程数，也就是（2^29-1）：000 11111111111111111111111111111 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池的状态存放在高3位中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;     <span class="comment">// 111 0000...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 000 0000...，对应 shutdown()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;        <span class="comment">// 001 0000...，对应 shutdownNow()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;       <span class="comment">// 010 0000...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 011 0000...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池的运行状态，~运算符i会将0、1取反</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取线程池中的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure></p><p>这里面的状态还是比较清晰的，并且状态值是顺序递增的。<code>RUNNING</code>表示线程池的初始状态，而<code>SHUTDOWN</code>和<code>STOP</code>分别是调用了<code>shutdown()</code>和<code>shutdownNow()</code>方法后进入的状态，其中在<code>tryTerminate()</code>方法中转换成<code>TIDYING</code>状态，表示在<code>SHUTDOWN / STOP</code>后任务队列和线程池都清空了，此时执行钩子方法<code>terminated()</code>，而当<code>terminated()</code>方法结束后，线程池的状态就会变为<code>TERMINATED</code>。</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p><code>Worker</code>是<code>ThreadPoolExecutor</code>的内部类，用于封装线程池中的工作线程，也就是用来执行任务的，而任务是<code>Runnable</code>（内部变量名叫<code>task</code>或<code>command</code>）。要注意的是，该类继承了AQS，用于实现一个简单的互斥锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程，用来执行任务的</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放此线程完成的任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);   <span class="comment">// 通过构造线程池时传入的线程工厂来创建一个新线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用了外部的 runWorker() 方法</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 以下为AQS相关的方法：</span></span><br><span class="line">    <span class="comment">// 0 表示解锁状态</span></span><br><span class="line">    <span class="comment">// 1 表示加锁状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><p><code>Worker</code>实现了<code>Runnable</code>接口，并将<code>run()</code>方法的实现委托给了外部类<code>ThreadPoolExecutor</code>的<code>runWorker()</code>方法，这个方法就是不断的从任务队列中拿取任务运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">// 用于标记完成任务时是否有异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环：初始任务（首次）或者从阻塞队列中拿一个（后续）</span></span><br><span class="line">        <span class="comment">// 这也体现了线程池的意义，工作线程在执行完一个任务后，会再次到任务队列中获取新的任务，实现了”线程复用“</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取互斥锁，在获取互斥锁时，调用 shutdown() 方法不会中断线程，但是 shutdownNow() 方法无视互斥锁，会中断所有线程</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 判断是否需要中断当前线程。如果线程池的状态 &gt;= STOP ，当前线程未中断，则中断当前线程，否则清除线程中断位</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 交由子类实现的前置处理钩子</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 真正的执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 交由子类实现的后置处理钩子</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++; <span class="comment">// 该 Worker 完成的任务数加一</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while 循环之外</span></span><br><span class="line">        </span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);    <span class="comment">// 处理工作线程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><p>在<code>runWorker()</code>方法中，会尝试通过阻塞队列获取任务来执行，而这个获取任务的逻辑则封装到了<code>getTask()</code>这个核心方法中。在以下几种情况会返回<code>null</code>从而接下来线程退出（<code>runWorker()</code>方法中的循环结束）：</p><ol><li>当前工作线程数超过了<code>maximumPoolSize</code>（由于<code>maximumPoolSize</code>可以动态调整，这是可能的）</li><li>线程池状态为<code>STOP</code>（因为<code>STOP</code>状态不处理阻塞队列中的任务了）</li><li>线程池状态为<code>SHUTDOWN</code>，但阻塞队列为空</li><li>线程数量大于<code>corePoolSize</code>或<code>allowCoreThreadTimeOut</code>设置为<code>true</code>，当线程空闲时间超过<code>keepAliveTime</code>（这里说的空闲时间其实就是<code>poll()</code>方法阻塞在队列上的时间）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上次从阻塞队列 poll 任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if 条件等价于  rs &gt;= STOP || (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 此时将工作线程数减一</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut 是用于设置核心线程是否受 keepAliveTime 影响，</span></span><br><span class="line">        <span class="comment">// 在 allowCoreThreadTimeOut 为 true 或工作线程数 &gt; corePoolSize的情况下，</span></span><br><span class="line">        <span class="comment">// 当前的工作线程会受 keepAliveTime 影响</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 工作线程数 &gt; maximumPoolSize，当前工作线程需要退出</span></span><br><span class="line">        <span class="comment">// 2. timed &amp;&amp; timedOut == true 说明当前线程受 keepAliveTime 影响并且上次获取任务超时。这种情况下，如果当前线程不是最后一个线程或者队列为空，则可以退出</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 timed 变量的值决定是限时阻塞获取还是一直阻塞获取队列中的任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :   <span class="comment">// 超时退出</span></span><br><span class="line">                workQueue.take();   <span class="comment">// 一直阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;    <span class="comment">// 走到这说明 poll 超时了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><p>有了上面的一些概念后，接下来我们看看最核心的<code>execute()</code>方法，它包含了提交任务时的几大过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();      <span class="comment">// 获取线程池的状态控制变量</span></span><br><span class="line">    <span class="comment">// 1. 如果线程数少于核心线程池的大小，则添加一个 Worker 来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 到这里说明当前线程数大于等于核心线程池大小（或者 addWorker() 失败），如果线程池处于 RUNNING 状态，则将这个任务添加到阻塞队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 2.1 线程池已经关闭了，则移除队列中刚提交的任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 2.2 没有工作线程了，则添加一个空任务工作线程用于执行提交的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 如果阻塞队列满了，那么以 maximumPoolSize 为界创建新的 Worker，</span></span><br><span class="line">    <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，此时执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先对上面的三大步骤做个抽象层面的梳理：<br><img src="http://blog.default.nanwulife.com/1787733-248f411a83669fff.webp" alt=""></p><ol><li>如果当前运行的线程数少于<code>corePoolSize</code>，则创建新线程来执行任务</li><li>如果运行的线程数大于或等于<code>corePoolSize</code>，则将任务加入阻塞队列</li><li>如果阻塞队列也满了，则以<code>maximumPoolSize</code>为界创建新线程，如果线程数比<code>maximumPoolSize</code>还大，则执行拒绝策略</li></ol><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>下面开始更细的去分析上述三大流程中涉及的一些方法，首先是<code>addWorker()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 准备提交给这个线程执行的任务，可以为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core 如果为 true，表示使用核心线程数 corePoolSize 作为创建线程的界限；如果为 false，表示使用最大线程数 maximumPoolSize 作为创建线程的界限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();          <span class="comment">// 获取线程池的状态控制变量</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">// 获取线程池的状态</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 当线程池状态小于 SHUTDOWN 时，直接往下继续执行</span></span><br><span class="line">        <span class="comment">// 当线程池状态等于 SHUTDOWN 时，如果 firstTask 为 null，且 workQueue 不为空，是允许创建新的 Worker 的，因为此时要把 workQueue 中的任务执行完；否则，当其中一个条件不满足时，不会继续往下执行</span></span><br><span class="line">        <span class="comment">// 当线程池状态大于 SHUTDOWN 时，不允许创建新的 Worker 提交任务，不会继续往下执行</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);  <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||         <span class="comment">// 如果超过了 2^29-1 这个上限，或者超过了 corePoolSize 或 maximumPoolSize（由传入参数决定使用哪个），一样不会继续往下执行</span></span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功 CAS 新增 Worker 的数目，跳出循环往下走</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 重读状态控制变量，如果线程池状态变了，则重试整个大循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 否则，仅仅是 workerCount 变了，也就是 CAS 新增 workerCount 失败，重试内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行到此处时，线程池线程数已经成功+1，下面进行实质操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;  <span class="comment">// Worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;  <span class="comment">// Worker 是否已经添加到 workers 中</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);  <span class="comment">// 在这个 Worker 的构造函数中，会通过线程工厂 new 一个新线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;  <span class="comment">// 获取在构造 Worker 时线程工厂 new 出的新线程</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 整个线程池的全局锁，因为关闭线程池是需要这个锁的，这能保证持有锁的期间，线程池不会关闭</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 由于获取锁之前线程池状态可能发生了变化，这里需要重新读一次状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 如果小于 SHUTDOWN 或者等于 SHUTDOWN 但 firstTask == null（不接受新任务但会继续执行阻塞队列中的任务）</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// worker 中的 thread 不能是已经启动了的，不然要抛出异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);     <span class="comment">// 将新创建的 Worker 加入到 workers 这个 HashSet 中</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;    <span class="comment">// 记录线程池的历史最大值</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// Worker 添加成功，启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 Worker 线程启动失败，则做一些回滚操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里笔者刚开始很疑惑的一点是，为什么<code>t.start();</code>会执行到<code>Worker</code>中的<code>run()</code>方法，它不是<code>Worker</code>中的属性吗，它自己本身并没有传入一个<code>Runnable</code>吧。但实际上，在通过线程工厂创建这个线程的时候，是传入了一个<code>Runnable</code>的，它就是<code>Worker</code>本身：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);   <span class="comment">// 注意这里的 this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，当我们使用<code>t.start()</code>开启这个<code>Thread</code>的时候，这个<code>Thread</code>中的<code>target</code>是为<code>Worker</code>本身的，所以才会执行它的<code>run()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此时就与之前分析<code>Worker</code>时候的方法串起来了，<code>Worker</code>的<code>run()</code>方法的执行逻辑其实是委托给外部类的<code>runWorker()</code>方法来完成，而<code>runWorker()</code>方法最终调用的就是传入的<code>firstTask</code>或者从阻塞队列中取到的某个任务，执行它的<code>run()</code>方法。</p><h4 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h4><p>线程成功启动后的逻辑已经分析完了，接下来看看线程如果启动失败时会发生什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是回滚后尝试终止线程池：</p><ol><li>从<code>workers</code>中删除失败的Worker</li><li><code>workerCount</code>减一</li><li>调用<code>tryTerminate()</code>尝试终止线程池</li></ol><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p><code>shutdown()</code>方法关闭线程池比较优雅，线程池进入<code>SHUTDOWN</code>后不会再接受新任务，并且中断所有空闲线程（阻塞在队列上的线程），但是任务队列中已有的任务将会继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();  <span class="comment">// 检查是否有 shutdown 的权限，非重点</span></span><br><span class="line">        advanceRunState(SHUTDOWN);  <span class="comment">// 状态切换到 SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers();             <span class="comment">// 中断所有空闲线程，或者说在任务队列上阻塞的线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池（状态流转至 TERMINATED）</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 工作线程在处理任务阶段是被互斥锁保护着的，所以 tryLock() 会返回 false，不会中断到</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p><code>shutdownNow()</code>方法关闭线程池相比<code>shutdown()</code>暴力了一些，会中断所有线程，哪怕线程正在执行任务。线程池进入<code>STOP</code>状态后既不会接受新任务，也不会处理任务队列中已有的任务。需要注意的是，即便<code>shutdownNow()</code>会中断正在执行任务的线程，但不代表任务一定会挂，因为如果提交的任务里面的代码没有对线程中断敏感的逻辑的话，线程中断是不会有任何效果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();      <span class="comment">// 检查是否有 shutdown 的权限，非重点</span></span><br><span class="line">        advanceRunState(STOP);      <span class="comment">// 状态切换到 STOP</span></span><br><span class="line">        interruptWorkers();             <span class="comment">// 与 SHUTDOWN 不同的是，直接中断所有线程</span></span><br><span class="line">        tasks = drainQueue();         <span class="comment">// 将任务队列中的任务收集到 tasks</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池（状态流转至 TERMINATED）</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法在 Worker 类中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>在<code>execute()</code>方法中我们可以看到，有两种情况会调用<code>reject()</code>拒绝策略来处理任务，一个是当任务加入阻塞队列后的短暂空窗期线程池已经关闭了，此时再次查看线程池的状态不为<code>RUNNING</code>就会将任务移出队列并执行拒绝策略，另一个是当线程数超过了<code>maximumPoolSize</code>，无法再创建新线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RejectedExecutionHandler</code>在<code>ThreadPoolExecutor</code>中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果线程池没有被关闭，那么由提交任务的线程自己来执行这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管怎样，直接抛出 RejectedExecutionException 异常</span></span><br><span class="line"><span class="comment">// 这个是默认的策略，如果在构造线程池时不传相应的 handler 的话，那就会使用这个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不做任何处理，直接忽略掉这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果线程池没有被关闭，那么丢弃任务队列中首部的任务，然后提交该任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p><code>Executors</code>是一个工具类，所有的方法都是<code>static</code>的，它为我们创建线程池提供了很大的便利。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>生成一个固定大小的线程池，最大线程数设置为与核心线程数相等，此时<code>keepAliveTime</code>设置为0（因为这里它是没用的，即使不为0，线程池默认也不会回收<code>corePoolSize</code>内的线程），阻塞队列采用<code>LinkedBlockingQueue</code>无界队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>生成只有一个线程的线程池，与<code>newFixedThreadPool</code>唯一的不同在于核心线程和最大线程数都为1，不需要指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>生成一个需要的时候就创建新线程的线程池。这种线程池对于任务可以比较快速地完成的情况下有比较好的性能，如果线程空闲了60秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有线程的关闭，整个线程池不会占用任何的系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从<code>Executor</code>顶层接口逐层向下分析，重点讲解了<code>ThreadPoolExecutor</code>的源码实现，包括核心参数、线程创建过程、执行任务、拒绝策略和线程池的关闭等，由于Executor体系本身内容还是比较多的，因此有些地方依然没有关注到，例如定时相关的<code>ScheduledExecutorService</code>接口和同时实现了<code>ThreadPoolExecutor</code>与<code>ScheduledExecutorService</code>的<code>ScheduledThreadPoolExecutor</code>，并且关于<code>ThreadPoolExecutor</code>的线程池关闭这一块，也还有几个方法没有深入分析，将来有时间一定补上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/micrari/p/7429364.html" target="_blank" rel="noopener">ThreadPoolExecutor源码解读</a></li><li><a href="https://javadoop.com/post/java-thread-pool" target="_blank" rel="noopener">深度解读 java 线程池设计思想及源码实现</a></li><li><a href="http://www.tianxiaobo.com/2018/04/17/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Java 线程池原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java中实现异步任务的处理，我们通常会使用Executor框架，而它的子类&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Executor" scheme="http://yoursite.com/tags/Executor/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码分析</title>
    <link href="http://yoursite.com/2019/05/11/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/11/ThreadLocal源码分析/</id>
    <published>2019-05-11T03:31:00.000Z</published>
    <updated>2019-05-11T03:32:42.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>每个线程读写<code>ThreadLocal</code>是线程隔离的，互相之间不会影响。其原因就是在于<code>Thread</code>类有一个<code>ThreadLocal.ThreadLocalMap</code>类型的属性，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>，读写某个<code>ThreadLocal</code>时都会获取当前线程以及当前线程的<code>ThreadLocalMap</code>属性，对其进行读写，以此实现线程隔离。以下是<code>ThreadLocal</code>的几个关键方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);   <span class="comment">// 将自己作为 key</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);    <span class="comment">// 将自己作为 key</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，<code>ThreadLocal</code>本身并没有太多东西，它只是作为<code>ThreadLocalMap</code>的key，核心源码其实都在<code>ThreadLocalMap</code>中。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>在开始源码分析之前，需要先了解弱引用这个概念，因为在<code>ThreadLocalMap</code>中<code>ThreadLocal</code>并不是直接作为key的，而是使用的弱引用对象<code>Entry</code>。在Java中存在四种引用，分别是强引用、软引用、弱引用和虚引用，它们的区别如下：</p><ul><li>强引用：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的，那么它就不被回收</li><li>软引用：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些</li><li>虚引用：虚引用是Java中最弱的引用，通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收</li></ul><p>之所以需要弱引用，是因为在类似<code>HashMap</code>的结构中，如果存放了一个key为<code>Product</code>对象且value为<code>1</code>的节点，此时我们有一个变量<code>product</code>指向了这个<code>Product</code>对象，当我们不再需要这个对象时，如果直接将<code>product</code>设为<code>null</code>，<code>Product</code>对象其实并不会被回收，因为通过<code>HashMap</code>它还存在一条强引用链，如果我们想让它被垃圾收集器回收，就必须将其彻底从<code>HashMap</code>中移除，让它不再存在任何强引用。如果上述过程我们不想自己手动去实现，而是想告诉垃圾收集器在只有<code>HashMap</code>中的key引用着<code>Product</code>对象的情况下，就可以回收相应的<code>Product</code>对象了，那么就可以使用弱引用。</p><p>Java中的弱引用具体指的是<code>java.lang.ref.WeakReference&lt;T&gt;</code>类，我们使用一个指向<code>Product</code>对象的弱引用对象来作为<code>HashMap</code>的<code>key</code>，只需这样定义这个弱引用对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product(...);</span><br><span class="line">WeakReference&lt;Product&gt; weakProduct = <span class="keyword">new</span> WeakReference&lt;&gt;(product);</span><br></pre></td></tr></table></figure></p><p>而如果要通过<code>weakProduct</code>获取它所指向的<code>Product</code>对象，我们只需要通过这行代码：<code>Product product = weakProductA.get();</code>即可。<code>WeakReference</code>的构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个指向给定对象的弱引用</span></span><br><span class="line">WeakReference(T referent)</span><br><span class="line"><span class="comment">//创建一个指向给定对象并且登记到给定引用队列的弱引用</span></span><br><span class="line">WeakReference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span><br></pre></td></tr></table></figure></p><p>通过将原始对象包装成弱引用对象，当变量<code>product</code>设为<code>null</code>时，指向这个<code>Product</code>对象的就只剩弱引用对象<code>weakProduct</code>了，显然这时候相应的<code>Product</code>对象是弱可达的，所以指向它的弱引用会被清除，这个<code>Product</code>对象随即会被回收，指向它的弱引用对象会进入引用队列中，在引用队列中可以对这些被清除的弱引用对象进行统一管理。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Entry节点"><a href="#Entry节点" class="headerlink" title="Entry节点"></a>Entry节点</h3><p>上面说过，<code>ThreadLocalMap</code>并不是简单的使用<code>ThreadLocal</code>作为key的，其实它内部存储着一个<code>Entry</code>节点数组，而<code>Entry</code>继承了弱引用类<code>WeakReference</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当构造一个<code>Entry</code>节点时，会先调用父类<code>WeakReference</code>的构造函数将<code>ThreadLocal</code>传入，并设置了一个类型为<code>Object</code>的<code>value</code>，用于存放<code>ThreadLocal</code>对应的值。</p><p>这里之所以要使用弱引用<code>Entry</code>节点而不是简单的key-value形式的节点，是因为如果简单的使用key-value形式会造成节点的生命周期与线程强绑定，只要线程存在，那么作为属性的<code>ThreadLocalMap</code>也就存在，在不显式移除的情况下，key对象就依然被强引用着，没办法被回收。在这里通过使用弱引用节点，当我们将某个<code>ThreadLocal</code>对象的强引用设为<code>null</code>后，这个<code>ThreadLocal</code>对象就只剩下弱引用了，之后会被GC回收掉，有效的避免了内存泄漏的问题。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 初始容量默认为16</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Entry 数组，大小必须为2的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中 Entry 的实际个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>与<code>HashMap</code>不同，它是使用的线性探测法而非拉链法解决碰撞冲突的，所以实际上<code>Entry[]</code>数组在逻辑上是作为一个环形存在的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环形意义的下一个索引下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环形意义的前一个索引下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化 table 数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 用位运算而非取模得到下标，这也是为什么容量需要为偶数的原因</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 构造并设置该节点</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 更新表（数组）的大小</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数我们重点需要关注其中的<code>threadLocalHashCode</code>，这是传入的<code>ThreadLocal</code>对象的哈希值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure></p><p>这个哈希值在对象创建时就会生成，每次都会累加<code>0x61c88647</code>，通过这种方式使得与2的幂取模（实际是位运算）后均匀分布，也就提高了线性探测时的效率。</p><h3 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h3><p><code>getEntry()</code>方法会被<code>ThreadLocal</code>的<code>get()</code>方法直接调用，上面也说过，<code>get()</code>方法内部就是先拿到当前线程的<code>ThreadLocalMap</code>，然后将自己<code>this</code>作为参数调用其<code>getEntry()</code>方法。这里要提前说明一点的是，每个索引（slot）上的状态有三种：有效（<code>ThreadLocal</code>未回收），失效（<code>ThreadLocal</code>已回收），空（<code>null</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取这个 key 的索引下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 对应的 entry 不为空且未失效，且弱引用指向的 ThreadLocal 就是传入的 key，则命中返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 因为用的是线性探测，所以往后还是有可能找到目标 Entry 的</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 getEntry() 未直接命中时调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于线性探测法不断向后探测直到遇到 null</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)  <span class="comment">// 如果该 entry 对应的 ThreadLocal 已经被回收（失效），调用 expungeStaleEntry() 来清理无效的 entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 如果该 entry 对应的 ThreadLocal 未被回收，但与传入的 key 不等，则继续向后探测</span></span><br><span class="line">            i = nextIndex(i, len);  <span class="comment">// 环形意义下往后面走，线性探测</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到指定的 key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocal 的核心清理函数，从 staleSlot 下标开始遍历，将无效的的 entry 清理，</span></span><br><span class="line"><span class="comment"> * 即将 entry 中的 value 置为 null，指向这个 entry 的 table[i] 置为 null，直到遍历到空 entry。</span></span><br><span class="line"><span class="comment"> * 另外，在这个过程中还会对非空的 entry 作 rehash。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 entry 对应的 ThreadLocal 已经被回收，此时为了垃圾回收：</span></span><br><span class="line">    <span class="comment">// 将 entry 中的 value 置为 null，显示断开强引用</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将指向这个 entry 的 table[i] 置为 null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将实际 entry 数减一</span></span><br><span class="line">    size--;</span><br><span class="line">    </span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 从 staleSlot 的下一个索引开始，不断向后遍历，直到遇到 null</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果当前 entry 中的 ThreadLocal 已经被回收，则做一次清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 如果 entry 对应的 ThreadLocal 还没被回收，需要做一次 rehash</span></span><br><span class="line">            <span class="comment">// 如果 ThreadLocal 计算出的 hash 对应的索引h与当前位置不同，</span></span><br><span class="line">            <span class="comment">// 则从 h 开始向后线性探测直到第一个空的 slot，把当前的 entry 给挪过去</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;  <span class="comment">// 先将当前索引置 null</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)  <span class="comment">// 遍历找到从索引h开始的第一个空 slot</span></span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;     <span class="comment">// 将 entry 挪到这个空 slot 上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 staleSlot 之后第一个 entry 为 null 的索引下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，<code>getEntry()</code>会经历以下几步：</p><ol><li>根据传入的<code>ThreadLocal</code>的哈希值定位到某个索引下标</li><li>如果该下标对应的<code>entry</code>存在，且其中的<code>ThreadLocal</code>和方法传入的<code>ThreadLocal</code>相同，则直接命中返回</li><li>否则，调用<code>getEntryAfterMiss()</code>进行线性探测，过程中每次碰到失效的 slot，就调用<code>expungeStaleEntry</code>进行段清理（清理并rehash，直到遇到null）</li><li>遍历直到 null 都未命中 key，直接返回 null</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);  <span class="comment">// 获取该键对应的索引下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>;  e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到 key 相同的 entry，覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果当前 entry 失效，则替换失效的 entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线性探测过程中没有遇到 key 相同的 entry，也没遇到失效的 entry，当遇到 null 时跳出循环</span></span><br><span class="line">    <span class="comment">// 在 null 的位置上建立新的 entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换失效的 entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 staleSlot 向前遍历，查找最前的一个无效的 slot</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 staleSlot 向后遍历，看能不能找到相同的 key，如果找到了则和无效的 staleSlot 交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>;  i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了 key，将其与无效的slot交换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从 slotToExpunge 开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的 slot 已经无效，并且向前扫描过程中没有无效 slot，则更新 slotToExpunge 为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找不到相同的 key，则直接设置在失效的 staleSlot 下标上</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在探测过程中如果发现任何无效 slot，则做一次清理（连续段清理+启发式清理）</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 做一次全量清理，并且调低阈值决定是否扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">// 因为做了一次清理，所以 size 很可能会变小</span></span><br><span class="line">    <span class="comment">// 这里是调低阈值判断是否需要扩容，下面一行相当于 if(size &gt;= len / 2)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 全量清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 这里其实可以将 j 设为返回值，j 之前的 entry 其实已经被清理过了，肯定为 null</span></span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容为原来的两倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);   <span class="comment">// 计算新容量时哈希值对应的索引下标</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)   <span class="comment">// 线性探测解决碰撞冲突</span></span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新阈值</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set()</code>方法总体过程如下：</p><ol><li>在遍历（也就是线性探测）遇到null之前，如果遇到了相同的key，则直接覆盖；如果遇到了失效的entry，则调用<code>replaceStaleEntry</code>，效果是最终一定会把key和value放在这个slot上，并且会尽可能地清理无效entry</li><li>遍历过程既没遇到相同的key，也没遇到失效的entry，也就是当前索引上为null，则直接将key和value插在这个空slot上</li><li>如果插入后的<code>size</code>大于阈值，那么做一次全量清理，再根据调低的阈值决定是否需要扩容，扩容两倍（因为容量必须为2的幂）</li></ol><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove()</code>方法相对比较简单，只需要找到对应的key，然后将弱引用显式的断开，并做一次段清理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();                      <span class="comment">// 显式断开弱引用</span></span><br><span class="line">            expungeStaleEntry(i);     <span class="comment">// 进行段清理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里光做<code>e.clear();</code>其实是不够的，因为<code>value</code>此时还被强引用着，所以才需要进行段清理，将<code>table[i] = null;</code>彻底断开强引用。</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>经过上面的分析我们已经清楚在每个<code>Thread</code>中有一个<code>ThreadLocalMap</code>，每个线程在对某个<code>ThreadLocal</code>对象操作时都会先获取当前线程的<code>ThreadLocalMap</code>，然后对<code>ThreadLocalMap</code>进行操作，并且，<code>ThreadLocal</code>不是简单的作为key的，而是将key和value包装成继承自弱引用<code>WeakReference</code>的<code>Entry</code>类。但这里要注意的是，弱引用只是针对key（<code>Entry</code>中的<code>ThreadLocal</code>），当没有任何强引用指向<code>ThreadLocal</code>的时候，它就只剩下弱引用了，GC时将会被回收，但是value却不会被回收，因为它存在一条<code>当前Thread-&gt;ThreadLocalMap-&gt;Entry数组-&gt;Entry-&gt;value</code>的强引用，所以除非线程销毁，否则它将与线程的生命周期绑定，尤其是在有线程复用比如线程池的场景中，一个线程的寿命很长，大对象长期不被回收会影响系统运行效率与安全，也就造成了人们常说的内存泄露。</p><p><img src="http://blog.default.nanwulife.com/1660f7ebfeecebf2.jpg" alt=""></p><p>但是在源码中我们也会发现，<code>ThreadLocalMap</code>实现中是有一套自我清理的机制的，当我们调用<code>get()</code>或者<code>set()</code>方法时会有很高的概率顺便清理掉失效的<code>Entry</code>，防止出现内存泄露。当然，显示地进行<code>remove()</code>是个良好的编程习惯，它可以确保不会发生内存泄露。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/micrari/p/6790229.html" target="_blank" rel="noopener">ThreadLocal源码解读</a></li><li><a href="http://www.importnew.com/21206.html" target="_blank" rel="noopener">十分钟理解Java中的弱引用</a></li><li><a href="https://www.zhihu.com/question/37401125" target="_blank" rel="noopener">Java中的强引用，软引用，弱引用，虚引用有什么用？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;每个线程读写&lt;code&gt;ThreadLocal&lt;/code&gt;是线程隔离的，互相之间不会影响。其原因就是在于&lt;code&gt;Thr
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ：流控与镜像队列</title>
    <link href="http://yoursite.com/2019/05/08/RabbitMQ%EF%BC%9A%E9%95%9C%E5%83%8F%E9%98%9F%E5%88%97%E3%80%81/"/>
    <id>http://yoursite.com/2019/05/08/RabbitMQ：镜像队列、/</id>
    <published>2019-05-08T10:08:45.000Z</published>
    <updated>2019-05-08T10:09:08.516Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="队列的结构"><a href="#队列的结构" class="headerlink" title="队列的结构"></a>队列的结构</h2><p>通常队列由<code>rabbit_amqqueue_process</code>和<code>backing_queue</code>两部分组成，前者负责协议相关的消息处理，即接受生产者发布的消息、向消费者交付消息、处理消息的确认（包括生产端的<code>confirm</code>和消费端的<code>ack</code>）等。<code>backing_queue</code>是消息存储的具体形式和引擎，并向<code>rabbit_amqqueue_process</code>提供相关的接口以供调用。</p><h3 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h3><p>如果消息投递的目的队列是空的，并且有消费者订阅了这个队列，那么该消息会直接发送给消费者，不会经过队列这一步。而当消息无法直接投递给消费者时，需要暂时将消息存入队列，以便重新投递。消息存入队列后，不是固定不变的，它会随着系统的负载在队列中不断地流动，消息的状态会不断发生变化。RabbitMQ中的队列消息可能会处于以下四种状态：</p><ul><li>alpha：消息内容（包括消息体、属性和headers）和消息索引都存储在内存中</li><li>beta：消息内容保存在磁盘中，消息索引保存在内存中</li><li>gamma：消息内容保存在磁盘中，消息索引在磁盘和内存中都有</li><li>delta：消息内容和索引都在磁盘中</li></ul><p>其中，gamma状态的消息是只有持久化的消息才会有的状态。</p><p>RabbitMQ在运行时会根据统计的消息传送速率定期计算一个当前内存中能够保存的最大消息数量，如果alpha状态的消息数量大于此值时，就会引起消息的状态转换，多余的消息可能会转换到beta、gamma或者delta状态。其中，delta状态需要执行两次I/O操作才能读取到消息，一次是读消息索引，一次是读消息内容；而对于beta和gamma状态都只需要一次I/O操作就可以读取到消息。</p><p>对于普通的没有设置优先级和镜像的队列来说，<code>backing_queue</code>内部通过5个子队列Q1、Q2、Delta、Q3和Q4来体现消息的各个状态，其中Q1、Q4只包含alpha状态的消息，Q2、Q3包含beta和gamma状态的消息，Delta只包含delta状态的消息，一般情况下，消息按照Q1-&gt;Q2-&gt;Delta-&gt;Q3-&gt;Q4这样的顺序步骤进行流动。如图：<br><img src="http://blog.designpattern.nanwulife.com/G7FVm50dZ65bV06ppeVXQM8AIizdmM8JWHqfUFiQwNoF=1544076799852compressflag.png" alt=""></p><p>从Q1到Q4基本经历了内存到磁盘，再从磁盘到内存的过程，如此可以在队列负载很高的情况下，能够通过将一部分消息由磁盘保存来节省内存空间，而在负载降低的时候，这部分消息又渐渐回到内存被消费者获取，使得整个队列具有很好的弹性。</p><p>通常在负载正常时，如果消息被消费的速度不小于接受新消息的速度，对于非持久化的消息，通常只会处于alpha状态，而对于持久化的消息，一定会进入gamma状态，并且在开启生产端确认机制时，只有到了gamma状态时才会确认该消息已被接收，若消息消费速度足够快、内存也充足，这些消息也不会继续走到下一个状态。</p><p>在系统负载较高时，这些消息若不能很快的被消费掉，就会进入到很深的队列中去，这样会增加处理每个消息的平均开销，因为要花更多的时间和资源处理堆积的消息，如此用来处理新流入的消息的能力就会降低，导致恶性循环。应对这一问题，RabbitMQ有一套流控机制，在下文会介绍。</p><h3 id="惰性队列"><a href="#惰性队列" class="headerlink" title="惰性队列"></a>惰性队列</h3><p>队列具有两种模式，一个是<code>default</code>，一个是<code>lazy</code>。默认情况下，当生产者将消息发送到RabbitMQ中的时候，队列中的消息会尽可能地存储在内存之中，这样可以更加快速地将消息发送给消费者。当RabbitMQ需要释放内存时，将消息换入磁盘会耗费较长时间，也会阻塞队列的操作，进而无法接受新的消息。</p><p>RabbitMQ从3.6.0版本开始引入了惰性队列的概念，即将接受到的消息直接存入文件系统中，而在消费者消费到相应的消息时才会被加载到内存中，它的一个重要的设计目标是能够支持更长的队列，即支持更多的消息存储。惰性队列虽然减少了内存的消耗，但是增加了I/O的使用，因此对于持久化的消息，本身就不可避免磁盘I/O，使用惰性队列是较佳的选择。要注意的是，如果惰性队列中存储的是非持久化的消息，重启之后消息一样会丢失。</p><h2 id="内存及磁盘告警"><a href="#内存及磁盘告警" class="headerlink" title="内存及磁盘告警"></a>内存及磁盘告警</h2><p>当内存使用超过配置的阈值或者磁盘剩余空间低于配置的阈值时，RabbitMQ会暂时阻塞客户端的连接并停止接收从客户端发来的消息。被阻塞的Connection的状态要么是blocking，要么是blocked，前者对应于并不试图发送消息的Connection，后者对应于一直有消息发送的Connection，这种状态下的Connection会被停止发送消息。注意在一个集群中，如果一个Broker节点的内存或者磁盘受限，都会引起整个集群中所有的Connection被阻塞。</p><h3 id="内存告警"><a href="#内存告警" class="headerlink" title="内存告警"></a>内存告警</h3><p>默认情况下内存阈值为0.4，表示当RabbitMQ使用的内存超过40%时，会产生内存告警并阻塞所有生产者的连接。一旦告警被解除（有消息被消费或者从内存转储到磁盘等情况的发生），一切都会恢复正常。</p><p>在某个Broker快达到内存阈值时，会先尝试将队列中的消息换页到磁盘以释放内存空间。默认情况下，在内存到达内存阈值的50%时会进行换页动作。</p><h3 id="磁盘告警"><a href="#磁盘告警" class="headerlink" title="磁盘告警"></a>磁盘告警</h3><p>当剩余磁盘空间低于确定的阈值时，RabbitMQ同样会阻塞生产者，这样可以避免因非持久化的消息持续换页而耗尽磁盘空间导致服务崩溃。默认情况下，磁盘阈值为50MB。RabbitMQ会定期检测磁盘剩余空间，检测的频率与上一次执行检测到的磁盘剩余空间大小有关，随着磁盘剩余空间与磁盘阈值的接近，检测频率会有所增加。</p><h2 id="流控"><a href="#流控" class="headerlink" title="流控"></a>流控</h2><p>当RabbitMQ出现内存或者磁盘资源达到阈值时，会触发流控机制，阻塞生产者的Connection，让生产者不能继续发送消息，直到内存或者磁盘资源得到释放。RabbitMQ基于Erlang开发，一个消息的生命周期中，会涉及多个进程间的转发，这些Erlang进程之间不共享内存，每个进程都有自己独立的内存空间，如果没有合适的流控机制，可能会导致某个进程占用内存过大，导致OOM。因此，要保证各个进程占用的内容在一个合理的范围。</p><p>RabbitMQ的流控机制的原理实质上就是通过监控各进程的mailbox，当某个进程负载过高来不及接收消息时，这个进程的mailbox就会开始堆积消息，当堆积到一定量时，就会阻塞住上游进程让其不得接收新消息，从而慢慢上游进程的mailbox也会开始积压消息，到了一定的量也会阻塞上游的上游的进程，最后就会使得负责网络数据包接收的进程阻塞掉，暂停接收数据。</p><p>从Connection到Channel到队列再到消息持久化存储形成了一个完整的流控链：<br><img src="http://blog.designpattern.nanwulife.com/7415a593-fa83-383b-869c-42659884dd1b.jpg" alt=""></p><p>其中的各个进程如下所述：</p><ul><li>rabbit_reader：Connection的处理进程，负责接收、解析AMQP协议数据包等</li><li>rabbit_channel：Channel的处理进程，负责处理AMQP协议的各种方法、进行路由解析等</li><li>rabbit_amqqueue_process：队列的处理进程，负责实现队列的所有逻辑</li><li>rabbit_msg_store：负责实现消息的持久化</li></ul><p>对于处于整个流控链中的任意进程，只要该进程阻塞，上游的进程必定全部被阻塞。也就是说，如果某个进程达到性能瓶颈，必然会导致上游所有的进程被阻塞。所以我们可以利用流控机制的这个特点找出瓶颈所在。</p><p>一个Connection触发流控时会处于<code>flow</code>的状态，也就意味着这个Connection的状态每秒在<code>blocked</code>和<code>unblocked</code>之间来回切换数次，这样可以将消息发送的速率控制在服务器能够支撑的范围之内。</p><h2 id="镜像队列"><a href="#镜像队列" class="headerlink" title="镜像队列"></a>镜像队列</h2><p>RabbitMQ的集群在默认模式下，队列实例只存在于一个节点上，既不能保证该节点崩溃的情况下队列还可以继续运行，也不能线性扩展该队列的吞吐量。虽然RabbitMQ的队列实际只会在一个节点上，但元数据可以存在于各个节点上。举个例子来说，当创建一个新的交换器时，RabbitMQ会把该信息同步到所有节点上，这个时候客户端不管连接到哪个RabbitMQ节点，都可以访问到这个新的交换器，也就能找到交换器下的队列：</p><p><img src="http://blog.designpattern.nanwulife.com/OFqjExcshZpj=tsMaQJXIBApa06sCdts0=91EuBoQhpl31544076799852compressflag.png" alt=""></p><p>RabbitMQ内部的元数据主要有：</p><ol><li>队列元数据：队列名称和属性</li><li>交换器元数据：交换器名称，类型和属性</li><li>绑定元数据：路由信息</li></ol><p>尽管交换器和绑定关系能够在单点故障问题上幸免于难，但是队列和其上存储的消息却不行，它们仅存在于单个节点上。引入镜像队列的机制，可以将队列镜像到集群中的其它Broker节点之上，如果集群中的一个节点失效了，队列能够自动地切换到镜像中的另一个节点上以保证服务的可用性。通常情况下，针对每一个配置镜像的队列都包含一个主拷贝和若干个从拷贝，相应架构如下：</p><p><img src="http://blog.designpattern.nanwulife.com/0JeBkrdwK7qUqTzySTsBegsoe6Bhg9PiMa3HYIMFSnPGQ1544076799852compressflag.png" alt=""></p><p>除了发送消息外的所有动作都只会向主拷贝发送，然后再由主拷贝将命令执行的结果广播给各个从拷贝，从拷贝实际只是个冷备（默认的情况下所有RabbitMQ节点上都会有镜像队列的拷贝），如果使用消息确认模式，RabbitMQ会在主拷贝和从拷贝都安全的接受到消息时才通知生产者。从这个结构上来看，如果从拷贝的节点挂了，实际没有任何影响，如果主拷贝挂了，那么会有一个重新选举的过程，这也是镜像队列的优点，除非所有节点都挂了，才会导致消息丢失。重新选举后，RabbitMQ会给消费者一个消费者取消通知（Consumer Cancellation），让消费者重连新的主拷贝。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>不同于普通的非镜像队列，镜像队列的实现结构如下：<br><img src="http://blog.designpattern.nanwulife.com/8=93STeAbnCfJrE7VLgGxEOr1IDyCPEUR8Lb8jY1F6IiF1544076799852compressflag.png" alt=""></p><p>所有对镜像队列主拷贝的操作，都会通过GM同步到各个slave节点，Coodinator负责组播结果的确认。GM是一种可靠的组播通信协议，该协议能够保证组播消息的原子性，即保证组内的存活节点要么都收到消息要么都收不到。</p><p>GM的组播并不是由master来负责通知所有slave的（目的是为了避免master压力过大，同时避免master失效导致消息无法最终ack)，RabbitMQ把所有节点组成一个链表，每个节点都会监控位于自己左右两边的节点，当有节点新增时，相邻的节点保证当前广播的消息会复制到新节点上；当有节点失效时，相邻的节点会接管以保证本次广播的消息会复制到所有的节点。操作命令由master发起，也由master最终确认通知到了所有的slave，而中间过程则由slave接力的方式进行消息传播。</p><p><img src="http://blog.designpattern.nanwulife.com/WUD5eU3KpIo3rCJZti5tw1TvD0yeQMZYCnHvQ6i5fXoCb1544076799853compressflag.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li><li><a href="https://sq.163yun.com/blog/article/229026816937607168" target="_blank" rel="noopener">深入理解：RabbitMQ的前世今生</a></li><li><a href="https://ybbct.iteye.com/blog/1562326" target="_blank" rel="noopener">通过流控机制分析rabbitmq性能（持久化）瓶颈</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;队列的结构&quot;&gt;&lt;a href=&quot;#队列的结构&quot; class=&quot;headerlink&quot; title=&quot;队列的结构&quot;&gt;&lt;/a&gt;队列的结构&lt;/h2&gt;&lt;p&gt;通常队列由&lt;code&gt;rabbit_amqqueue_process&lt;/code&gt;和&lt;co
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java8新特性</title>
    <link href="http://yoursite.com/2019/05/06/Java-8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/05/06/Java-8新特性/</id>
    <published>2019-05-06T09:03:00.000Z</published>
    <updated>2019-05-08T10:10:41.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Java 8是Java开发的一个主要版本，也是一个有着重大改变的版本，在此对Java 8的部分新特性进行总结，主要总结以下几个部分：</p><ul><li>Lambda表达式</li><li>函数式接口</li><li>默认方法</li><li>Stream</li></ul><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式能够让我们把函数作为方法参数，或者把代码作为数据对待，使用Lambda表达式可以使代码变得更加简洁紧凑。语法如下：</p><ol><li>方法体为表达式，该表达式的值作为返回值返回：<code>(parameters) -&gt; expression</code></li><li>方法体为代码块，必须用<code>{}</code>包裹起来，且需要有一个<code>return</code>返回值：<code>(parameters) -&gt; { statements; }</code></li></ol><p>Lambda表达式还有以下几个特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号</li></ul><p>Lambda表达式的简单例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1. 不需要参数,返回值为 5  </span></span><br><span class="line">() -&gt; <span class="number">5</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2. 接收一个参数(数字类型),返回其2倍的值  </span></span><br><span class="line">x -&gt; <span class="number">2</span> * x  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3. 接受2个参数(数字),并返回他们的差值 </span></span><br><span class="line">(x, y) -&gt; x – y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 4. 接收2个int型整数,返回他们的和  </span></span><br><span class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)  </span></span><br><span class="line">(String s) -&gt; System.out.print(s)</span><br></pre></td></tr></table></figure></p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口的重要特点是，我们能够使用Lambda实例化它们，如定义了一个函数式接口如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么就可以使用Lambda表达式来表示该接口的一个实现（Java 8之前一般是用匿名类实现）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GreetingService greetService1 = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br></pre></td></tr></table></figure></p><p>注意该函数式接口上有一个新的注解<code>@FunctionalInterface</code>，该接口不是必须的，用来标记该接口为只允许有一个抽象方法的函数式接口，当接口不符合函数式接口定义的时候，编译器会报错。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>接口的默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法，我们只需要在方法名前面加个<code>default</code>关键字即可实现默认方法。</p><p>为什么要有这个特性呢？首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是当需要修改接口的时候，需要修改全部实现了该接口的类，但是如果我们想给接口添加新方法的同时不影响已有的实现，就可以使用默认方法这个特性，解决接口的修改与现有的实现不兼容的问题。</p><p>如果一个类实现了多个接口，并且这些接口有相同的默认方法，此时可以覆盖接口的默认方法，也可以使用<code>super</code>来调用指定接口的默认方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMethodTest</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A.<span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"b"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Java 8还可以在接口中提供静态方法的实现，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>流式操作分为中间操作和最终操作两种，最终操作返回一特定类型的结果，而中间操作返回流本身，这样就可以将多个操作依次串联起来。</p><h3 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h3><p>在Java 8中，集合接口有两个方法来生成流：</p><ul><li><code>stream()</code>：为集合创建串行流</li><li><code>parallelStream()</code>：为集合创建并行流</li></ul><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p>Stream 提供了新的方法<code>forEach</code>来迭代流中的每个数据。以下代码片段使用<code>forEach</code>输出了10个随机数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random(); </span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<code>forEach</code>是一个终止操作，也就是说该操作必须是流的最后一个操作，一旦被调用，<code>Stream</code>就不能再使用了。</p><h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p><code>filter</code>方法用于通过设置的条件过滤出元素。以下代码片段使用<code>filter</code>方法过滤出空字符串：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>); <span class="comment">// 获取空字符串的数量</span></span><br><span class="line"><span class="keyword">int</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p><h3 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h3><p><code>limit</code>方法用于获取指定数量的流。 以下代码片段使用<code>limit</code>方法打印出10条数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p><code>sorted</code>方法用于对流进行排序。以下代码片段使用<code>sorted</code>方法对输出的10个随机数进行排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random(); </span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></p><h3 id="并行程序"><a href="#并行程序" class="headerlink" title="并行程序"></a>并行程序</h3><p><code>parallelStream</code>是流并行处理程序的代替方法。以下实例我们使用<code>parallelStream</code>来输出空字符串的数量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"abc"</span>, <span class="string">""</span>, <span class="string">"bc"</span>, <span class="string">"efg"</span>, <span class="string">"abcd"</span>,<span class="string">""</span>, <span class="string">"jkl"</span>); <span class="comment">// 获取空字符串的数量 </span></span><br><span class="line"><span class="keyword">int</span> count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p><p>我们可以很容易的在顺序运行和并行直接切换。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jdk8newfeature/index.html" target="_blank" rel="noopener">Java 8 新特性概述</a></li><li><a href="https://www.runoob.com/java/java8-new-features.html" target="_blank" rel="noopener">Java 8 新特性</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Java 8是Java开发的一个主要版本，也是一个有着重大改变的版本，在此对Java 8的部分新特性进行总结，主要总结以下几个部分：&lt;/p&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的装箱与拆箱</title>
    <link href="http://yoursite.com/2019/05/06/Java%E4%B8%AD%E7%9A%84%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2019/05/06/Java中的装箱与拆箱/</id>
    <published>2019-05-06T03:16:00.000Z</published>
    <updated>2019-05-08T10:11:10.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自动装箱和拆箱从Java 1.5开始引入，目的是让原始类型值与对应的包装对象之间可以自动的相互转换，比如将<code>int</code>类型值转换成<code>Integer</code>对象称为装箱，反之将<code>Integer</code>对象转换成<code>int</code>类型值称为拆箱。因为这里的装箱和拆箱是自动进行的而非人为转换，所以就称为自动装箱和拆箱。</p><p>在Java中，原始类型<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code>分别对应的包装类为<code>Byte</code>、<code>Short</code>、<code>Character</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Boolean</code>。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>自动装箱与拆箱其实是编译器自动为我们调用了相关方法，自动装箱是通过调用包装类的<code>valueOf()</code>方法实现的，而自动拆箱是通过调用包装类的<code>xxxValue()</code>方法实现的（xxx代表对应的基本数据类型）。</p><h2 id="何时发生自动装箱和拆箱"><a href="#何时发生自动装箱和拆箱" class="headerlink" title="何时发生自动装箱和拆箱"></a>何时发生自动装箱和拆箱</h2><p>自动装箱和拆箱主要发生在两种情况，一种是赋值时，另一种是在方法调用时。</p><h3 id="赋值时"><a href="#赋值时" class="headerlink" title="赋值时"></a>赋值时</h3><p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before autoboxing</span></span><br><span class="line">Integer iObject = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">int</span> iPrimitive = iObject.intValue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//after java5</span></span><br><span class="line">Integer iObject = <span class="number">3</span>; <span class="comment">//autobxing - primitive to wrapper conversion</span></span><br><span class="line"><span class="keyword">int</span> iPrimitive = iObject; <span class="comment">//unboxing - object to primitive conversion</span></span><br></pre></td></tr></table></figure><h3 id="方法调用时"><a href="#方法调用时" class="headerlink" title="方法调用时"></a>方法调用时</h3><p>这是另一个常用的情况，当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">show</span><span class="params">(Integer iParam)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"autoboxing example - method invocation i: "</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="keyword">int</span> result = show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure><p><code>show</code>方法接受<code>Integer</code>对象作为参数，当调用<code>show(3)</code>时，会将<code>int</code>值转换成对应的<code>Integer</code>对象，这就是所谓的自动装箱，<code>show</code>方法返回<code>Integer</code>对象，而<code>int result = show(3);</code>中<code>result</code>为<code>int</code>类型，所以这时候发生自动拆箱操作，将<code>show</code>方法的返回的<code>Integer</code>对象转换成<code>int</code>值。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>自动装箱与拆箱虽然为我们省下了很多不必要的工作，使代码更加简洁清晰，但是如果使用不当，则会引起性能问题。</p><h3 id="循环中的自动装箱"><a href="#循环中的自动装箱" class="headerlink" title="循环中的自动装箱"></a>循环中的自动装箱</h3><p>自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">   sum+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码<code>sum+=i</code>可以看成<code>sum = sum + i</code>，但是<code>+</code>这个操作符不适用于<code>Integer</code>对象，首先<code>sum</code>进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成<code>Integer</code>对象。其内部变化如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = sum.intValue() + i;</span><br><span class="line">Integer sum = Integer.valueOf(result);</span><br></pre></td></tr></table></figure></p><p>由于我们这里声明的<code>sum</code>为<code>Integer</code>类型，在上面的循环中会创建将近4000个无用的<code>Integer</code>对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p><h3 id="对象和原始类型值的比较"><a href="#对象和原始类型值的比较" class="headerlink" title="对象和原始类型值的比较"></a>对象和原始类型值的比较</h3><p>包装类对象和原始类型值的比较是很容易出错的一个地方，需要注意的是，<code>==</code>可以用于原始值的比较，也可以用于对象的比较，但是用于对象之间的比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象。而当其中一个操作数是原始类型值或算术运算时，则比较的是数值（触发自动拆箱）。以下几个例子基本可以涵盖所有情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);               <span class="comment">// 比较对象是否为同一个，因为 Integer 会缓存-128~127之间的对象</span></span><br><span class="line">        System.out.println(e==f);               <span class="comment">// 比较对象是否为同一个，数值在缓存之外</span></span><br><span class="line">        System.out.println(c==(a+b));         <span class="comment">// a+b运算触发自动拆箱，之后数值比较</span></span><br><span class="line">        System.out.println(c.equals(a+b));    <span class="comment">// a+b运算触发自动拆箱，之后自动装箱</span></span><br><span class="line">        System.out.println(g==(a+b));        <span class="comment">// a+b运算触发自动拆箱，之后数值比较</span></span><br><span class="line">        System.out.println(g.equals(a+b));   <span class="comment">// a+b运算触发自动拆箱，之后自动装箱，由于不是同一类型，equals() 返回 false</span></span><br><span class="line">        System.out.println(g.equals(a+h));  <span class="comment">// a+h运算触发自动拆箱，int类型晋升为long，之后自动装箱为Long，equals() 返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">Java中的自动装箱与拆箱</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析Java中的装箱和拆箱</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自动装箱和拆箱从Java 1.5开始引入，目的是让原始类型值与对应的包装对象之间可以自动的相互转换，比如将&lt;code&gt;int&lt;/code&gt;类
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB的MVCC实现原理</title>
    <link href="http://yoursite.com/2019/05/05/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/05/InnoDB的MVCC实现原理/</id>
    <published>2019-05-05T13:45:00.000Z</published>
    <updated>2019-05-05T13:49:42.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>在数据库中经常能听到各种各样的锁，比如说悲观锁、乐观锁、行锁、表锁等等，但实际上前两者是从思想上进行划分的，而后两者是从锁粒度上进行划分的，真正的锁有共享锁和排他锁，也就是常说的读锁（S锁）和写锁（X锁）。</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象进行加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持锁时间、何时释放等，这些规则称为封锁协议，对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>一级封锁协议即事务在修改某行数据时必须先对其加X锁，直到事务结束才释放，事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。一级封锁协议可以防止丢失修改，因为此时别的事务要想修改该数据将会阻塞到对方释放X锁，但如果仅仅是读数据不对其进行修改，是不需要加锁的，也就不能保证可重复读和脏读问题。</p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>二级封锁协议即在一级封锁协议的基础上，事务读取某数据之前必须先对其加S锁，读完后即可释放S锁。二级封锁协议除了防止丢失修改，还可以进一步防止脏读问题，但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>三级封锁协议即在一级封锁协议的基础上，事务读取某数据之前必须先对其加S锁，直到事务结束才释放。三级封锁协议除了防止丢失修改和脏读问题以外，还进一步防止了不可重复读。</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>一次性锁协议指的是在事务开始时，一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。</p><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）：</p><ul><li>加锁阶段：事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段</li><li>解锁阶段：事务只能解锁，也可以操作数据，但不能加锁</li></ul><p>两段锁协议使得事务具有较高的并发度，但是没有解决死锁的问题，因为它在加锁阶段没有顺序要求，如两个事务分别申请了A、B锁，接着又申请了对方的锁，此时进入死锁状态。</p><h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><p>InnoDB采用的是两段锁协议，开始时不断加锁，最后COMMIT或ROLLBACK时一次性释放所有锁，实质上是一种悲观并发控制，而在实际场景下更多都是读多写少的情况，此时悲观的方式会降低系统的并发性能。为了提高并发性能，InnoDB同时实现了MVCC，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高数据库系统的并发性能。</p><h3 id="redo-undo-log"><a href="#redo-undo-log" class="headerlink" title="redo/undo log"></a>redo/undo log</h3><p>为了支持事务，InnoDB实现了redo log与undo log：</p><ul><li>redo log：保存执行的sql语句到一个指定的log文件，当MySQL执行recovery时重新执行redo log记录的sql操作即可，当客户端执行每条sql时，redo log首先会被写入log buffer，当客户端执行COMMIT时，log buffer中的内容会被视情况刷新到磁盘。redo log在磁盘上作为一个独立的文件存在，即InnoDB的log文件。</li><li>undo log：与redo log相反，undo log是为回滚而用，把该行修改前的值copy到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在.ibd数据文件中。</li></ul><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>在MySQL中，InnoDB为每行记录都实现了三个隐藏字段：</p><ul><li>6字节的<code>DB_TRX_ID</code>：事务ID，每处理一个事务，其值自动+1</li><li>7字节的<code>DATA_ROLL_PTR</code>：回滚指针，指向该行修改前的上一个历史版本</li><li>6字节的<code>DB_ROW_ID</code>：如果表中没有显示定义主键或者没有唯一非空索引时InnoDB会自动创建</li></ul><p>当插入一条新数据时，记录上对应的回滚指针为null：</p><p><img src="http://blog.default.nanwulife.com/20170401151910811.jpg" alt=""></p><p>更新记录时，原记录将被放入到undo log中，并通过<code>DATA_ROLL_PT</code>指向该记录：</p><p><img src="http://blog.default.nanwulife.com/20170401151927986.jpg" alt=""></p><p>MySQL就是根据记录上的回滚指针及事务ID判断记录是否可见，如果不可见则按照<code>DATA_ROLL_PT</code>继续回溯查找。</p><h3 id="通过read-view判断行记录是否可见"><a href="#通过read-view判断行记录是否可见" class="headerlink" title="通过read view判断行记录是否可见"></a>通过read view判断行记录是否可见</h3><p><img src="http://blog.default.nanwulife.com/20170401151940733.jpg" alt="">)</p><p>相关源码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">changes_visible</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">trx_id_t</span>    id,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">table_name_t</span>&amp; name)</span> <span class="keyword">const</span></span></span><br><span class="line">MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">ut_ad(id &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//如果ID小于Read View中最小的, 则这条记录是可以看到。说明这条记录是在select这个事务开始之前就结束的</span></span><br><span class="line"><span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">check_trx_id_sanity(id, name);</span><br><span class="line"><span class="comment">//如果比Read View中最大的还要大，则说明这条记录是在事务开始之后进行修改的，所以此条记录不应查看到</span></span><br><span class="line"><span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">ids_t</span>::value_type*    p = m_ids.data();</span><br><span class="line"><span class="keyword">return</span>(!<span class="built_in">std</span>::binary_search(p, p + m_ids.size(), id)); <span class="comment">//判断是否在Read View中， 如果在说明在创建Read View时 此条记录还处于活跃状态则不应该查询到，否则说明创建Read View是此条记录已经是不活跃状态则可以查询到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是，InnoDB的MVCC仅针对RR和RC这两种隔离级别而言。对于<code>Read Uncommitted</code>，由于读取到的总是最新的数据，不管该记录是否已经提交，因此不会遍历版本链，也就不需要MVCC；而对于<code>Serializable</code>级别，使用的仍是悲观并发控制，读加共享锁，写加排他锁，读写相互阻塞。而对于RR和RC级别，它们对于MVCC的可见性实现也是不同的：</p><ul><li>RC：事务内的每个查询语句都会重新创建read view，这样就会产生不可重复读的现象发生</li><li>RR：事务开始时创建read view，直到事务结束的这段时间内每一次查询都不会重建read view，从而实现了可重复读</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVCC是一种用来解决读-写冲突的无锁并发控制机制，它所支持的RR和RC两种隔离级别，读写之间不会被阻塞，大大提高了并发性能。InnoDB实现的四种隔离级别，总体就是通过MVCC+2PL实现的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/joy0921/article/details/80128857" target="_blank" rel="noopener">MVCC原理探究及MySQL源码实现分析</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">【mysql】关于innodb中MVCC的一些理解</a></li><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></li><li><a href="https://www.zhihu.com/question/27876575" target="_blank" rel="noopener">乐观锁和 MVCC 的区别？</a></li><li><a href="https://www.zhihu.com/question/263820564" target="_blank" rel="noopener">MySQL 是如何实现四大隔离级别的？</a></li><li><a href="https://www.cnblogs.com/zszmhd/p/3365220.html" target="_blank" rel="noopener">两阶段锁协议</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁的种类&quot;&gt;&lt;a href=&quot;#锁的种类&quot; class=&quot;headerlink&quot; title=&quot;锁的种类&quot;&gt;&lt;/a&gt;锁的种类&lt;/h2&gt;&lt;p&gt;在数据库中经常能听到各种各样的锁，比如说悲观锁、乐观锁、行锁、表锁等等，但实际上前两者是从思想上进行划分的，而后两者是从锁粒
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
      <category term="MVCC" scheme="http://yoursite.com/tags/MVCC/"/>
    
      <category term="封锁协议" scheme="http://yoursite.com/tags/%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化与反序列化机制</title>
    <link href="http://yoursite.com/2019/05/04/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/04/Java序列化与反序列化机制/</id>
    <published>2019-05-04T14:32:00.000Z</published>
    <updated>2019-05-05T13:47:20.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>序列化是一种对象持久化的手段，使用Java对象序列化，保存对象时会将其状态保存为一组字节，在之后可以再将这些字节组装成对象。简单来说，要实现Java对象的序列化，我们只需要让被序列化类实现<code>Serializable</code>接口，并且使用<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>进行对象的读写即可。但是，关于Java序列化和反序列化其实还有一些更深层次的特性需要了解。</p><h2 id="如何实现对象的序列化"><a href="#如何实现对象的序列化" class="headerlink" title="如何实现对象的序列化"></a>如何实现对象的序列化</h2><p>首先，先介绍一下如何将对象序列化并反序列化。在Java中，被序列化的类必须实现<code>Serializable</code>接口，然后通过<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>进行对象的读写即可实现对象的序列化与反序列化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"LiHua"</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        oo.writeObject(person);</span><br><span class="line">        oo.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        Person anotherPerson = (Person) oi.readObject();</span><br><span class="line">        oi.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(anotherPerson);</span><br><span class="line">        System.out.println(person == anotherPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name=&apos;LiHua&apos;, age=19&#125;</span><br><span class="line">Person&#123;name=&apos;LiHua&apos;, age=19&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>可以看出，对象在序列化到文件后，可以再通过反序列化重新加载进内存，不过虽然这两个对象的属性值都相同，可是它们并不是同一个对象，它们的内存地址并不相同。</p><p>这里需要注意的是，被序列化类虽然实现了<code>Serializable</code>接口，但这个接口并不包含任何方法，仅仅起到标识的作用，那么它是在什么地方起到作用的呢？这里就要从<code>ObjectOutputStream</code>的<code>writeObject</code>方法的调用栈去寻找：<code>writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeSerialData-&gt;invokeWriteObject</code>，在<code>writeObject0</code>这个方法中有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，在序列化时该方法会先判断被序列化的类是否是<code>String</code>、<code>Array</code>、<code>Enum</code>或<code>Serializable</code>类型，如果不是则直接抛出<code>NotSerializableException</code>异常。</p><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的一点是两个类的序列化ID是否一致，也就是我们可以在被序列化的类中加上<code>private static final long serialVersionUID = 1L;</code>来控制该类的序列化版本号，如果序列化与反序列化的该属性不同，则会抛出异常。这个序列化ID可以是随机的一个不重复的<code>long</code>型数值，但是如果没有特殊需求的话，使用默认的<code>1L</code>就可以了。</p><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p><code>transient</code>关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，<code>transient</code>变量的值被设为初始值，如<code>int</code>型的是0，对象型的是<code>null</code>。但是，其实我们也可以使用自定义的序列化和反序列化策略，将<code>transient</code>修饰过的变量序列化到文件中，在<code>ArrayList</code>中就有这样的应用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></p><p>我们知道，<code>ArrayList</code>的本质其实就是通过数组存储元素，但是查看源码会发现这个存储元素的数组<code>elementData</code>被<code>transient</code>修饰了，这并不意味着它就无法被序列化了，相反，<code>ArrayList</code>通过<code>writeObject</code>和<code>readObject</code>方法以自定义的方式将其序列化并反序列化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在序列化的过程中，如果被序列化的类定义了<code>writeObject</code>和<code>readObject</code>方法，虚拟机会试图调用这两个方法进行用户自定义的序列化和反序列化，如果没有这两个方法，则默认调用是<code>ObjectOutputStream</code>的<code>defaultWriteObject</code>方法以及<code>ObjectInputStream</code>的<code>defaultReadObject</code>方法。</p><p>因此，如果我们想在序列化的过程中动态改变序列化的数值，就可以定义这两个方法。典型的应用场景就是在序列化对象数据时，有一些数据是敏感的，我们想在序列化时进行加密，而在反序列化时进行解密，那么此时就可以通过这两个方法来实现。</p><p>那么在上面的<code>ArrayList</code>中，又为什么要用这种方式实现序列化呢？原因是因为<code>ArrayList</code>实际上是动态数组，每次放满元素后都会自动扩容，此时如果实际的元素个数小于容量大小时，会将<code>null</code>元素也序列化到文件中。为了保证只序列化实际存在的元素，<code>ArrayList</code>把<code>elementData</code>用<code>transient</code>关键字修饰，并自定义了序列化反序列化的策略。</p><p>那么这个自定义的序列化反序列化策略又是在哪调用的？还是上面的调用栈<code>writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeSerialData-&gt;invokeWriteObject</code>，在<code>writeSerialData</code>方法中我们可以看到这样一段逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">        bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">        slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">        bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curPut = oldPut;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defaultWriteFields(obj, slotDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会先通过<code>hasWriteObjectMethod</code>判断存在用户自定义的<code>writeObject</code>方法后，调用<code>invokeWriteObject</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, UnsupportedOperationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="keyword">if</span> (writeObjectMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; out &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>writeObjectMethod.invoke(obj, new Object[]{ out });</code>是关键，正是在这里通过反射的方式调用自定义的<code>writeObject</code>方法的。</p><h2 id="父类与静态变量序列化"><a href="#父类与静态变量序列化" class="headerlink" title="父类与静态变量序列化"></a>父类与静态变量序列化</h2><p>关于序列化反序列化机制还有几点需要注意的是，静态变量是无法被序列化的，原因在于序列化保存的是对象的状态，而静态变量属于类的状态。除此之外，如果被序列化的类的父类没有实现<code>Serializable</code>接口时，虚拟机是不会序列化父对象的，要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code>接口。因此，如果我们想要让某些字段不被序列化，可以将这些字段抽取出来放到父类中，且让子类实现<code>Serialzable</code>接口，父类不实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在Java中，只要一个类实现了<code>Serializable</code>接口，那么就可以通过<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>将其对象进行序列化与反序列化。</li><li>如果两个类的<code>serialVersionUID</code>不同，则无法被反序列化，此时会抛出异常。</li><li>序列化不保存静态变量。</li><li>要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code>接口。</li><li>将被序列化的类的字段用<code>transient</code>关键字修饰，可以阻止该字段被序列化，在被反序列化时，该变量的值会被设为初始值。</li><li>可以通过定义<code>writeObject</code>和<code>readObject</code>方法实现自定义的序列化反序列化策略，如对敏感数据进行加密与解密。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="noopener">Java 序列化的高级认识</a></li><li><a href="http://www.importnew.com/18024.html" target="_blank" rel="noopener">深入分析Java的序列化与反序列化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;序列化是一种对象持久化的手段，使用Java对象序列化，保存对象时会将其状态保存为一组字节，在之后可以再将这些字节组装成对象。简单来说，要实现
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2019/05/04/Java%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/05/04/Java中的深拷贝与浅拷贝/</id>
    <published>2019-05-04T10:09:00.000Z</published>
    <updated>2019-05-04T10:10:20.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象并复制其内容，做到了真正完全的拷贝。</li></ul><h2 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h2><p>以下场景中有两个类，一个是<code>Parent</code>，一个是<code>Child</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要实现浅拷贝，只需要让<code>Parent</code>实现<code>Cloneable</code>接口，并覆盖<code>Object</code>的<code>clone()</code>方法即可。以下为测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Parent parent1 = <span class="keyword">new</span> Parent(<span class="string">"parent name"</span>, <span class="keyword">new</span> Child(<span class="string">"child name"</span>));</span><br><span class="line">        Parent parent2 = (Parent) parent1.clone();</span><br><span class="line">        System.out.println(parent1 == parent2);</span><br><span class="line">        System.out.println(parent1.parentName);</span><br><span class="line">        System.out.println(parent2.parentName);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        System.out.println(parent1.child == parent2.child);</span><br><span class="line">        System.out.println(parent1.child.childName);</span><br><span class="line">        System.out.println(parent2.child.childName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">true</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p><p>可以看出，浅拷贝确实创建了一个新的<code>Parent</code>对象，并且属性<code>parentName</code>的值也一模一样，但是对于为引用类型的属性<code>child</code>，实际上与之前引用的是同一个对象。</p><h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><p>要实现深拷贝，常用的方案有以下两种：</p><ol><li>序列化这个对象，再反序列化回来，就可以得到新的对象。</li><li>让属性也实现<code>Cloneable</code>。</li></ol><h3 id="属性实现Cloneable"><a href="#属性实现Cloneable" class="headerlink" title="属性实现Cloneable"></a>属性实现Cloneable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Parent parentClone = (Parent) <span class="keyword">super</span>.clone();</span><br><span class="line">        parentClone.child = (Child) <span class="keyword">this</span>.child.clone();</span><br><span class="line">        <span class="keyword">return</span> parentClone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的浅拷贝不同之处在于这里<code>Child</code>也实现了<code>Cloneable</code>，并覆盖了<code>clone()</code>方法，而<code>Parent</code>的<code>clone()</code>方法也有略微不同，在调用了<code>clone()</code>方法后还调用了属性<code>child</code>的<code>clone()</code>方法重新设置属性，从而实现完完全全的拷贝。</p><p>此时控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">false</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p><p>注意到此时原始对象和拷贝对象的<code>child</code>属性所引用的不再是同一个对象了。</p><h3 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将对象写到流里</span></span><br><span class="line">        OutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//OutputStream op = new ObjectOutputStream();</span></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">        oo.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从流里读对象出来</span></span><br><span class="line">        InputStream bi = <span class="keyword">new</span> ByteArrayInputStream(((ByteArrayOutputStream) bo).toByteArray());</span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">        <span class="keyword">return</span> (oi.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时两个类都不需要再实现<code>Cloneable</code>接口并覆盖<code>clone()</code>方法了，但是它们都需要实现<code>Serializable</code>接口，并且在<code>Parent</code>的克隆方法中要实现序列化反序列化的逻辑，此时控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">false</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝。&lt;/li&gt;
&lt;li&gt;深拷贝：对基本数据类型进行值传递，对引用
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>StringBuilder与StringBuffer源码分析</title>
    <link href="http://yoursite.com/2019/05/03/StringBuilder%E4%B8%8EStringBuffer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/StringBuilder与StringBuffer源码分析/</id>
    <published>2019-05-03T13:32:00.000Z</published>
    <updated>2019-05-06T03:19:04.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>StringBuilder</code>与<code>StringBuffer</code>是两个常用的字符串操作类，与<code>String</code>的不同之处在于他们是可变的，不像<code>String</code>的<code>value</code>数组被<code>final</code>修饰的严严实实的，而<code>StringBuilder</code>和<code>StringBuffer</code>的<code>value</code>数组没有被<code>final</code>修饰过，并且这两个类的实现几乎一样，主要的区别在于<code>StringBuffer</code>的方法由<code>synchronized</code>关键字修饰过，所以是线程安全的。这里先贴出整个体系的UML类图：</p><p><img src="http://blog.default.nanwulife.com/AbstractStringBuilder.png" alt=""></p><h2 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h2><p>从上面的类图也能看到，<code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，<code>AbstractStringBuilder</code>为子类提供了大部分的实现，因此，我们有必要先分析一下<code>AbstractStringBuilder</code>的源码。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p><code>AbstractStringBuilder</code>主要有以下两个成员变量，值得注意的是<code>value</code>并没有被<code>final</code>修饰，意味着它是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 String 一样维护一个字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"><span class="comment">// 字符的个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>在这里顺便将构造函数的源码也分析了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];     <span class="comment">// 初始化为指定容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在分析关键的<code>append()</code>方法前，我们先分析一下数组的扩容操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &gt; <span class="number">0</span>)</span><br><span class="line">        ensureCapacityInternal(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;   <span class="comment">// 如果所需容量大于当前容量，则进行扩容</span></span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;  <span class="comment">// 计算新容量为原来容量的两倍加2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;           <span class="comment">// 如果计算出的新容量不够大</span></span><br><span class="line">        newCapacity = minCapacity;                  <span class="comment">// 直接将新容量设为所需容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE，还要做进一步判断</span></span><br><span class="line">        : newCapacity;                      <span class="comment">// 否则，返回新容量即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所需容量大于整型最大值，则直接抛出 OutOfMemoryError</span></span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所需容量大于 MAX_ARRAY_SIZE 且小于整型最大值时，返回所需容量</span></span><br><span class="line">    <span class="comment">// 如果所需容量小于 MAX_ARRAY_SIZE，返回 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的扩容操作逻辑有点复杂，这里先总结下流程：</p><ol><li>默认的新容量大小为原容量大小的两倍加2，如果还不够，就直接设为所需要的容量大小</li><li>如果新容量大小比<code>MAX_ARRAY_SIZE</code>小，那么直接返回该新容量大小</li><li>否则，检查需要的容量大小是否超过整型最大值，如果超过则抛出异常</li><li>如果需要的容量大小比<code>MAX_ARRAY_SIZE</code>大，则直接返回需要的容量大小；否则，返回<code>MAX_ARRAY_SIZE</code></li></ol><p>其实这个扩容操作和<code>ArrayList</code>的扩容操作逻辑基本一致，这里的<code>MAX_ARRAY_SIZE</code>的值为<code>Integer.MAX_VALUE - 8</code>也就是整型的最大值减8，那么为什么要设置成这个值呢？其实在注释中也有说明，一些虚拟机的实现可能会在数组中存储header words，因此如果分配比这个值更大的容量的话，有可能会导致<code>OutOfMemoryError</code>。</p><h3 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h3><p>接下来看看<code>append()</code>方法，<code>append()</code>方法是整个类的核心，我们在实际中也经常使用。实际上它有很多个重载方法，这里就只分析参数为<code>String</code>类型的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)                <span class="comment">// 如果参数为 null</span></span><br><span class="line">        <span class="keyword">return</span> appendNull();    <span class="comment">// 实际上是添加 'n' 、'u'、'l' 、'l' 四个字符到 value 数组中</span></span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);    <span class="comment">// 扩容</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);        <span class="comment">// 调用 String 的 getChars() 方法将 str 追加到 value 末尾</span></span><br><span class="line">    count += len;   <span class="comment">// 更新字符长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;       <span class="comment">// 返回自身，支持链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = count;</span><br><span class="line">    ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">    value[c++] = <span class="string">'n'</span>;</span><br><span class="line">    value[c++] = <span class="string">'u'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    count = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>append()</code>方法其实逻辑挺简单的，但有两点是需要注意到的，一个是追加字符串的操作是通过<code>String</code>的<code>getChars()</code>完成的，但最后还是调用的<code>System.arraycopy()</code>这个native方法；另一个是该方法返回的是自身<code>this</code>，通过这种方式，我们可以实现<code>append()</code>方法的链式调用。</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>上面分析的<code>AbstractStringBuilder</code>已经实现了大部分需要的方法了，接下来开始分析第一个子类<code>StringBuilder</code>，先看看构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(CharSequence seq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seq.length() + <span class="number">16</span>);</span><br><span class="line">    append(seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>StringBuilder</code>有四个重载的构造函数，并且默认的初始化容量为16，当然我们也可以指定初始化容量，或者直接传入一个已有的字符序列。</p><h3 id="append-1"><a href="#append-1" class="headerlink" title="append()"></a>append()</h3><p><code>StringBuilder</code>的<code>append()</code>方法有非常多的重载，但其实都是调用父类<code>AbstractStringBuilder</code>的方法，在上面已经分析过了，所以这里就简单看一个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><code>StringBuffer</code>和<code>StringBuilder</code>的实现基本一样，只不过方法被<code>synchronized</code>关键字修饰了，因此是线程安全的，比如下面的<code>append()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到方法中有个<code>toStringCache</code>变量，这个变量是最近一次<code>toString()</code>方法的缓存，任何写操作都会将该缓存重设为<code>null</code>，我们看下这个<code>toString()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果缓存为空的话，那么就会先填充缓存，否则直接使用缓存<code>new</code>一个新的<code>String</code>对象并返回，但要注意的是，这里并不会有复制操作，而是直接将<code>String</code>对象中的<code>value</code>指向这个缓存数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>与<code>String</code>不同，<code>StringBuilder</code>和<code>StringBuffer</code>都是可变字符串，底层<code>value</code>数组没有使用<code>final</code>关键字修饰</li><li><code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，它完成了大部分方法的实现，因此子类只需要调用父类的方法即可</li><li><code>StringBuilder</code>和<code>StringBuffer</code>的默认容量都为16，并且默认的扩容大小是原来的两倍加2</li><li><code>StringBuilder</code>不是线程安全的，而<code>StringBuffer</code>通过<code>synchronized</code>关键字保证了线程安全</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;StringBuilder&lt;/code&gt;与&lt;code&gt;StringBuffer&lt;/code&gt;是两个常用的字符串操作类，与&lt;cod
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="StringBuilder" scheme="http://yoursite.com/tags/StringBuilder/"/>
    
      <category term="StringBuffer" scheme="http://yoursite.com/tags/StringBuffer/"/>
    
  </entry>
  
</feed>
