<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-27T13:16:41.657Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>InnoDB的行锁与表锁</title>
    <link href="http://yoursite.com/2019/05/27/InnoDB%E7%9A%84%E8%A1%8C%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/"/>
    <id>http://yoursite.com/2019/05/27/InnoDB的行锁与表锁/</id>
    <published>2019-05-27T12:21:00.000Z</published>
    <updated>2019-05-27T13:16:41.657Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在数据库系统中，根据作用范围我们可以将锁分为行级锁与表级锁，下面结合InnoDB与MyISAM引擎分别介绍一下这两种锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，但发出锁冲突的概率最高，并发度也是最低的。MyISAM就是使用的表级锁，并且因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待，所以是不会发生死锁的。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是MySQL中锁定粒度最小的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</p><h2 id="InnoDB中的行锁与表锁"><a href="#InnoDB中的行锁与表锁" class="headerlink" title="InnoDB中的行锁与表锁"></a>InnoDB中的行锁与表锁</h2><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表级锁。除此之外，虽然是访问不同行的记录，但是如果使用相同的索引键，是会出现锁冲突的。但如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。</p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><h2 id="行级锁与死锁"><a href="#行级锁与死锁" class="headerlink" title="行级锁与死锁"></a>行级锁与死锁</h2><p>InnoDB与MyISAM不同，它是遵循的两段锁协议，是逐步获取锁的，也就有可能出现死锁问题。前面说过，InnoDB不是锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条SQL语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.hollischuang.com/archives/914" target="_blank" rel="noopener">MySQL中的行级锁,表级锁,页级锁</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在数据库系统中，根据作用范围我们可以将锁分为行级锁与表级锁，下面结合InnoDB与MyISAM引擎分别介绍一下这两种锁。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制与分库分表</title>
    <link href="http://yoursite.com/2019/05/27/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://yoursite.com/2019/05/27/MySQL主从复制与读写分离/</id>
    <published>2019-05-27T09:12:38.000Z</published>
    <updated>2019-05-27T10:09:41.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li>I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li><li>SQL线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="http://blog.default.nanwulife.com/master-slave.png" alt=""></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p><img src="http://blog.default.nanwulife.com/master-slave-proxy.png" alt=""></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>当在主从复制、索引优化并且升级硬件后，数据库性能依然无法达到要求，此时就可以考虑数据库的切分，根据其切分类型，可以分为两种切分方式：垂直切分和水平切分。</p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分又分为垂直分库和垂直分表。</p><p>垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，每个微服务使用单独的一个数据库。（例如用户User一个库，商品Producet一个库，订单Order一个库）</p><p>垂直分表是针对列进行的。如果某个表的字段较多，可以把不常用的字段或者长度较长的字段拆分到一张新的扩展表中。在字段较多的情况下，通过“大表拆小表”，更有利于维护与开发，也能避免跨页问题（一致性、排序等问题）。MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。</p><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>因为垂直切分并没有解决单表数据量过大的问题（1000W行切分后还是1000W行），所以当还是无法满足需求的时候，可以进行水平切分。水平切分有以下几种方式：</p><ul><li>范围切分：比如按照时间区间或ID区间来切分，这可以使得冷热数据分离。由于是顺序存储，天然适合水平扩展，但是无法解决集中写入瓶颈的问题。</li><li>Hash切分：通过Hash取模解决了数据访问不均匀的问题，但是在集群扩容的时候，数据迁移量是很大的（使用一致性hash算法能较好的避免这个问题）。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/butterfly100/p/9034281.html" target="_blank" rel="noopener">数据库分库分表思路</a></li><li><a href="http://codingcms.cn/2019/05/14/MySQL_4/" target="_blank" rel="noopener">MySQL 分库分表策略</a></li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/MySQL?id=%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener">CS-NOTE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h2&gt;&lt;p&gt;主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binlog线程：负责将主服
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GET和POST的区别</title>
    <link href="http://yoursite.com/2019/05/26/PUT%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/26/PUT和POST的区别/</id>
    <published>2019-05-26T11:13:46.000Z</published>
    <updated>2019-05-26T12:06:33.206Z</updated>
    
    <content type="html"><![CDATA[<ol start="0"><li>GET用于资源获取，是安全且幂等的，安全的意思是仅仅会获取资源而不会影响资源状态，幂等则是对同一URL的多次请求应该返回同样的结果；POST主要用来传输数据，多次调用会产生多个新的资源，因此是不安全且非幂等的。</li><li>GET请求的数据会包含在URL中，而POST请求则把数据放置在HTTP请求体中。</li><li>正因为GET请求是通过URL提交数据，所以GET请求可提交的数据量跟URL的长度有关系，而POST请求从理论上讲是没有大小限制，可传较大量的数据。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;GET用于资源获取，是安全且幂等的，安全的意思是仅仅会获取资源而不会影响资源状态，幂等则是对同一URL的多次请求应该返回同样的结果；POST主要用来传输数据，多次调用会产生多个新的资源，因此是不安全且非幂等的。&lt;/li&gt;
&lt;li&gt;GET请求的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP与UDP的区别</title>
    <link href="http://yoursite.com/2019/05/26/TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/26/TCP与UDP的区别/</id>
    <published>2019-05-26T11:11:00.000Z</published>
    <updated>2019-05-26T11:29:54.156Z</updated>
    
    <content type="html"><![CDATA[<p>OSI和TCP/IP模型在传输层定义了两种传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。它们的主要区别如下：</p><ol><li>面向连接与无连接</li><li>TCP保证数据可靠性，错误重发；UDP不可靠，可能丢包 </li><li>TCP保证数据顺序，UDP不保证</li><li>TCP主要提供完整性服务，UDP主要提供及时性服务</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OSI和TCP/IP模型在传输层定义了两种传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。它们的主要区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向连接与无连接&lt;/li&gt;
&lt;li&gt;TCP保证数据可靠性，错误重发；UDP不可靠，可能丢包 &lt;/li&gt;
&lt;li&gt;TCP保证
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>@Autowired源码分析</title>
    <link href="http://yoursite.com/2019/05/24/Autowired%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/24/Autowired源码分析/</id>
    <published>2019-05-24T06:24:18.000Z</published>
    <updated>2019-05-24T06:24:55.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h2><p><code>@Autowired</code>注解的逻辑是由<code>AutowiredAnnotationBeanPostProcessor</code>实现的，<code>AutowiredAnnotationBeanPostProcessor</code>不是一个简单的<code>BeanPostProcessor</code>，而是一个实现了多重接口的<code>BeanPostProcessor</code>，它主要实现了以下两个接口：</p><ul><li><code>InstantiationAwareBeanPostProcessor</code>：对应<code>postProcessPropertyValues()</code>方法</li><li><code>MergedBeanDefinitionPostProcessor</code>：对应<code>findAutowiringMetadata</code>方法</li></ul><p>下面我们分别来看看这两个接口的实现是如何完成<code>@Autowired</code>的逻辑的。</p><h2 id="作为MergedBeanDefinitionPostProcessor的行为"><a href="#作为MergedBeanDefinitionPostProcessor的行为" class="headerlink" title="作为MergedBeanDefinitionPostProcessor的行为"></a>作为MergedBeanDefinitionPostProcessor的行为</h2><p>首先，我们从<code>ApplicationContext</code>体系最核心的<code>refresh()</code>方法说起：<br><img src="http://blog.default.nanwulife.com/162cc16e4b0eee57.jpg" alt=""></p><p><code>refresh()</code>方法中<code>registerBeanPostProcessors(beanFactory)</code>这一行代码完成了对<code>AutowiredAnnotationBeanPostProcessor</code>的注册，当执行<code>finishBeanFactoryInitialization(beanFactory)</code>方法时，会实例化所有非懒加载的单例Bean，这个过程中会调用<code>AbstractAutowireCapableBeanFactory</code>类的<code>doCreateBean()</code>方法，其中在使用合适的实例化策略实例化完Bean之后，会有下面这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); <span class="comment">// 重点关注这一行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>applyMergedBeanDefinitionPostProcessors()</code>方法中，会判断当前的<code>BeanPostProcessor</code>是否是<code>MergedBeanDefinitionPostProcessor</code>类型的，如果是的话则调用它的<code>postProcessMergedBeanDefinition()</code>方法（显然，这里会判断为真，因为<code>AutowiredAnnotationBeanPostProcessor</code>实现了<code>MergedBeanDefinitionPostProcessor</code>）。我们再来看看<code>AutowiredAnnotationBeanPostProcessor</code>对该方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey); <span class="comment">// 先从缓存中找 InjectionMetadata，诸如 @Autowire，@Inject 等</span></span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;                  <span class="comment">// 如果找不到，则从这里开始，通过分析 bean，去找到它的 InjectionMetadata</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    metadata = buildAutowiringMetadata(clazz);              <span class="comment">// 重点关注：去找，并构建其 InjectionMetadata 对象</span></span><br><span class="line">                    <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);    <span class="comment">// 如果找到了，将其放入 injectionMetadataCache 中返回；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to introspect bean class ["</span> + clazz.getName() +</span><br><span class="line">                            <span class="string">"] for autowiring metadata: could not find class that it depends on"</span>, err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>findAutowiringMetadata()</code>方法先从缓存中判断否已经存在该<code>InjectionMetadata</code>了，如果存在，且无需进行刷新，则返回；如果缓存中不存在（或者存在但需要刷新），那么就需要去构建一个<code>InjectionMetadata</code>。</p><p>接下来就是比较核心的部分了，通过<code>buildAutowiringMetadata()</code>方法构建<code>InjectionMetadata</code>对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        <span class="comment">// 1. 通过反射从 targetClass 的 field 中去找注解</span></span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field); <span class="comment">// 是否存在 @Autowired</span></span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation is not supported on static fields: "</span> + field);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 如果当前处理的属性是静态属性，则直接返回</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 2. 通过反射从 targetClass 的 method 中去找注解</span></span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 上述代码处理 bridged method 相关情况；可忽略；</span></span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); <span class="comment">// 是否存在 @Autowired</span></span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation is not supported on static methods: "</span> + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 如果方法是静态的，则直接返回；</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation should only be used on methods with parameters: "</span> +</span><br><span class="line">                                    method); <span class="comment">// 警告，方法参数长度为 0</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法分为两部分，通过工具类<code>ReflectionUtils</code>分别从当前Bean实例的<code>fields</code>和<code>methods</code>中去查找<code>@Autowired</code>注解：</p><ol><li>从<code>fields</code>找<code>@Autowired</code>注解，若找到，则创建<code>AutowiredFieldElement</code>实例，并放入<code>currElements</code>队列中</li><li>从<code>methods</code>中找<code>@Autowired</code>注解，若找到，则创建<code>AutowiredMethodElement</code>实例，并放入<code>currElements</code>队列中</li><li>最后，通过Bean的Class对象和<code>curreElements</code>构建<code>InjectionMetadata</code>实例并返回</li></ol><p>此时，将构建好的<code>InjectionMetadata</code>加入缓存<code>injectionMetadataCache</code>中并返回。</p><h2 id="作为InstantiationAwareBeanPostProcessor的行为"><a href="#作为InstantiationAwareBeanPostProcessor的行为" class="headerlink" title="作为InstantiationAwareBeanPostProcessor的行为"></a>作为InstantiationAwareBeanPostProcessor的行为</h2><p>同样，在<code>doCreateBean()</code>方法中执行<code>populateBean()</code>方法填充属性时，<code>populateBean()</code>方法中有如下一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<span class="comment">// 重点关注这一行</span></span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>pvs = ibp.postProcessPropertyValues()</code>这行代码调用了<code>InstantiationAwareBeanPostProcessor</code>的接口方法，继续跟进去看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// &lt;1&gt;</span></span><br><span class="line">InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// &lt;2&gt;</span></span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刚实例化完Bean之后，作为<code>MergedBeanDefinitionPostProcessor</code>，已经调用过<code>findAutowiringMetadata()</code>方法，即从当前Bean对象中的属性和方法中找到了<code>@Autowired</code>注解，并将它们封装成了<code>InjectionMetadata</code>放入了缓存当中，因此，此处直接从缓存中就可以获取到该Bean对应的<code>InjectMetadata</code>。接下来就是通过<code>InjectMetadata</code>进行注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">(checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line"><span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Processing injected element of bean '"</span> + beanName + <span class="string">"': "</span> + element);</span><br><span class="line">&#125;</span><br><span class="line">element.inject(target, beanName, pvs);<span class="comment">// 重点关注</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isField) &#123;</span><br><span class="line">Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">ReflectionUtils.makeAccessible(field);</span><br><span class="line">field.set(target, getResourceToInject(target, requestingBeanName));<span class="comment">// 重点关注</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line">method.invoke(target, getResourceToInject(target, requestingBeanName));<span class="comment">// 重点关注</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>InjectionMetadata</code>对象本身包含了一系列的<code>AutowiredFieldElement</code>和<code>AutowiredMethodElement</code>，所以这里迭代<code>InjectedElement</code>并依次处理它们，而处理的逻辑都在<code>inject()</code>这一关键方法中，可以看到最终就是根据是属性还是方法来分别使用反射注入，并且对于方法而言，该方法会被调用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.shangyang.me/2017/04/05/spring-core-container-sourcecode-analysis-annotation-autowired/" target="_blank" rel="noopener">Spring Core Container 源码分析五：@Autowired</a></li><li><a href="https://juejin.im/entry/5ad3fda5f265da238d512a98" target="_blank" rel="noopener">深入理解Spring系列之十四：@Autowired是如何工作的</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AutowiredAnnotationBeanPostProcessor&quot;&gt;&lt;a href=&quot;#AutowiredAnnotationBeanPostProcessor&quot; class=&quot;headerlink&quot; title=&quot;AutowiredAnnotationB
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破坏双亲委派模型</title>
    <link href="http://yoursite.com/2019/05/24/%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/24/破坏双亲委派模型/</id>
    <published>2019-05-24T02:34:00.000Z</published>
    <updated>2019-05-24T03:37:28.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="headerlink" title="如何破坏双亲委派模型"></a>如何破坏双亲委派模型</h2><p>双亲委派模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。考虑这么一个问题，如果基础类需要调用用户的代码该怎么办，因为根据双亲委派模型，越基础的类由越上层的加载器进行加载，但是上层的加载器并不认识用户的代码。</p><p>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进<code>rt.jar</code>）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在<code>rt.jar</code>中，但是启动类加载器又需要加载。怎么办呢？</p><p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置。如果创建线程时未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认即是应用程序类加载器。</p><p>有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。</p><h2 id="Tomcat的类加载器是怎么设计的？"><a href="#Tomcat的类加载器是怎么设计的？" class="headerlink" title="Tomcat的类加载器是怎么设计的？"></a>Tomcat的类加载器是怎么设计的？</h2><p>前面3个类加载器和默认的一致，CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>（在tomcat 6之后已经合并到根目录下的lib目录下）和<code>/WebApp/WEB-INF/*</code>中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</p><p><img src="http://blog.default.nanwulife.com/4236553-89bacc3467d513f0.png" alt=""></p><ul><li><code>commonLoader</code>：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问。</li><li><code>catalinaLoader</code>：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见。</li><li><code>sharedLoader</code>：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见。</li><li><code>WebappClassLoader</code>：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见。</li></ul><p>Common ClassLoader能加载的类都可以被Catalina ClassLoader和Shared ClassLoader使用，从而实现了公有类库的共用，而Catalina ClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离，从而保证了安全性。WebApp ClassLoader可以使用Shared ClassLoader加载到的类，但各个WebApp ClassLoader实例之间相互隔离。JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能。</p><p>可以看出，Tomcat没有遵循双亲委派模型，每个Webapp ClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="www.jianshu.com/p/abf6fd4531e7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation">深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何破坏双亲委派模型&quot;&gt;&lt;a href=&quot;#如何破坏双亲委派模型&quot; class=&quot;headerlink&quot; title=&quot;如何破坏双亲委派模型&quot;&gt;&lt;/a&gt;如何破坏双亲委派模型&lt;/h2&gt;&lt;p&gt;双亲委派模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。考虑
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="双亲委派模型" scheme="http://yoursite.com/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>ApplicationContext体系分析</title>
    <link href="http://yoursite.com/2019/05/23/ApplicationContext%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/23/ApplicationContext源码分析/</id>
    <published>2019-05-23T11:15:41.000Z</published>
    <updated>2019-05-23T13:28:02.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ApplicationContext</code>实现了除基本容器外的多个接口，提供了比<code>BeanFactory</code>更为丰富的功能，比如说自动识别<code>BeanPostProcessor</code>以及其它特殊类型Bean、容器启动时自动加载Bean、国际化支持、容器内事件发布等。因此，我们在实际应用中一般会使用<code>ApplicationContext</code>而不是<code>BeanFactory</code>。</p><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="http://blog.default.nanwulife.com/72307-b0c809e1cc035cdb.jpg" alt=""></p><p>从上图可以看出，<code>ApplicationContext</code>继承了<code>BeanFactory</code>，因此拥有<code>BeanFactory</code>的全部功能，实际上，它是将容器的功能委派给<code>DefaultListableBeanFactory</code>来实现。除此之外，<code>ApplicationContext</code>还继承了<code>ResourceLoader</code>、<code>EnvironmentCable</code>、<code>ApplicationEventPublisher</code>、<code>MessageSource</code>等接口，提供了十分丰富的功能。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>创建一个常用的<code>ApplicationContext</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application.xml"</span>);</span><br></pre></td></tr></table></figure></p><p><code>ClassPathXmlApplicationContext</code>的构造函数在设置完配置文件的位置后，紧接着调用<code>refresh()</code>方法，这个方法是整个<code>ApplicationContext</code>体系的核心，是在<code>AbstractApplicationContext</code>中实现的，并且是个典型的模板方法，也就是说其中的一些步骤是交由具体子类来实现的。以下是这个方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 1. 准备刷新时的上下文环境</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 刷新并初始化 BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 配置 BeanFactory 中的一些其它信息</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 4. 提供子类覆盖的额外处理，即子类处理自定义的 BeanFactoryPostProcess</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 调用各种 BeanFactoryPostProcessor</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 注册 BeanPostProcessor 到 BeanFactory 中去</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 初始化上下文中的资源文件，如国际化文件的处理等</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 初始化上下文事件广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 初始化其它特殊 Bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 检查 listener 类型的 Bean 并注册</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. 实例化所有非懒加载的单例 Bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12. 发布相应的事件</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h3><p><code>obtainFreshBeanFactory()</code>方法核心是内部调用<code>refreshBeanFactory()</code>方法并将容器内部的<code>ConfigurableListableBeanFactory</code>返回，从这也看到了<code>ApplicationContext</code>和<code>BeanFactory</code>的关系：<code>ApplicationContext</code>内部包含一个<code>BeanFactory</code>，<code>ApplicationContext</code>所有关于<code>BeanFactory</code>的功能将委派给此<code>BeanFactory</code>处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 清理之前的BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// createBeanFactory方法直接新建一个DefaultListableBeanFactory，也就是说内部使用的是DefaultListableBeanFactory实例</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">// 自定义此上下文使用的内部bean工厂</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">// 将BeanDefinition加载到给定的bean工厂中，通常通过委托给一个或多个BeanDefinitionReader来实现</span></span><br><span class="line">      <span class="comment">// 子类实现的方法，此处调用的是AbstractXmlApplicationContext的方法</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(...);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这一步是构建<code>ApplicationContext</code>内部的<code>BeanFactory</code>，以及根据配置将<code>BeanDefinition</code>加载到<code>BeanFactory</code>中（此时并没有实例化Bean）。</p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><p>配置内部<code>BeanFactory</code>的一些基础参数，比如<code>ClassLoader</code>等等。</p><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>对<code>BeanFactory</code>预处理，<code>ClassPathXmlApplicationContext</code>未重写，<code>WebXmlApplicationContext</code>有重写，这里不展开。</p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>在任何Bean的实例化之前，实例化并调用所有已注册的<code>BeanFactoryPostProcessor</code>Bean，如果实现了<code>PriorityOrdered</code>或者<code>Ordered</code>接口则按顺序调用。此时允许<code>BeanFactoryPostProcessor</code>在实例化<code>BeanDefinition</code>之前对当前的配置数据进行修改。</p><h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h3><p>将当前所有的<code>BeanPostProcessor</code>注册到<code>BeanFactory</code>中去，同样也是按照<code>PriorityOrdered</code>或者<code>Ordered</code>的顺序。这也是<code>ApplicationContext</code>与<code>BeanFactory</code>的一个不同，<code>BeanFactory</code>必须自己手动的调用<code>addBeanPostProcessor()</code>方法。</p><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h3><p>初始化<code>MessageSource</code>，如果没有定义则使用<code>DelegatingMessageSource</code>，实际是委派给父类的。</p><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h3><p>初始化<code>ApplicationEventMulticaster</code>，如果没有定义则使用<code>SimpleApplicationEventMulticaster</code>。</p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>模板方法，交给子类来实现，一般是用于在实例化单例Bean之前调用特定Bean的初始化。</p><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h3><p>将所有<code>ApplicationListener</code>注册到<code>ApplicationEventMulticaster</code>中，然后将<code>earlyApplicationEvents</code>中定义的事件进行广播。</p><h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><p>实例化所有剩余的非懒加载的单例Bean，就是遍历所有的<code>beanName</code>，然后挨个调用<code>getBean(beanName)</code>。</p><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h3><p>完成此上下文的刷新，调用<code>LifecycleProcessor</code>的<code>onRefresh()</code>方法并发布<code>ContextRefreshedEvent</code>。主要是对于有生命周期的Bean，按照分组，调用其<code>start()</code>方法。</p><h2 id="ApplicationContext使用"><a href="#ApplicationContext使用" class="headerlink" title="ApplicationContext使用"></a>ApplicationContext使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beanFactory</span></span><br><span class="line">UserService userService = context.getBean(<span class="string">"userService"</span>, UserService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件</span></span><br><span class="line">context.addApplicationListener(<span class="keyword">new</span> WalkListener());</span><br><span class="line">context.publishEvent(<span class="keyword">new</span> WalkEvent(<span class="keyword">new</span> User(<span class="string">"Jerry"</span>)));</span><br><span class="line">context.publishEvent(<span class="keyword">new</span> WalkEvent(<span class="keyword">new</span> User(<span class="string">"Peter"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// locale</span></span><br><span class="line">context.getMessage(<span class="string">"menu.edit"</span>, <span class="keyword">null</span>, <span class="string">"Edit"</span>, Locale.US);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/d75faa3ddce3" target="_blank" rel="noopener">Spring IOC ApplicationContext 源码分析</a></li><li><a href="">Spring ApplicationContext源码分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;实现了除基本容器外的多个接口，提供了比&lt;code&gt;BeanFactory&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：加载Bean</title>
    <link href="http://yoursite.com/2019/05/21/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9AgetBean/"/>
    <id>http://yoursite.com/2019/05/21/Simple-IoC开发日志：getBean/</id>
    <published>2019-05-21T10:43:00.000Z</published>
    <updated>2019-05-22T12:32:14.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>在之前加载注册<code>BeanDefinition</code>完成后，Spring已经存在一组<code>beanName</code> - &gt;<code>BeanDefinition</code>的映射了，接下来我们就可以根据名称或类型实例化并获取我们想要的Bean，而和这个实例化Bean相关的则是整个<code>BeanFactory</code>体系。接下来我们从<code>doGetBean()</code>这个方法开始分析起，这个方法涵盖了实例化Bean的总流程，大致步骤如下：</p><ol><li>将 alias name、FactoryBean name 转换为对应的<code>beanName</code></li><li>尝试从缓存中获取单例Bean</li><li>如果缓存中不存在，则从父类容器中加载</li><li>合并父类的属性，获取<code>RootBeanDefinition</code></li><li>加载所依赖的Bean</li><li>根据不同的<code>scope</code>实例化Bean</li><li>类型转换处理，如果传递的<code>requiredType</code>不为<code>null</code>，则需要检测所得到的Bean的类型是否与该<code>requiredType</code>一致。</li></ol><p>首先，如果名称是以<code>&amp;</code>开头的，则去掉<code>&amp;</code>，并且根据别名获取到<code>beanName</code>，然后尝试从单例缓存中获取Bean，这也正是解决循环依赖的关键，第一次获取时是没有效果的，继续往下走。此时判断是否发生原型模式的循环依赖，如果发生了，则抛出异常。接下来根据<code>beanName</code>从映射中获取到<code>BeanDefinition</code>（其实是<code>RootBeanDefinition</code>），然后优先加载所依赖的Bean（<code>depends-on</code>标签），然后根据不同的<code>scope</code>分别实例化Bean，完成<code>FactoryBean</code>的相关处理，最后做类型转换即可，不过目前不会去关心这个类型转换。下面开始分析比较重要的几个步骤。</p><h3 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h3><p>Bean会根据不同的<code>scope</code>采取不同的实例化策略，总共有五种<code>scope</code>：<code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code>、<code>global session</code>，其实比较常用的也就<code>singleton</code>和<code>prototype</code>，而<code>prototype</code>不需要解决循环依赖的问题，直接反射创建就好了，重点需要关注的是<code>singleton</code>的实例化过程。</p><p>接下来从<code>getSingleton()</code>这个方法进入Bean实例化的正戏。这个方法的开始可以看到用到了双重校验锁，因为多个线程可能在之前同时判断缓存中没有Bean，就都进入到了这里，但为了保证不重复实例化Bean（单例模式），在获取锁之后还会再判断一次是否能从缓存中获取，这里是要注意的。接下来通过<code>ObjectFactory#getObject()</code>方法开始实例化，里面会调用<code>doCreateBean()</code>方法，然后经历以下几个步骤：</p><ol><li>使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化。此时Bean已经被创建出来了，只是没有进行属性填充和初始化</li><li>如果为单例模式、允许循环依赖且当前单例Bean正在被创建，那么将其加入到三级缓存<code>singletonFactories</code>中</li><li>属性填充</li><li>调用初始化方法<br> 4.1. 激活<code>Aware</code>方法，对特殊的Bean处理<br>4.2. 调用<code>postProcessBeforeInitialization()</code><br>4.3. 如果实现了<code>InitializingBean</code>接口，调用其<code>afterPropertiesSet()</code>方法；如果指定了<code>init-method</code>，则调用指定的<code>init-method</code><br>4.4. 调用<code>postProcessAfterInitialization()</code></li><li>注册Bean的销毁方法。与<code>InitializingBean</code>和<code>init-method</code>用于对象的自定义初始化工作相似，<code>DisposableBean</code>和<code>destroy-method</code>用于对象的自定义销毁工作。但这里并不是立刻执行，而是先注册，等到Spring容器关闭的时候才去调用，并且需要我们主动去告知Spring容器，对于<code>BeanFactory</code>容器需要调用<code>destroySingletons()</code>方法，对于<code>ApplicationContext</code>容器需要调用<code>registerShutdownHook()</code>方法。</li></ol><p>到这里，我们就获取到一个Bean了，下面对其中的一些细节进行解释。</p><h3 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h3><p>在这个方法中，完成了Bean的实例化（注意，此时还没填充属性等等），Spring提供了四种实例化策略：</p><ol><li><code>Supplier</code>回调：从<code>BeanDefinition</code>中获取<code>Supplier</code>对象，如果不为空，则调用<code>obtainFromSupplier()</code>方法完成Bean的初始化</li><li>工厂方法初始化</li><li>构造函数自动注入初始化</li><li>默认构造函数注入</li></ol><p>工厂方法初始化的工厂分为静态工厂和实例工厂，静态工厂的配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eat"</span> <span class="attr">class</span>=<span class="string">"it.spring.liao.com.EatFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>实例工厂的配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eatFactory"</span> <span class="attr">class</span>=<span class="string">"it.spring.liao.com.EatFactory "</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eat"</span> <span class="attr">factory-bean</span>=<span class="string">"eatFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果配置了构造函数的自动注入或者配置了构造函数参数，则调用带参的构造函数去实例化Bean。因为一个类有多个构造函数，每个构造函数都有不同的构造参数，需要根据参数个数和类型确定最精确匹配的构造函数，这部分的源码还是十分复杂的。</p><p>对于带参构造函数或默认构造函数，都会先判断是否有覆盖方法，如果有的话则使用CGLIB创建代理对象，否则通过反射来创建Bean（核心代码其实就是<code>constructorToUse.newInstance()</code>）。</p><p>而对于工厂方法，其实也就是通过该<code>Method</code>反射创建Bean（核心代码其实就是<code>factoryMethod.invoke(factoryBean, args)</code>）。</p><h3 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h3><p>先看一下Spring中关于这块的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() <span class="comment">// 如果为单例模式</span></span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">// 允许循环依赖</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName));<span class="comment">// 当前单例 Bean 正在被创建</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法的调用发生在 createBeanInstance() 方法之后，也就是说这个 bean 其实已经创建出来了，但是没有进行属性填充和初始化，</span></span><br><span class="line"><span class="comment">// 但是此时已经可以根据对象引用定位到堆中该对象了，所以将该对象提前曝光出来，加入到三级缓存 singletonFactories 中</span></span><br><span class="line"><span class="comment">// 这里是为了后期避免循环依赖</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring IoC是通过三级缓存这么个机制解决循环依赖的问题的，每次在调用<code>createBeanInstance()</code>方法实例化一个Bean后，就将这个Bean加入到三级缓存<code>singletonFactories</code>中，而此时如果依赖的属性又依赖于自己，即发生循环依赖的话，那么就会直接从三级缓存中拿到这个Bean，并将其升级到二级缓存中去，如果后续还有循环依赖的话，直接从二级缓存就能获取到结果。需要注意的是，这时候的Bean仅仅只是实例化了出来，并没有进行属性填充等操作，只有当一切都完成后，才会将这个Bean升级到一级缓存中去。</p><h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>上面已经实例化出了Bean，并且加入到三级缓存中了，但是这个Bean还有许多事没做完，接下来第一件事就是对其进行属性填充，也就是<code>populateBean()</code>这个方法，它的大体步骤如下：</p><ol><li>获取Bean的属性值，也就是<code>PropertyValues</code></li><li>根据名称或类型解析依赖（此时并未注入到Bean中，仅仅将属性放到了`pvs中）</li><li>调用<code>applyPropertyValues()</code>真正注入属性：<br> 3.1. 检测属性值列表是否已经转换过，若转换过，则直接填充属性，无需再次转换<br>3.2. 遍历属性值列表<code>pvs</code>，解析原始值<code>originalValue</code>，得到解析值<code>resolvedValue</code><br>3.3. 对解析后的属性值<code>resolvedValue</code>进行类型转换<br>3.4. 将类型转换后的属性值设置到<code>PropertyValue</code>对象中，并将<code>PropertyValue</code>对象存入<code>deepCopy</code>集合中<br>3.5. 将<code>deepCopy</code>中的属性信息注入到Bean对象中</li></ol><p>首先讲讲根据名称或类型解析依赖。<code>autowireByName()</code>方法主要完成了以下几件事：</p><ol><li>获取Bean对象中的非简单属性名，即类型为对象类型的属性，<code>String</code>、<code>Enum</code>、<code>Date</code>、<code>URI/URL</code>、<code>Number</code>的继承类如<code>Integer/Long</code>、<code>byte/short/int</code>等基本类型、<code>Locale</code>、以上所有类型的数组形式。</li><li>遍历那些非简单属性名，如果容器中包含该名称对应的Bean，则递归实例化该Bean（也就是调用<code>getBean()</code>方法）</li><li>将递归获取到的Bean存入到属性值列表<code>PropertyValues</code>中</li><li>注册依赖（就是建立映射关系）</li></ol><p><code>autowireByType()</code>方法比<code>autowireByName()</code>方法复杂一些，因为相同类型的Bean可能有多个，它最核心的思路如下：</p><ol><li>根据类型查找所有合适的候选Bean。比如说我们的成员变量是<code>Dao</code>类型的，那么此时<code>MongoDao</code>和<code>MySQLDao</code>这两个Bean可能都属于合适的候选项，因为它们都实现了<code>Dao</code>接口。</li><li>如果没有找到合适的候选Bean，并且<code>autowire</code>的<code>require</code>属性为<code>true</code>，则直接抛出异常</li><li>当候选者不唯一时，则依次根据<code>Primary</code>、<code>Priority</code>决定最终的候选Bean（此时拿到了<code>autowiredBeanName</code>和<code>instanceCandidate</code>）</li><li>当候选者唯一时，可以直接决定候选Bean（此时拿到了<code>autowiredBeanName</code>和<code>instanceCandidate</code>）</li><li>候选Bean可能并没有实例化，也就是<code>instanceCandidate</code>仅仅为<code>Class</code>类型，比如说是<code>MySQLDao.class</code>，此时根据<code>beanFactory.getBean(autowiredBeanName)</code>方法实例化该Bean</li><li>返回已实例化好的Bean</li></ol><p>接下来就和<code>autowireByName()</code>方法一样了，将获取到的Bean存入到属性值列表<code>PropertyValues</code>中，并且注册这个依赖关系。此时，<code>&lt;property&gt;</code>标签表示的属性和自动注入的属性都已经解析到<code>PropertyValues</code>中了，调用<code>applyPropertyValues()</code>开始真正的属性注入，该方法核心步骤如下：</p><ol><li>将<code>ref</code>（在之前解析标签时将其封装成了<code>RuntimeBeanReference</code>）解析为具体的对象，将<code>&lt;list&gt;</code>标签转换为<code>List</code>对象，还会解析<code>&lt;set/&gt;</code>、<code>&lt;map/&gt;</code>、<code>&lt;array/&gt;</code>等标签。</li><li>对属性值的类型进行转换，比如将<code>String</code>类型的属性值<code>&quot;123&quot;</code>转换为<code>Integer</code>类型的<code>123</code></li><li>反射设置<code>PropertyValues</code>中的所有属性</li></ol><p>至此，属性值已经注入到Bean中了。</p><h3 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h3><p>填充完属性，接下来就是调用初始化方法，该方法的步骤如下：</p><ol><li>激活<code>Aware</code>方法：Bean可以实现<code>Aware</code>接口，从而对当前环境进行感知（就是实现了<code>setXXX()</code>方法）。在这里，会针对<code>BeanNameAware</code>、<code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code>三种<code>Aware</code>接口进行判断，将一些值设置到当前Bean中。</li><li>调用<code>postProcessBeforeInitialization()</code>方法</li><li>调用<code>invokeInitMethods()</code>方法：<br> 3.1. 如果Bean实现了<code>InitializingBean</code>接口，那么会先调用该接口的<code>afterPropertiesSet()</code>方法<br>3.2. 检查是否指定了<code>init-method</code>，如果指定了则通过反射机制调用<code>init-method</code>方法</li><li>调用<code>postProcessAfterInitialization()</code>方法</li></ol><p>至此，几个核心步骤就都介绍完了。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><p>Simple IoC的实现大体思路上与Spring IoC一致，但是尚不支持<code>&lt;list/&gt;</code>等一些集合标签，并且不像Spring实现了一套类型转换体系，这里直接使用了<code>apache</code>的<code>BeanUtils</code>完成类型转换相关的操作。除此之外，暂时还未实现<code>initializeBean()</code>相关的逻辑。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>第一个测试是模拟登陆接口的场景，分为<code>Controller</code>、<code>Service</code>、<code>Dao</code>三层，XML配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginController"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.LoginController"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginService"</span> <span class="attr">ref</span>=<span class="string">"loginService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginService"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.LoginServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.UserDao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\login.xml"</span>);</span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line">    LoginController loginController = (LoginController) factory.getBean(<span class="string">"loginController"</span>);</span><br><span class="line">    assertEquals(loginController.login(<span class="string">"Lihua"</span>, <span class="string">"123456789"</span>), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个测试是针对循环依赖问题的，XML配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.persons.Person"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Lihua"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idCard"</span> <span class="attr">ref</span>=<span class="string">"idCard"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idCard"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.persons.IdCard"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"441301188875468912"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"owner"</span> <span class="attr">ref</span>=<span class="string">"person"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCyclicDependence</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\persons.xml"</span>);</span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line">    Person person = (Person) factory.getBean(<span class="string">"person"</span>);</span><br><span class="line">    IdCard idCard = (IdCard) factory.getBean(<span class="string">"idCard"</span>);</span><br><span class="line">    assertEquals(person.getName(), <span class="string">"Lihua"</span>);</span><br><span class="line">    assertEquals(person.getAge(), <span class="number">18</span>);</span><br><span class="line">    assertEquals(person.getIdCard(), idCard);</span><br><span class="line">    assertEquals(idCard.getId(), <span class="number">441301188875468912L</span>);</span><br><span class="line">    assertEquals(idCard.getOwner(), person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;在之前加载注册&lt;code&gt;BeanDefinition&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：注册BeanDefinitions</title>
    <link href="http://yoursite.com/2019/05/19/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9ABeanDefinition%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/19/Simple-IoC开发日志：BeanDefinition加载/</id>
    <published>2019-05-19T14:29:00.000Z</published>
    <updated>2019-05-20T08:04:26.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>在之前已经介绍过Spring IoC对资源的抽象了，也就是<code>Resource</code>接口。当我们加载了指定的资源后，接下来需要做的就是将资源（也就是XML文件）解析成<code>Document</code>实例，并解析成<code>BeanDefinition</code>然后注册。这个过程的整体流程如下：</p><ol><li><code>loadBeanDefinitions(Resource resource)</code>作为方法入口。</li><li><code>doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code>方法实现了真正的加载逻辑，它首先根据XML获取<code>Document</code>实例，然后根据<code>Document</code>实例注册Bean信息。<br> 2.1. <code>doLoadDocument()</code>方法根据XML获取<code>Document</code>实例，其中会牵扯到获取验证模式和错误处理等过程。<br> 2.2. <code>registerBeanDefinitions()</code>遍历XML的每一个节点并注册它们的<code>BeanDefinition</code>。</li></ol><p>接下来就上面获取<code>Document</code>实例和注册<code>BeanDefinition</code>进行分析。</p><h3 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h3><p>解析XML有两种方式，一种是DOM解析，另一种则是SAX解析，关于这两个解析方式在网上也有比较充足的资料，就不在这赘述了。在这一个过程还有两个方面是需要关心的，一个是验证模式，另一个是错误处理（还有一个是Spring实现的<code>EntityResolver</code>，自定义了验证文件的获取方式，在本地建立了一个映射而不需要从网络中获取）。</p><p>首先，验证模式同样也有两种，一种是DTD验证模式，另一种是XSD验证模式。因此，在这里需要根据XML文件中的一些信息来探测决定具体使用哪种验证模式，比如说如果内容中包含<code>DOCTYPE</code>则肯定为DTD验证模式，而如果探测不出的话，最终会使用XSD验证模式。错误处理就是当加载<code>Document</code>发生错误时需要做出的反应，简单的实现就是输出错误日志。当以上两个都准备好了后，就先通过<code>DocumentBuilderFactory</code>创建一个<code>DocumentBuilder</code>，再调用<code>DocumentBuilder</code>的<code>parse()</code>方法直接解析并返回一个<code>Document</code>实例即可。</p><h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>注册<code>BeanDefinition</code>实际上就是通过上面获取到的<code>Document</code>的根节点开始逐个遍历子节点（要先判断根节点是否使用的默认命名空间），然后根据<code>&lt;import/&gt;</code>、<code>&lt;alias/&gt;</code>、<code>&lt;bean/&gt;</code>、<code>&lt;beans/&gt;</code>这四种标签分别进行解析，其中<code>&lt;beans/&gt;</code>标签的处理是一个递归的过程，而<code>&lt;bean/&gt;</code>标签的处理则是需要重点关注的，在这个过程中主要分为两步：解析出<code>BeanDefinition</code>并且完成注册。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><h3 id="获取Document-1"><a href="#获取Document-1" class="headerlink" title="获取Document"></a>获取Document</h3><p>目前仅支持XSD格式的验证，并且没有实现<code>EntityResolver</code>，也就是说无法根据自定义的策略从本地拿到验证文件，还是默认的从网络中获取。</p><h3 id="注册BeanDefinition-1"><a href="#注册BeanDefinition-1" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>在目前的实现中，并没有像Spring IoC一样支持四种标签的解析，这里只解析了<code>&lt;bean/&gt;</code>标签。之后，需要重点关注的一个方法就是<code>parseBeanDefinitionElement()</code>，这是解析<code>&lt;bean/&gt;</code>标签的核心逻辑，主要完成了从<code>&lt;bean/&gt;</code>标签的<code>id</code>属性和<code>name</code>属性还有一些别的属性以及子元素中获取到值并组装成一个<code>BeanDefinition</code>（实际上还会包装一层<code>BeanDefinitionHolder</code>，其中保存了<code>beanName</code>和<code>aliases</code>），下面对这一部分的细节进行分析。</p><h4 id="parseBeanDefinitionElement"><a href="#parseBeanDefinitionElement" class="headerlink" title="parseBeanDefinitionElement"></a>parseBeanDefinitionElement</h4><p>这个方法主要完成以下这些事：</p><ol><li>解析出<code>&lt;bean&gt;</code>标签中的<code>id</code>属性和<code>name</code>属性，在Spring中是以<code>,</code>作为分隔符取得多个别名，但在这里的实现中只考虑一种别名的情况，也就是没有使用<code>,</code>进行分割。</li><li>优先使用id作为<code>beanName</code>，但如果并没有设置<code>id</code>属性的话，就使用第一个别名作为<code>beanName</code>，那么在这里就只有唯一的一个别名，当id没设置时它就是<code>beanName</code>。</li><li>检查<code>beanName</code>和别名的唯一性，如果不唯一，则抛出异常，唯一的话则加入到集合中去。（注意，别名也是需要唯一的）</li><li>解析别的属性以及子元素，开始构造<code>AbstractBeanDefinition</code>。上面几步只是对名称做一些解析，这一步的工作量则相对要大很多，下面是一些比较常见的属性：<br> 4.1. 解析<code>class</code>属性，最重要的了<br>4.2. 解析<code>parent</code>属性，未实现<br>4.3. 解析<code>scope</code>属性<br>4.4. 解析<code>autowire</code>属性<br>4.5. 解析<code>init-method</code>属性<br>4.6. 解析<code>destroy-method</code>属性<br>4.7. 解析<code>factory-bean</code>属性<br>4.8. 解析<code>factory-method</code>属性<br>4.9. 解析<code>&lt;lookup-method/&gt;</code>子元素，未实现<br>4.10. 解析<code>&lt;replaced-method/&gt;</code>子元素，未实现<br>4.11. 解析<code>&lt;property/&gt;</code>子元素，这一步也很重要，它将属性名和属性值封装到了<code>PropertyValue</code>中，并且用<code>PropertyValues</code>封装所有属性（也就是每个<code>BeanDefinition</code>都有一个<code>PropertyValues</code>类型的成员变量）。<br>4.12. 解析<code>&lt;constructor-arg/&gt;</code>子元素，未实现</li><li>此时已经构造出了一个相对完整的<code>BeanDefinition</code>了，这时候将其和<code>beanName</code>与别名一起封装成<code>BeanDefinitionHolder</code>对象。</li><li>注册<code>beanName</code> -&gt; <code>BeanDefinition</code>以及<code>alias</code> -&gt; <code>beanName</code>的映射关系（个人认为，这正是IoC的本质所在，通过一个映射表维护一个名称到<code>BeanDefinition</code>的关系，而这个<code>BeanDefinition</code>中封装了这个Bean的各种信息）。这里要注意的是，在注册<code>alias</code> -&gt; <code>beanName</code>的映射关系时，Spring考虑了别名循环指向的问题，它是通过递归来进行判断的。</li><li>此时，这个<code>BeanDefinition</code>已经注册成功，可以等待使用了</li></ol><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>针对根据XML获取<code>Document</code>实例并注册<code>BeanDefinition</code>的过程做一些简单的测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadBeanDefinitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\simple.xml"</span>);</span><br><span class="line">    BeanDefinitionRegistry registry = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);</span><br><span class="line">    assertEquals(beanDefinitionReader.loadBeanDefinitions(resource), <span class="number">2</span>);</span><br><span class="line">    assertEquals(((DefaultListableBeanFactory) registry).getBeanDefinition(<span class="string">"first"</span>).getBeanClassName(),</span><br><span class="line">            <span class="string">"beans.First"</span>);</span><br><span class="line">    assertEquals(((DefaultListableBeanFactory) registry).getBeanDefinition(<span class="string">"second"</span>).getBeanClassName(),</span><br><span class="line">            <span class="string">"beans.Second"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;在之前已经介绍过Spring IoC对资源的抽象了，也就是&lt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="IoC" scheme="http://yoursite.com/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：资源加载</title>
    <link href="http://yoursite.com/2019/05/19/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9A%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/19/Simple-IoC开发日志：资源加载/</id>
    <published>2019-05-19T13:51:40.000Z</published>
    <updated>2019-05-19T14:04:00.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>Spring对资源文件和资源的加载都做了统一的抽象，以下是资源文件的继承体系：<br><img src="http://blog.default.nanwulife.com/spring-201805091003.jpg" alt=""></p><p>其中，顶层接口<code>InputStreamSource</code>只包含一个<code>getInputStream()</code>方法用于返回指定资源的<code>InputStream</code>；而<code>Resource</code>是对资源的一个抽象，里面提供了判断资源是否存在、资源是否可读、资源大小等常见接口，并且大部分接口由抽象子类<code>AbstractResource</code>提供了默认实现，而一些方法则由具体的子类如<code>FileSystemResource</code>、<code>ClassPathResource</code>等覆写，以满足特定的场景需求。</p><p>接下来看看Spring对资源加载的统一抽象，同样从它的继承体系说起：<br><img src="http://blog.default.nanwulife.com/FileSystemResourceLoader.png" alt=""></p><p>与<code>AbstractResource</code>相似，<code>DefaultResourceLoader</code>是<code>ResourceLoader</code>的默认实现。其中<code>getResource()</code>方法是其核心（两个子类都没覆盖该方法），它根据方法参数<code>location</code>的内容来决定到底是返回<code>ClassPathResource</code>还是<code>FileSystemResource</code>还是<code>Resource</code>其它的一些子类。由于在默认的实现策略中，凡是以<code>/</code>开头的都会返回<code>ClassPathContextResource</code>类型的资源，但对于<code>/user/hecenjie/test.xml</code>这样的路径我们更加希望是<code>FileSystemResource</code>类型的资源，因此在子类<code>FileSystemResourceLoader</code>中覆写了相关方法，使之可以从文件系统中获取资源；而另一个子类<code>ClassRelativeResourceLoader</code>则扩展了功能，可以根据给定的Class所在包或者所在包的子包下加载资源。</p><p><code>ResourceLoader</code>的另一个重要实现是<code>ResourcePatternResolver</code>，与上面的<code>ResourceLoader</code>实现类不同的是，它支持根据指定的资源路径匹配模式每次返回多个<code>Resource</code>实例（也就是<code>Resource</code>数组），并且它也新增了一种新的协议前缀<code>classpath*:</code>，该前缀表示可以加载多个jar包中相同的资源文件，而<code>classpath:</code>只能加载找到的第一个文件。</p><p><code>PathMatchingResourcePatternResolver</code>除了支持<code>ResourceLoader</code>和<code>ResourcePatternResolver</code>新增的<code>classpath*:</code>前缀外，还支持Ant风格的路径匹配模式（类似于<code>**/*.xml</code>）。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><p>目前自己实现的IoC容器中，只实现了文件系统的资源与加载抽象，以下为它们各自的类图：<br><img src="http://blog.default.nanwulife.com/FileSystemResource.png" alt=""> </p><p><img src="http://blog.default.nanwulife.com/FileSystemResourceLoader1.png" alt=""></p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>我们可以尝试写一些简单的单元测试从文件系统中加载指定的资源，并对该资源做一些基本操作。首先，准备一个<code>test.xml</code>文件，然后编写以下测试方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSystemResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> FileSystemResource(<span class="string">"C:\\Users\\canjie\\Desktop\\test.xml"</span>);</span><br><span class="line">    assertTrue(resource.exists());</span><br><span class="line">    assertEquals(resource.contentLength(), <span class="number">992</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSystemResourceLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\test.xml"</span>);</span><br><span class="line">    assertTrue(resource.exists());</span><br><span class="line">    assertEquals(resource.contentLength(), <span class="number">992</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;Spring对资源文件和资源的加载都做了统一的抽象，以下是资
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis之Mapper接口</title>
    <link href="http://yoursite.com/2019/05/19/Mybatis%E4%B9%8BMapper%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/05/19/Mybatis之Mapper接口/</id>
    <published>2019-05-19T11:26:00.000Z</published>
    <updated>2019-05-19T11:27:08.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MyBatis有两种方式能和数据库打交道，一种是直接调用<code>SqlSession</code>的<code>select()</code>、<code>update()</code>等方法，传入statementId参数即可；另一种则是通过Mapper接口，这种方式在实际应用中更加常见，因为它使我们可以使用面向接口编程的方式操作数据库。</p><h2 id="XML映射文件"><a href="#XML映射文件" class="headerlink" title="XML映射文件"></a>XML映射文件</h2><p>Mybatis将所有XML配置信息都封装到<code>Configuration</code>内部，在XML映射文件中：</p><ul><li><code>&lt;parameterMap&gt;</code>标签，会被解析为<code>ParameterMap</code>对象，其每个子元素会被解析为<code>ParameterMapping</code>对象</li><li><code>&lt;resultMap&gt;</code>标签，会被解析为<code>ResultMap</code>对象，其每个子元素会被解析为<code>ResultMapping</code>对象</li><li>每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，均会被解析为一个<code>MappedStatement</code>对象，标签内的SQL会被解析为一个<code>BoundSql</code>对象</li></ul><h2 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h2><p>在MyBatis中，Mapper接口是与XML映射文件相对应的，它们之间的对应关系如下：</p><ul><li>接口的全限名，就是映射文件中的<code>namespace</code>的值</li><li>接口的方法名，就是映射文件中<code>MappedStatement</code>的<code>id</code>值</li><li>接口方法内的参数，就是传递给SQL的参数</li></ul><p>当调用接口方法时，通过接口全限名+方法名可唯一定位一个对应的<code>MappedStatement</code>，MyBatis会使用JDK动态代理自动为该Mapper接口生成代理对象，而这个代理对象会拦截接口的方法，从而调用对应的<code>MappedStatement</code>方法，最终执行SQL语句并返回执行结果。</p><p>也正因为是全限名+方法名的保存和寻找策略，所以Mapper接口里的方法是不能重载的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://svip.iocoder.cn/MyBatis/Interview/" target="_blank" rel="noopener">精尽 MyBatis 面试题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MyBatis有两种方式能和数据库打交道，一种是直接调用&lt;code&gt;SqlSession&lt;/code&gt;的&lt;code&gt;select()&lt;/co
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Spring MVC：请求处理流程</title>
    <link href="http://yoursite.com/2019/05/19/Spring-MVC%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/19/Spring-MVC：请求处理流程/</id>
    <published>2019-05-19T09:12:00.000Z</published>
    <updated>2019-05-19T10:01:03.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p><img src="http://blog.default.nanwulife.com/20180708224853769.png" alt=""></p><h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>虽然在上面的整体流程图中，我们看到请求首先是被<code>DispatcherServlet</code>所处理，但是实际上，<code>FrameworkServlet</code>才是真正的入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// &lt;1&gt; 获得请求方法</span></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="comment">// &lt;2.1&gt; 处理 PATCH 请求</span></span><br><span class="line"><span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="comment">// &lt;2.2&gt; 调用父类，处理其它请求</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当不是<code>PATCH</code>请求时，会调用父类<code>HttpServlet</code>的<code>service()</code>方法，在这个方法中调用由子类<code>FrameworkServlet</code>实现的<code>doGet()</code>、<code>doPost()</code>、<code>doPut()</code>、<code>doDelete()</code>等各种方法上，而这些方法最终会调用<code>processRequest()</code>方法，处理请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doService(request, response);   <span class="comment">// 执行真正的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法，交由子类 DispatcherServlet 实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p><code>DispatcherServlet</code>实现了<code>FrameworkServlet</code>的<code>doService()</code>方法，这个方法中会调用到<code>doDispatch()</code>执行请求的分发，而这个过程正是处理请求的核心逻辑，也对应着本文最开始的流程图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);<span class="comment">// 检查是否是上传请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取可处理当前请求的处理器</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果获取不到，则调用 noHandlerFound 根据配置抛出异常或返回 404</span></span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取可执行处理器逻辑的适配器</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">String method = request.getMethod();    <span class="comment">// 处理 last-modified 消息头</span></span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行拦截器 preHandle 方法</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 真正调用处理器逻辑（一般就是在这里调用我们的 Controller 方法）</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 controller 未返回 view 名称，这里生成默认的 view 名称</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行拦截器 postHandle 方法</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 解析并渲染视图</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line"><span class="comment">// 如果是上传请求，清理资源</span></span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个过程涉及以下几个核心组件：</p><ul><li><code>DispatcherServlet</code>：请求入口，负责协调各个组件工作</li><li><code>HandlerMapping</code>：内部维护了一些&lt;访问路径，处理器&gt;映射，负责为请求找到合适的处理器</li><li><code>HandlerAdapter</code>：处理器的适配器。Spring中的处理器的实现多变，比如用户处理器可以实现<code>Controller</code>接口，也可以用<code>@RequestMapping</code>注解将方法作为一个处理器等，这就导致 Spring 不止到怎么调用用户的处理器逻辑。所以这里需要一个处理器适配器，由处理器适配器去调用处理器的逻辑</li><li><code>ViewResolver</code>：根据视图名查找获得视图对象<code>View</code></li><li><code>View</code>：视图对象用于将模板渲染成html或其他类型的文件。比如<code>InternalResourceView</code>可将jsp渲染成 html。</li></ul><p>完整流程虽然像上面那样，但在目前主流的架构中，前后端已经彻底分离了，所以也就将View移交给了前端，上面的视图解析与渲染步骤已不再需要，而是当Handler（Controller）执行完后，判断方法是否有<code>@ResponseBody</code>注解，有的话则直接将结果写回给用户。但是由于HTTP是不支持返回Java POJO对象的，所以还需要将结果使用<code>HttpMessageConverter</code>进行转换后才能返回。</p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>根据请求获得相应的处理器和拦截器们（<code>HandlerInterceptor</code>数组 )，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerMapping.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".bestMatchingPattern"</span>;</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".uriTemplateVariables"</span>;</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".matrixVariables"</span>;</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".producibleMediaTypes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得请求对应的处理器和拦截器们</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的对象类型是<code>HandlerExecutionChain</code>，它包含处理器（<code>handler</code>）和拦截器们（<code>HandlerInterceptor</code>数组），简单代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerExecutionChain.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 处理器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 拦截器数组 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是处理器的类型是<code>Object</code>。</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>因为处理器<code>handler</code>的类型是<code>Object</code>类型，需要有一个调用者来实现<code>handler</code>是怎么被使用，怎么被执行，而<code>HandlerAdapter</code>的用途就在于此：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 是否支持该处理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 执行处理器，返回 ModelAndView 结果 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回请求的最新更新时间。如果不支持该操作，则返回 -1 即可 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><p><code>HandlerInterceptor</code>是Spring MVC中的拦截器接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter&#125; 执行完之后，无论成功还是失败，</span></span><br><span class="line"><span class="comment"> * 并且，只有 &#123;<span class="doctag">@link</span> #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结来说：</p><ul><li><code>preHandle()</code>方法，按拦截器定义顺序调用，若任一拦截器返回<code>false</code>，则后面的拦截器不再执行，且Controller方法不再调用，处理请求流程结束</li><li><code>postHandle()</code>方法，按拦截器定义逆序调用，在调用Controller方法成功之后执行</li><li><code>afterCompletion()</code>方法，按拦截器定义逆序调用，只有该拦截器在<code>preHandle()</code>方法返回<code>true</code>，Controller方法执行完后才能够被调用（不管是否执行成功），且一定会被调用（过程中出现的异常仅会记录到日志中，不会打断下一个拦截器的<code>afterCompletion()</code>执行）。</li></ul><h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2><p>在Spring MVC中，可以使用<code>@RequestBody</code>和<code>@ResponseBody</code>两个注解，分别完成请求报文到对象和对象到响应报文的转换，底层这种灵活的消息转换机制就是通过<code>HttpMessageConverter</code>完成的。</p><p>我们知道，在Servlet标准中，可以用<code>javax.servlet.ServletRequest</code>接口中的以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>来得到一个<code>ServletInputStream</code>，从这个<code>ServletInputStream</code>中，可以读取到一个原始请求报文的所有内容。同样的，在<code>javax.servlet.ServletResponse</code>接口中，可以用以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>来得到一个<code>ServletOutputStream</code>，从这个<code>ServletOutputSteam</code>中，可以输出Http的响应报文内容。</p><p>当请求报文来到Java世界，它会被封装成为一个<code>ServletInputStream</code>的输入流，供我们读取报文，而响应报文则是通过一个<code>ServletOutputStream</code>的输出流，来输出响应报文。由于从输入流中只能读取到原始的字符串报文，同样，往输出流中也只能写原始的字符，但在处理业务逻辑时更多都是以一个个对象作为处理维度的，因此在SpringMVC中，由<code>HttpMessageConverter</code>完成这中间的一个转换工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMessageNotReadableException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T t, MediaType contentType, HttpOutputMessage outputMessage)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMessageNotWritableException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpMessageConverter</code>接口的定义出现了成对的<code>canRead()</code>+<code>read()</code> 和<code>canWrite()</code>+<code>write()</code> 方法，而参数中的<code>HttpInputMessage</code>和<code>HttpOutputMessage</code>则分别是Spring MVC内部对Http请求报文和响应报文的抽象。下面通过一个例子解释消息转换的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/string"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">readString</span><span class="params">(@RequestBody String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Read string '"</span> + string + <span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在SpringMVC进入<code>readString(@RequestBody String string)</code>方法前，会根据<code>@RequestBody</code>注解选择适当的<code>HttpMessageConverter</code>实现类来将请求参数解析到<code>string</code>变量中，具体来说是使用了<code>StringHttpMessageConverter</code>类，它的<code>canRead()</code>方法返回<code>true</code>，然后它的<code>read()</code>方法会从请求中读出请求参数，绑定到<code>readString(@RequestBody String string)</code>方法的<code>string</code>变量中。</p><p>当Spring MVC执行<code>readString(@RequestBody String string)</code>方法后，由于返回值标识了<code>@ResponseBody</code>注解，Spring MVC将使用<code>StringHttpMessageConverter</code>的<code>write()</code>方法，将结果作为<code>String</code>值写入响应报文，当然，此时<code>canWrite()</code>方法返回<code>true</code>。</p><h3 id="RequestResponseBodyMethodProcessor"><a href="#RequestResponseBodyMethodProcessor" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h3><p><code>RequestResponseBodyMethodProcessor</code>同时实现了<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>两个接口，前者是将请求报文绑定到处理方法形参的策略接口，后者则是对处理方法返回值进行处理的策略接口。</p><p>对<code>HandlerMethodArgumentResolver</code>接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestResponseBodyMethodProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object argument = readWithMessageConverters(webRequest, parameter, parameter.getGenericParameterType());</span><br><span class="line"></span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, argument, name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argument != <span class="keyword">null</span>) &#123;</span><br><span class="line">validate(binder, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> argument;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对<code>HandlerMethodReturnValueHandler</code>接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestResponseBodyMethodProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> returnType.getMethodAnnotation(ResponseBody.class) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (returnValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">writeWithMessageConverters(returnValue, returnType, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个接口的实现，分别是以是否有<code>@RequestBody</code>和<code>@ResponseBody</code>为条件，然后分别调用<code>HttpMessageConverter</code>来进行消息的读写。</p><h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><p>Spring MVC提供了异常解析器<code>HandlerExceptionResolver</code>接口，将处理器执行时发生的异常，转换成对应的<code>ModelAndView</code>结果。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析异常，转换成对应的 ModelAndView 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，如果异常被解析成功，则会返回<code>ModelAndView</code>对象。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tianxiaobo.com/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 一个请求的旅行过程</a></li><li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/#3-3-processDispatchResult" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 请求处理一览</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;处理流程&quot;&gt;&lt;a href=&quot;#处理流程&quot; class=&quot;headerlink&quot; title=&quot;处理流程&quot;&gt;&lt;/a&gt;处理流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blog.default.nanwulife.com/20180708224853769.
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC" scheme="http://yoursite.com/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Spring MVC：WebApplicationContext容器初始化</title>
    <link href="http://yoursite.com/2019/05/19/WebApplicationContext%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/19/WebApplicationContext容器初始化/</id>
    <published>2019-05-19T04:39:00.000Z</published>
    <updated>2019-05-19T09:13:07.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略非关键的配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [1] Spring配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Spring Bean的配置文件所在目录，默认配置在WEB-INF目录下。该 &lt;context-param&gt; 标签会被设置到 ServletContext 中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ====================================== --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [2] Spring MVC配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以自定义servlet.xml配置文件的位置和名称，默认为WEB-INF目录下，名称为[&lt;servlet-name&gt;]-servlet.xml，如spring-servlet.xml</span></span><br><span class="line"><span class="comment">    &lt;init-param&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt; // 默认</span></span><br><span class="line"><span class="comment">    &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[1]</code>处配置了<code>org.springframework.web.context.ContextLoaderListener</code>对象，它实现了<code>javax.servlet.ServletContextListener</code>接口，会初始化一个Root WebApplicationContext容器；</li><li><code>[2]</code>处配置了<code>org.springframework.web.servlet.DispatcherServlet</code>对象，它实现了<code>javax.servlet.http.HttpServlet</code>，除了拦截我们制定的<code>*.do</code>请求外，也会初始化一个属于它的 Servlet WebApplicationContext 容器，并且这个容器是以 [1] 处的 Root 容器作为父容器。</li></ul><p>下面就以上两个容器进行分析，一个是业务容器，一个是Web容器。</p><h2 id="Root-WebApplicationContext"><a href="#Root-WebApplicationContext" class="headerlink" title="Root WebApplicationContext"></a>Root WebApplicationContext</h2><p>Root WebApplicationContext也就是业务容器，用于加载业务逻辑相关的类，比如service、dao层的一些类。它的初始化是通过<code>ContextLoaderListener</code>来实现，在Servlet容器启动时，例如Tomcat、Jetty启动，则会被<code>ContextLoaderListener</code>监听到，从而调用<code>contextInitialized(ServletContextEvent event)</code>方法，初始化Root WebApplicationContext容器。它的核心配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [1] Spring配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上，<code>ContextLoaderListener</code>可通过<code>ServletContext</code>获取到<code>contextConfigLocation</code>配置。这样，业务容器就可以加载<code>application.xml</code>配置文件了。</p><h3 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h3><p><code>org.springframework.web.context.ContextLoaderListener</code>，实现<code>ServletContextListener</code>接口，继承<code>ContextLoader</code>类，上面说过，它实现了Servlet容器启动和关闭时，分别初始化和销毁<code>WebApplicationContext</code>容器。</p><p><img src="http://blog.default.nanwulife.com/01.png" alt=""></p><p>对于<code>ContextLoaderListener</code>，它的初始化和销毁的真正逻辑其实是由父类<code>ContextLoader</code>实现的。</p><ul><li><p>初始化<code>WebApplicationContext</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextLoaderListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 WebApplicationContext，调用父类实现的方法</span></span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁<code>WebApplicationContext</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextLoaderListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    closeWebApplicationContext(event.getServletContext());</span><br><span class="line">    ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Servlet-WebApplicationContext"><a href="#Servlet-WebApplicationContext" class="headerlink" title="Servlet WebApplicationContext"></a>Servlet WebApplicationContext</h2><p>Servlet WebApplicationContext也就是Web容器，它的初始化是在<code>DispatcherServlet</code>初始化的过程中执行，并且会将业务容器作为父容器，之所以这样是因为Web容器中的一些Bean会依赖于业务容器中的Bean，比如我们的controller层接口通常会依赖service层的业务逻辑类。</p><p><img src="http://blog.default.nanwulife.com/01%20%281%29.png" alt=""></p><p>以下是这个继承体系中各个类负责的任务，结构还是比较清晰的：</p><ul><li><p><code>HttpServletBean</code>：覆写了父类<code>HttpServlet</code>中的<code>init()</code>方法，是创建Web容器的入口，负责将<code>ServletConfig</code>设置到<code>HttpServletBean</code>的子类对象中（比如<code>DispatcherServlet</code>）。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServletBean.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple extension of &#123;<span class="doctag">@link</span> javax.servlet.http.HttpServlet&#125; which treats</span></span><br><span class="line"><span class="comment"> * its config parameters (&#123;<span class="doctag">@code</span> init-param&#125; entries within the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> servlet&#125; tag in &#123;<span class="doctag">@code</span> web.xml&#125;) as bean properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>FrameworkServlet</code>：覆写了父类<code>HttpServletBean</code>中的<code>initServletBean()</code>方法，负责初始化Servlet WebApplicationContext容器。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base servlet for Spring's web framework. Provides integration with</span></span><br><span class="line"><span class="comment"> * a Spring application context, in a JavaBean-based overall solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>DispatcherServlet</code>：负责初始化Spring MVC的各个组件，以及处理客户端的请求。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central dispatcher for HTTP request handlers/controllers, e.g. for web UI controllers</span></span><br><span class="line"><span class="comment"> * or HTTP-based remote service exporters. Dispatches to registered handlers for processing</span></span><br><span class="line"><span class="comment"> * a web request, providing convenient mapping and exception handling facilities.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Root-WebApplicationContext/" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 容器的初始化（一）之 Root WebApplicationContext 容器</a></li><li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Servlet-WebApplicationContext/#5-SourceFilteringListener" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 容器的初始化（二）之 Servlet WebApplicationContext 容器</a></li><li><a href="https://www.tianxiaobo.com/2018/06/30/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 容器的创建过程</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web-xml&quot;&gt;&lt;a href=&quot;#web-xml&quot; class=&quot;headerlink&quot; title=&quot;web.xml&quot;&gt;&lt;/a&gt;web.xml&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC" scheme="http://yoursite.com/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis插件机制</title>
    <link href="http://yoursite.com/2019/05/17/MyBatis%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/17/MyBatis插件机制/</id>
    <published>2019-05-17T14:31:00.000Z</published>
    <updated>2019-05-17T14:33:27.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。MyBatis所允许拦截的接口与方法如下：</p><ul><li><code>Executor</code> </li><li><code>ParameterHandler</code> </li><li><code>ResultSetHandler</code> </li><li><code>StatementHandler</code> </li></ul><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>如果我们要实现一个插件，比如我们想要拦截<code>Executor</code>的<code>query</code>方法，那么可以这样定义插件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">    <span class="meta">@Signature</span>(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = <span class="string">"query"</span>,</span><br><span class="line">        args =&#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="meta">@Signature</span>(...),</span><br><span class="line">    <span class="meta">@Signature</span>(...)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的注解是必须的，<code>@Intercepts</code>注解装载一个<code>@Signature</code>列表，一个<code>@Signature</code>其实就是一个需要拦截的方法封装。那么，当一个拦截器要拦截多个方法，自然就是一个<code>@Signature</code>列表。</p><p>除此之外，我们还需将插件配置到相关文件中，这样MyBatis在启动时可以加载插件，并保存插件实例到拦截器链<code>InterceptorChain</code>中。待准备工作做完后，MyBatis处于就绪状态。我们在执行SQL时，需要先通过<code>DefaultSqlSessionFactory</code>创建<code>SqlSession</code>。<code>Executor</code>实例会在创建<code>SqlSession</code>的过程中被创建，<code>Executor</code>实例创建完毕后，MyBatis会通过JDK动态代理为实例生成代理类。这样，插件逻辑即可在<code>Executor</code>相关方法被调用前执行。配置示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.mybatis3.interceptor.ExamplePlugin"</span>&gt;</span></span><br><span class="line">                // ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h2><p><code>Executor</code>实例是在开启<code>SqlSession</code>时被创建的，<code>Executor</code>的创建过程封装在<code>Configuration</code>中，注册插件也正是这个时候：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 executorType 创建相应的 Executor 实例</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册插件</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面创建好<code>Executor</code>后，紧接着通过拦截器链<code>interceptorChain</code>为<code>Executor</code>实例注册代理逻辑（注意是注册而非执行）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历拦截器集合</span></span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">          <span class="comment">// 调用拦截器的 plugin 方法植入相应的插件逻辑</span></span><br><span class="line">          target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>它的<code>pluginAll()</code>方法会调用具体插件的<code>plugin()</code>方法注册相应的插件逻辑。如果有多个插件，则会多次调用<code>plugin()</code>方法，最终生成一个层层嵌套的代理类。<code>plugin()</code>方法是由具体的插件类实现，以下是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取插件类 @Signature 注解内容</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 获取目标类实现的接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>plugin</code>方法在内部调用了<code>Plugin</code>类的<code>wrap()</code>方法，用于为目标对象生成代理。<code>Plugin</code>类实现了<code>InvocationHandler</code>接口，因此它可以作为参数传给<code>Proxy</code>的<code>newProxyInstance()</code>方法。</p><h2 id="执行插件"><a href="#执行插件" class="headerlink" title="执行插件"></a>执行插件</h2><p>在上面注册插件的过程中，我们在<code>wrap()</code>方法中看到了如下代码，它传入了一个<code>Plugin</code>对象作为参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">    type.getClassLoader(),</span><br><span class="line">    interfaces,</span><br><span class="line">    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br></pre></td></tr></table></figure></p><p><code>Plugin</code>实现了<code>InvocationHandler</code>接口，因此它的<code>invoke()</code>方法会拦截所有的方法调用。<code>invoke()</code>方法会对所拦截的方法进行检测，以决定是否执行插件逻辑。该方法的逻辑如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取被拦截方法列表</span></span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">     <span class="comment">// 检测方法列表是否包含当前被拦截的方法</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="comment">// 执行插件逻辑，在 ExamplePlugin 实现中仅仅为执行被拦截的方法</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 执行被拦截的方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tianxiaobo.com/2018/08/26/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">MyBatis 源码分析 - 插件机制</a></li><li><a href="https://my.oschina.net/zudajun/blog/738973" target="_blank" rel="noopener">Mybatis3.4.x技术内幕（十九）：Mybatis之plugin插件设计原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis缓存机制</title>
    <link href="http://yoursite.com/2019/05/17/MyBatis%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/17/MyBatis缓存机制/</id>
    <published>2019-05-17T04:10:00.000Z</published>
    <updated>2019-05-17T04:11:42.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>缓存机制是MyBatis的一大特性，它分为一级和二级缓存，其中一级缓存是<code>SqlSession</code>级别的缓存，其实现较为简单，而二级缓存是mapper级别的缓存，并且多个<code>SqlSession</code>之间可以共享。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>每当我们使用MyBatis开启一次和数据库的会话，MyBatis会创建出一个<code>SqlSession</code>对象表示一次数据库会话，对于这种会话级别的数据缓存，我们就称之为一级缓存。通过一级缓存，每次查询时都将结果缓存起来，当下次查询的时候，如果判断先前有个完全一样的查询，会从缓存中直接将结果取出，返回给用户，不需要再进行一次数据库查询了。</p><p><img src="http://blog.default.nanwulife.com/20141121213425390.jpg" alt=""></p><p>我们知道，<code>SqlSession</code>只是一个MyBatis对外的接口，<code>SqlSession</code>将它的工作交给了<code>Executor</code>执行器这个角色来完成，负责完成对数据库的各种操作。当创建了一个<code>SqlSession</code>对象时，MyBatis会为这个<code>SqlSession</code>对象创建一个新的<code>Executor</code>执行器，而缓存信息就被维护在这个<code>Executor</code>执行器中，MyBatis将缓存和对缓存相关的操作封装到了<code>Cache</code>接口中。</p><h3 id="PerpetualCache"><a href="#PerpetualCache" class="headerlink" title="PerpetualCache"></a>PerpetualCache</h3><p><code>Executor</code>接口的实现类<code>BaseExecutor</code>中拥有一个<code>Cache</code>接口的实现类<code>PerpetualCache</code>，则对于<code>BaseExecutor</code>对象而言，它将使用<code>PerpetualCache</code>对象维护缓存，下面看一下它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，<code>PerpetualCache</code>实现原理其实很简单，其内部就是通过一个简单的<code>HashMap</code>来实现的，没有其他的任何限制。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>关于一级缓存的生命周期，有以下几条规则：</p><ul><li>MyBatis在开启一个数据库会话时，会创建一个新的<code>SqlSession</code>对象，<code>SqlSession</code>对象中会有一个新的<code>Executor</code>对象，<code>Executor</code>对象中持有一个新的<code>PerpetualCache</code>对象；当会话结束时，<code>SqlSession</code>对象及其内部的<code>Executor</code>对象还有<code>PerpetualCache</code>对象也一并释放掉。</li><li>如果<code>SqlSession</code>调用了<code>close()</code>方法，会释放掉一级缓存<code>PerpetualCache</code>对象，一级缓存将不可用；</li><li>如果<code>SqlSession</code>调用了<code>clearCache()</code>，会清空<code>PerpetualCache</code>对象中的数据，但是该对象仍可使用；</li><li><code>SqlSession</code>中执行了任何一个update操作(<code>update()</code>、<code>delete()</code>、<code>insert()</code>) ，都会清空<code>PerpetualCache</code>对象的数据，但是该对象可以继续使用；</li></ul><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol><li>对于某个查询，会构建一个key值，根据这个key值去缓存<code>Cache</code>中取出对应的缓存结果</li><li>判断从<code>Cache</code>中根据特定的key值取的数据数据是否为空，即是否命中</li><li>如果命中，则直接将缓存结果返回</li><li>如果没命中：<br> 4.1  去数据库中查询数据，得到查询结果<br> 4.2  将key和查询到的结果分别作为key-value对存储到<code>Cache</code>中<br> 4.3. 将查询结果返回</li><li>结束</li></ol><p><img src="http://blog.default.nanwulife.com/20141120133247125.jpg" alt=""></p><h3 id="CacheKey"><a href="#CacheKey" class="headerlink" title="CacheKey"></a>CacheKey</h3><p>在上面的工作流程中已经看到，<code>Cache</code>中的<code>Map</code>是根据一个key来查询缓存的，这个key的决定因素具体如下：</p><ol><li>传入的<code>statementId</code> （比如为<code>com.xxx.mapper.selectUserName</code>）</li><li>查询时要求的结果集中的结果范围 （结果的范围通过<code>rowBounds.offset</code>和<code>rowBounds.limit</code>表示）</li><li>这次查询所产生的最终要传递给JDBC <code>Preparedstatement</code>的SQL语句（<code>boundSql.getSql()</code>）</li><li>要设置的参数值（只用这个SQL语句所需要的参数）</li></ol><p>因此，CacheKey其实就是由<code>statementId + rowBounds + 传递给JDBC的SQL + 传递给JDBC的参数值</code>这四个条件并生成哈希构建而成的。MyBatis认为，对于两次查询，只要构建出的CacheKey一样，就认为它们是完全相同的查询，也就可以根据这个CacheKey去缓存中查找已有的缓存结果。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>MyBatis的一级缓存就是简单的使用了<code>HashMap</code>，MyBatis只负责将查询数据库的结果存储到缓存中去，不会去判断缓存存放的时间是否过长、是否过期，并且也没有对缓存的大小进行限制，因此对于准确性要求比较高的数据来说，要控制好<code>SqlSession</code>的生存时间，其生存时间越长，它缓存的数据有可能就越旧，从而造成与真实数据库的误差较大。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>当开一个会话时，一个<code>SqlSession</code>对象会使用一个<code>Executor</code>对象来完成会话操作，MyBatis的二级缓存机制的关键就是对这个<code>Executor</code>对象做文章。如果用户配置了<code>cacheEnabled=true</code>，那么MyBatis在为<code>SqlSession</code>对象创建<code>Executor</code>对象时，会对<code>Executor</code>对象加上一个装饰者：<code>CachingExecutor</code>，这时<code>SqlSession</code>使用<code>CachingExecutor</code>对象来完成操作请求。<code>CachingExecutor</code>对于查询请求，会先判断该查询请求在二级缓存中是否有缓存结果，如果有缓存结果，则直接返回该结果；如果缓存中没有，再交给真正的<code>Executor</code>对象来完成查询操作，之后<code>CachingExecutor</code>会将真正<code>Executor</code>返回的查询结果放置到缓存中，然后在返回给用户。</p><p><img src="http://blog.default.nanwulife.com/20141123125640998.jpg" alt=""></p><h3 id="缓存粒度"><a href="#缓存粒度" class="headerlink" title="缓存粒度"></a>缓存粒度</h3><p>MyBatis并不是简单地对整个Application就只有一个<code>Cache</code>缓存对象，它将缓存划分的更细，即是Mapper级别的，每一个Mapper都可以拥有一个<code>Cache</code>对象，具体如下：</p><ul><li>为每一个Mapper分配一个<code>Cache</code>缓存对象（使用<code>&lt;cache&gt;</code>节点配置）</li><li>多个Mapper共用一个<code>Cache</code>缓存对象（使用<code>&lt;cache-ref&gt;</code>节点配置）</li></ul><p><img src="http://blog.default.nanwulife.com/20141123125741812.jpg" alt=""></p><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>虽然在Mapper中配置了<code>&lt;cache&gt;</code>，并且为此Mapper分配了<code>Cache</code>对象，这并不表示我们使用Mapper中定义的查询语句查到的结果都会放置到<code>Cache</code>对象之中，我们必须指定Mapper中的某条选择语句是否支持缓存，即在<code>&lt;select&gt;</code>节点中配置<code>useCache=&quot;true&quot;</code>，如 <code>&lt;select id=&quot;selectByMinSalary&quot; resultMap=&quot;BaseResultMap&quot; parameterType=&quot;java.util.Map&quot; useCache=&quot;true&quot;&gt;</code> ，Mapper才会对此Select的查询支持缓存特性。</p><p>总结来说，要想使某条<code>select</code>查询支持二级缓存，需要保证：</p><ol><li>MyBatis支持二级缓存的总开关：全局配置变量参数<code>cacheEnabled=true</code></li><li>该<code>select</code>语句所在的Mapper，配置了<code>&lt;cache&gt;</code>或<code>&lt;cached-ref&gt;</code>节点，并且有效</li><li>该<code>select</code>语句的参数<code>useCache=true</code></li></ol><h3 id="二级缓存实现的选择"><a href="#二级缓存实现的选择" class="headerlink" title="二级缓存实现的选择"></a>二级缓存实现的选择</h3><p>MyBatis对二级缓存的设计非常灵活，它自己内部实现了一系列的<code>Cache</code>缓存实现类，有大量的<code>Cache</code>的装饰器来增强<code>Cache</code>缓存的功能。另外，MyBatis还允许用户自定义<code>Cache</code>接口实现，用户只需要实现<code>org.apache.ibatis.cache.Cache</code>接口，然后将<code>Cache</code>实现类配置在<code>&lt;cache  type=&quot;&quot;&gt;</code>节点的<code>type</code>属性上即可。除此之外，MyBatis还支持跟第三方内存缓存库如Memecached的集成。总之，使用MyBatis的二级缓存有三个选择:</p><ol><li>MyBatis自身提供的缓存实现</li><li>用户自定义的<code>Cache</code>接口实现</li><li>跟第三方内存缓存库的集成</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/luanlouis/article/details/41280959" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的一级缓存实现详解 及使用注意事项</a></li><li><a href="https://blog.csdn.net/luanlouis/article/details/41408341" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的二级缓存的设计原理</a>08341)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;缓存机制是MyBatis的一大特性，它分为一级和二级缓存，其中一级缓存是&lt;code&gt;SqlSession&lt;/code&gt;级别的缓存，其实现较为
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis之#{}和${}的区别</title>
    <link href="http://yoursite.com/2019/05/16/MyBatis%E4%B9%8B-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/16/MyBatis之-和-的区别/</id>
    <published>2019-05-16T09:58:00.000Z</published>
    <updated>2019-05-16T10:00:29.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>动态SQL是MyBatis的强大特性之一，我们在使用MyBatis作为持久层框架时，经常需要动态传递参数，例如我们需要根据用户的姓名来筛选用户时，SQL如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"Lihua"</span>;</span><br></pre></td></tr></table></figure></p><p>上述SQL中，我们希望<code>name</code>是动态可变的，即不同的时刻根据不同的姓名来查询用户，那么在MyBatis的xml中可以如下配置：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = #&#123;<span class="keyword">name</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>或者<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'$&#123;name&#125;'</span>;</span><br></pre></td></tr></table></figure></p><p>这两种方式的本质是不同的，如果不了解其原理，在某些场景下会导致意想不到的后果。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>MyBatis在对SQL语句进行预编译之前，会对SQL进行动态解析，解析为一个<code>BoundSql</code>对象，也正是在这个阶段<code>#{}</code>和<code>${}</code>会有不同的表现。</p><h3 id=""><a href="#" class="headerlink" title="#{}"></a>#{}</h3><p>在动态SQL解析阶段，<code>#{}</code>解析为一个JDBC预编译（<code>PreparedStatement</code>）的参数标记符。例如，如下的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = #&#123;<span class="keyword">name</span>&#125;;</span><br></pre></td></tr></table></figure></p><p>会被解析为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = ?;</span><br></pre></td></tr></table></figure></p><p>也就是说，一个<code>#{}</code>被解析为一个参数占位符<code>?</code>。</p><h3 id="-1"><a href="#-1" class="headerlink" title="${}"></a>${}</h3><p>在动态SQL解析阶段，<code>${}</code>仅仅为一个纯粹的字符串替换。例如，如下的SQL语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">'$&#123;name&#125;'</span>;</span><br></pre></td></tr></table></figure></p><p>当我们传递的参数为<code>Lihua</code>时，上述SQL解析为：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> <span class="keyword">name</span> = <span class="string">"Lihua"</span>;</span><br></pre></td></tr></table></figure></p><p>也就是说，预编译前的SQL语句已经不包含变量<code>name</code>了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于<code>#{}</code>，它其实就对应着JDBC中的<code>PreparedStatement</code>的<code>?</code>，因此一旦MySQL服务器对SQL模板进行了编译，并且存储了函数，<code>PreparedStatement</code>做的就是把参数进行转义后直接传入参数到数据库，然后让函数执行，也就避免了SQL注入的问题；而<code>${}</code>的变量替换是在动态SQL解析阶段，也就是预编译之前，相当于这个SQL语句已经是个常量了，因此会产生SQL注入的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000004617028" target="_blank" rel="noopener">mybatis深入理解(一)之 # 与 $ 区别以及 sql 预编译</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;动态SQL是MyBatis的强大特性之一，我们在使用MyBatis作为持久层框架时，经常需要动态传递参数，例如我们需要根据用户的姓名来筛选用
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis架构设计</title>
    <link href="http://yoursite.com/2019/05/16/MyBatis%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2019/05/16/MyBatis架构设计/</id>
    <published>2019-05-16T08:28:00.000Z</published>
    <updated>2019-05-16T08:29:08.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p><img src="http://blog.default.nanwulife.com/20180314192452838.jpg" alt=""></p><p>MyBatis和数据库交互有两种方式：</p><ol><li>使用传统的MyBatis提供的API：传递Statement Id和查询参数给<code>SqlSession</code>对象，使用<code>SqlSession</code>对象完成和数据库的交互：<br><img src="http://blog.default.nanwulife.com/20141103155203576.jpg" alt=""></li><li>使用Mapper接口：MyBatis将配置文件中的每一个<code>&lt;mapper&gt;</code>节点抽象为一个<code>Mapper</code>接口，而这个接口中声明的方法和<code>&lt;mapper&gt;</code>节点中的<code>&lt;select | update | delete | insert&gt;</code>节点项对应，即<code>select | update | delete | insert</code>节点的id值为<code>Mapper</code>接口中的方法名称，<code>parameterType</code>值表示<code>Mapper</code>对应方法的入参类型，而<code>resultMap</code>值则对应了<code>Mapper</code>接口表示的返回值类型：<br><img src="http://blog.default.nanwulife.com/20141103163301421.jpg" alt=""></li></ol><p>使用<code>Mapper</code>接口的方式并配置好相关信息后，通过<code>SqlSession.getMapper(XXXMapper.class)</code>方法，MyBatis会根据相应的接口声明的方法信息，通过动态代理机制生成一个<code>Mapper</code>实例，我们使用<code>Mapper</code>接口的某一个方法时，MyBatis会根据这个方法的方法名，确定<code>Statement Id</code>，底层还是通过<code>SqlSession.select(&quot;statementId&quot;,parameterObject);</code>或者<code>SqlSession.update(&quot;statementId&quot;,parameterObject);</code>等等来实现对数据库的操作。</p><h2 id="主要构件"><a href="#主要构件" class="headerlink" title="主要构件"></a>主要构件</h2><p>从MyBatis代码实现的角度来看，MyBatis的主要的核心部件有以下几个：</p><ul><li><code>SqlSession</code>：作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</li><li><code>Executor</code>：MyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护</li><li><code>StatementHandler</code>：封装了JDBC Statement操作，负责对JDBC Statement的操作，如设置参数、将Statement结果集转换成<code>List</code>集合</li><li><code>ParameterHandler</code>：负责对用户传递的参数转换成JDBC Statement所需要的参数</li><li><code>ResultSetHandler</code>：负责将JDBC返回的<code>ResultSet</code>结果集对象转换成<code>List</code>类型的集合</li><li><code>TypeHandler</code>：负责java数据类型和jdbc数据类型之间的映射和转换</li><li><code>MappedStatement</code>：<code>MappedStatement</code>维护了一条<code>&lt;select | update | delete | insert&gt;</code>节点的封装</li><li><code>SqlSource</code>：负责根据用户传递的<code>parameterObject</code>，动态地生成SQL语句，将信息封装到<code>BoundSql</code>对象中，并返回</li><li><code>BoundSql</code>：表示动态生成的SQL语句以及相应的参数信息</li><li><code>Configuration</code>：MyBatis所有的配置信息都维持在<code>Configuration</code>对象之中。</li></ul><p>它们的关系如下图所示：</p><p><img src="http://blog.default.nanwulife.com/20141028140852531.png" alt=""></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/luanlouis/article/details/40422941" target="_blank" rel="noopener">《深入理解mybatis原理》 MyBatis的架构设计以及实例分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blog.default.nanwulife.com/20180314192452838.
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>JDBC：PreparedStatement和Statement</title>
    <link href="http://yoursite.com/2019/05/16/JDBC%EF%BC%9APreparedStatement%E5%92%8CStatement/"/>
    <id>http://yoursite.com/2019/05/16/JDBC：PreparedStatement和Statement/</id>
    <published>2019-05-16T06:49:00.000Z</published>
    <updated>2019-05-16T06:49:49.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL支持预编译"><a href="#MySQL支持预编译" class="headerlink" title="MySQL支持预编译"></a>MySQL支持预编译</h2><p>在不使用预编译时，客户端每发送一条sql语句给服务器后，服务器总是需要校验sql语句的语法格式是否正确，然后把sql语句编译成可执行函数，最后才是执行sql语句。其中，校验语法和编译所花的时间可能比执行sql语句花的时间还要多。因此，如果我们需要执行多次<code>insert</code>语句，但每次只是插入的值不同，MySQL都要校验语法和编译，会浪费许多时间，而如果使用预编译功能，那么就只用对sql语句进行一次语法校验和编译，所以效率要高。</p><p>MySQL本身是支持预编译的，MySQL执行预编译分为如下三步：</p><ol><li>执行预编译语句，例如：<code>prepare myFunc from &#39;select * from user where username like ?&#39;</code></li><li>设置变量，例如：<code>set @username=&#39;%小明%&#39;</code></li><li>执行语句，例如：<code>execute myFunc using @username</code></li></ol><p>如果需要再次执行<code>myFunc</code>，那就不再需要第一步，即不需要再编译语句了：</p><ol><li>设置变量，例如：<code>set @username=&#39;%小宋%&#39;</code></li><li>执行语句，例如：<code>execute myFunc using @username</code></li></ol><h2 id="PreparedStatement使用预编译"><a href="#PreparedStatement使用预编译" class="headerlink" title="PreparedStatement使用预编译"></a>PreparedStatement使用预编译</h2><p>JDBC的<code>PreparedStatement</code>接口是有预编译功能的，但是在JDBC MySQL驱动5.0.5以后的版本默认是关闭预编译功能的，因此如果我们不手动开启的话，其实并没有使用到预编译，只是用到了防止sql注入的功能。要开启预编译功能，我们需要设置MySQL连接URL参数：<code>useServerPrepStmts=true</code>，这样才能保证MySQL驱动会先把sql语句发送给服务器进行预编译，然后在执行<code>executeQuery()</code>时只是把参数发送给服务器。</p><p>注意：通过设置MySQL连接参数，目的是告诉MySQL<code>PreparedStatement</code>使用预编译功能，但不管我们是否使用预编译功能，MySQL Server4.1版本以后都是支持预编译功能的。</p><p>当使用不同的<code>PreparedStatement</code>对象来执行相同的sql语句时，还是会出现编译两次的现象，这是因为驱动没有缓存编译后的函数key，导致二次编译。但在实际的应用场景中，我们不可能保持同一个<code>PreparedStatement</code>，此时如果希望缓存编译后的函数的key，那么就要设置MySQL连接参数<code>cachePrepStmts=true</code>。</p><h2 id="在持久层框架中存在的问题"><a href="#在持久层框架中存在的问题" class="headerlink" title="在持久层框架中存在的问题"></a>在持久层框架中存在的问题</h2><p>很多主流持久层框架其实都没有真正的用上预编译，预编译是要我们自己在连接参数上配置的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>MySQL主流版本是支持预编译的，但<code>PremaredStatement</code>在JDBC MySQL驱动5.0.5以后需要手动配置连接参数才可以使用预编译功能，如果同时也开启了缓存，那么MySQL服务器是会缓存编译后的函数，而编译后的函数key缓存在<code>PreparedStatement</code>中，此时不同的<code>PreparedStatement</code>执行相同的sql语句时不会重复编译，也就提高了效率。</li><li><code>Statement</code>对于MySQL数据库是不会对编译后的函数进行缓存的，数据库不会缓存函数，<code>Statement</code>也不会缓存函数的key，所以多次执行相同的sql语句时，还是会先检查sql语句语法是否正确，然后编译sql语句成函数，最后执行函数。</li><li>因为<code>PreparedStatement</code>已经对sql模板进行了编译，并且存储了函数，所以<code>PreparedStatement</code>做的就是把参数进行转义后直接传入参数到数据库，然后让函数执行，这也就是为什么<code>PreparedStatement</code>能够防止sql注入攻击的原因。</li><li><code>PreparedStatement</code>还有一点要注意的是，在数据库端存储的函数和<code>PreparedStatement</code>中存储的函数key，都是建立在数据库连接的基础上的，如果当前数据库连接断开了，数据库端的函数会清空，建立在连接上的<code>PreparedStatement</code>里面的函数key也会被清空。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/Marvel__Dead/article/details/69486947" target="_blank" rel="noopener">JDBC：深入理解PreparedStatement和Statement</a></li><li><a href="https://cs-css.iteye.com/blog/1847772" target="_blank" rel="noopener">探究mysql预编译</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL支持预编译&quot;&gt;&lt;a href=&quot;#MySQL支持预编译&quot; class=&quot;headerlink&quot; title=&quot;MySQL支持预编译&quot;&gt;&lt;/a&gt;MySQL支持预编译&lt;/h2&gt;&lt;p&gt;在不使用预编译时，客户端每发送一条sql语句给服务器后，服务器总是需要校验s
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="PreparedStatement" scheme="http://yoursite.com/tags/PreparedStatement/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池源码分析</title>
    <link href="http://yoursite.com/2019/05/12/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/12/Java线程池源码分析/</id>
    <published>2019-05-12T13:51:00.000Z</published>
    <updated>2019-05-12T13:52:24.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在Java中实现异步任务的处理，我们通常会使用Executor框架，而它的子类<code>ThreadPoolExecutor</code>则提供了线程池的实现，避免了线程频繁创建与销毁所带来的性能开销，为线程做了统一的管理与监控。因此，本文将从<code>Executor</code>接口开始逐层向下分析，重点关注<code>ThreadPoolExecutor</code>，这也是我们平时使用最多的一个类，深入理解它的原理还是很重要的。</p><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><code>Executor</code>接口位于整个体系的最顶层，它只包含一个<code>execute()</code>方法；<code>ExecutorService</code>也是接口，它在<code>Executor</code>接口的基础上添加了很多的接口方法，所以一般我们会使用这个接口；<code>AbstractExecutorService</code>是抽象类，实现了部分的方法，而把其它一些核心方法交给了子类去实现；<code>ThreadPoolExecutor</code>是最核心的一个类，它真正的实现了线程池的相关功能，是重点需要分析的一个类；<code>ScheduledExecutorService</code>是定时任务相关的接口，本文不会去分析该类。</p><p><img src="http://blog.default.nanwulife.com/ScheduledThreadPoolExecutor.png" alt=""></p><p>除此之外，该体系还涉及一个<code>Executors</code>工具类，它提供了很多创建线程池的静态方法，为我们省去了创建线程池时需要关心的参数细节。</p><h2 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Executor</code>接口非常简单，只有一个<code>execute()</code>方法，用来提交一个任务去执行。注意参数是<code>Runnable</code>类型的，表示一个任务。</p><h2 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h2><p>由于<code>Executor</code>接口只有提交任务的功能，我们更多使用的是<code>ExecutorService</code>，它定义的方法比较丰富，大部分情况下已经能满足我们的需求了。例如 ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(args...);</span><br><span class="line">ExecutorService executor = Executors.newCachedThreadPool(args...);</span><br></pre></td></tr></table></figure></p><p>下面看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭线程池：停止接受外部提交的新任务，而等到正在执行的任务以及队列中等待的任务执行完才真正关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池：停止接受外部提交的新任务，忽略队列里等待的任务，尝试将正在跑的任务中断，然后返回未执行的任务列表</span></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池是否关闭</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果调用了 shutdown() 或 shutdownNow() 方法后，所有任务结束了，那么返回 true</span></span><br><span class="line">    <span class="comment">// 这个方法必须在调用 shutdown() 或 shutdownNow() 方法之后调用才会返回 true</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭线程池后等待所有任务完成，并设置超时时间：调用 shutdown() 或 shutdownNow() 方法后，调用该方法阻塞直到所有任务执行完毕或发生了超时，返回 false 表示发生了超时</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Callable 任务，返回一个 Future</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务，返回一个 Future，第二个参数会放到 Future 中作为返回值</span></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交一个 Runnable 任务</span></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个接口提供了大部分我们需要的功能，一些不太常用的如<code>invokeAll()</code>、<code>invokeAny()</code>等上面将其省略了，不进行分析。</p><h2 id="AbstractExecutorService"><a href="#AbstractExecutorService" class="headerlink" title="AbstractExecutorService"></a>AbstractExecutorService</h2><p><code>AbstractExecutorService</code>抽象类实现了几个实用的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将 Runnable 包装成 FutureTask，内部其实会通过 Executors#callable 方法将这个 Runnable 转换成 Callable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交任务，和 execute() 不同的是这个会返回一个 Future</span></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);    <span class="comment">// 将 Runnable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);     <span class="comment">// 将 Runnable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);         <span class="comment">// 将Callable 包装成 FutureTask</span></span><br><span class="line">        execute(ftask);     <span class="comment">// 执行这个任务，execute() 方法交由子类实现，FutureTask 间接实现了 Runnable 接口</span></span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个抽象类封装了一些基本的方法如<code>submit()</code>，但是都没有真正开启线程来执行任务，它们都只是在方法内部调用了<code>execute()</code>方法，而将该方法交由子类去实现。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>ThreadPoolExecutor</code>是JDK中的线程池实现，这个类实现了一个线程池需要的各个方法，比如任务提交、线程管理、监控等等。关于这个方法内容比较多，因此将会拆开来分析。</p><h3 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h3><p>我们先看看该类的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心参数的作用分别如下：</p><ul><li><code>corePoolSize</code>：核心线程数，当线程数小于该值时，线程池会创建新线程来执行新任务</li><li><code>maximumPoolSize</code>：线程池允许创建的最大线程数</li><li><code>keepAliveTime</code>：空闲线程的存活时间，但要注意这个值不会对所有线程起作用，如果线程池中的线程数少于等于核心线程数<code>corePoolSize</code>，那么这些线程不会因为空闲太长时间而被关闭，但也可以通过调用<code>allowCoreThreadTimeOut(true)</code>使核心线程数内的线程也可以被回收。</li><li><code>workQueue</code>：任务队列，用来存储未执行的任务，是<code>BlockingQueue</code>接口的某个实现</li><li><code>threadFactory</code>：线程工厂，可通过工厂为新建的线程设置更有意义的名字</li><li><code>handler</code>：拒绝策略，当线程池和任务队列均处于饱和状态时该使用的处理方式，默认为抛出异常</li></ul><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p><code>ThreadPoolExecutor</code>采用一个32位的整数来存放线程池的状态和当前池中的线程数，其中高3位用于存放线程池状态，低29位表示线程数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 状态控制变量，该变量用于表示线程池的状态和线程数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">/** 该方法用于组合线程池的状态和线程数，通过按位或的方式 */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 就是29 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">/** 线程池的最大线程数，也就是（2^29-1）：000 11111111111111111111111111111 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池的状态存放在高3位中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;     <span class="comment">// 111 0000...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 000 0000...，对应 shutdown()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;        <span class="comment">// 001 0000...，对应 shutdownNow()</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;       <span class="comment">// 010 0000...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;   <span class="comment">// 011 0000...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取线程池的运行状态，~运算符i会将0、1取反</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 获取线程池中的线程数</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure></p><p>这里面的状态还是比较清晰的，并且状态值是顺序递增的。<code>RUNNING</code>表示线程池的初始状态，而<code>SHUTDOWN</code>和<code>STOP</code>分别是调用了<code>shutdown()</code>和<code>shutdownNow()</code>方法后进入的状态，其中在<code>tryTerminate()</code>方法中转换成<code>TIDYING</code>状态，表示在<code>SHUTDOWN / STOP</code>后任务队列和线程池都清空了，此时执行钩子方法<code>terminated()</code>，而当<code>terminated()</code>方法结束后，线程池的状态就会变为<code>TERMINATED</code>。</p><h3 id="Worker"><a href="#Worker" class="headerlink" title="Worker"></a>Worker</h3><p><code>Worker</code>是<code>ThreadPoolExecutor</code>的内部类，用于封装线程池中的工作线程，也就是用来执行任务的，而任务是<code>Runnable</code>（内部变量名叫<code>task</code>或<code>command</code>）。要注意的是，该类继承了AQS，用于实现一个简单的互斥锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程，用来执行任务的</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始任务</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放此线程完成的任务数</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);   <span class="comment">// 通过构造线程池时传入的线程工厂来创建一个新线程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用了外部的 runWorker() 方法</span></span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 以下为AQS相关的方法：</span></span><br><span class="line">    <span class="comment">// 0 表示解锁状态</span></span><br><span class="line">    <span class="comment">// 1 表示加锁状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="runWorker"><a href="#runWorker" class="headerlink" title="runWorker"></a>runWorker</h4><p><code>Worker</code>实现了<code>Runnable</code>接口，并将<code>run()</code>方法的实现委托给了外部类<code>ThreadPoolExecutor</code>的<code>runWorker()</code>方法，这个方法就是不断的从任务队列中拿取任务运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;   <span class="comment">// 用于标记完成任务时是否有异常</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环：初始任务（首次）或者从阻塞队列中拿一个（后续）</span></span><br><span class="line">        <span class="comment">// 这也体现了线程池的意义，工作线程在执行完一个任务后，会再次到任务队列中获取新的任务，实现了”线程复用“</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取互斥锁，在获取互斥锁时，调用 shutdown() 方法不会中断线程，但是 shutdownNow() 方法无视互斥锁，会中断所有线程</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 判断是否需要中断当前线程。如果线程池的状态 &gt;= STOP ，当前线程未中断，则中断当前线程，否则清除线程中断位</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 交由子类实现的前置处理钩子</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 真正的执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 交由子类实现的后置处理钩子</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++; <span class="comment">// 该 Worker 完成的任务数加一</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// while 循环之外</span></span><br><span class="line">        </span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);    <span class="comment">// 处理工作线程退出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="getTask"><a href="#getTask" class="headerlink" title="getTask"></a>getTask</h4><p>在<code>runWorker()</code>方法中，会尝试通过阻塞队列获取任务来执行，而这个获取任务的逻辑则封装到了<code>getTask()</code>这个核心方法中。在以下几种情况会返回<code>null</code>从而接下来线程退出（<code>runWorker()</code>方法中的循环结束）：</p><ol><li>当前工作线程数超过了<code>maximumPoolSize</code>（由于<code>maximumPoolSize</code>可以动态调整，这是可能的）</li><li>线程池状态为<code>STOP</code>（因为<code>STOP</code>状态不处理阻塞队列中的任务了）</li><li>线程池状态为<code>SHUTDOWN</code>，但阻塞队列为空</li><li>线程数量大于<code>corePoolSize</code>或<code>allowCoreThreadTimeOut</code>设置为<code>true</code>，当线程空闲时间超过<code>keepAliveTime</code>（这里说的空闲时间其实就是<code>poll()</code>方法阻塞在队列上的时间）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上次从阻塞队列 poll 任务时是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if 条件等价于  rs &gt;= STOP || (rs == SHUTDOWN &amp;&amp; workQueue.isEmpty())</span></span><br><span class="line">        <span class="comment">// 此时将工作线程数减一</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allowCoreThreadTimeOut 是用于设置核心线程是否受 keepAliveTime 影响，</span></span><br><span class="line">        <span class="comment">// 在 allowCoreThreadTimeOut 为 true 或工作线程数 &gt; corePoolSize的情况下，</span></span><br><span class="line">        <span class="comment">// 当前的工作线程会受 keepAliveTime 影响</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 工作线程数 &gt; maximumPoolSize，当前工作线程需要退出</span></span><br><span class="line">        <span class="comment">// 2. timed &amp;&amp; timedOut == true 说明当前线程受 keepAliveTime 影响并且上次获取任务超时。这种情况下，如果当前线程不是最后一个线程或者队列为空，则可以退出</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 根据 timed 变量的值决定是限时阻塞获取还是一直阻塞获取队列中的任务</span></span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :   <span class="comment">// 超时退出</span></span><br><span class="line">                workQueue.take();   <span class="comment">// 一直阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;    <span class="comment">// 走到这说明 poll 超时了</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><h4 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h4><p>有了上面的一些概念后，接下来我们看看最核心的<code>execute()</code>方法，它包含了提交任务时的几大过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();      <span class="comment">// 获取线程池的状态控制变量</span></span><br><span class="line">    <span class="comment">// 1. 如果线程数少于核心线程池的大小，则添加一个 Worker 来执行任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 到这里说明当前线程数大于等于核心线程池大小（或者 addWorker() 失败），如果线程池处于 RUNNING 状态，则将这个任务添加到阻塞队列 workQueue 中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 2.1 线程池已经关闭了，则移除队列中刚提交的任务</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 2.2 没有工作线程了，则添加一个空任务工作线程用于执行提交的任务</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 如果阻塞队列满了，那么以 maximumPoolSize 为界创建新的 Worker，</span></span><br><span class="line">    <span class="comment">// 如果失败，说明当前线程数已经达到 maximumPoolSize，此时执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先对上面的三大步骤做个抽象层面的梳理：<br><img src="http://blog.default.nanwulife.com/1787733-248f411a83669fff.webp" alt=""></p><ol><li>如果当前运行的线程数少于<code>corePoolSize</code>，则创建新线程来执行任务</li><li>如果运行的线程数大于或等于<code>corePoolSize</code>，则将任务加入阻塞队列</li><li>如果阻塞队列也满了，则以<code>maximumPoolSize</code>为界创建新线程，如果线程数比<code>maximumPoolSize</code>还大，则执行拒绝策略</li></ol><h4 id="addWorker"><a href="#addWorker" class="headerlink" title="addWorker"></a>addWorker</h4><p>下面开始更细的去分析上述三大流程中涉及的一些方法，首先是<code>addWorker()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 准备提交给这个线程执行的任务，可以为 null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core 如果为 true，表示使用核心线程数 corePoolSize 作为创建线程的界限；如果为 false，表示使用最大线程数 maximumPoolSize 作为创建线程的界限</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();          <span class="comment">// 获取线程池的状态控制变量</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c); <span class="comment">// 获取线程池的状态</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">// 当线程池状态小于 SHUTDOWN 时，直接往下继续执行</span></span><br><span class="line">        <span class="comment">// 当线程池状态等于 SHUTDOWN 时，如果 firstTask 为 null，且 workQueue 不为空，是允许创建新的 Worker 的，因为此时要把 workQueue 中的任务执行完；否则，当其中一个条件不满足时，不会继续往下执行</span></span><br><span class="line">        <span class="comment">// 当线程池状态大于 SHUTDOWN 时，不允许创建新的 Worker 提交任务，不会继续往下执行</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);  <span class="comment">// 获取线程数</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||         <span class="comment">// 如果超过了 2^29-1 这个上限，或者超过了 corePoolSize 或 maximumPoolSize（由传入参数决定使用哪个），一样不会继续往下执行</span></span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果成功 CAS 新增 Worker 的数目，跳出循环往下走</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">// 重读状态控制变量，如果线程池状态变了，则重试整个大循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// 否则，仅仅是 workerCount 变了，也就是 CAS 新增 workerCount 失败，重试内层循环</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 运行到此处时，线程池线程数已经成功+1，下面进行实质操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;  <span class="comment">// Worker 是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;  <span class="comment">// Worker 是否已经添加到 workers 中</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);  <span class="comment">// 在这个 Worker 的构造函数中，会通过线程工厂 new 一个新线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;  <span class="comment">// 获取在构造 Worker 时线程工厂 new 出的新线程</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 整个线程池的全局锁，因为关闭线程池是需要这个锁的，这能保证持有锁的期间，线程池不会关闭</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 由于获取锁之前线程池状态可能发生了变化，这里需要重新读一次状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// 如果小于 SHUTDOWN 或者等于 SHUTDOWN 但 firstTask == null（不接受新任务但会继续执行阻塞队列中的任务）</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// worker 中的 thread 不能是已经启动了的，不然要抛出异常</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);     <span class="comment">// 将新创建的 Worker 加入到 workers 这个 HashSet 中</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;    <span class="comment">// 记录线程池的历史最大值</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// Worker 添加成功，启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 Worker 线程启动失败，则做一些回滚操作</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回线程是否启动成功</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里笔者刚开始很疑惑的一点是，为什么<code>t.start();</code>会执行到<code>Worker</code>中的<code>run()</code>方法，它不是<code>Worker</code>中的属性吗，它自己本身并没有传入一个<code>Runnable</code>吧。但实际上，在通过线程工厂创建这个线程的时候，是传入了一个<code>Runnable</code>的，它就是<code>Worker</code>本身：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);   <span class="comment">// 注意这里的 this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此，当我们使用<code>t.start()</code>开启这个<code>Thread</code>的时候，这个<code>Thread</code>中的<code>target</code>是为<code>Worker</code>本身的，所以才会执行它的<code>run()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Thread.java</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>此时就与之前分析<code>Worker</code>时候的方法串起来了，<code>Worker</code>的<code>run()</code>方法的执行逻辑其实是委托给外部类的<code>runWorker()</code>方法来完成，而<code>runWorker()</code>方法最终调用的就是传入的<code>firstTask</code>或者从阻塞队列中取到的某个任务，执行它的<code>run()</code>方法。</p><h4 id="addWorkerFailed"><a href="#addWorkerFailed" class="headerlink" title="addWorkerFailed"></a>addWorkerFailed</h4><p>线程成功启动后的逻辑已经分析完了，接下来看看线程如果启动失败时会发生什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addWorkerFailed</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="keyword">null</span>)</span><br><span class="line">            workers.remove(w);</span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是回滚后尝试终止线程池：</p><ol><li>从<code>workers</code>中删除失败的Worker</li><li><code>workerCount</code>减一</li><li>调用<code>tryTerminate()</code>尝试终止线程池</li></ol><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p><code>shutdown()</code>方法关闭线程池比较优雅，线程池进入<code>SHUTDOWN</code>后不会再接受新任务，并且中断所有空闲线程（阻塞在队列上的线程），但是任务队列中已有的任务将会继续处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();  <span class="comment">// 检查是否有 shutdown 的权限，非重点</span></span><br><span class="line">        advanceRunState(SHUTDOWN);  <span class="comment">// 状态切换到 SHUTDOWN</span></span><br><span class="line">        interruptIdleWorkers();             <span class="comment">// 中断所有空闲线程，或者说在任务队列上阻塞的线程</span></span><br><span class="line">        onShutdown(); <span class="comment">// hook for ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池（状态流转至 TERMINATED）</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">            Thread t = w.thread;</span><br><span class="line">            <span class="comment">// 工作线程在处理任务阶段是被互斥锁保护着的，所以 tryLock() 会返回 false，不会中断到</span></span><br><span class="line">            <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h4><p><code>shutdownNow()</code>方法关闭线程池相比<code>shutdown()</code>暴力了一些，会中断所有线程，哪怕线程正在执行任务。线程池进入<code>STOP</code>状态后既不会接受新任务，也不会处理任务队列中已有的任务。需要注意的是，即便<code>shutdownNow()</code>会中断正在执行任务的线程，但不代表任务一定会挂，因为如果提交的任务里面的代码没有对线程中断敏感的逻辑的话，线程中断是不会有任何效果的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();      <span class="comment">// 检查是否有 shutdown 的权限，非重点</span></span><br><span class="line">        advanceRunState(STOP);      <span class="comment">// 状态切换到 STOP</span></span><br><span class="line">        interruptWorkers();             <span class="comment">// 与 SHUTDOWN 不同的是，直接中断所有线程</span></span><br><span class="line">        tasks = drainQueue();         <span class="comment">// 将任务队列中的任务收集到 tasks</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终止线程池（状态流转至 TERMINATED）</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Worker w : workers)</span><br><span class="line">            w.interruptIfStarted();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此方法在 Worker 类中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h3><p>在<code>execute()</code>方法中我们可以看到，有两种情况会调用<code>reject()</code>拒绝策略来处理任务，一个是当任务加入阻塞队列后的短暂空窗期线程池已经关闭了，此时再次查看线程池的状态不为<code>RUNNING</code>就会将任务移出队列并执行拒绝策略，另一个是当线程数超过了<code>maximumPoolSize</code>，无法再创建新线程了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RejectedExecutionHandler</code>在<code>ThreadPoolExecutor</code>中有四个已经定义好的实现类可供我们直接使用，当然，我们也可以实现自己的策略，不过一般也没有必要。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果线程池没有被关闭，那么由提交任务的线程自己来执行这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不管怎样，直接抛出 RejectedExecutionException 异常</span></span><br><span class="line"><span class="comment">// 这个是默认的策略，如果在构造线程池时不传相应的 handler 的话，那就会使用这个</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不做任何处理，直接忽略掉这个任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果线程池没有被关闭，那么丢弃任务队列中首部的任务，然后提交该任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p><code>Executors</code>是一个工具类，所有的方法都是<code>static</code>的，它为我们创建线程池提供了很大的便利。</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><p>生成一个固定大小的线程池，最大线程数设置为与核心线程数相等，此时<code>keepAliveTime</code>设置为0（因为这里它是没用的，即使不为0，线程池默认也不会回收<code>corePoolSize</code>内的线程），阻塞队列采用<code>LinkedBlockingQueue</code>无界队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><p>生成只有一个线程的线程池，与<code>newFixedThreadPool</code>唯一的不同在于核心线程和最大线程数都为1，不需要指定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><p>生成一个需要的时候就创建新线程的线程池。这种线程池对于任务可以比较快速地完成的情况下有比较好的性能，如果线程空闲了60秒都没有任务，那么将关闭此线程并从线程池中移除。所以如果线程池空闲了很长时间也不会有问题，因为随着所有线程的关闭，整个线程池不会占用任何的系统资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文从<code>Executor</code>顶层接口逐层向下分析，重点讲解了<code>ThreadPoolExecutor</code>的源码实现，包括核心参数、线程创建过程、执行任务、拒绝策略和线程池的关闭等，由于Executor体系本身内容还是比较多的，因此有些地方依然没有关注到，例如定时相关的<code>ScheduledExecutorService</code>接口和同时实现了<code>ThreadPoolExecutor</code>与<code>ScheduledExecutorService</code>的<code>ScheduledThreadPoolExecutor</code>，并且关于<code>ThreadPoolExecutor</code>的线程池关闭这一块，也还有几个方法没有深入分析，将来有时间一定补上。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/micrari/p/7429364.html" target="_blank" rel="noopener">ThreadPoolExecutor源码解读</a></li><li><a href="https://javadoop.com/post/java-thread-pool" target="_blank" rel="noopener">深度解读 java 线程池设计思想及源码实现</a></li><li><a href="http://www.tianxiaobo.com/2018/04/17/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">Java 线程池原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在Java中实现异步任务的处理，我们通常会使用Executor框架，而它的子类&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Executor" scheme="http://yoursite.com/tags/Executor/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码分析</title>
    <link href="http://yoursite.com/2019/05/11/ThreadLocal%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/11/ThreadLocal源码分析/</id>
    <published>2019-05-11T03:31:00.000Z</published>
    <updated>2019-05-11T03:32:42.851Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>每个线程读写<code>ThreadLocal</code>是线程隔离的，互相之间不会影响。其原因就是在于<code>Thread</code>类有一个<code>ThreadLocal.ThreadLocalMap</code>类型的属性，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>，读写某个<code>ThreadLocal</code>时都会获取当前线程以及当前线程的<code>ThreadLocalMap</code>属性，对其进行读写，以此实现线程隔离。以下是<code>ThreadLocal</code>的几个关键方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);   <span class="comment">// 将自己作为 key</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);    <span class="comment">// 将自己作为 key</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，<code>ThreadLocal</code>本身并没有太多东西，它只是作为<code>ThreadLocalMap</code>的key，核心源码其实都在<code>ThreadLocalMap</code>中。</p><h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><p>在开始源码分析之前，需要先了解弱引用这个概念，因为在<code>ThreadLocalMap</code>中<code>ThreadLocal</code>并不是直接作为key的，而是使用的弱引用对象<code>Entry</code>。在Java中存在四种引用，分别是强引用、软引用、弱引用和虚引用，它们的区别如下：</p><ul><li>强引用：通常我们通过new来创建一个新对象时返回的引用就是一个强引用，若一个对象通过一系列强引用可到达，它就是强可达的，那么它就不被回收</li><li>软引用：软引用和弱引用的区别在于，若一个对象是弱引用可达，无论当前内存是否充足它都会被回收，而软引用可达的对象在内存不充足时才会被回收，因此软引用要比弱引用“强”一些</li><li>虚引用：虚引用是Java中最弱的引用，通过虚引用甚至无法获取到被引用的对象，虚引用存在的唯一作用就是当它指向的对象被回收后，虚引用本身会被加入到引用队列中，用作记录它指向的对象已被回收</li></ul><p>之所以需要弱引用，是因为在类似<code>HashMap</code>的结构中，如果存放了一个key为<code>Product</code>对象且value为<code>1</code>的节点，此时我们有一个变量<code>product</code>指向了这个<code>Product</code>对象，当我们不再需要这个对象时，如果直接将<code>product</code>设为<code>null</code>，<code>Product</code>对象其实并不会被回收，因为通过<code>HashMap</code>它还存在一条强引用链，如果我们想让它被垃圾收集器回收，就必须将其彻底从<code>HashMap</code>中移除，让它不再存在任何强引用。如果上述过程我们不想自己手动去实现，而是想告诉垃圾收集器在只有<code>HashMap</code>中的key引用着<code>Product</code>对象的情况下，就可以回收相应的<code>Product</code>对象了，那么就可以使用弱引用。</p><p>Java中的弱引用具体指的是<code>java.lang.ref.WeakReference&lt;T&gt;</code>类，我们使用一个指向<code>Product</code>对象的弱引用对象来作为<code>HashMap</code>的<code>key</code>，只需这样定义这个弱引用对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Product product = <span class="keyword">new</span> Product(...);</span><br><span class="line">WeakReference&lt;Product&gt; weakProduct = <span class="keyword">new</span> WeakReference&lt;&gt;(product);</span><br></pre></td></tr></table></figure></p><p>而如果要通过<code>weakProduct</code>获取它所指向的<code>Product</code>对象，我们只需要通过这行代码：<code>Product product = weakProductA.get();</code>即可。<code>WeakReference</code>的构造函数如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个指向给定对象的弱引用</span></span><br><span class="line">WeakReference(T referent)</span><br><span class="line"><span class="comment">//创建一个指向给定对象并且登记到给定引用队列的弱引用</span></span><br><span class="line">WeakReference(T referent, ReferenceQueue&lt;? <span class="keyword">super</span> T&gt; q)</span><br></pre></td></tr></table></figure></p><p>通过将原始对象包装成弱引用对象，当变量<code>product</code>设为<code>null</code>时，指向这个<code>Product</code>对象的就只剩弱引用对象<code>weakProduct</code>了，显然这时候相应的<code>Product</code>对象是弱可达的，所以指向它的弱引用会被清除，这个<code>Product</code>对象随即会被回收，指向它的弱引用对象会进入引用队列中，在引用队列中可以对这些被清除的弱引用对象进行统一管理。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="Entry节点"><a href="#Entry节点" class="headerlink" title="Entry节点"></a>Entry节点</h3><p>上面说过，<code>ThreadLocalMap</code>并不是简单的使用<code>ThreadLocal</code>作为key的，其实它内部存储着一个<code>Entry</code>节点数组，而<code>Entry</code>继承了弱引用类<code>WeakReference</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当构造一个<code>Entry</code>节点时，会先调用父类<code>WeakReference</code>的构造函数将<code>ThreadLocal</code>传入，并设置了一个类型为<code>Object</code>的<code>value</code>，用于存放<code>ThreadLocal</code>对应的值。</p><p>这里之所以要使用弱引用<code>Entry</code>节点而不是简单的key-value形式的节点，是因为如果简单的使用key-value形式会造成节点的生命周期与线程强绑定，只要线程存在，那么作为属性的<code>ThreadLocalMap</code>也就存在，在不显式移除的情况下，key对象就依然被强引用着，没办法被回收。在这里通过使用弱引用节点，当我们将某个<code>ThreadLocal</code>对象的强引用设为<code>null</code>后，这个<code>ThreadLocal</code>对象就只剩下弱引用了，之后会被GC回收掉，有效的避免了内存泄漏的问题。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 初始容量默认为16</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">// Entry 数组，大小必须为2的幂</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中 Entry 的实际个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容时的阈值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p><code>ThreadLocalMap</code>与<code>HashMap</code>不同，它是使用的线性探测法而非拉链法解决碰撞冲突的，所以实际上<code>Entry[]</code>数组在逻辑上是作为一个环形存在的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 环形意义的下一个索引下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环形意义的前一个索引下标</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">// 初始化 table 数组</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">// 用位运算而非取模得到下标，这也是为什么容量需要为偶数的原因</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 构造并设置该节点</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    <span class="comment">// 更新表（数组）的大小</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 设置扩容阈值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个构造函数我们重点需要关注其中的<code>threadLocalHashCode</code>，这是传入的<code>ThreadLocal</code>对象的哈希值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger nextHashCode = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure></p><p>这个哈希值在对象创建时就会生成，每次都会累加<code>0x61c88647</code>，通过这种方式使得与2的幂取模（实际是位运算）后均匀分布，也就提高了线性探测时的效率。</p><h3 id="getEntry"><a href="#getEntry" class="headerlink" title="getEntry"></a>getEntry</h3><p><code>getEntry()</code>方法会被<code>ThreadLocal</code>的<code>get()</code>方法直接调用，上面也说过，<code>get()</code>方法内部就是先拿到当前线程的<code>ThreadLocalMap</code>，然后将自己<code>this</code>作为参数调用其<code>getEntry()</code>方法。这里要提前说明一点的是，每个索引（slot）上的状态有三种：有效（<code>ThreadLocal</code>未回收），失效（<code>ThreadLocal</code>已回收），空（<code>null</code>）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取这个 key 的索引下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="comment">// 对应的 entry 不为空且未失效，且弱引用指向的 ThreadLocal 就是传入的 key，则命中返回</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 因为用的是线性探测，所以往后还是有可能找到目标 Entry 的</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用 getEntry() 未直接命中时调用此方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于线性探测法不断向后探测直到遇到 null</span></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)  <span class="comment">// 如果该 entry 对应的 ThreadLocal 已经被回收（失效），调用 expungeStaleEntry() 来清理无效的 entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span>    <span class="comment">// 如果该 entry 对应的 ThreadLocal 未被回收，但与传入的 key 不等，则继续向后探测</span></span><br><span class="line">            i = nextIndex(i, len);  <span class="comment">// 环形意义下往后面走，线性探测</span></span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到指定的 key</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ThreadLocal 的核心清理函数，从 staleSlot 下标开始遍历，将无效的的 entry 清理，</span></span><br><span class="line"><span class="comment"> * 即将 entry 中的 value 置为 null，指向这个 entry 的 table[i] 置为 null，直到遍历到空 entry。</span></span><br><span class="line"><span class="comment"> * 另外，在这个过程中还会对非空的 entry 作 rehash。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为 entry 对应的 ThreadLocal 已经被回收，此时为了垃圾回收：</span></span><br><span class="line">    <span class="comment">// 将 entry 中的 value 置为 null，显示断开强引用</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将指向这个 entry 的 table[i] 置为 null</span></span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将实际 entry 数减一</span></span><br><span class="line">    size--;</span><br><span class="line">    </span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// 从 staleSlot 的下一个索引开始，不断向后遍历，直到遇到 null</span></span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 如果当前 entry 中的 ThreadLocal 已经被回收，则做一次清理</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 如果 entry 对应的 ThreadLocal 还没被回收，需要做一次 rehash</span></span><br><span class="line">            <span class="comment">// 如果 ThreadLocal 计算出的 hash 对应的索引h与当前位置不同，</span></span><br><span class="line">            <span class="comment">// 则从 h 开始向后线性探测直到第一个空的 slot，把当前的 entry 给挪过去</span></span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;  <span class="comment">// 先将当前索引置 null</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)  <span class="comment">// 遍历找到从索引h开始的第一个空 slot</span></span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;     <span class="comment">// 将 entry 挪到这个空 slot 上</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 staleSlot 之后第一个 entry 为 null 的索引下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总的来说，<code>getEntry()</code>会经历以下几步：</p><ol><li>根据传入的<code>ThreadLocal</code>的哈希值定位到某个索引下标</li><li>如果该下标对应的<code>entry</code>存在，且其中的<code>ThreadLocal</code>和方法传入的<code>ThreadLocal</code>相同，则直接命中返回</li><li>否则，调用<code>getEntryAfterMiss()</code>进行线性探测，过程中每次碰到失效的 slot，就调用<code>expungeStaleEntry</code>进行段清理（清理并rehash，直到遇到null）</li><li>遍历直到 null 都未命中 key，直接返回 null</li></ol><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);  <span class="comment">// 获取该键对应的索引下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线性探测</span></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>;  e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">// 找到 key 相同的 entry，覆盖 value</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果当前 entry 失效，则替换失效的 entry</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线性探测过程中没有遇到 key 相同的 entry，也没遇到失效的 entry，当遇到 null 时跳出循环</span></span><br><span class="line">    <span class="comment">// 在 null 的位置上建立新的 entry</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 替换失效的 entry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value, <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    Entry e;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 staleSlot 向前遍历，查找最前的一个无效的 slot</span></span><br><span class="line">    <span class="keyword">int</span> slotToExpunge = staleSlot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>; i = prevIndex(i, len))</span><br><span class="line">        <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 staleSlot 向后遍历，看能不能找到相同的 key，如果找到了则和无效的 staleSlot 交换</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len); (e = tab[i]) != <span class="keyword">null</span>;  i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到了 key，将其与无效的slot交换</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line"></span><br><span class="line">            tab[i] = tab[staleSlot];</span><br><span class="line">            tab[staleSlot] = e;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                slotToExpunge = i;</span><br><span class="line">            <span class="comment">// 从 slotToExpunge 开始做一次连续段的清理，再做一次启发式清理</span></span><br><span class="line">            cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的 slot 已经无效，并且向前扫描过程中没有无效 slot，则更新 slotToExpunge 为当前位置</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">            slotToExpunge = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果找不到相同的 key，则直接设置在失效的 staleSlot 下标上</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在探测过程中如果发现任何无效 slot，则做一次清理（连续段清理+启发式清理）</span></span><br><span class="line">    <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">        cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 做一次全量清理，并且调低阈值决定是否扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做一次全量清理</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    <span class="comment">// 因为做了一次清理，所以 size 很可能会变小</span></span><br><span class="line">    <span class="comment">// 这里是调低阈值判断是否需要扩容，下面一行相当于 if(size &gt;= len / 2)</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 全量清理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        Entry e = tab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 这里其实可以将 j 设为返回值，j 之前的 entry 其实已经被清理过了，肯定为 null</span></span><br><span class="line">            expungeStaleEntry(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容为原来的两倍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    Entry[] newTab = <span class="keyword">new</span> Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        Entry e = oldTab[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);   <span class="comment">// 计算新容量时哈希值对应的索引下标</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>)   <span class="comment">// 线性探测解决碰撞冲突</span></span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置新阈值</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    size = count;</span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set()</code>方法总体过程如下：</p><ol><li>在遍历（也就是线性探测）遇到null之前，如果遇到了相同的key，则直接覆盖；如果遇到了失效的entry，则调用<code>replaceStaleEntry</code>，效果是最终一定会把key和value放在这个slot上，并且会尽可能地清理无效entry</li><li>遍历过程既没遇到相同的key，也没遇到失效的entry，也就是当前索引上为null，则直接将key和value插在这个空slot上</li><li>如果插入后的<code>size</code>大于阈值，那么做一次全量清理，再根据调低的阈值决定是否需要扩容，扩容两倍（因为容量必须为2的幂）</li></ol><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>remove()</code>方法相对比较简单，只需要找到对应的key，然后将弱引用显式的断开，并做一次段清理即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">            e.clear();                      <span class="comment">// 显式断开弱引用</span></span><br><span class="line">            expungeStaleEntry(i);     <span class="comment">// 进行段清理</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里光做<code>e.clear();</code>其实是不够的，因为<code>value</code>此时还被强引用着，所以才需要进行段清理，将<code>table[i] = null;</code>彻底断开强引用。</p><h2 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h2><p>经过上面的分析我们已经清楚在每个<code>Thread</code>中有一个<code>ThreadLocalMap</code>，每个线程在对某个<code>ThreadLocal</code>对象操作时都会先获取当前线程的<code>ThreadLocalMap</code>，然后对<code>ThreadLocalMap</code>进行操作，并且，<code>ThreadLocal</code>不是简单的作为key的，而是将key和value包装成继承自弱引用<code>WeakReference</code>的<code>Entry</code>类。但这里要注意的是，弱引用只是针对key（<code>Entry</code>中的<code>ThreadLocal</code>），当没有任何强引用指向<code>ThreadLocal</code>的时候，它就只剩下弱引用了，GC时将会被回收，但是value却不会被回收，因为它存在一条<code>当前Thread-&gt;ThreadLocalMap-&gt;Entry数组-&gt;Entry-&gt;value</code>的强引用，所以除非线程销毁，否则它将与线程的生命周期绑定，尤其是在有线程复用比如线程池的场景中，一个线程的寿命很长，大对象长期不被回收会影响系统运行效率与安全，也就造成了人们常说的内存泄露。</p><p><img src="http://blog.default.nanwulife.com/1660f7ebfeecebf2.jpg" alt=""></p><p>但是在源码中我们也会发现，<code>ThreadLocalMap</code>实现中是有一套自我清理的机制的，当我们调用<code>get()</code>或者<code>set()</code>方法时会有很高的概率顺便清理掉失效的<code>Entry</code>，防止出现内存泄露。当然，显示地进行<code>remove()</code>是个良好的编程习惯，它可以确保不会发生内存泄露。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/micrari/p/6790229.html" target="_blank" rel="noopener">ThreadLocal源码解读</a></li><li><a href="http://www.importnew.com/21206.html" target="_blank" rel="noopener">十分钟理解Java中的弱引用</a></li><li><a href="https://www.zhihu.com/question/37401125" target="_blank" rel="noopener">Java中的强引用，软引用，弱引用，虚引用有什么用？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;每个线程读写&lt;code&gt;ThreadLocal&lt;/code&gt;是线程隔离的，互相之间不会影响。其原因就是在于&lt;code&gt;Thr
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="ThreadLocal" scheme="http://yoursite.com/tags/ThreadLocal/"/>
    
  </entry>
  
</feed>
