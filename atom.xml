<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-28T03:05:22.277Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RabbitMQ高级特性</title>
    <link href="http://yoursite.com/2019/04/26/RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/26/RabbitMQ高级特性/</id>
    <published>2019-04-26T05:03:00.000Z</published>
    <updated>2019-04-28T03:05:22.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息返回"><a href="#消息返回" class="headerlink" title="消息返回"></a>消息返回</h2><p><code>mandatory</code>和<code>immediate</code>是发布消息时的两个参数，它们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。<code>mandatory</code>参数告诉服务器该消息至少能路由到一个队列中，而<code>immediate</code>参数告诉服务器要投递的队列必须有消费者。</p><h3 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a>mandatory</h3><p>当<code>mandatory</code>参数设为<code>true</code>时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用<code>Basic.Return</code>命令将消息返回给生产者；当<code>mandatory</code>参数设置为<code>false</code>时，出现上述情形，则消息直接被丢弃。</p><p>对于没有被正确路由而返回给生产者的消息，可以通过给channel添加监听器获取到那些消息。</p><h3 id="immediate"><a href="#immediate" class="headerlink" title="immediate"></a>immediate</h3><p>当<code>immediate</code>参数设为<code>true</code>时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过<code>Basic.Return</code>命令返回给生产者。</p><p>RabbitMQ从3.0的版本开始去掉了对<code>immediate</code>参数的支持。</p><h3 id="备份交换器"><a href="#备份交换器" class="headerlink" title="备份交换器"></a>备份交换器</h3><p>生产者在发送消息的时候如果不设置<code>mandatory</code>参数，那么消息在未被路由的情况下将会丢失；如果设置了<code>mandatory</code>参数，那么需要添加监听器的编程逻辑，生产者的代码会很复杂。如果既不想丢失消息，也不想使代码复杂化，那么可以使用备份交换器，将未被路由的消息存储在RabbitMQ中，需要的时候再去处理。</p><p>备份交换器和普通的交换器没有什么太大的区别，声明一个备份交换器后，在声明普通交换器时添加<code>alternate-exchange</code>参数即可建立它们之间的联系。为了方便使用，备份交换器建议设置为fanout类型的。</p><p><img src="http://blog.default.nanwulife.com/20181207093904597.jpg" alt=""></p><h2 id="过期时间（TTL）"><a href="#过期时间（TTL）" class="headerlink" title="过期时间（TTL）"></a>过期时间（TTL）</h2><p>RabbitMQ可以对消息和队列设置TTL。</p><h3 id="设置消息的TTL"><a href="#设置消息的TTL" class="headerlink" title="设置消息的TTL"></a>设置消息的TTL</h3><p>如果不设置TTL，则表示此消息不会过期，而如果将TTL设置为0，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃。设置消息的TTL有两种方式：</p><ol><li>通过队列属性设置，此时队列中所有消息都有相同的过期时间。</li><li>对消息本身进行单独设置，每条消息的TTL可以不同。</li></ol><p>如果两种方法一起使用，则消息的TTL以两者之间较小的那个数值为准，消息在队列中的生存时间一旦超过设置的TTL时，就会变成死信。</p><p>还要注意的是，对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，因为队列中己过期的消息肯定在队列头部；而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。</p><h3 id="设置队列的TTL"><a href="#设置队列的TTL" class="headerlink" title="设置队列的TTL"></a>设置队列的TTL</h3><p>在声明队列时可以通过<code>x-expires</code>参数控制队列被自动删除前处于未使用状态的时间，未使用的意思是队列上没有任何消费者，队列也没有被重新声明，并且在过期时间段内也未调用过<code>Basic.Get</code>命令。队列的TTL不能像消息一样设置为0。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX（Dead-Letter-Exchange，死信交换器），绑定DLX的队列就称之为死信队列。消息变成死信一般是由于以下几种情况：</p><ul><li>消息被拒绝（<code>Basic.Reject</code> / <code>Basic.Nack</code>），并且设置<code>requeue</code>参数为<code>false</code></li><li>消息过期</li><li>队列达到最大长度值</li></ul><p>DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到死信队列中。</p><p><img src="http://blog.default.nanwulife.com/20181207094035629.png" alt=""></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列存储的对象是对应的延迟消息，即当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。RabbitMQ本身并没有直接支持延迟队列的功能，但是可以通过DLX和TTL模拟出延迟队列的功能。</p><p>生产者将消息发送到过期时间为n毫秒的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器转发到死信队列中，而消费者从死信队列中消费消息。这个时候就达到了“生产者发布了消息，过了n毫秒后消费者消费了消息”的延迟队列的效果。</p><p><img src="http://blog.default.nanwulife.com/20181207094103998.jpg" alt=""></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>可以将队列声明为优先级队列，即在创建队列的时候添加参数<code>x-max-priority</code>指定最大的优先级，值为0-255，此时的规则如下：</p><ul><li>优先级高的消息具备优先被消费的特权</li><li>没有指定优先级的消息会将优先级以0对待</li><li>对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待</li><li>对于相同优先级的消息，后进的排在前面</li></ul><p>如果在消费者的消费速度大于生产者的速度且Broker中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化用以解决因为服务器的异常崩溃导致的消息丢失。RabbitMQ的持久化分为交换器的持久化、队列的持久化和消息的持久化：</p><ul><li>交换器持久化：交换器的持久化是通过在声明交换器时将<code>durable</code>参数置为<code>true</code>实现的。</li><li>队列持久化：队列的持久化是通过在声明队列时将<code>durable</code>参数置为<code>true</code>实现的。如果队列不设置持久化，那么在RabbitMQ服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。但即使设置了该队列为持久化的，也不能保证内部存储的消息不会丢失。</li><li>消息持久化：要确保消息不会丢失，需要通过将消息的投递模式（<code>BasicProperties</code>中的<code>deliveryMode</code>属性）设置为2即可实现消息的持久化。</li></ul><p>就算将交换器、队列、消息都设置了持久化之后也不能百分百保证数据不会丢失。比如说消费者在订阅消费队列时将<code>autoAck</code>参数设置为<code>true</code>，那么当消费者接受到相关消息之后，还没来得及处理就宕机了，这样数据就丢失了。要解决这个问题可以将<code>autoAck</code>参数设置为<code>false</code>，并进行手动确认。</p><p>其次，在持久化的消息正确存入RabbitMQ之后，RabbitMQ并不会为每条消息都进行同步存盘（调用内核的<code>fsync</code>方法），此时仅仅保存到操作系统缓存之中，如果这时候发生了宕机，那么消息将会丢失。要解决这个问题可以使用RabbitMQ的镜像队列机制。</p><h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>当消息的生产者将消息发送出去之后，如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，这样生产者也就不知道消息有没有正确到达服务器。RabbitMQ针对这个问题，提供了两种解决方式：</p><ol><li>通过事务机制实现</li><li>通过发送方确认（publisher confirm）机制实现</li></ol><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>RabbitMQ客户端中与事务机制相关的方法有三个：<code>channel.txSelect</code>、<code>channel.txCommit</code>、<code>channel.txRollback</code>。其中<code>channel.txSelect</code>用于将当前的信道设置成事务模式，<code>channel.txCommit</code>用于提交事务，<code>channel.txRollback</code>用于事务回滚。</p><p>当开启事务并且提交成功，那么消息就一定到达了RabbitMQ中了，如果在事务提交之前由于RabbitMQ异常崩溃或者其它原因抛出异常，这个时候便可以将其捕获，进而通过执行<code>channel.txRollback</code>方法来实现事务回滚，与此同时可以进行消息重发。</p><h3 id="发送方确认机制"><a href="#发送方确认机制" class="headerlink" title="发送方确认机制"></a>发送方确认机制</h3><p>事务机制会严重降低RabbitMQ的消息吞吐量，而发送方确认机制则更加轻量级。</p><p>生产者通过<code>Confirm.Select</code>命令将信道设置成confirm（确认）模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），当消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（<code>Basic.ACK</code>）给生产者（包含消息的唯一ID），生产者可以通过回调方法来处理该确认消息。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。如果RabbitMQ因为内部错误导致消息丢失，就会发送一条<code>Basic.Nack</code>命令，生产者同样也可以在回调方法中处理该命令。</p><p>RabbitMQ回传给生产者的确认消息中的<code>deliveryTag</code>包含了确认消息的序号，此外RabbitMQ也可以设置<code>channel.basicAck</code>方法中的<code>multiple</code>参数（默认为<code>true</code>，也就是批量确认），表示到这个序号之前的所有消息都已经得到了处理。</p><p><img src="http://blog.default.nanwulife.com/1352849-20190223221457597-1239923675.png" alt=""></p><p>事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息。而发送方确认机制如果使用同步串行的编程方式实现，其实并没有比事务机制好多少，但是该机制的优势是在于并不一定需要同步确认，对此有以下两种改进方案：</p><ul><li>批量confirm方法：每发送一批消息后，调用<code>channel.waitForConfirms</code>方法，等待服务器的确认返回（该方法会阻塞到最后一条消息得到确认或者得到nack才结束）。</li><li>异步confirm方法：提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法进行处理。</li></ul><p>对于批量confirm方法，客户端程序需要定期或者定量（达到多少条），亦或者两者结合起来调用<code>channel.waitForConfirms</code>来等待RabbitMQ的确认返回，但是如果出现返回<code>Basic.Nack</code>或者超时情况时，客户端需要将这一批次的消息全部重发。</p><p>而对于异步confirm方法，它的编程比较复杂一些，但因为不会被阻塞，所以性能也略好一些。</p><h2 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h2><p>上面的生产者确认是保证生产者的消息正确的到达了服务器，而为了保证消息从队列可靠地到达消费者，消费者在订阅队列时可以指定<code>autoAck</code>参数，当<code>autoAck</code>等于<code>true</code>时，RabbitMQ会自动把发送出去的消息设置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费了这些消息；当<code>autoAck</code>为<code>false</code>时，RabbitMQ会等待消费者显示地回复确认信号后才从内存（或者磁盘）中移除消息。RabbitMQ不会为未确认的消息设置过期时间，除非消费此消息的消费者已经断开连接，此时RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者。</p><h3 id="消费者拒绝"><a href="#消费者拒绝" class="headerlink" title="消费者拒绝"></a>消费者拒绝</h3><p>在消费者接受到消息后，如果想明确拒绝当前的消息而不是确认，那么可以使用<code>Basic.Reject</code>命令，其中如果将参数<code>requeue</code>设置为<code>false</code>，则RabbitMQ立即会把消息从队列中删除，否则，RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者。</p><p><code>Basic.Reject</code>命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用<code>Basic.Nack</code>这个命令，将<code>multiple</code>设为<code>true</code>则表示拒绝<code>deliveryTag</code>编号之前所有未被当前消费者确认的信息。</p><blockquote><p>注意：如果<code>requeue</code>设置为<code>false</code>，那么可以启用死信队列的功能。</p></blockquote><p><code>Basic.Recover</code>命令用来请求RabbitMQ重新发送还未被确认的消息，也具备可重入队列的特性。如果将其参数<code>requeue</code>设置为<code>true</code>，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。如果将<code>requeue</code>参数设置为<code>false</code>，那么同一条消息会被分配给与之前相同的消费者。</p><h3 id="消息分发"><a href="#消息分发" class="headerlink" title="消息分发"></a>消息分发</h3><p>当RabbitMQ队列拥有多个消费者时，队列收到的消息将以轮询的分发方式发送给消费者，但轮询的分发机制在各台机器性能差异较大时效率很低，那么就可以使用<code>Basic.Qos</code>命令限制信道上的消费者所能保持的最大未确认消息的数量，此时RabbitMQ会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ就不会向这个消费者再发送任何消息，直到消费者确认了某条消息后，RabbitMQ将相应的计数减一，之后消费者才可以继续接收消息。</p><h2 id="可靠性总结"><a href="#可靠性总结" class="headerlink" title="可靠性总结"></a>可靠性总结</h2><p>为了提升数据的可靠性，从上文分析可以总结出以下几个途径：</p><ul><li>设置<code>mandatory</code>参数或者备份交换器来处理未能正确路由到队列的消息。</li><li>设置事务机制或者publisher confirm机制保证生产者的消息正确的到达了RabbitMQ。</li><li>设置交换器、队列和消息为持久化。</li><li>设置消费端对应的<code>autoAck</code>参数为<code>false</code>，在消费完消息后手动确认。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li><li><a href="https://dbaplus.cn/news-159-2326-1.html" target="_blank" rel="noopener">玩转不同业务场景，这些RabbitMQ特性会是得力助攻</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息返回&quot;&gt;&lt;a href=&quot;#消息返回&quot; class=&quot;headerlink&quot; title=&quot;消息返回&quot;&gt;&lt;/a&gt;消息返回&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mandatory&lt;/code&gt;和&lt;code&gt;immediate&lt;/code&gt;是发布消息时的两个参数，它们都有当
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ基本概念</title>
    <link href="http://yoursite.com/2019/04/26/RabbitMQ%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/04/26/RabbitMQ基本概念/</id>
    <published>2019-04-26T02:12:00.000Z</published>
    <updated>2019-04-26T04:50:28.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>RabbitMQ整体上是一个生产者-消费者模型，主要负责接收、存储和转发消息。整体架构如下：</p><p><img src="http://blog.default.nanwulife.com/rabbitmq_example.png" alt=""></p><p>这里省略生产者、消费者等最基础的概念，主要介绍队列、交换器、路由键等。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（Queue）是RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一个队列，这时队列中的消息会被分摊（轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><h2 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h2><p>生产者不是直接将消息发送到队列中，而是发送给交换器（Exchange），由交换器将消息路由到一个或者多个队列中。交换器主要有fanout、direct、topic、headers四种类型：</p><ul><li>fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li><li>direct：它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。</li><li>topic：对direct类型的扩展，允许BindingKey和RoutingKey不严格的匹配它约定：<ul><li>RoutingKey和BindingKey为一个点号<code>.</code>分隔的字符串，如<code>com.rabbitmq.client</code></li><li>BindingKey中可以存在两种特殊字符串<code>*</code>和<code>#</code>，用于做模糊匹配，其中<code>*</code>用于匹配一个单词，<code>#</code>用于匹配多规格单词（可以是零个）。</li></ul></li><li>headers：headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。这个类型基本不会使用。</li></ul><h2 id="路由键"><a href="#路由键" class="headerlink" title="路由键"></a>路由键</h2><p>生产者将消息发送给交换器的时候一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效。这里要注意BindingKey并不是所有情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视BindingKey，而是将信息路由到所有绑定到该交换器的队列中。</p><h2 id="Connection与Channel"><a href="#Connection与Channel" class="headerlink" title="Connection与Channel"></a>Connection与Channel</h2><p>无论是生产者还是消费者，都需要和RabbitMQ Broker建立连接，这个连接就是一条TCP连接，也就是Connection。一旦TCP连接建立起来，客户端紧接着可以创建一个AMQP信道（Channel），每个信道都会被指派一个唯一的ID，它是建立在Connection之上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。</p><p><img src="http://blog.default.nanwulife.com/connection_channel.png" alt=""></p><p>因为操作系统建立和销毁TCP连接是非常昂贵的开销，所以RabbitMQ采用TCP连接复用的方式，减少性能开销。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot; class=&quot;headerlink&quot; title=&quot;基本架构&quot;&gt;&lt;/a&gt;基本架构&lt;/h2&gt;&lt;p&gt;RabbitMQ整体上是一个生产者-消费者模型，主要负责接收、存储和转发消息。整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门：单线程及五大数据类型</title>
    <link href="http://yoursite.com/2019/04/21/Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/04/21/Redis五大数据类型及应用场景/</id>
    <published>2019-04-21T07:29:00.000Z</published>
    <updated>2019-04-21T09:57:32.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么Redis是单线程的</h2><p>首先对于Redis的网络通信模块，它是基于I/O多路复用模型实现的，也就是说只使用一个线程就可以处理多个连接，避免了传统方案使用多线程处理多条连接时的上下文切换开销。而对于命令的执行，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，单线程的处理效率就是最高的，使用多线程反而会增大切换开销，并且引入线程安全的问题，因此Redis使用单线程的方案。</p><p>那什么时候应该使用多线程呢？其实对于类似磁盘I/O读写的操作，如果使用单线程执行，当耗时较长时，后面的所有其它请求都会被阻塞在这，这时候就可以使用新的线程去异步的处理之后的一些请求，提高系统的性能。</p><h2 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h2><ul><li>Redis是基于内存的操作</li><li>Redis底层使用C语言实现，效率更高</li><li>Redis使用I/O多路复用，不像传统方案开多个线程处理多个I/O，大大降低了线程切换的开销</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是最基础的类型，字符串长度不能超过512MB。常用的API有如下几个：</p><ul><li><code>get key</code>：获取一个<code>key</code>的<code>value</code></li><li><code>set key value</code>：设置一个<code>key</code>的<code>value</code></li><li><code>del key</code>：删除一个<code>key</code></li><li><code>incr key</code>：<code>key</code>自增1，如果<code>key</code>不存在，自增后<code>key</code>的<code>value</code>为1</li><li><code>decr key</code>：<code>key</code>自减1，如果<code>key</code>不存在，自减后<code>key</code>的<code>value</code>为-1</li><li><code>incrby key k</code>：<code>key</code>自增k，如果<code>key</code>不存在，自增后<code>key</code>的<code>value</code>为k</li><li><code>set key value</code>：不管<code>key</code>是否存在，都设置<code>value</code></li><li><code>setnx key value</code>：当<code>key</code>不存在时才设置<code>value</code></li><li><code>mget key1 key2 key3...</code>：批量获取<code>key</code>，原子操作</li><li><code>mset key1 value1 key2 value2 key3 value3</code>：批量设置<code>key</code>的<code>value</code></li></ul><p>适用场景：</p><ul><li>记录某个用户的页面访问量：<code>incr userid:pageview</code></li><li>实现分布式锁</li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希可以理解为Map中的Map，因为它每个key对应的value都是一个Map结构，每个field不能相同，但value可以相同。常用的API有如下几个：</p><ul><li><code>hget key field</code>：获取<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hgetall key</code>：返回<code>key</code>对应所有的<code>field</code>和<code>value</code></li><li><code>hset key field value</code>：设置<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hdel key field</code>：删除<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hmget key field1 field2 ... fieldN</code>：批量获取<code>key</code>的一批<code>field</code>对应的<code>value</code></li><li><code>hmset key field1 value1 field2 value2 ... fieldN valueN</code>：批量设置<code>key</code>的一批<code>field</code>对应的<code>value</code></li></ul><p>要注意的是，哈希结构无法针对某个指定的<code>field</code>设置超时时间，TTL不好控制。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）用来存储多个有序（插入顺序）的字符串，每个字符串称为元素，并且元素是可以重复的。常用的API有如下几个：</p><ul><li><code>rpush key value1 value2 ... valuen</code>：从列表右端插入元素</li><li><code>lpush key value1 value2 ... valuen</code>：从列表左端插入元素</li><li><code>linsert key before|after value newValue</code>：在某个<code>key</code>下的<code>list</code>指定的<code>value</code>前|后插入<code>newValue</code></li><li><code>lpop key</code>：从列表左侧弹出一个元素</li><li><code>rpop key</code>：从列表右侧弹出一个元素</li><li><code>lrem key count value</code>：根据<code>count</code>的值，从列表中删除所有<code>value</code>相等的元素。当<code>count</code> &gt; 0时，从左到右删除最多<code>count</code>个<code>value</code>相等的元素；当<code>count</code> &lt; 0时，从右到左删除最多<code>Math.abs(count)</code>个<code>value</code>相等的元素；当<code>count</code> = 0时，删除所有<code>value</code>相等的元素。</li><li><code>ltrim key start end</code>：按照索引范围修剪列表，即删除索引范围之外的元素</li><li><code>lrange key start end</code>：获取列表索引范围内的所有元素，包含<code>end</code></li><li><code>blpop key timeout</code>：<code>lpop</code>阻塞版本，<code>timeout</code>是阻塞超时时间，<code>timeout</code>为0表示永不阻塞</li><li><code>brpop key timeout</code>：<code>rpop</code>阻塞版本，<code>timeout</code>是阻塞超时时间，<code>timeout</code>为0表示永不阻塞</li></ul><p>适用场景：</p><ul><li>用户动态的时间轴：当用户更新动态的时候可以使用<code>lpush</code>命令加入列表，使用<code>lrange</code>命令展示一定数量的动态，并且使用<code>ltrim</code>限制动态的数量。</li><li>使用<code>lpush</code> + <code>lpop</code>实现一个栈，使用<code>lpush</code> + <code>rpop</code>实现一个队列。</li><li>使用<code>lpush</code> + <code>brpop</code>实现一个消息队列。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）与列表类似，都是用来保存多个字符串，但集合中的元素是无序的，因此不能通过索引来操作元素，并且集合中的元素不能有重复。常用的API有如下几个：</p><ul><li><code>sadd key element</code>：向<code>key</code>添加<code>element</code>，如果<code>element</code>已经存在，则添加失败</li><li><code>srem key element</code>：将<code>key</code>中的<code>element</code>移除掉</li><li><code>sinter key1 key2</code>：取交集</li><li><code>sdiff key1 key2</code>：取差集</li><li><code>sunion key1 key2</code>：取并集</li><li><code>scard key</code>：返回集合中元素的数量</li><li><code>sismember key member</code>：判断集合<code>key</code>中是否存在<code>member</code></li><li><code>spop key</code>：从集合中随机弹出一个元素</li></ul><p>适用场景：</p><ul><li>使用<code>sadd</code>命令给用户添加标签，或者给标签添加用户，通过<code>sinter</code>命令实现共同关注等功能。</li></ul><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>有序集合与集合一样，元素都不能重复，但有序集合中的元素是有顺序的，与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。常用的API有如下几个：</p><ul><li><code>zadd key score element</code>：添加<code>score</code>和<code>element</code>，<code>score</code>是可以重复的，但<code>element</code>是不能重复的。</li><li><code>zrem key element</code>：删除元素<code>element</code></li><li><code>zscore key element</code>：返回元素<code>element</code>的分数<code>score</code></li><li><code>zincrby key increScore element</code>：增加或减少元素<code>element</code>的分数<code>score</code></li><li><code>zcard key</code>：返回元素的总个数</li><li><code>zrange key start end [WITHSCORES]</code>：返回指定索引范围内的升序元素（相当于排名）</li><li><code>zrangebyscore key minScore maxScore [WITHSCORES]</code>：返回指定分数范围内的升序元素</li><li><code>zcount key minScore maxScore</code>：返回有序集合内在指定分数范围内的个数</li></ul><p>适用场景：</p><ul><li>排行榜：可以将销售量、关注人数、时间戳作为<code>score</code>进行元素的排序</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么Redis是单线程的&quot;&gt;&lt;a href=&quot;#为什么Redis是单线程的&quot; class=&quot;headerlink&quot; title=&quot;为什么Redis是单线程的&quot;&gt;&lt;/a&gt;为什么Redis是单线程的&lt;/h2&gt;&lt;p&gt;首先对于Redis的网络通信模块，它是基于I/O多路
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Pipeline</title>
    <link href="http://yoursite.com/2019/04/21/Redis-%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2019/04/21/Redis-管道/</id>
    <published>2019-04-21T06:28:00.000Z</published>
    <updated>2019-04-21T07:13:14.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>Redis客户端执行一条命令分为以下四个步骤:</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>其中，第一步加第四步称为Round Trip Time（RTT，往返时间）。</p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>Redis提供了批量操作命令（例如<code>mget</code>、<code>mset</code>等），有效的节约了RTT，但大部分命令是不支持批量操作的。由于Redis命令执行本身是很快的（微妙级别），而发送命令以及返回结果的网络耗时往往更大，所以说Redis的性能瓶颈其实是网络。</p><h2 id="Pipeline机制"><a href="#Pipeline机制" class="headerlink" title="Pipeline机制"></a>Pipeline机制</h2><p>Pipeline机制能改善上面这类问题，它能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令按照顺序执行并装填结果返回给客户端。</p><p>Pipeline虽然好用，但是每次Pipeline组装的命令个数不能没有节制，否则一次组装Pipeline数据量过大，一方面会增加客户端的等待时机，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p><h2 id="对比原生批量命令"><a href="#对比原生批量命令" class="headerlink" title="对比原生批量命令"></a>对比原生批量命令</h2><ul><li>原生批量命令是原子性，Pipeline是非原子性的。</li><li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li><li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端与客户端的共同实现。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/yixianyixian/p/8353563.html" target="_blank" rel="noopener">redis学习笔记 - Pipeline与事务</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h2&gt;&lt;p&gt;Redis客户端执行一条命令分为以下四个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送命令&lt;/li&gt;
&lt;li&gt;命令排队&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="http://yoursite.com/2019/04/21/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/04/21/Redis实现分布式锁/</id>
    <published>2019-04-21T03:03:00.000Z</published>
    <updated>2019-04-21T06:23:57.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h2><p>下面的加锁操作直接使用一条原子命令即可，而解锁操作需要用到Lua脚本保证原子性，该实现只适用于在单节点上操作。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>加锁可以使用Redis提供的一条原子命令完成：<code>SET key value NX PX 30000</code>。</p><p>这里对其中的一些参数做一些解释：</p><ul><li><code>key</code>：我们使用key来当锁，因为key是唯一的。</li><li><code>value</code>：为保证可靠性，加锁和解锁要是同一个客户端，客户端自己不能把别人加的锁给解了。所以这里<code>value</code>可用于标识客户端，解锁时需要进行比较。</li><li><code>NX</code>：当key不存在时才进行set操作，若key已经存在，则不做任何操作。这个参数保证了只有一个人能拿到锁。</li><li><code>PX</code>：这里其实可以传入<code>EX</code>或<code>PX</code>，主要目的是设置一个过期时间，锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</li></ul><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>为确保原子性，这里使用Lua脚本实现Redis分布式锁的解锁操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>实现的关键在于一定要先比较<code>value</code>是否相等，这也是上面加锁时提到的客户端自己不能把别人加的锁给解了，如果是同一个客户端那么就直接将<code>key</code>删除即可。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>事实上，上面的分布式锁实现在Redis单机部署的场景下工作是没问题的。但是如果Redis有多个节点的话，加锁就只能作用在一个Redis节点上，即使使用了哨兵或者集群方案保证高可用，如果master节点由于某些原因发生了主从切换，依然会出现锁丢失的情况：</p><ol><li>在Redis的master节点上获取到锁</li><li>这个锁的key还没来得及同步到slave节点</li><li>master故障，发生故障转移，slave节点升级为master节点</li><li>导致锁丢失</li></ol><h2 id="Redlock实现"><a href="#Redlock实现" class="headerlink" title="Redlock实现"></a>Redlock实现</h2><p>由于上述的分布式锁只适用于单机环境，Redis作者基于分布式环境提出了一种更高级的实现方式：Redlock。</p><p>在Redis的分布式环境中，我们假设有N个Redis master节点，这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁，我们确保将在每个实例上使用此方法获取和释放锁。这里假设有5个Redis master节点，并且运行在5台不同的服务器上以保证他们不会同时都宕掉。以下为加锁操作：</p><ol><li>首先获取当前的本地时间</li><li>使用相同的key和value依次尝试在5个实例上申请锁。在获得锁的过程中，为每一个锁操作设置一个快速失败时间（如果想要获得一个10秒的锁，那么每一个锁操作的失败时间设为5-50ms）。这样可以避免客户端与一个已经故障的master节点通信占用太长时间，通过快速失败的方式尽快与集群中的其他节点完成锁操作。</li><li>客户端计算出与master获得锁操作过程中消耗的时间（即当前时间减去第一步记录的时间），当且仅当客户端获得锁的过程中消耗的时间小于锁的存活时间，并且在一半以上的master节点中都获得锁，才认为client成功的获得了锁。</li><li>如果已经获得了锁，客户端执行任务的有效时间是锁的存活时间减去获得锁的过程中所消耗的时间。</li><li>如果客户端获得锁的数量不足一半以上，或获得锁的时间超时，那么认为获得锁失败，客户端应尽快地释放（部分）已经成功取到的锁，这样其他的客户端就不必非得等到锁过完有效时间才能取到。</li></ol><p>这个算法的核心思想其实在于只可能有一个客户端能获取到大部分master节点中的锁，也就避免了多个客户端都能获取到锁的情况。对于释放锁来说，过程就相对简单一些了：向所有的Redis实例发送释放锁命令即可，不用关心之前有没有从Redis实例成功获取到锁。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.redis.cn/topics/distlock.html" target="_blank" rel="noopener">Redis分布式锁</a></li><li><a href="http://cmsblogs.com/?p=3266#Redlock-2" target="_blank" rel="noopener">Redlock：Redis分布式锁最牛逼的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;普通实现&quot;&gt;&lt;a href=&quot;#普通实现&quot; class=&quot;headerlink&quot; title=&quot;普通实现&quot;&gt;&lt;/a&gt;普通实现&lt;/h2&gt;&lt;p&gt;下面的加锁操作直接使用一条原子命令即可，而解锁操作需要用到Lua脚本保证原子性，该实现只适用于在单节点上操作。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>String源码分析</title>
    <link href="http://yoursite.com/2019/04/20/String%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/04/20/String源码分析/</id>
    <published>2019-04-20T04:17:00.000Z</published>
    <updated>2019-04-21T11:32:45.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String-简介"><a href="#String-简介" class="headerlink" title="String 简介"></a>String 简介</h2><p><code>String</code>实例是常量，一旦创建后就不能再修改其值。以下为它的继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><img src="http://blog.default.nanwulife.com/String%20UML.png" alt=""></p><p>可以看出<code>String</code>实现了<code>Serializable</code>、<code>CharSequence</code>、<code>Comparable</code>接口，其中<code>CharSequence</code>主要提供一些对字符序列的只读访问，许多类如<code>StringBuilder</code>、<code>StringBuffer</code>也都实现了此接口，里面就只有几个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>String</code>类通过<code>final</code>修饰，不可被继承，同时<code>String</code>底层的字符数组也是被<code>final</code>修饰的，<code>char</code>属于基本数据类型，一旦被赋值之后也是不能被修改的，所以<code>String</code>是不可变的。这里对<code>final</code>做一个简单的总结：</p><ul><li>修饰类：当用<code>final</code>修饰一个类时，表明这个类不能被继承。也就是说，<code>String</code>类是不能被继承的，</li><li>修饰方法：把方法锁定，以防任何继承类对其覆盖。</li><li>修饰变量：修饰基本数据类型变量，则其数值一旦在初始化之后便不能更改；修饰引用类型变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];<span class="comment">// String的核心，用final修饰，无法再被修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值，默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>String</code>有很多重载的构造方法，介绍如下：</p><ol><li><p>空参数构造方法，初始化字符串实例，默认为空字符，理论上不需要用到这个构造方法，实际上定义一个空字符<code>String = &quot;&quot;</code>就会初始化一个空字符串的<code>String</code>对象，而此构造方法，也是把空字符的<code>value[]</code>拷贝一遍而已，源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过一个字符串参数构造<code>String</code>对象，实际上将形参的<code>value</code>和<code>hash</code>赋值给实例对象作为初始化，相当于深拷贝了一个形参<code>String</code>对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过字符数组去构建一个新的<code>String</code>对象，这里使用<code>Arrays.copyOf</code>方法拷贝字符数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在源字符数组基础上，通过偏移量（起始位置）和字符数量，截取构建一个新的<code>String</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果偏移量小于0，则抛出越界异常</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果字符数量小于0，则抛出越界异常</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在截取的字符数量为0的情况下，偏移量在字符串长度范围内，则返回空字符</span></span><br><span class="line">            <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">                <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">        <span class="comment">//如果偏移量大于字符总长度-截取的字符长度，则抛出越界异常</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用Arrays.copyOfRange静态方法，截取一定范围的字符数组，从offset开始，长度为offset+count，赋值给当前实例的字符数组</span></span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过源字节数组，按照一定范围，从<code>offset</code>开始截取<code>length</code>个长度，初始化<code>String</code>实例，同时可以指定字符编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="comment">//字符编码参数为空，抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    <span class="comment">//静态方法 检查字节数组的索引是否越界</span></span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="comment">//使用 StringCoding.decode 将字节数组按照一定范围解码为字符串，从offset开始截取length个长度</span></span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>StringBuffer</code>构建成一个新的<code>String</code>，比较特别的就是这个方法有<code>synchronized</code>锁，同一时间只允许一个线程对这个<code>StringBuffer</code>构建成<code>String</code>对象，所以是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对当前 StringBuffer 对象加同步锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="comment">//拷贝 StringBuffer 字符数组给当前实例的字符数组</span></span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>StringBuilder</code>构建成一个新的<code>String</code>，与另一个构造器不同的是，此构造器不是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="value相关"><a href="#value相关" class="headerlink" title="value相关"></a>value相关</h3><ol><li><p>获取字符串长度，实际上是获取字符数组长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断字符串是否为空，实际上是判断字符数组长度是否为0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据索引参数获取字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//索引小于0或者索引大于字符数组长度，则抛出越界异常</span></span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回字符数组指定位置字符</span></span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><p>实现了<code>Comparable</code>接口的<code>compareTo</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出该方法实现还是比较简单的，直接逐个比较每个字符是否相等，如果其中某个字符不相等就直接返回结果，否则比较它们的长度。</p><h3 id="equals与hashCode"><a href="#equals与hashCode" class="headerlink" title="equals与hashCode"></a>equals与hashCode</h3><p><code>equals</code>方法首先判断两个对象的地址是否相等，如果不等再判断对象是否为<code>String</code>类型，如果是的话再比较它们的长度与值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先判断地址是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要比较的对象是否为 String 类型</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="comment">// 比较两个字符串的长度</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 逐个比较两个字符串中每个字符是否相等</span></span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashCode</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为在大多数构造函数中，其实并没有设置成员变量<code>hash</code>的值，默认值是为0的，因此调用此方法会根据<code>value</code>数组重新计算哈希值，并赋给成员变量<code>hash</code>，下次就可以直接拿到该哈希值了。这里还有一行<code>h = 31 * h + val[i];</code>比较特别，它其实可以推导成一个公式：<code>val[0]*31^(n-1) + val[1]*31^(n-2) + ... + val[n-1]</code>，这里之所以要取31这个数字，原因如下：</p><blockquote><p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：<code>31 * i == (i &lt;&lt; 5) - i</code>，现代的 Java 虚拟机可以自动的完成这个优化。</p></blockquote><p>具体可以参考这篇文章：<a href="https://www.tianxiaobo.com/2018/01/18/String-hashCode-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/" target="_blank" rel="noopener">String hashCode 方法为什么选择数字31作为乘子</a></p><h3 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h3><p>在Java中有8种基本类型和一种比较特殊的类型<code>String</code>，这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。8种基本类型的常量池都是系统协调的，<code>String</code>类型的常量池比较特殊，它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li><li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。<code>intern</code>方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</li></ul><p>关于这个方法网上的解释有很多，但大多都比较混乱，我暂时还没有整理清楚，日后回来填坑。</p><h2 id="String对-的重载"><a href="#String对-的重载" class="headerlink" title="String对 + 的重载"></a>String对 + 的重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String apple = <span class="string">"Apple,"</span>;</span><br><span class="line">        String fruit = apple + <span class="string">"Pear,"</span> + <span class="string">"Orange"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在执行上述代码的时候会自动引入<code>StringBuilder</code>类。虽然在上面的代码中我们并没有使用到<code>StringBuilder</code>类，但是编译器却自动引入了它，因为它更高效。编译器首先会创建一个<code>StringBuilder</code>对象，用来构造最终要生成的<code>String</code>，并为每一个字符串调用一次<code>StringBuilder</code>中的<code>append()</code>方法，因此上述代码一共执行了三次<code>append()</code>方法，最后调用<code>toString</code>生成最终的结果，并保存为<code>fruit</code>。</p><p>但是我们不能认为编译器已经帮我们做了优化，我们就可以随意的使用<code>String</code>对象，下面是两种方法生成一个<code>String</code>，一个方法使用了<code>String</code>对象，另一个使用了<code>StringBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString1</span><span class="params">(String[] strArray)</span></span>&#123;</span><br><span class="line">       String result = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)</span><br><span class="line">           result += strArray[i];</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString2</span><span class="params">(String[] strArray)</span></span>&#123;</span><br><span class="line">       StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)</span><br><span class="line">           result.append(strArray[i]);</span><br><span class="line">       <span class="keyword">return</span> result.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面两个方法都是用来对一个数组中的数据进行连接并返回一个<code>String</code>对象，但是需要我们注意的是<code>getString1</code>方法是在循环内部构造<code>StringBuilder</code>对象的，这意味着每循环一次就会创建一个新的<code>StringBuilder</code>对象。</p><p><code>getString2</code>方法只生成了一个<code>StringBuilder</code>对象，这样更简单更高效的实现了同<code>getString1</code>一样的功能。所以在我们使用<code>String</code>对象时，最好考虑一下是否可以用<code>StringBuilder</code>对象更高效的实现我们想要的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>String</code>类被修饰符<code>final</code>修饰是无法被继承的，而它内部的关键成员变量<code>char value[]</code>同样也是被<code>final</code>修饰不能更改的，因此<code>String</code>是不可变的。</li><li><code>String</code>实现了<code>Serializable</code>接口，可以被序列化；实现了<code>Comparable</code>接口，可用于比较大小；实现了<code>CharSequence</code>，实现了通用的字符序列的只读方法。</li><li><code>String</code>重载了+运算符，会创建一个<code>StringBuilder</code>对象并调用其<code>append()</code>实现字符串拼接。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java 编程思想》Bruce Eckel 著 陈昊鹏 译</li><li><a href="https://juejin.im/post/5c2588d8f265da6110371d2b#heading-3" target="_blank" rel="noopener">String 源码浅析(一)</a></li><li><a href="https://juejin.im/post/59fffddc5188253d6816f9c1#heading-17" target="_blank" rel="noopener">String源码分析</a></li><li><a href="https://www.tianxiaobo.com/2018/01/18/String-hashCode-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/" target="_blank" rel="noopener">String hashCode 方法为什么选择数字31作为乘子</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;String-简介&quot;&gt;&lt;a href=&quot;#String-简介&quot; class=&quot;headerlink&quot; title=&quot;String 简介&quot;&gt;&lt;/a&gt;String 简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;实例是常量，一旦创建后就不能再修改其值。以下为
      
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存设计与优化</title>
    <link href="http://yoursite.com/2019/03/31/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/31/Redis缓存设计与优化/</id>
    <published>2019-03-31T12:28:00.000Z</published>
    <updated>2019-03-31T14:45:22.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>Redis过期策略是：定期删除+惰性删除。</p><p>所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置了过期时间的key（全部都检查的话十分消耗CPU资源），检查其是否过期，如果过期了就删除。但仅依赖此策略会有许多过期的key未被检查到，因此Redis还使用惰性删除策略，即在读/写key的时候再检查其是否过期，如果过期了则删除。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果某些key没有被定期删除，也没及时去读/写以触发惰性删除，那么Redis的内存会越来越高，当已用内存超过<code>maxmemory</code>限定时，就会根据内存淘汰机制删除部分key。Redis内存淘汰机制有以下几个：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>一般的缓存系统，都是根据key去缓存查询，如果不存在对应的value，就应该去数据库查找。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对数据库造成很大的压力，这就叫做缓存穿透。</p><p>第一个解决办法是对查询结果为空的键也进行缓存，由于这种方式需要更多的键，所以可以设置一个短一点的过期时间。</p><p>第二个解决方案则是使用布隆过滤器拦截。布隆过滤器的原理是，当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位数组中的K个点，并把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素有可能在。</p><p><img src="http://blog.default.nanwulife.com/booleanfilter.png" alt=""></p><p>通过布隆过滤器，一个一定不存在的数据会被它拦截掉，从而避免了对数据库的查询压力。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，所有请求都会查询数据库，也会给数据库带来很大压力，这就叫做缓存雪崩。对于缓存雪崩有以下几种解决方案：</p><ul><li>可以给缓存设置过期时间时加上一个随机时间，使得每个key的过期时间分散开来，不会集中在同一时刻失效。</li><li>进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li><li>使用分布式缓存。</li><li>提前演练。</li></ul><h2 id="热点key重建"><a href="#热点key重建" class="headerlink" title="热点key重建"></a>热点key重建</h2><p>当前key是一个热点key（比如说某个热门的娱乐新闻），如果在缓存失效时有大量线程并发请求，那么这些线程会同时去访问数据库并重建key，导致后端系统负载过大，甚至因此崩溃。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180629202036949-8223995.png" alt=""></p><p>为此有以下几种解决方案：</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>可以使用互斥锁的方式实现，直接利用redis的<code>set</code>命令即可（如<code>SET mutexKey &quot;1&quot; EX 10086 NX</code>），为了防止该锁未被正确释放，还应给该锁设置一个过期时间。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703003410961-1677269917.png" alt=""></p><p>这种方式的缺点在于重建的过程中别的线程都会处于等待状态，整体性能不高。</p><h3 id="永远不过期"><a href="#永远不过期" class="headerlink" title="永远不过期"></a>永远不过期</h3><p>我们不为每个key设置一个过期时间，但会添加一个逻辑过期时间属性，每次去读的时候都判断一下当前时间是否已经大于逻辑过期时间，如果是的话就使用单独的线程去构建缓存。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703004145474-1329843618.png" alt=""></p><p>这种方式的缺点在于缓存的构建是异步的，因此别的线程在这个过程中依然会取到老值，不保证数据的一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">缓存穿透与缓存雪崩</a></li><li><a href="https://blog.csdn.net/fouy_yun/article/details/81075432" target="_blank" rel="noopener">分布式缓存击穿（布隆过滤器 Bloom Filter）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过期策略&quot;&gt;&lt;a href=&quot;#过期策略&quot; class=&quot;headerlink&quot; title=&quot;过期策略&quot;&gt;&lt;/a&gt;过期策略&lt;/h2&gt;&lt;p&gt;Redis过期策略是：定期删除+惰性删除。&lt;/p&gt;
&lt;p&gt;所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster</title>
    <link href="http://yoursite.com/2019/03/31/Redis-Cluster/"/>
    <id>http://yoursite.com/2019/03/31/Redis-Cluster/</id>
    <published>2019-03-31T05:21:00.000Z</published>
    <updated>2019-03-31T12:22:57.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster作用"><a href="#Redis-Cluster作用" class="headerlink" title="Redis Cluster作用"></a>Redis Cluster作用</h2><p>Redis Cluster是Redis 3.0开始引入的分布式存储方案，集群由多个节点组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制。集群的作用，可以归纳为两点：</p><ul><li>数据分片：集群将数据分散到多个节点，突破了Redis单机内存大小的限制，存储容量大大增加。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。</li></ul><h2 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h2><p>常见的哈希分区方案包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。</p><ul><li>哈希取余分区：哈希取余分区思路非常简单，首先计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</li><li>一致性哈希分区：一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，范围为<code>0 ~ 2^32-1</code>。对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。<br><img src="http://blog.default.nanwulife.com/U%7BKC_N~EU%5DO%5B9_%7B3KK03U58.png" alt=""></li><li>一致性哈希分区（虚拟节点机制）：普通的一致性哈希在服务器节点数量较少时容易产生数据倾斜问题，各个服务器的负载不均匀。为解决这个问题，引入了虚拟节点机制，每台机器可以负责更多节点，数据负担更加均匀。<br><img src="http://blog.default.nanwulife.com/Y90YE9D$%29CU%7B6AA%604QP~VEB.png" alt=""></li><li>虚拟槽分区：Redis Cluser底层使用的虚拟槽分区，有一个长度为16384的虚拟槽，每个Master节点都会负责一部分的槽，Redis对key计算哈希值，使用的算法是CRC16，然后根据哈希值计算数据属于哪个槽，最后根据槽与节点的映射关系，计算数据属于哪个节点。其中哪个节点负责哪个槽，这是可以由用户指定的。<br><img src="http://blog.default.nanwulife.com/1174710-20181025213453407-302249562.png" alt=""></li></ul><h2 id="节点通信机制"><a href="#节点通信机制" class="headerlink" title="节点通信机制"></a>节点通信机制</h2><h3 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h3><p>在redis sentinel中，节点分为数据节点和sentinel节点：前者存储数据，后者实现额外的控制功能。在redis cluster中，没有数据节点与非数据节点之分，所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点都提供了两个TCP端口，普通端口主要用于为客户端提供服务，集群端口用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信。</p><h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>Gossip过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p><img src="http://blog.default.nanwulife.com/v2-575e785e7d03ad317e5bce4e36debb03_b.gif" alt=""></p><p>Gossip协议的优点：</p><ul><li>负载低：比广播低，广播每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li><li>去中心化：Gossip协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li><li>容错性高：网络中任何节点的宕机和重启都不会影响Gossip消息的传播，Gossip协议具有天然的分布式系统容错特性。<br>Gossip协议的缺点：</li><li>消息的延迟：由于节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用Gossip协议会造成不可避免的消息延迟，不适合用在对实时性要求较高的场景下。</li></ul><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>集群节点间发送的消息有以下几种类型：</p><ul><li>meet：在节点握手阶段，当节点收到客户端的<code>cluster meet</code>命令时，会向新加入的节点发送meet消息，请求新节点加入到当前集群，新节点收到meet消息后会回复一个pong消息。</li><li>ping：集群里每个节点每秒钟会选择部分节点发送ping消息，接收者收到消息后会回复一个pong消息。ping消息使用Gossip协议发送，内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。</li><li>pong：pong消息封装了自身状态数据，可以分为两种：第一种是在接到meet/ping消息后回复的pong消息，第二种是指节点向集群广播pong消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播pong消息。</li><li>fail：当一个主节点判断另一个主节点客观下线后，会向集群广播这一fail消息，通知集群中所有节点标记故障节点为客观下线，并通知故障节点的从节点触发故障转移流程。</li><li>publish：节点收到publish命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该publish命令。</li></ul><h2 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h2><h3 id="moved重定向"><a href="#moved重定向" class="headerlink" title="moved重定向"></a>moved重定向</h3><p>moved异常代表槽已经确认迁移至别的节点。</p><p><img src="http://blog.default.nanwulife.com/1.png" alt=""><br><img src="http://blog.default.nanwulife.com/3.png" alt=""></p><h3 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h3><p>在集群缩容扩容的时候，要对槽进行迁移，在迁移的过程中访问一个key，但是key已经迁移到目标节点，那么就会返回一个ask异常。</p><p><img src="http://blog.default.nanwulife.com/6.png" alt=""></p><h3 id="Smart-Client"><a href="#Smart-Client" class="headerlink" title="Smart Client"></a>Smart Client</h3><p>redis-cli这一类客户端称为Dummy客户端，因为它们在执行命令前不知道数据在哪个节点上，因此需要借助moved异常重定向。为了追求性能，我们不可能每次都随机访问一个节点，再根据moved或ask异常去重定向到目标节点，因此需要实现一个Smart客户端，比如说JedisCluster。JedisCluster的基本原理大致如下：</p><ol><li>从集群中选一个可运行节点，使用<code>cluster slots</code>命令并将结果映射到本地，这样本地就有了slot-&gt;node的映射关系缓存。</li><li>JedisCluster为每个节点创建连接池(即JedisPool)。</li><li>当执行命令时，JedisCluster根据key-&gt;slot-&gt;node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现moved错误时，刷新本地的映射关系缓存。</li></ol><p>这里需要注意的是，JedisCluster中已经包含所有节点的连接池，因此JedisCluster要使用单例。</p><h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>集群伸缩的核心是槽迁移，通过修改槽与节点的对应关系，实现槽（即数据）在节点之间的移动。例如，如果槽均匀分布在集群的3个节点中，此时增加一个节点，则需要从3个节点中分别拿出一部分槽给新节点，从而实现槽在4个节点中的均匀分布。</p><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><ol><li>启动节点</li><li>加入集群：使用<code>cluster meet</code>命令。</li><li>迁移槽和数据</li></ol><h3 id="减少节点"><a href="#减少节点" class="headerlink" title="减少节点"></a>减少节点</h3><ol><li>迁移槽和数据</li><li>忘记节点：使用<code>cluster forget</code>命令</li><li>关闭节点</li></ol><p>这里要注意应先下线从节点再下线主节点，因为若主节点先下线，会触发故障的自动转移。</p><p>在槽迁移未完成时，客户端访问了负责该槽的节点，但key此时已经迁移到了别的节点下，这时候会返回ask异常，通过这个机制使得redis cluster可以无痛的完成扩缩容操作。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>集群对故障发现与故障转移的实现与哨兵思路类似：通过定时任务发送ping消息检测其他节点状态，若某个主节点发现另一个主节点不可用（与参数<code>cluster-node-timeout</code>有关），则标记该节点进行主观下线，而当半数以上持有槽的主节点都标记该节点主观下线，则对该节点进行客观下线，并向集群广播fail消息，让集群中所有节点都将其标记为客观下线，并触发从节点的故障转移。</p><p>在故障转移阶段，主要有以下几个步骤：</p><ul><li>检查资格：每个从节点都会检查与故障主节点的断线时间，如果超过默认值150s（<code>cluster-node-timeout * cluster-slave-validity-factor</code>）则会取消资格。</li><li>准备选举时间：为了保证偏移量比较大的从节点更有可能成为主节点，会将该从节点的延迟时间设置更小一些。</li><li>选举投票：从节点选举胜出需要的票数为N/2+1，其中N为主节点数量（包括故障主节点），但故障主节点实际上不能投票。因此为了能够在故障发生时顺利选出从节点，集群中至少需要3个主节点。</li><li>替换主节点。</li></ul><p>与哨兵一样，集群只实现了主节点的故障转移，从节点故障时只会被下线，不会进行故障转移。因此，使用集群时，应谨慎使用读写分离技术，因为从节点故障会导致读服务不可用，可用性变差。</p><h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><h3 id="cluster-node-timeout"><a href="#cluster-node-timeout" class="headerlink" title="cluster_node_timeout"></a>cluster_node_timeout</h3><p><code>cluster_node_timeout</code>的默认值是15s，影响包括：</p><ul><li>值越大对延迟容忍度越高，并且由于节点发现与其它节点最后通信时间超过<code>cluster_node_timeout / 2</code>时会直接发送ping消息，因此调大该参数还可以降低带宽消耗，但同时也会降低收敛速度。</li><li>影响故障转移的判定和时间，值越大越不容易误判，但完成转移消耗时间越长。</li></ul><h3 id="cluster-require-full-coverage"><a href="#cluster-require-full-coverage" class="headerlink" title="cluster-require-full-coverage"></a>cluster-require-full-coverage</h3><p><code>cluster-require-full-coverage</code>参数设置为yes时，当主节点发生故障而故障转移尚未完成，原主节点中的槽不在任何节点中，此时集群会处于下线状态，无法响应客户端的请求。但在实际应用中为了保证服务的高可用性，都会将该参数设置为no。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://duqingfeng.net/2018/06/12/%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%E6%8A%80%E6%9C%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E3%80%81Redis%20cluster%E8%99%9A%E6%8B%9F%E6%A7%BD%EF%BC%89/" target="_blank" rel="noopener">哈希分区技术之间的对比（一致性哈希、Redis cluster虚拟槽）</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a></li><li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener">P2P 网络核心技术：Gossip 协议</a></li><li><a href="https://enpsl.top/2019/01/24/2019-01-24-redis-cluster-route/" target="_blank" rel="noopener">Redis cluster 客户端路由</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Cluster作用&quot;&gt;&lt;a href=&quot;#Redis-Cluster作用&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster作用&quot;&gt;&lt;/a&gt;Redis Cluster作用&lt;/h2&gt;&lt;p&gt;Redis Cluster是Redi
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper集群节点为什么推荐为奇数</title>
    <link href="http://yoursite.com/2019/03/31/Zookeeper%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%B8%BA%E5%A5%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/31/Zookeeper集群节点为什么推荐为奇数/</id>
    <published>2019-03-31T03:36:00.000Z</published>
    <updated>2019-03-31T03:58:27.604Z</updated>
    
    <content type="html"><![CDATA[<p>不止包括Zookeeper集群，其它大多数集群都推荐节点数最好为奇数个，因此本文将详细说明其中的缘由。首先我们需要明白一个概念“脑裂”：</p><blockquote><p>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，每个小集群都认为其它小集群的节点是不可用的，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。</p></blockquote><p>在zookeeper的选举过程中，有个规则是要求可用节点数量&gt;总节点数量/2。之所以会有这样的要求，就是为了防止集群出现脑裂的时候，可能会出现多个子集群同时服务的情况（即子集群各组选举出自己的leader）。如果遵守这个规则，那么只会有一个子集群能进行Leader选举，因为当前集群中只可能有一个子集群的节点数能超过总节点数的一半。</p><p>说明了可用节点数量&gt;总节点数量/2这个规则后，我们再进一步探索为什么Zookeeper集群节点数推荐为奇数个。主要有以下两个原因：</p><h2 id="1-防止脑裂造成集群不可用"><a href="#1-防止脑裂造成集群不可用" class="headerlink" title="1. 防止脑裂造成集群不可用"></a>1. 防止脑裂造成集群不可用</h2><p>如果集群的数量为偶数个，那么在发生脑裂的时候，可能两个子集群的数量都无法超过总节点数量的一半，也就无法满足Zookeeper进行选举的规则，这时候整个服务对外是彻底不可用的。但是如果集群的数量为奇数个的话，发生脑裂时必然有一个子集群的节点数目大于总节点数目的一半，这时候可以保证当前服务对外依然是可用的。</p><h2 id="2-在容错能力相同的情况下，奇数台更节省资源"><a href="#2-在容错能力相同的情况下，奇数台更节省资源" class="headerlink" title="2. 在容错能力相同的情况下，奇数台更节省资源"></a>2. 在容错能力相同的情况下，奇数台更节省资源</h2><p>比如说，如果当前集群有四个节点，要想完成Leader选举，只允许一个节点不可用，这样才能保证可用的节点数大于总节点数的一半。但如果当前集群有三个节点，要想完成Leader选举，同样也只允许一个节点不可用，因为只有当两个节点都存活的时候才能满足可用节点数大于总节点数的一半。可以看出，以上两个集群都只有一个节点的容错能力，但是第二个集群比第一个集群节约了更多的资源，因此，更推荐Zookeeper的节点数为奇数个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不止包括Zookeeper集群，其它大多数集群都推荐节点数最好为奇数个，因此本文将详细说明其中的缘由。首先我们需要明白一个概念“脑裂”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，每个小集群都认为其它
      
    
    </summary>
    
      <category term="Zookeeper" scheme="http://yoursite.com/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel</title>
    <link href="http://yoursite.com/2019/03/30/Redis-Sentinel/"/>
    <id>http://yoursite.com/2019/03/30/Redis-Sentinel/</id>
    <published>2019-03-30T13:45:00.000Z</published>
    <updated>2019-03-31T05:33:44.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h2><p>复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的，但它故障恢复无法自动化，因此Redis提供了哨兵（Sentinel）这么一个高可用方案。Redis Sentinel由两部分组成，哨兵节点和数据节点：</p><ul><li>哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。</li><li>数据节点：主节点和从节点都是数据节点。</li></ul><p><img src="http://blog.default.nanwulife.com/1174710-20180908182924632-1069251418.png" alt=""></p><p>Redis Sentinel具有以下功能：</p><ul><li>监控：哨兵通过心跳检测会不断地检查主节点和从节点是否运作正常。</li><li>自动故障转移：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供者：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li>通知：哨兵可以将故障转移的结果发送给客户端。</li></ul><h2 id="客户端连接Redis-Sentinel"><a href="#客户端连接Redis-Sentinel" class="headerlink" title="客户端连接Redis Sentinel"></a>客户端连接Redis Sentinel</h2><p>对于Redis Sentinel，它仅仅完成了服务端的高可用，当master挂掉时能选举出一个新的master节点来完成故障转移，但是我们客户端并没有去连接新的master节点，因此我们还要使得客户端也是高可用的。</p><p>Jedis客户端对Redis Sentinel提供了很好的支持。我们只需要向Jedis提供sentinel节点集合和<code>masterName</code>，构造<code>JedisSentinelPool</code>对象，然后便可以像使用普通redis连接池一样来使用了：通过<code>pool.getResource()</code>获取连接，执行具体的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSentinel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">         Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26379"</span>);</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26380"</span>);</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26381"</span>);</span><br><span class="line"> </span><br><span class="line">         JedisSentinelPool pool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels); <span class="comment">//初始化过程做了很多工作</span></span><br><span class="line">         Jedis jedis = pool.getResource();</span><br><span class="line">         jedis.set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">         pool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个过程中，我们的代码不需要显式的指定主节点的地址，就可以连接到主节点。代码中对故障转移也没有任何体现，就可以在sentinel完成故障转移后自动的切换主节点。之所以可以做到这些，是因为客户端完成了以下几个工作：</p><ul><li>遍历sentinel节点，找到一个可用的sentinel节点，通过<code>sentinel get-master-addr-by-name</code>命令获取master节点的信息（IP和端口），之后再对master节点执行<code>role</code>命令判断其是否真的为master节点。</li><li>客户端和sentinel使用了一个发布订阅模式，客户端订阅sentinel的某一个频道，当master发生变化时，sentinel向这个频道发布一条消息，客户端就可以获取再对新的master进行一个连接。</li></ul><p>前面说过sentinel相当于配置提供者，我们得到了sentinel的集合后就可以通过sentinel节点获取到master的地址。这里要注意sentinel只是配置提供者，而不是代理，二者的区别在于如果是配置提供者，客户端在通过sentinel获得master信息后，会直接建立到master的连接，后续的请求会直接发向master，而如果是代理，客户端的每一次请求都会发向sentinel，sentinel再通过主节点处理请求。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><ul><li>10秒每个sentinel对master和slave执行info，以此发现slave节点并确认主从关系。</li><li>2秒每个sentinel通过master节点的channel交换信息（因此sentinel节点之间能够自动感知）。</li><li>每1秒每个sentinel对其它sentinel和redis执行ping也就是心跳检测。</li></ul><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><ul><li>主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线。</li><li>客观下线：哨兵节点在对主节点进行主观下线后，会通过<code>sentinel is-master-down-by-addr</code>命令询问其他哨兵节点该主节点的状态。如果判断主节点下线的哨兵数量达到设置的法定人数（quorum），则对该主节点进行客观下线。</li></ul><p>需要特别注意的是，客观下线是主节点才有的概念，如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</p><h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><p>由于只需要一个sentinel节点完成故障转移，因此sentinel内部需要选举出一个节点作为领导者，同样也是通过<code>sentinel is-master-down-by-addr</code>这个命令完成领导者的选举（这正是这条命令的第二个作用）。过程如下：</p><ol><li>每个做主观下线的sentinel节点向其它sentinel节点发送命令，要求将它设置为领导者。</li><li>收到命令的sentinel节点如果没有同意通过其它sentinel节点发送的命令，那么将同意该请求，否则拒绝。</li><li>如果该sentinel节点发现自己的票数已经超过sentinel集合半数并且超过quorum，那么将它成为领导者。</li></ol><p>需要特别注意的是，客观下线是主节点才有的概念，如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>完成了领导者选举后，由领导者进行故障转移操作：</p><ol><li>从slave节点中选出一个“合适的”节点作为新的master节点：选择优先级最高的从节点(由<code>slave-priority</code>指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。</li><li>对上面slave节点执行<code>slaveof no one</code>命令让其成为master节点。</li><li>向剩余的slave节点发送命令，让它们成为新master节点的slave节点，复制规则和<code>parallel-syncs</code>参数有关。</li><li>更新原来master节点配置为slave，并保持着对其“关注”，当其恢复后命令它去复制新的master节点。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Redis Sentinel无法对从节点进行自动故障转移，在读写分离场景下，从节点故障会导致读服务不可用，需要我们对从节点做额外的监控、切换操作。除此之外，它的存储能力受到单机限制的问题，因此如果我们对扩容有需求的话，应当使用Redis Cluster这么一个高可用的集群方案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9609938.html#t33" target="_blank" rel="noopener">深入学习Redis（4）：哨兵</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Sentinel架构&quot;&gt;&lt;a href=&quot;#Redis-Sentinel架构&quot; class=&quot;headerlink&quot; title=&quot;Redis Sentinel架构&quot;&gt;&lt;/a&gt;Redis Sentinel架构&lt;/h2&gt;&lt;p&gt;复制是高可用Redis的基础
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://yoursite.com/2019/03/30/dis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/30/dis主从复制/</id>
    <published>2019-03-30T08:06:00.000Z</published>
    <updated>2019-03-31T05:34:03.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制是指将主节点（master）的数据复制到从节点（slave）中，数据的复制是单向的，只能由主节点到从节点。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>主从复制过程大体可以分为3个阶段：连接建立阶段、数据同步阶段、命令传播阶段。</p><h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><p>主从复制的开启，完全是在从节点发起的（通过<code>slaveof</code>命令），不需要我们在主节点做任何事情。需要注意的是，<code>slaveof</code>是异步命令，从节点完成主节点ip和port的保存后，向发送<code>slaveof</code>命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p><h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步。数据同步阶段是主从复制最核心的阶段，由从节点向主节点发送<code>psync</code>命令开始同步，并且根据主从节点当前状态的不同，可以分为全量复制和部分复制。</p><p><img src="http://blog.default.nanwulife.com/psync.jpg" alt=""></p><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>全量复制用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。执行过程如下：</p><ul><li>主节点收到全量复制的命令后，执行<code>bgsave</code>，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</li><li>主节点的<code>bgsave</code>执行完成后，将RDB文件发送给从节点，从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行<code>bgsave</code>时的数据库状态。</li><li>主节点将复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</li><li>如果从节点开启了AOF，则会触发<code>bgrewriteaof</code>的执行，从而保证AOF文件更新至主节点的最新状态。</li></ul><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>复制偏移量：主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数。主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。</p><p>复制缓冲区：复制缓冲区是由主节点维护的、固定长度的、先进先出队列，默认大小1MB，当主节点开始有从节点时创建。在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制缓冲区，作为写命令的备份。除了存储写命令，复制缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令，时间较早的写命令会被挤出缓冲区，因此当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</p><p>服务器运行ID（runid）：每个Redis节点（无论主从），在启动时都会自动生成一个随机ID（每次启动都不一样），runid用来唯一识别一个Redis节点。主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来。当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步阶段完成后，主从节点进入命令传播阶段。在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复，因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在没有使用哨兵或集群的场景下，当主节点挂掉了以后，从节点没法完成master选举，从而导致整个服务对外不可用。我们需要自行选择一个从节点作为主节点并继续对外提供服务，并将其它从节点的主节点设为它，由于这些过程都需要手动完成，出错率比较高，因此在真实场景中往往都会使用哨兵或者集群来实现系统的高可用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;主从复制是指将主节点（master）的数据复制到从节点（slave）中，数据的复制是单向的，只能由主节点到从节点。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化：AOF与RDB</title>
    <link href="http://yoursite.com/2019/03/30/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/30/Redis五种数据类型/</id>
    <published>2019-03-30T03:30:00.000Z</published>
    <updated>2019-03-30T08:05:54.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘，当下次Redis重启时，利用持久化文件实现数据恢复。</p><p>Redis持久化分为RDB持久化和AOF持久化：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘，保存的文件后缀是rdb，当Redis重新启动时，可以读取快照文件恢复数据。RDB持久化分为手动触发和自动触发两种方式：</p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>手动触发可以使用<code>save</code>命令和<code>bgsave</code>命令，都可以生成rdb文件。它们的区别在于<code>save</code>命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求；而<code>bgsave</code>命令会创建一个子进程，由子进程来负责创建RDB文件，父进程（即Redis主进程）则继续处理请求，整个过程中只有<code>fork</code>子进程时会阻塞服务器。</p><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>自动触发最常见的情况是在配置文件中通过<code>save m n</code>，指定当m秒内发生n次变化时，会触发<code>bgsave</code>。例如默认配置文件中有以下三行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p><p>只要上面三行任意一条满足时，就会执行<code>bgsave</code>。除此之外，在主从复制的场景下，如果从节点执行全量复制操作，则主节点会执行<code>bgsave</code>命令，并将rdb文件发送给从节点。执行<code>shutdown</code>命令时，也会自动执行rdb持久化。</p><h3 id="启动时加载"><a href="#启动时加载" class="headerlink" title="启动时加载"></a>启动时加载</h3><p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>RDB持久化是将进程数据写入文件，而AOF持久化则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog），当Redis重启时再次执行AOF文件中的命令来恢复数据。与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</p><h3 id="三种策略"><a href="#三种策略" class="headerlink" title="三种策略"></a>三种策略</h3><p>为了提高文件写入效率，在现代操作系统中，当用户将数据写入文件时（<code>write</code>命令），操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但如果系统崩溃，内存缓冲区中的数据将会丢失。因此可以设置同步选项，强制操作系统什么时候将缓冲区中的数据写入到硬盘中（<code>fsync</code>命令），Redis提供了以下三种同步策略：</p><ul><li>always：每个写命令都同步</li><li>everysec：每秒同步一次</li><li>no：让操作系统来决定何时同步</li></ul><p>always会严重降低服务器的性能，而no的不可控性太强，因此Redis使用everysec作为默认配置，但在系统崩溃时可能会丢失一秒的数据。</p><h3 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h3><p>随着Redis服务器执行的写命令越来越多，AOF文件也会越来越大，过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件，而不会对旧的AOF文件进行任何读取、写入操作。</p><p>文件重写主要是针对以下一些语句：</p><ul><li>过期的数据（如<code>expire</code>），可以不用再写入文件。</li><li>多次<code>INCR</code>命令可以合并为一个<code>SET</code>命令。</li><li>无效的命令不再写入文件，比如有些数据被删除了。</li></ul><h3 id="手动触发-1"><a href="#手动触发-1" class="headerlink" title="手动触发"></a>手动触发</h3><p>可以直接调用<code>bgrewriteaof</code>命令重写文件，该命令的执行与<code>bgsave</code>有些类似，都是<code>fork</code>子进程进行具体的工作，且都只有在<code>fork</code>时阻塞。</p><h3 id="自动触发-1"><a href="#自动触发-1" class="headerlink" title="自动触发"></a>自动触发</h3><p>默认配置是当AOF文件大小是上次重写后大小的一倍（<code>auto-aof-rewrite-min-size</code>）且文件大于64M时触发（<code>auto-aof-rewrite-percentage</code>）。</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ol><li>父进程执行<code>fork</code>操作创建子进程，这个过程中父进程是阻塞的。</li><li>子进程创建后，Redis的所有写命令依然写入AOF缓冲区，并根据设置策略同步到硬盘，保证原有AOF机制的正确。</li><li>由于<code>fork</code>操作使用写时复制技术，子进程只能共享<code>fork</code>操作时的内存数据。由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区（图中的aof_rewrite_buf）保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。</li><li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。</li><li>子进程写完新的AOF文件后，向父进程发信号，父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。</li><li>使用新的AOF文件替换老文件，完成AOF重写。</li></ol><p><img src="http://blog.default.nanwulife.com/1174710-20180605092001589-1724580361.png" alt=""></p><h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><ul><li>RDB持久化：RDB文件紧凑，体积小，恢复速度比AOF快很多，但数据的实时性较低。</li><li>AOF持久化：实时性较高，但是文件大，并且恢复速度较慢，且对性能有一定影响。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="fork阻塞：CPU的阻塞"><a href="#fork阻塞：CPU的阻塞" class="headerlink" title="fork阻塞：CPU的阻塞"></a>fork阻塞：CPU的阻塞</h3><p>在Redis中，无论是RDB持久化的<code>bgsave</code>，还是AOF重写的<code>bgrewriteaof</code>，都需要<code>fork</code>出子进程来进行操作，而在操作系统<code>fork</code>的实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间，但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分（内存的一页）制作一个副本。</p><p>也就是说，虽然<code>fork</code>时子进程不会复制父进程的数据空间，但是会复制内存页表，如果Redis内存过大，会导致fork操作时复制内存页表耗时过多，而Redis主进程在进行<code>fork</code>时是完全阻塞的，意味着无法响应客户端的请求，造成请求延迟过大。</p><p>为了防止该问题的发生，我们需要控制Redis单机内存的大小，并且适当放宽AOF重写的触发条件，尽量在写入较少的时间段完成重写。</p><h3 id="AOF追加阻塞：硬盘的阻塞"><a href="#AOF追加阻塞：硬盘的阻塞" class="headerlink" title="AOF追加阻塞：硬盘的阻塞"></a>AOF追加阻塞：硬盘的阻塞</h3><p>AOF持久化过程中，通过<code>fsync</code>命令每秒一次将缓冲区的数据写入磁盘中，但在硬盘负载过高时，<code>fsync</code>操作可能会超过1s，当继续向缓冲区内写入数据时，磁盘负载会越来越大，如果此时Redis进程异常退出，丢失的数据也有可能远超1s。</p><p>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比距离上次<code>fsync</code>成功的时间，如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到<code>fsync</code>同步完成。因此，如果系统硬盘负载过大导致<code>fsync</code>速度太慢，会导致Redis主线程的阻塞。这里还要注意的是，如果使用everysec策略，AOF最多可能丢失2s的数据，而不是1s。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis持久化&quot;&gt;&lt;a href=&quot;#Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化&quot;&gt;&lt;/a&gt;Redis持久化&lt;/h2&gt;&lt;p&gt;Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux五种IO模型</title>
    <link href="http://yoursite.com/2019/03/27/Linux-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/27/Linux-五种IO模型/</id>
    <published>2019-03-27T02:39:00.000Z</published>
    <updated>2019-03-27T05:05:05.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>对于一次IO访问，会分为两个阶段，首先等待数据准备好后被拷贝到操作系统内核的缓冲区中，然后再从操作系统内核的缓冲区拷贝到用户空间。IO模型可以分为以下五种类型：</p><ul><li>阻塞式I/O（Blocking I/O）</li><li>非阻塞式I/O（Non-blocking I/O）</li><li>多路复用I/O（Multiplexing I/O）</li><li>信号驱动I/O（Signal-driven I/O）</li><li>异步I/O（Asynchronous I/O）</li></ul><p>其中信号驱动式IO并不常用，所以重点关注另外四种IO模型。</p><h2 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h2><p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的IO。</p><p>阻塞IO的特点就是能够及时的返回数据，但是在IO执行的两个阶段都被阻塞了，只有当数据从内核复制到了用户空间中，进程才能继续往下执行，因此对性能有所牺牲。</p><p><img src="http://blog.default.nanwulife.com/1492928416812_4.png" alt=""></p><h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h2><p>应用进程执行系统调用之后，内核会立即返回一个错误码，但IO操作还没完成。此时应用进程并没有被阻塞，可以继续执行，但是需要不断的执行系统调用来获知IO操作是否完成，这种方式称为轮询。</p><p>这种模型的CPU利用率比较低，并且因为每过一段时间才去轮询一次，所以存在一个响应延迟。还需要注意的是，拷贝数据的整个过程，进程仍然是属于阻塞的状态。</p><p><img src="http://blog.default.nanwulife.com/1492929000361_5.png" alt=""></p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>使用<code>select</code>或者<code>poll</code>对多个IO端口进行监听，只要多个套接字中的任何一个数据准备好了，就能返回可读，之后应用进程再执行recvfrom系统调用把数据从内核复制到进程中。</p><p>I/O复用模型让单个进程具有处理多个I/O事件的能力，因此相比多进程和多线程技术，它的系统开销小了许多。但是<code>select</code>，<code>poll</code>，<code>epoll</code>函数依然会阻塞应用进程，并且由于多路复用可以处理多个IO，那么多个IO之间的顺序就变得不确定了。</p><p><img src="http://blog.default.nanwulife.com/1492929444818_6.png" alt=""></p><h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p>应用进程使用sigaction系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送SIGIO信号，应用进程收到之后在信号处理程序中调用recvfrom将数据从内核复制到应用进程中。</p><p>相比于非阻塞式I/O的轮询方式，信号驱动I/O的CPU利用率更高。</p><p><img src="http://blog.default.nanwulife.com/1492929553651_7.png" alt=""></p><h2 id="异步非阻塞I-O"><a href="#异步非阻塞I-O" class="headerlink" title="异步非阻塞I/O"></a>异步非阻塞I/O</h2><p>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户进程就可以去做别的事情。等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。这个IO模式的两个阶段，进程都是非阻塞的。</p><p><img src="http://blog.default.nanwulife.com/1492930243286_8.png" alt=""></p><h2 id="五种I-O模型对比"><a href="#五种I-O模型对比" class="headerlink" title="五种I/O模型对比"></a>五种I/O模型对比</h2><ul><li>阻塞式I/O：同步阻塞</li><li>非阻塞式I/O：同步非阻塞（轮询）</li><li>I/O多路复用：同步阻塞（可以监听多个IO）</li><li>信号驱动I/O：同步非阻塞（收到SIGIO信号后才执行recvfrom并阻塞）</li><li>异步I/O：异步非阻塞（两个阶段都不会阻塞）</li></ul><p><img src="http://blog.default.nanwulife.com/1492928105791_3.png" alt=""></p><h2 id="I-O多路复用中的select、poll、epoll"><a href="#I-O多路复用中的select、poll、epoll" class="headerlink" title="I/O多路复用中的select、poll、epoll"></a>I/O多路复用中的select、poll、epoll</h2><p>select，poll，epoll都是IO多路复用的机制，select出现的最早，之后是poll，再是epoll。I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p></blockquote><ul><li><strong>select</strong>：它仅仅知道有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，测试每个流是否有事件发生，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的时间复杂度，同时处理的流越多，无差别轮询时间就越长。</li><li><strong>poll</strong>：poll本质上和select没有区别，需要查询每个fd对应的设备状态，但是它没有最大连接数的限制，因为select的描述符类型使用数组实现，而poll的描述符类型使用链表实现。</li><li><strong>epoll</strong>：epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="https://www.cnblogs.com/aspirant/p/9166944.html" target="_blank" rel="noopener">select、poll、epoll之间的区别(搜狗面试)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;p&gt;对于一次IO访问，会分为两个阶段，首先等待数据准备好后被拷贝到操作系统内核的缓冲区中，然后再从操作系统内核的缓冲区拷贝到用户
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>NIO知识点总结</title>
    <link href="http://yoursite.com/2019/03/10/NIO%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/10/NIO知识点总结/</id>
    <published>2019-03-10T12:55:00.000Z</published>
    <updated>2019-03-11T13:08:04.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java NIO是一个可以替代标准Java IO API的IO API，主要有以下三个核心组件：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>NIO与IO的主要区别在于：</p><ul><li>IO是面向流的，NIO是面向缓冲区的。</li><li>IO是阻塞的，NIO是非阻塞的。</li><li>NIO有选择器，允许一个单独的线程来管理多个输入通道。</li></ul><a id="more"></a><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Java NIO的通道类似流，主要区别在于：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>NIO中有以下几个重要的通道实现。</p><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p><p>注意：FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开FileChannel</span></span><br><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在FileChannel的某个特定位置进行数据的读/写操作</span></span><br><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用FileChannel.truncate()方法截取一个文件，指定长度后面的部分将被删除</span></span><br><span class="line">channel.truncate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上，而通过FileChannel.force()方法则可以将通道里尚未写入磁盘的数据强制写到磁盘上</span></span><br><span class="line">channel.force(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p><ul><li>打开一个SocketChannel并连接到互联网上的某台服务器。</li><li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li></ul><p>SocketChannel是可以设置为非阻塞模式的，设置之后，就可以在异步模式下调用<code>connect()</code>, <code>read()</code>和<code>write()</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开并连接</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//非阻塞模式可以调用finishConnect()的方法确定连接是否建立</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">   <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>ServerSocketChannel是一个可以监听新进来的TCP连接的通道。在打开了ServerSocketChannel之后，可以通过<code>accept()</code>方法监听新进来的连接，当<code>accept()</code>方法返回的时候，它返回一个包含新进来的连接的<code>SocketChannel</code>。因此，<code>accept()</code>方法会一直阻塞到有新连接到达。</p><p>ServerSocketChannel也可以设置成非阻塞模式。在非阻塞模式下，<code>accept()</code>方法会立刻返回，如果还没有新进来的连接,返回的将是<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开通道并监听新进来的连接</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h2><p>DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开DatagramChannel</span></span><br><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过receive()方法从DatagramChannel接收数据到指定的Buffer，如果Buffer容不下收到的数据，多出的数据将被丢弃</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过send()方法从DatagramChannel发送数据</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>Buffer本质是一块可以写入数据，并可以从中读取数据的内存，用于和通道进行交互，过程如下：</p><ul><li>写入数据到Buffer</li><li>调用<code>flip()</code>方法</li><li>从Buffer中读取数据</li><li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li></ul><p>其中<code>flip()</code>方法是将Buffer从写模式切换到读模式，<code>clear()</code>方法会清空整个缓冲区，<code>compact()</code>方法只会清除已经读过的数据并将所有未读的数据拷贝到Buffer起始处。</p><p>Buffer有三个属性：</p><ul><li>capacity</li><li>position：当写数据到Buffer中时，position表示当前的位置；当从Buffer读取数据时，也是从当前位置开始读；将Buffer从写模式切换到读模式，position会被重置为0。</li><li>limit：在写模式下，limit表示你最多能往Buffer里写多少数据，此时limit等于capacity；在读模式下，limit表示最多能读到多少数据，因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。</li></ul><p>Buffer有以下几种类型，它们代表了不同的数据类型：</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h2 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h2><p>要想获得一个Buffer对象首先要进行分配。每一个Buffer类都有一个allocate方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure></p><h2 id="向Buffer写数据"><a href="#向Buffer写数据" class="headerlink" title="向Buffer写数据"></a>向Buffer写数据</h2><p>写数据到Buffer有两种方式：</p><ul><li>从Channel写到Buffer。</li><li>通过Buffer的<code>put()</code>方法写到Buffer里。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"></span><br><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure><h2 id="从Buffer读数据"><a href="#从Buffer读数据" class="headerlink" title="从Buffer读数据"></a>从Buffer读数据</h2><p>从Buffer中读取数据有两种方式：</p><ul><li>从Buffer读取数据到Channel。</li><li>使用get()方法从Buffer中读取数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure><h2 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h2><p><code>rewind()</code>将position设回0，所以可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素。</p><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector是NIO中能够检测一到多个通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h2 id="创建并注册"><a href="#创建并注册" class="headerlink" title="创建并注册"></a>创建并注册</h2><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Selector的创建</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//向Selector注册通道</span></span><br><span class="line">  channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,</span><br><span class="line">  Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>注意<code>register()</code>方法的第二个参数。这是一个interest集合，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件，用SelectionKey的四个常量来表示:</p><ul><li><code>SelectionKey.OP_CONNECT</code>：某个channel成功连接到另一个服务器称为“连接就绪”</li><li><code>SelectionKey.OP_ACCEPT</code>：一个server socket channel准备好接收新进入的连接称为“接收就绪”</li><li><code>SelectionKey.OP_READ</code>：一个有数据可读的通道可以说是“读就绪”</li><li><code>SelectionKey.OP_WRITE</code>：等待写数据的通道可以说是“写就绪”。</li></ul><p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如<code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></p><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>当向Selector注册Channel时，<code>register()</code>法会返回一个SelectionKey对象，这个对象包含以下几个属性：</p><ul><li>terest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><h3 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h3><p>可以用位与操作interest集合和给定的SelectionKey常量来确定某个事件是否在interest集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h3><p>ready集合是通道已经准备就绪的操作的集合。可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪，也可以通过如下的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p><h3 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel Selector"></a>Channel Selector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h3 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h3><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><h2 id="选择通道"><a href="#选择通道" class="headerlink" title="选择通道"></a>选择通道</h2><p>一旦向Selector注册了一或多个通道，就可以调用<code>select()</code>方法选择就绪的通道，方法返回已经就绪的通道数目。<code>select()</code>阻塞到至少有一个通道在你注册的事件上就绪了，而<code>selectNow()</code>不会阻塞。</p><p>一旦调用了<code>select()</code>方法，并且返回值表明有一个或更多个通道就绪了，就可以通过调用<code>selectedKeys()</code>方法返回就绪通道的集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>之后就可以通过遍历这个集合来访问就绪的通道：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意每次迭代末尾的<code>keyIterator.remove()</code>调用。Selector不会自己从集合中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入集合中。</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>用完Selector后调用其<code>close()</code>方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效，但通道本身并不会关闭。</p><h1 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h1><p>Java NIO支持scatter/gather，scatter是指数据从一个channel读取到多个buffer中，而gather则是指数据从多个buffer写入到同一个channel。scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样可以方便的处理消息头和消息体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.read(bufferArray);</span><br><span class="line"></span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>注意，Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这意味着它不适用于动态消息，而Gathering Writes只有position和limit之间的数据才会被写入，因此能较好的处理动态消息。</p><h1 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h1><p>如果两个通道中有一个是FileChannel，那么可以直接将数据从一个通道传输到另外一个通道。</p><h2 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h2><p><code>transferFrom()</code>方法可以将数据从源channel传输到FileChannel中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure></p><h2 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h2><p><code>transferTo()</code>方法将数据从FileChannel传输到其他的channel中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>Path接口表示的是一个与平台无关的路径，既可以是绝对路径也可以是相对路径，文件和目录都用Path表示。</p><h2 id="创建Path"><a href="#创建Path" class="headerlink" title="创建Path"></a>创建Path</h2><p>可以使用Paths工具类的工厂方法创建一个Path对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"C:\\DATA\\test.txt"</span>);</span><br><span class="line"></span><br><span class="line">Path projects = Paths.get(<span class="string">"d:\\data"</span>, <span class="string">"projects"</span>);</span><br><span class="line"></span><br><span class="line">Path currentDir = Paths.get(<span class="string">"."</span>);</span><br><span class="line">Path parentDir = Paths.get(<span class="string">".."</span>);</span><br></pre></td></tr></table></figure><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h2><p><code>normalize()</code>方法可以标准化路径，它会处理路径中的相对路径，去除<code>.</code> <code>..</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"c:/Z_DATA/./test.txt"</span>);</span><br><span class="line">System.out.println(<span class="string">"path = "</span> + path);</span><br><span class="line"></span><br><span class="line">path = path.normalize();</span><br><span class="line">System.out.println(<span class="string">"path = "</span> + path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">path = c:\Z_DATA\.\test.txt</span><br><span class="line">path = c:\Z_DATA\test.txt</span><br></pre></td></tr></table></figure></p><h1 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h1><p>Files工具类封装提供了一些操作文件系统中文件的工具方法，往往和和Path一起使用。</p><h2 id="exists"><a href="#exists" class="headerlink" title="exists()"></a>exists()</h2><p><code>exists()</code>可以判断一个Path在文件系统中是否存在。</p><h2 id="createDirctory"><a href="#createDirctory" class="headerlink" title="createDirctory()"></a>createDirctory()</h2><p>在调用创建方法前最好先检查是否存在，如果已经存在会抛出<code>FileAlreadyExistsException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Path newDir = Paths.get(<span class="string">"c:/Z_DATA/newDir"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!Files.exists(newDir)) &#123;</span><br><span class="line">        Files.createDirectory(newDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h2><p><code>copy()</code>只能复制到不存在的路径，如果复制的目标文件已存在则会抛出异常。强制覆盖已存在文件也是可以的，需要增加相应参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(classPath,<span class="string">"nio-data.txt"</span>);</span><br><span class="line">Path targetPath = Paths.get(classPath,<span class="string">"nio-data-copy.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); <span class="comment">// 复制并覆盖已有文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="move"><a href="#move" class="headerlink" title="move()"></a>move()</h2><p>Java NIO Files类同样提供了移动文件的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(classPath,<span class="string">"nio-data.txt"</span>);</span><br><span class="line">Path targetPath = Paths.get(classPath,<span class="string">"nio-data-copy.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); <span class="comment">// 移动并覆盖已有文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h2><p>删除文件或目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.delete(targetPath);</span><br></pre></td></tr></table></figure><p>如果删除的文件或目录不存在会抛出<code>IOException</code>异常。</p><h1 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h1><p>使用AsynchronousFileChannel可以实现异步地读取和写入文件数据。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们可以使用AsynchronousFileChannel提供的静态方法<code>open()</code>创建它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test.xml"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel =</span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>AsynchronousFileChannel提供了两种读取数据的方式，都是调用它本身的<code>read()</code>方法。</p><h3 id="使用Futrue读取数据"><a href="#使用Futrue读取数据" class="headerlink" title="使用Futrue读取数据"></a>使用Futrue读取数据</h3><p>第一种方式是调用AsynchronousFileChannel的<code>read()</code>方法，该方法返回一个<code>Future</code>类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">buffer.get(data);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure><p>以上代码<code>read()</code>方法会立即返回，即使整个读的过程还没有完全结束。我们可以通过<code>Future.isDone()</code>来检查读取是否完成。</p><h3 id="使用CompletionHandler读取数据"><a href="#使用CompletionHandler读取数据" class="headerlink" title="使用CompletionHandler读取数据"></a>使用CompletionHandler读取数据</h3><p>第二种读取数据的方式是调用AsynchronousFileChannel的另一个<code>read()</code>方法，该方法需要一个<code>CompletionHandler</code>作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.read(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line"></span><br><span class="line">        attachment.flip();</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[attachment.limit()];</span><br><span class="line">        attachment.get(data);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">        attachment.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一旦读取操作完成，<code>CompletionHandler</code>的<code>complete()</code>方法将会被调用。它的第一个参数是个<code>Integer</code>类型，表示读取的字节数。第二个参数<code>attachment</code>是<code>ByteBuffer</code>类型的，用来存储读取的数据(<code>ByteBuffer</code>也可以换成其他合适的对象方便数据写入)。它其实就是由<code>read()</code>方法的第三个参数。读取失败的时候，<code>CompletionHandler</code>的<code>failed()</code>方法会被调用。</p><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><p>就像读取一样，我们同样有两种方式向AsynchronousFileChannel写入数据。</p><h3 id="使用Future读取数据"><a href="#使用Future读取数据" class="headerlink" title="使用Future读取数据"></a>使用Future读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.write(buffer, position);</span><br><span class="line">buffer.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Write done"</span>);</span><br></pre></td></tr></table></figure><p>注意，写入目标文件要提前创建好，如果它不存在的话，<code>write()</code>方法会抛出一个 <code>NoSuchFileException</code>。</p><h3 id="使用CompletionHandler写入数据"><a href="#使用CompletionHandler写入数据" class="headerlink" title="使用CompletionHandler写入数据"></a>使用CompletionHandler写入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line"><span class="keyword">if</span>(!Files.exists(path))&#123;</span><br><span class="line">    Files.createFile(path);</span><br><span class="line">&#125;</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">fileChannel.write(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes written: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Write failed"</span>);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当写入程序完成时，CompletionHandler的<code>completed()</code>方法将会被调用，相反的如果写入失败则会调用<code>failed()</code>方法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">Java NIO 系列教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Java NIO是一个可以替代标准Java IO API的IO API，主要有以下三个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Buffers&lt;/li&gt;
&lt;li&gt;Selectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO与IO的主要区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IO是面向流的，NIO是面向缓冲区的。&lt;/li&gt;
&lt;li&gt;IO是阻塞的，NIO是非阻塞的。&lt;/li&gt;
&lt;li&gt;NIO有选择器，允许一个单独的线程来管理多个输入通道。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NIO" scheme="http://yoursite.com/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS的过程与原理</title>
    <link href="http://yoursite.com/2019/02/17/HTTPS%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/17/HTTPS的过程与原理/</id>
    <published>2019-02-17T03:05:00.000Z</published>
    <updated>2019-02-17T03:36:25.883Z</updated>
    
    <content type="html"><![CDATA[<p>由于HTTP存在明文通信、无法验证服务器的真实性等弊端，使用HTTPS的人变得越来越多。HTTPS并不是新的协议，而是在HTTP基础之上加一层TLS模块，TLS提供了加密、认证以及消息完整性校验的服务，从而保证通信的安全性。</p><a id="more"></a><h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>HTTPS总的流程就相当于使用非对称加密的方式来传递对称私钥，之后的通信就可以使用这个私钥进行对称加密了。</p><p><img src="http://blog.default.nanwulife.com/2012072310244445.png" alt="HTTPS的过程与原理"></p><h3 id="客户端发起HTTPS请求"><a href="#客户端发起HTTPS请求" class="headerlink" title="客户端发起HTTPS请求"></a>客户端发起HTTPS请求</h3><p>用户在浏览器里输入一个https网址，然后连接到server的443端口。</p><h3 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h3><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。</p><h3 id="传送证书"><a href="#传送证书" class="headerlink" title="传送证书"></a>传送证书</h3><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h3 id="客户端解析证书"><a href="#客户端解析证书" class="headerlink" title="客户端解析证书"></a>客户端解析证书</h3><p>这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。</p><h3 id="传送加密信息"><a href="#传送加密信息" class="headerlink" title="传送加密信息"></a>传送加密信息</h3><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><h3 id="服务段解密信息"><a href="#服务段解密信息" class="headerlink" title="服务段解密信息"></a>服务段解密信息</h3><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><h3 id="传输加密后的信息"><a href="#传输加密后的信息" class="headerlink" title="传输加密后的信息"></a>传输加密后的信息</h3><p>这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。</p><h3 id="客户端解密信息"><a href="#客户端解密信息" class="headerlink" title="客户端解密信息"></a>客户端解密信息</h3><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p><h2 id="证书认证"><a href="#证书认证" class="headerlink" title="证书认证"></a>证书认证</h2><p>单纯的加密是无法保证通信安全的，TLS还需要通过证书机制来保证访问的服务器是真实的。</p><p><img src="http://blog.default.nanwulife.com/2402164-db6c5a0d348fcc15.png" alt=""></p><p>证书是由权威机构颁发的，服务端如果能够提供一个合法的证书，说明这个服务端是合法的，可以被信任。整个证书的认证过程如下：</p><ul><li>客户端获取到了站点证书，拿到了站点的公钥</li><li>要验证站点可信后，才能使用其公钥，因此客户端找到其站点证书颁发者的信息</li><li>站点证书的颁发者验证了服务端站点是可信的，但客户端依然不清楚该颁发者是否可信</li><li>再往上回溯，找到了认证了中间证书商的根证书颁发者。由于根证书颁发者非常少，我们浏览器之前就认识了，因此可以认为根证书颁发者是可信的</li><li>一路倒推，证书颁发者可信，那么它所颁发的所有站点也是可信的，最终确定我们所要访问的服务端是可信的</li><li>客户端使用证书中包含的公钥，继续完成TLS的握手过程</li></ul><p>如果证书过期了、颁发机构不受信任或者证书绑定的域名和请求的域名不一致等原因，浏览器会抛出异常信息，说明此时的访问是不安全的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank" rel="noopener">图解HTTPS</a></li><li><a href="https://www.jianshu.com/p/24af67c40e8d" target="_blank" rel="noopener">TLS整理（下）：TLS如何保证安全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于HTTP存在明文通信、无法验证服务器的真实性等弊端，使用HTTPS的人变得越来越多。HTTPS并不是新的协议，而是在HTTP基础之上加一层TLS模块，TLS提供了加密、认证以及消息完整性校验的服务，从而保证通信的安全性。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
      <category term="TLS" scheme="http://yoursite.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB和MyISAM的区别</title>
    <link href="http://yoursite.com/2019/02/16/InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/02/16/InnoDB和MyISAM的区别/</id>
    <published>2019-02-16T07:05:00.000Z</published>
    <updated>2019-02-16T07:11:45.835Z</updated>
    
    <content type="html"><![CDATA[<ol><li>InnoDB支持事务，MyISAM不支持。</li><li>InnoDB支持外键，而MyISAM不支持。</li><li>InnoDB是聚集索引，而MyISAM是非聚集索引。</li><li>InnoDB不保存表的具体行数，执行<code>select count(*) from table</code>时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;InnoDB支持事务，MyISAM不支持。&lt;/li&gt;
&lt;li&gt;InnoDB支持外键，而MyISAM不支持。&lt;/li&gt;
&lt;li&gt;InnoDB是聚集索引，而MyISAM是非聚集索引。&lt;/li&gt;
&lt;li&gt;InnoDB不保存表的具体行数，执行&lt;code&gt;select c
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MyISAM" scheme="http://yoursite.com/tags/MyISAM/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>访问一个网页的全过程</title>
    <link href="http://yoursite.com/2019/02/13/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/13/访问一个网页的全过程/</id>
    <published>2019-02-13T10:09:00.000Z</published>
    <updated>2019-02-18T03:18:09.754Z</updated>
    
    <content type="html"><![CDATA[<ol><li>客户端用户从浏览器输入<code>www.google.com</code>网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的。</li></ol><a id="more"></a><ol start="3"><li><p>如果hosts与DNS缓存都没有解析记录时，系统会把浏览器的解析请求交给客户端本地设置的DNS服务器地址解析，如果本地DNS服务器的本地缓存有对应的解析记录，就会直接返回IP地址。</p></li><li><p>如果本地DNS服务器没有对应的解析记录，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<code>google.com</code>)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<code>google.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.google.com</code>主机。</p></li><li><p>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li><li><p>通过DNS解析拿到了ip之后，就可以通过ip向服务器发送http请求了，因为http工作在应用层，tcp工作在传输层，所以发生http请求之前，还会进行tcp的三次握手建立连接。</p></li><li><p>在连接成功建立后，开始向web服务器发送请求，当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求报文，请求报文由<code>请求方法 URI 协议/版本</code>、<code>请求头</code>、<code>请求正文</code>三部分组成。</p></li><li><p>请求报文由应用层向下，依次经过传输层、网络层、数据链路层与物理层。应用层的任务是通过应用进程间的交互来完成特定网络应用，有HTTP、DNS等众多协议，传输层的主要任务则是负责向两台主机进程之间的通信提供通用的数据传输服务，包括TCP与UDP两种协议，TCP是面向连接的、可靠的的数据传输服务，而UDP提供无连接的、不可靠的数据传输服务，TCP主要提供完整性服务，UDP主要提供及时性服务；传输层是为主机中的进程提供数据传输服务，而网络层则是为不同主机提供数据传输服务，这一层有IP协议，由于主机之间可以有很多链路，数据链路层则是为同一链路的主机提供数据传输服务。最终物理层考虑怎样在传输媒体上传输数据比特流。数据通过以太网电缆传送到服务器，服务器拿到数据包后同样再由数据链路层、网络层、传输层依次向上解析，应用层最终收到请求内容。</p></li><li><p>服务器收到请求报文之后，就会将响应报文返回给客户端，响应报文由<code>协议/版本 状态码 描述</code>、<code>响应头</code>、<code>响应正文</code>三部分组成。这里的状态码分为1XX（信息类）、2XX（成功类）、3XX（重定向类）、4XX（客户端错误）、5XX（服务器错误）。</p></li><li><p>当浏览器加载一个完整的页面时，还需要与服务器断开连接，这个过程就是tcp的四次挥手。</p></li><li><p>在HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。因此，每次的请求都会造成无谓的TCP连接建立与断开，增加通信量的开销。为了解决这个问题，HTTP/1.1使用长连接减少开销，只要任意一端没有明确提出断开连接，就保持TCP连接状态，当客户端再次访问这个服务器上的网页时，会继续使用这一条已经建立的连接。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;客户端用户从浏览器输入&lt;code&gt;www.google.com&lt;/code&gt;网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程断点续传下载器</title>
    <link href="http://yoursite.com/2019/02/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/12/多线程断点续传下载器/</id>
    <published>2019-02-12T08:58:00.000Z</published>
    <updated>2019-02-12T11:13:32.667Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究多线程的断点续传下载。断点续传的原理其实很简单，就是在下载时将下载进度保存到一个临时文件中，如果下载过程遇到什么意外中断了，下次下载同一个文件时就可以从临时文件中读取到上次下载发生中断时的进度，然后从这个进度开始继续下载。</p><a id="more"></a><p>要使用断点续传下载首先要判断服务器是否支持范围请求，假如在响应中存在<code>Accept-Ranges</code>首部并且它的值不为 <code>none</code>，那么表示该服务器支持范围请求。通常情况下Web服务器会默认开启对范围请求的支持，我们只需要在请求头中加入<code>Range</code>首部来指示服务器应该返回文件的哪一部分，例如使用<code>Range: bytes=0-1023</code>返回某个资源的前1024个字节，在代码中体现为：<code>httpcon.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + startPos + &quot;-&quot; + endPos);</code>，这时候服务器会返回状态码为<code>206 Partial Content</code>的响应表示成功。</p><p>项目中还使用了多线程进行分块下载，要注意的是并非线程数越多下载就越快（受限于带宽），一般开十个线程就差不多了，多线程之所以能提高下载速度的原因也很复杂，具体可以参考<a href="https://www.zhihu.com/question/19914902" target="_blank" rel="noopener">为什么多线程下载能加速？</a>以及<a href="https://www.zhihu.com/question/21813579" target="_blank" rel="noopener">为什么多 TCP 连接分块下载比单连接下载快？</a>。简单来说就是当链路存在争用的情况下，由于传输网络的带宽有限，每个TCP连接可以得到均等的带宽。在多用户环境下，一个用户拥有越多TCP连接，获得的带宽越大。除此之外，由于TCP的拥塞控制机制被设计的十分友好，只要丢了点包就会极大的减慢速率，而此时可能并没有发生拥塞，导致单个连接没法最大化的利用带宽。</p><p>下图为该项目的执行流程：</p><p><img src="http://blog.algorithms.nanwulife.com/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0.jpg" alt=""></p><p>以下为项目源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Project</span>: breakpoint</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Cenjie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 2019/2/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String urlStr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> String filename_tmp;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lenPerThread;  <span class="comment">//每个线程的下载大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] start;    <span class="comment">//保留每个线程下载的起始位置。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] end;      <span class="comment">//保留每个线程下载的结束位置。</span></span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Downloader</span><span class="params">(String urlStr, <span class="keyword">int</span> threadNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.urlStr = urlStr;</span><br><span class="line">        <span class="keyword">this</span>.threadNum = threadNum;</span><br><span class="line">        start = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="keyword">this</span>.threadNum];</span><br><span class="line">        end = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="keyword">this</span>.threadNum];</span><br><span class="line">        latch = <span class="keyword">new</span> CountDownLatch(<span class="keyword">this</span>.threadNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        File file_tmp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从文件链接中获取文件名</span></span><br><span class="line">        filename = urlStr.substring(urlStr.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, urlStr</span><br><span class="line">                .contains(<span class="string">"?"</span>) ? urlStr.lastIndexOf(<span class="string">'?'</span>) : urlStr.length());</span><br><span class="line">        <span class="comment">//设置临时文件的文件名</span></span><br><span class="line">        filename_tmp = filename + <span class="string">"_tmp"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建url</span></span><br><span class="line">            url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打开下载链接，并且得到一个HttpURLConnection的一个对象httpcon</span></span><br><span class="line">            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            httpcon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取请求资源的总长度，为Long型</span></span><br><span class="line">            fileLength = httpcon.getContentLengthLong();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下载文件和临时文件</span></span><br><span class="line">            file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            file_tmp = <span class="keyword">new</span> File(filename_tmp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每个线程需下载的资源大小；由于文件大小不确定，为避免数据丢失</span></span><br><span class="line">            lenPerThread = fileLength % threadNum == <span class="number">0</span> ? fileLength / threadNum : fileLength / threadNum + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//打印下载信息</span></span><br><span class="line">            System.out.println(<span class="string">"文件名: "</span> + filename + <span class="string">"，"</span> + <span class="string">"文件大小："</span></span><br><span class="line">                    + fileLength + <span class="string">"字节，每个线程下载大小："</span> + lenPerThread + <span class="string">"字节"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (file.exists() &amp;&amp; file.length() == fileLength) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件已存在"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setBreakPoint(file_tmp);</span><br><span class="line">                ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    exec.execute(<span class="keyword">new</span> DownLoadThread(start[i], end[i],</span><br><span class="line">                            <span class="keyword">this</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">                latch.await();  <span class="comment">//当所有线程下载完毕后，才会从此阻塞中返回</span></span><br><span class="line">                System.out.println(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下载完成后，判断文件是否完整，并删除临时文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.length() == fileLength) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file_tmp.exists()) &#123;</span><br><span class="line">                file_tmp.delete();</span><br><span class="line">                System.out.println(<span class="string">"删除临时文件完成，下载结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该文件不完整"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取临时文件中记录的断点，加载每个线程的任务区间，若临时文件不存在，则重新分配每个线程的任务区间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file_tmp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBreakPoint</span><span class="params">(File file_tmp)</span> </span>&#123;</span><br><span class="line">        RandomAccessFile random_file_tmp = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"开始分配任务区间："</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果存在临时文件，则从临时文件记录的位置继续下载</span></span><br><span class="line">            <span class="keyword">if</span> (file_tmp.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"找到临时文件，将从断点处恢复下载..."</span>);</span><br><span class="line">                random_file_tmp = <span class="keyword">new</span> RandomAccessFile(file_tmp, <span class="string">"rw"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    random_file_tmp.seek(i * <span class="number">8</span>);</span><br><span class="line">                    start[i] = random_file_tmp.readLong();</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(<span class="number">1000</span> + i * <span class="number">8</span>);</span><br><span class="line">                    end[i] = random_file_tmp.readLong();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + i + <span class="string">" 起始位置："</span></span><br><span class="line">                            + start[i] + <span class="string">"，结束位置："</span> + end[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"未找到临时文件，开始一个新的下载..."</span>);</span><br><span class="line">                random_file_tmp = <span class="keyword">new</span> RandomAccessFile(file_tmp, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    <span class="comment">//设置线程i的下载起始位置</span></span><br><span class="line">                    start[i] = lenPerThread * i;</span><br><span class="line">                    <span class="keyword">if</span> (i == threadNum - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//当线程i为最后一个线程时，设置线程i的下载结束位置为文件长度</span></span><br><span class="line">                        end[i] = fileLength - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        end[i] = lenPerThread * (i + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(i * <span class="number">8</span>);</span><br><span class="line">                    random_file_tmp.writeLong(start[i]);</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(<span class="number">1000</span> + i * <span class="number">8</span>);</span><br><span class="line">                    random_file_tmp.writeLong(end[i]);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + i + <span class="string">" 起始位置："</span></span><br><span class="line">                            + start[i] + <span class="string">"，结束位置："</span> + end[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (random_file_tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    random_file_tmp.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownLoadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;         <span class="comment">//线程id</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> startPos;  <span class="comment">//线程下载起始位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> endPos;    <span class="comment">//线程下载结束位置</span></span><br><span class="line">        <span class="keyword">private</span> Downloader task;</span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile rand_file;</span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile rand_file_tmp;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownLoadThread</span><span class="params">(<span class="keyword">long</span> startPos, <span class="keyword">long</span> endPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Downloader task, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rand_file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.task.filename, <span class="string">"rw"</span>);</span><br><span class="line">                <span class="keyword">this</span>.rand_file_tmp = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.task.filename_tmp, <span class="string">"rw"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            HttpURLConnection httpcon;</span><br><span class="line">            InputStream is = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 开始下载..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    httpcon = (HttpURLConnection) task.url.openConnection();</span><br><span class="line">                    httpcon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//防止网络阻塞，设置指定的超时时间；单位都是ms。超过指定时间，就会抛出异常</span></span><br><span class="line">                    httpcon.setReadTimeout(<span class="number">20000</span>);<span class="comment">//读取数据的超时设置</span></span><br><span class="line">                    httpcon.setConnectTimeout(<span class="number">20000</span>);<span class="comment">//连接的超时设置</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (startPos &lt; endPos) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//向服务器请求指定区间段的数据，这是实现断点续传的根本。</span></span><br><span class="line">                        httpcon.setRequestProperty(<span class="string">"Range"</span>, <span class="string">"bytes="</span> + startPos + <span class="string">"-"</span> + endPos);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 长度："</span> + (endPos - startPos + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        rand_file.seek(startPos);</span><br><span class="line"></span><br><span class="line">                        is = httpcon.getInputStream();<span class="comment">//获取服务器返回的资源流</span></span><br><span class="line">                        <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> ((length = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            count += length;</span><br><span class="line">                            rand_file.write(buf, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//不断更新每个线程下载资源的起始位置，并写入临时文件</span></span><br><span class="line">                            startPos += length;</span><br><span class="line">                            rand_file_tmp.seek(id * <span class="number">8</span>);</span><br><span class="line">                            rand_file_tmp.writeLong(startPos);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + id</span><br><span class="line">                                + <span class="string">" 总下载大小: "</span> + count);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//关闭流</span></span><br><span class="line">                        is.close();</span><br><span class="line">                        httpcon.disconnect();</span><br><span class="line">                        rand_file.close();</span><br><span class="line">                        rand_file_tmp.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 下载完成"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            is.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line">        String url = <span class="string">"http://blog.default.nanwulife.com/pexels-photo-640947.jpeg"</span>;</span><br><span class="line"></span><br><span class="line">        Downloader load = <span class="keyword">new</span> Downloader(url, threadNum);</span><br><span class="line">        load.download();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究多线程的断点续传下载。断点续传的原理其实很简单，就是在下载时将下载进度保存到一个临时文件中，如果下载过程遇到什么意外中断了，下次下载同一个文件时就可以从临时文件中读取到上次下载发生中断时的进度，然后从这个进度开始继续下载。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="断点续传" scheme="http://yoursite.com/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池与Executor框架</title>
    <link href="http://yoursite.com/2019/02/10/Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/02/10/Executor框架/</id>
    <published>2019-02-10T10:27:00.000Z</published>
    <updated>2019-02-15T12:25:56.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，使用线程池可以进行统一分配、调优和监控。</li></ul><a id="more"></a><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p><img src="http://blog.default.nanwulife.com/1787733-248f411a83669fff.webp" alt=""></p><ol><li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（这一步需获取全局锁）。</li><li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>如果队列已满，则创建新的线程来处理任务（这一步需获取全局锁）。</li><li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并使用相关饱和策略进行处理，默认是直接抛出异常。</li></ol><p>之所以采用这个步骤，是因为在执行<code>execute()</code>方法时，尽可能地避免获取全局锁。在线程池完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor框架内部使用了线程池机制，它在<code>java.util.cocurrent</code>包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，通过<code>Executor</code>来启动线程比使用<code>Thread</code>的<code>start()</code>方法更易管理且效率更好。</p><h2 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h2><p><img src="http://blog.default.nanwulife.com/6021163-4e29a753826e7d23.webp" alt=""></p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>是Executor框架的最核心的类，是线程池的实现类，用来执行被提交的任务，通常使用工厂类<code>Executors</code>来创建，有以下三种类型：</p><ul><li><code>FixedThreadPool</code>：线程数固定。适用于为了满足资源管理而需要限制线程数的场景，适用于负载比较重的服务器。</li><li><code>SingleThreadExecutor</code>：只有一个线程。适用于需要保证顺序地执行各个任务，并且在任意时间点不会有多个线程是活动的场景。</li><li><code>CachedThreadPool</code>：根据需要创建新线程。空闲线程等待新任务超过60秒就会被终止。适用于执行很多短期异步任务的小程序，或者是负载较轻的服务器。</li></ul><p><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列。<code>CachedThreadPool</code>使用没有容量的<code>SynchronousQueue</code>作为线程池的工作队列。</p><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>，主要用来在给定的延迟之后运行任务，或者定期执行任务。<code>ScheduledThreadPoolExecutor</code>的功能与<code>Timer</code>类似，但<code>ScheduledThreadPoolExecutor</code>功能更强大、更灵活，<code>Timer</code>对应的是单个后台线程，而<code>ScheduledThreadPoolExecutor</code>可以在构造函数中指定多个对应的后台线程数。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果。<code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。可以把<code>FutureTask</code>交给<code>Executor</code>执行，也可以通过<code>submit()</code>方法返回一个<code>FutureTask</code>，然后执行<code>FutureTask.get()</code>方法。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用<code>execute()</code>方法提交任务，但是<code>execute()</code>方法没有返回值，所以无法判断任务是否被线程池执行成功。也可以使用<code>submit()</code>方法来提交任务，它会返回一个<code>future</code>，可以通过这个<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞直到任务完成。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的<code>shutdown()</code>或<code>shutdownNow()</code>方法来关闭线程池。</p><ul><li><code>shutdown()</code>先将线程池状态置为<code>SHUTDOWN</code>，停止接受外部提交的新任务，而等到正在执行的任务以及队列中等待的任务执行完才真正停止。</li><li><code>shutdownNow()</code>先将线程池状态置为<code>STOP</code>，停止接受外部提交的新任务，忽略队列里等待的任务，使用<code>interrupt()</code>方法尝试将正在跑的任务中断，然后返回未执行的任务列表。</li></ul><p>注意，如果线程中没有<code>sleep</code>、<code>wait</code>、<code>Condition</code>等应用，<code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>shutdownNow()</code>并不代表线程池一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/java-threadpool/" target="_blank" rel="noopener">聊聊并发（三）Java线程池的分析和使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用线程池&quot;&gt;&lt;a href=&quot;#为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池&quot;&gt;&lt;/a&gt;为什么要使用线程池&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性：线程是稀缺资源，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Executor" scheme="http://yoursite.com/tags/Executor/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的并发工具类</title>
    <link href="http://yoursite.com/2019/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/10/Java中的并发工具类/</id>
    <published>2019-02-10T06:27:00.000Z</published>
    <updated>2019-02-10T09:00:32.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p><code>CountDownLatch</code>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p><a id="more"></a><p><code>CountDownLatch</code>是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过创建一个初始计数为1的<code>CountDownLatch</code>，并让所有线程都在这个锁上等待，随后调用<code>countDown()</code>方法来同时启动多个线程。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>同步屏障<code>CyclicBarrier</code>可以让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><p><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。所以<code>CyclicBarrier</code>能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<code>Semaphore</code>的构造方法接受一个整型的数字，表示可用的许可证数量，线程使用<code>acquire()</code>方法获取一个许可证，如果没有许可证能够获得则被阻塞，使用完后调用<code>release()</code>方法归还许可证。还可以使用<code>tryAcquire()</code>方法尝试获取许可证，若获取成功，则立即返回true，若获取失败，则立即返回false。</p><p><code>Semaphore</code>可以用于流量控制，特别是公用资源有限的应用场景，比如数据库连接。如果线程数有几十个，而数据库的连接只有十个，那么就可以使用<code>Semaphore</code>控制同时获取数据库连接的个数。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java并发编程的艺术》</li><li><a href="http://www.importnew.com/15731.html" target="_blank" rel="noopener">什么时候使用CountDownLatch</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CountdownLatch&quot;&gt;&lt;a href=&quot;#CountdownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountdownLatch&quot;&gt;&lt;/a&gt;CountdownLatch&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
