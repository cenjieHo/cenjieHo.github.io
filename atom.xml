<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-04T03:09:32.260Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>汇编程序设计练习</title>
    <link href="http://yoursite.com/2019/07/04/%E6%B1%87%E7%BC%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/07/04/汇编程序设计练习/</id>
    <published>2019-07-04T03:09:19.000Z</published>
    <updated>2019-07-04T03:09:32.260Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h4 id="把内存中首地址为MEM1的200个字节送到首地址为MEM2的区域中"><a href="#把内存中首地址为MEM1的200个字节送到首地址为MEM2的区域中" class="headerlink" title="把内存中首地址为MEM1的200个字节送到首地址为MEM2的区域中"></a>把内存中首地址为<code>MEM1</code>的200个字节送到首地址为<code>MEM2</code>的区域中</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">SI</span>, OFFSET MEM1</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DI</span>, OFFSET MEM2</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">200</span></span><br><span class="line"><span class="symbol">NEXT:</span>   <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]</span><br><span class="line"><span class="keyword">MOV</span> [<span class="built_in">DI</span>], <span class="built_in">AL</span></span><br><span class="line"><span class="keyword">INC</span> <span class="built_in">SI</span></span><br><span class="line"><span class="keyword">INC</span> <span class="built_in">DI</span></span><br><span class="line"><span class="keyword">DEC</span> <span class="built_in">CX</span></span><br><span class="line"><span class="keyword">JNZ</span> NEXT    <span class="comment">;若循环次数（CX）不为0，则转移到 NEXT 标号处</span></span><br><span class="line"><span class="keyword">HLT</span>         <span class="comment">;停止</span></span><br></pre></td></tr></table></figure><h4 id="x、y、z均为32位数，分别存放在地址为X，X-2；Y，Y-2；Z，Z-2的存储单元中，用指令序列实现W-lt-x-y-24-z，结果放在W，W-2单元中"><a href="#x、y、z均为32位数，分别存放在地址为X，X-2；Y，Y-2；Z，Z-2的存储单元中，用指令序列实现W-lt-x-y-24-z，结果放在W，W-2单元中" class="headerlink" title="x、y、z均为32位数，分别存放在地址为X，X+2；Y，Y+2；Z，Z+2的存储单元中，用指令序列实现W&lt;-x+y+24-z，结果放在W，W+2单元中"></a>x、y、z均为32位数，分别存放在地址为X，X+2；Y，Y+2；Z，Z+2的存储单元中，用指令序列实现W&lt;-x+y+24-z，结果放在W，W+2单元中</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>, X</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DX</span>, X+<span class="number">2</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">AX</span>, Y</span><br><span class="line"><span class="keyword">ADC</span> <span class="built_in">DX</span>, Y+<span class="number">2</span>    <span class="comment">;X+Y</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">AX</span>, <span class="number">24</span></span><br><span class="line"><span class="keyword">ADC</span> <span class="built_in">DX</span>, <span class="number">0</span>      <span class="comment">;x+y+24</span></span><br><span class="line"><span class="keyword">SUB</span> <span class="built_in">AX</span>, Z</span><br><span class="line"><span class="keyword">SBB</span> <span class="built_in">DX</span>, Z+<span class="number">2</span>    <span class="comment">;x+y+24-z</span></span><br><span class="line"><span class="keyword">MOV</span> W, <span class="built_in">AX</span></span><br><span class="line"><span class="keyword">MOV</span> W+<span class="number">2</span>, <span class="built_in">DX</span>    <span class="comment">;结果存入W, W+2单元中</span></span><br></pre></td></tr></table></figure><h4 id="比较AL、BL、CL中带符号数的大小，将最小数放在AL中"><a href="#比较AL、BL、CL中带符号数的大小，将最小数放在AL中" class="headerlink" title="比较AL、BL、CL中带符号数的大小，将最小数放在AL中"></a>比较AL、BL、CL中带符号数的大小，将最小数放在AL中</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">AL</span>, <span class="built_in">BL</span></span><br><span class="line"><span class="keyword">JLE</span> BBB</span><br><span class="line"><span class="keyword">XCHG</span> <span class="built_in">AL</span>, <span class="built_in">BL</span></span><br><span class="line"><span class="symbol">BBB:</span><span class="keyword">CMP</span> <span class="built_in">AL</span>, <span class="built_in">CL</span></span><br><span class="line"><span class="keyword">JLE</span> CCC</span><br><span class="line"><span class="keyword">XCHG</span> <span class="built_in">AL</span>, <span class="built_in">CL</span></span><br><span class="line"><span class="symbol">CCC:</span> <span class="keyword">HLT</span></span><br></pre></td></tr></table></figure><h4 id="用除法指令计算-7FA2H-03DDH"><a href="#用除法指令计算-7FA2H-03DDH" class="headerlink" title="用除法指令计算 7FA2H / 03DDH"></a>用除法指令计算 7FA2H / 03DDH</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>, <span class="number">7FA2H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">BX</span>, <span class="number">03DDH</span></span><br><span class="line"><span class="keyword">CWD</span>       <span class="comment">;DX:AX=00007FA2H</span></span><br><span class="line"><span class="keyword">DIV</span> <span class="built_in">BX</span>    <span class="comment">;商=AX=0021H, 余数=DX=0025H</span></span><br></pre></td></tr></table></figure><h4 id="34H-25H"><a href="#34H-25H" class="headerlink" title="34H / 25H"></a>34H / 25H</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="number">34H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">BL</span>, <span class="number">25H</span></span><br><span class="line"><span class="keyword">CBW</span></span><br><span class="line"><span class="keyword">IDIV</span> <span class="built_in">BL</span></span><br></pre></td></tr></table></figure><h4 id="从4000H开始的单元中放有32个有符号数，要求统计出其中负数的个数，并将统计结果放入BUFFER字单元中"><a href="#从4000H开始的单元中放有32个有符号数，要求统计出其中负数的个数，并将统计结果放入BUFFER字单元中" class="headerlink" title="从4000H开始的单元中放有32个有符号数，要求统计出其中负数的个数，并将统计结果放入BUFFER字单元中"></a>从4000H开始的单元中放有32个有符号数，要求统计出其中负数的个数，并将统计结果放入BUFFER字单元中</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">XOR</span> <span class="built_in">DX</span>, <span class="built_in">DX</span>    <span class="comment">;清DX内容</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">SI</span>, <span class="number">4000H</span> <span class="comment">;SI&lt;-起始地址</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">20H</span>   <span class="comment">;CX&lt;-统计次数</span></span><br><span class="line"><span class="symbol">AGAIN:</span>  <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]  <span class="comment">;AL&lt;-取第一个数</span></span><br><span class="line"><span class="keyword">INC</span> <span class="built_in">SI</span>        <span class="comment">;地址指针加一</span></span><br><span class="line"><span class="keyword">TEST</span> <span class="built_in">AL</span>, <span class="number">80H</span></span><br><span class="line"><span class="keyword">JZ</span> NEXT       <span class="comment">;不为负数，跳转</span></span><br><span class="line"><span class="keyword">INC</span> <span class="built_in">DX</span>        <span class="comment">;为负数</span></span><br><span class="line"><span class="symbol">NEXT:</span>   <span class="keyword">DEC</span> <span class="built_in">CX</span></span><br><span class="line"><span class="keyword">JNZ</span> AGAIN     <span class="comment">;若CX!=0则继续检测下一个</span></span><br><span class="line"><span class="keyword">MOV</span> BUFFER, <span class="built_in">DX</span>  <span class="comment">;统计结果送BUFFER单元</span></span><br></pre></td></tr></table></figure><h4 id="给1A000H开始的256个内存单元均减去1，若发现某个单元减为0则立即退出循环，其后的单元不再减一"><a href="#给1A000H开始的256个内存单元均减去1，若发现某个单元减为0则立即退出循环，其后的单元不再减一" class="headerlink" title="给1A000H开始的256个内存单元均减去1，若发现某个单元减为0则立即退出循环，其后的单元不再减一"></a>给1A000H开始的256个内存单元均减去1，若发现某个单元减为0则立即退出循环，其后的单元不再减一</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>, <span class="number">1A00H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DI</span>, -<span class="number">1</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">256</span></span><br><span class="line"><span class="symbol">GOON:</span> <span class="keyword">INC</span> <span class="built_in">DI</span></span><br><span class="line"><span class="keyword">DEC</span> <span class="built_in">BYTE</span> <span class="built_in">PTR</span>[<span class="built_in">DI</span>]</span><br><span class="line"><span class="keyword">LOOPNZ</span> GOON</span><br><span class="line"><span class="keyword">HLT</span></span><br></pre></td></tr></table></figure><h4 id="在8000H开始的长度为1000字节的字符串中查找’S’，若找到，把其偏移地址记录在ADDR中，否则ADDR单元置为0FFFFH"><a href="#在8000H开始的长度为1000字节的字符串中查找’S’，若找到，把其偏移地址记录在ADDR中，否则ADDR单元置为0FFFFH" class="headerlink" title="在8000H开始的长度为1000字节的字符串中查找’S’，若找到，把其偏移地址记录在ADDR中，否则ADDR单元置为0FFFFH"></a>在8000H开始的长度为1000字节的字符串中查找’S’，若找到，把其偏移地址记录在ADDR中，否则ADDR单元置为0FFFFH</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">DI</span>, <span class="number">8000H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">1000</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="string">'S'</span>    <span class="comment">;要查找的字符放在AL中</span></span><br><span class="line"><span class="keyword">MOV</span> ADDR, <span class="number">0FFFFH</span></span><br><span class="line"><span class="symbol">GOON:</span>   <span class="keyword">SCASB</span> </span><br><span class="line">        <span class="keyword">LOOPNZ</span> GOON    <span class="comment">;ZF=0则继续扫描</span></span><br><span class="line">        <span class="keyword">JNZ</span> DONE</span><br><span class="line">        <span class="keyword">DEC</span> <span class="built_in">DI</span></span><br><span class="line">        <span class="keyword">MOV</span> ADDR, <span class="built_in">DI</span></span><br><span class="line"><span class="symbol">DONE:</span> <span class="keyword">HLT</span></span><br></pre></td></tr></table></figure><h4 id="编写一个两个字相加的程序"><a href="#编写一个两个字相加的程序" class="headerlink" title="编写一个两个字相加的程序"></a>编写一个两个字相加的程序</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DSEG <span class="meta">SEGMENT</span></span><br><span class="line">DATA1 <span class="built_in">DW</span> <span class="number">0F865H</span></span><br><span class="line">DATA2 <span class="built_in">DW</span> <span class="number">360CH</span></span><br><span class="line">DSEG ENDS</span><br><span class="line"></span><br><span class="line">ESEG <span class="meta">SEGMENT</span></span><br><span class="line">SUM <span class="built_in">DW</span> <span class="number">2</span> DUP(?)</span><br><span class="line">ESEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG <span class="meta">SEGMENT</span></span><br><span class="line"><span class="meta">ASSUME</span> <span class="built_in">CS</span>:CSEG, <span class="built_in">DS</span>:DSEG, <span class="built_in">ES</span>:ESEG</span><br><span class="line"><span class="symbol">START:</span>  <span class="keyword">MOV</span> <span class="built_in">AX</span>, DSEG</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>, ESEG</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">ES</span>, <span class="built_in">AX</span></span><br><span class="line"><span class="keyword">LEA</span> <span class="built_in">SI</span>, SUM    <span class="comment">;存放结果的偏移地址送SI</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AX</span>, DATA1  <span class="comment">;取被加数</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">AX</span>, DATA2  <span class="comment">;相加</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">ES</span>:[<span class="built_in">SI</span>], <span class="built_in">AX</span><span class="comment">;和送附加段的SUM单元中</span></span><br><span class="line"><span class="keyword">HLT</span></span><br><span class="line">CSEG EMDS</span><br><span class="line">END START    <span class="comment">;源程序结束，起始运行地址为START</span></span><br></pre></td></tr></table></figure><h4 id="编写一个10ms延时的子程序"><a href="#编写一个10ms延时的子程序" class="headerlink" title="编写一个10ms延时的子程序"></a>编写一个10ms延时的子程序</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">DELAY PROC</span><br><span class="line"><span class="keyword">PUSH</span> <span class="built_in">BX</span>    <span class="comment">;保护BX原来的内容</span></span><br><span class="line"><span class="keyword">PUSH</span> <span class="built_in">CX</span>    <span class="comment">;保护CX原来的内容</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">BL</span>, <span class="number">2</span>  <span class="comment">;外循环次数</span></span><br><span class="line"><span class="symbol">  NEXT:</span> <span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">4167</span>    <span class="comment">;内循环次数（实现延时5ms）</span></span><br><span class="line"><span class="symbol">  W10MS:</span><span class="keyword">LOOP</span> W10MS      <span class="comment">;CX!=0则循环</span></span><br><span class="line">        <span class="keyword">DEC</span> <span class="built_in">BL</span>          <span class="comment">;修改外循环计数值</span></span><br><span class="line">        <span class="keyword">JNZ</span> NEXT        <span class="comment">;BX!=0则进行第二轮循环</span></span><br><span class="line">        <span class="keyword">POP</span> <span class="built_in">CX</span><span class="comment">;         ;恢复CX原来的内容</span></span><br><span class="line">        <span class="keyword">POP</span> <span class="built_in">BX</span><span class="comment">;         ;恢复BX原来的内容</span></span><br><span class="line">        <span class="keyword">RET</span></span><br><span class="line">DELAY ENDP   <span class="comment">;过程结束</span></span><br></pre></td></tr></table></figure><h4 id="编写S-86H-34H-21H的程序，式中的3个数均为无符号数"><a href="#编写S-86H-34H-21H的程序，式中的3个数均为无符号数" class="headerlink" title="编写S = 86H * 34H - 21H的程序，式中的3个数均为无符号数"></a>编写S = 86H * 34H - 21H的程序，式中的3个数均为无符号数</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">NUM <span class="built_in">DB</span> <span class="number">86H</span>, <span class="number">34H</span>, <span class="number">21H</span>    <span class="comment">;定义源操作数</span></span><br><span class="line">RESULT <span class="built_in">DW</span> ?</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line"><span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE, <span class="built_in">DS</span>:DATA</span><br><span class="line"><span class="symbol">START:</span> <span class="keyword">MOV</span> <span class="built_in">AX</span>, DATA</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line">   <span class="keyword">LEA</span> <span class="built_in">SI</span>, NUM</span><br><span class="line">   <span class="keyword">LEA</span> <span class="built_in">DI</span>, RESULT</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">SI</span>]    <span class="comment">;AL&lt;-86H</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">BL</span>, [<span class="built_in">SI</span>+<span class="number">1</span>]  <span class="comment">;BL&lt;-34H</span></span><br><span class="line">   <span class="keyword">MUL</span> <span class="built_in">BL</span>          <span class="comment">;AX&lt;-86H * 34H</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">BL</span>, [<span class="built_in">SI</span>+<span class="number">2</span>]  <span class="comment">;BL&lt;-21H</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="number">BH</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">SUB</span> <span class="built_in">AX</span>, <span class="built_in">BX</span>      <span class="comment">;AX&lt;-86H * 34H - 21H</span></span><br><span class="line">   <span class="keyword">MOV</span> [<span class="built_in">DI</span>], <span class="built_in">AX</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="number">AH</span>, <span class="number">4CH</span>     <span class="comment">;返回DOS</span></span><br><span class="line">   <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line">CODE ENDS</span><br><span class="line">   END START</span><br></pre></td></tr></table></figure><h4 id="内存自TABLE开始的连续16个单元中存放着0-15的平方值（称平方表），查表求DATA中任意数X（0-lt-X-lt-15）的平方值，并将结果放RESULT中"><a href="#内存自TABLE开始的连续16个单元中存放着0-15的平方值（称平方表），查表求DATA中任意数X（0-lt-X-lt-15）的平方值，并将结果放RESULT中" class="headerlink" title="内存自TABLE开始的连续16个单元中存放着0-15的平方值（称平方表），查表求DATA中任意数X（0&lt;=X&lt;=15）的平方值，并将结果放RESULT中"></a>内存自TABLE开始的连续16个单元中存放着0-15的平方值（称平方表），查表求DATA中任意数X（0&lt;=X&lt;=15）的平方值，并将结果放RESULT中</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DSEG <span class="meta">SEGMENT</span></span><br><span class="line">TABLE <span class="built_in">DB</span> <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">100</span>, <span class="number">121</span>, <span class="number">144</span>, <span class="number">169</span>, <span class="number">196</span>, <span class="number">225</span>  <span class="comment">;定义平方表</span></span><br><span class="line">DATA <span class="built_in">DB</span> ?</span><br><span class="line">RESULT <span class="built_in">DB</span> ?</span><br><span class="line">DSEG ENDS</span><br><span class="line"></span><br><span class="line">SSEG <span class="meta">SEGMENT</span> STACK <span class="string">'STACK'</span></span><br><span class="line"><span class="built_in">DB</span> <span class="number">100</span> DUP(?)</span><br><span class="line">SSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG <span class="meta">SEGMENT</span></span><br><span class="line">   <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CSEG, <span class="built_in">DS</span>:DSEG, <span class="built_in">SS</span>:SSEG</span><br><span class="line"><span class="symbol">   BEGIN:</span> <span class="keyword">MOV</span> <span class="built_in">AX</span>, DSEG</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">AX</span>, SSEG</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">SS</span>, <span class="built_in">AX</span></span><br><span class="line">   <span class="keyword">LEA</span> <span class="built_in">BX</span>, TABLE</span><br><span class="line">   <span class="keyword">MOV</span> <span class="number">AH</span>, <span class="number">0</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">AL</span>, DATA    <span class="comment">;取待查数</span></span><br><span class="line">   <span class="keyword">ADD</span> <span class="built_in">BX</span>, <span class="built_in">AX</span>      <span class="comment">;查表</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">AL</span>, [<span class="built_in">BX</span>]</span><br><span class="line">   <span class="keyword">MOV</span> RESULT, <span class="built_in">AL</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="number">AH</span>, <span class="number">4CH</span></span><br><span class="line">   <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line">CSEG ENDS</span><br><span class="line">   END BEGIN</span><br></pre></td></tr></table></figure><h4 id="编写程序，将数据区中以BUFFER为首地址的100个字节单元消0"><a href="#编写程序，将数据区中以BUFFER为首地址的100个字节单元消0" class="headerlink" title="编写程序，将数据区中以BUFFER为首地址的100个字节单元消0"></a>编写程序，将数据区中以BUFFER为首地址的100个字节单元消0</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DATA <span class="meta">SEGMENT</span></span><br><span class="line">BUFFER <span class="built_in">DB</span> <span class="number">100</span> DUP(?)</span><br><span class="line">COUNT <span class="built_in">DW</span> <span class="number">100</span></span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">STACK <span class="meta">SEGMENT</span></span><br><span class="line"><span class="built_in">DW</span> <span class="number">32</span> DUP(?)</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">CODE <span class="meta">SEGMENT</span></span><br><span class="line">   <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CODE, <span class="built_in">DS</span>:DATA, <span class="built_in">SS</span>:STACK</span><br><span class="line"><span class="symbol">START:</span> <span class="keyword">MOV</span> <span class="built_in">AX</span>, DATA</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">AX</span>, STACK</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">SS</span>, <span class="built_in">AX</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">CX</span>, COUNT</span><br><span class="line">   <span class="keyword">LEA</span> <span class="built_in">BX</span>, BUFFER</span><br><span class="line">   <span class="keyword">ADD</span> <span class="built_in">CX</span>, <span class="built_in">BX</span></span><br><span class="line"><span class="symbol">AGAIN:</span> <span class="keyword">MOV</span> <span class="built_in">BYTE</span> <span class="built_in">PTR</span>[<span class="built_in">BX</span>], <span class="number">0</span></span><br><span class="line">   <span class="keyword">INC</span> <span class="built_in">BX</span></span><br><span class="line">   <span class="keyword">CMP</span> <span class="built_in">BX</span>, <span class="built_in">CX</span></span><br><span class="line">   <span class="keyword">JB</span> AGAIN</span><br><span class="line">   <span class="keyword">MOV</span> <span class="number">AH</span>, <span class="number">4CH</span></span><br><span class="line">   <span class="keyword">INT</span> <span class="number">21H</span></span><br><span class="line">CODE ENDS</span><br><span class="line">   END START</span><br></pre></td></tr></table></figure><h4 id="把从MEM单元开始的100个16位无符号数按从大到小的顺序排列"><a href="#把从MEM单元开始的100个16位无符号数按从大到小的顺序排列" class="headerlink" title="把从MEM单元开始的100个16位无符号数按从大到小的顺序排列"></a>把从MEM单元开始的100个16位无符号数按从大到小的顺序排列</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DSEG <span class="meta">SEGMENT</span></span><br><span class="line">MEM <span class="built_in">DW</span> <span class="number">100</span> DUP(?)</span><br><span class="line">DSEG ENDS</span><br><span class="line"></span><br><span class="line">CSEG <span class="meta">SEGMENT</span></span><br><span class="line">   <span class="meta">ASSUME</span> <span class="built_in">CS</span>:CSEG, <span class="built_in">DS</span>:DSEG</span><br><span class="line"><span class="symbol">START:</span> <span class="keyword">MOV</span> <span class="built_in">AX</span>, DSEG</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">DS</span>, <span class="built_in">AX</span></span><br><span class="line">   <span class="keyword">LEA</span> <span class="built_in">DI</span>, MEM</span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">BL</span>, <span class="number">99</span></span><br><span class="line"><span class="comment">;以下为外循环开始</span></span><br><span class="line"><span class="symbol">NEXT1:</span> <span class="keyword">MOV</span> <span class="built_in">SI</span>, <span class="built_in">DI</span>    <span class="comment">;SI指向当前要比较的数</span></span><br><span class="line">   <span class="keyword">MOV</span> <span class="built_in">CL</span>, <span class="built_in">BL</span>    <span class="comment">;CL为内循环计数器</span></span><br><span class="line"><span class="comment">;以下为内循环开始</span></span><br><span class="line"><span class="symbol">NEXT2:</span> <span class="keyword">MOV</span> <span class="built_in">AX</span>, [<span class="built_in">SI</span>]  <span class="comment">;取第一个数</span></span><br><span class="line">       <span class="keyword">ADD</span> <span class="built_in">SI</span>, <span class="number">2</span>     <span class="comment">;指向下一个数</span></span><br><span class="line">       <span class="keyword">CMP</span> <span class="built_in">AX</span>, [<span class="built_in">SI</span>]</span><br><span class="line">       <span class="keyword">JG</span> NEXT3      <span class="comment">;若大于，则不交换</span></span><br><span class="line">       <span class="keyword">MOV</span> <span class="built_in">DX</span>, [<span class="built_in">SI</span>]  <span class="comment">;以下三条指令为交换</span></span><br><span class="line">       <span class="keyword">MOV</span> [<span class="built_in">SI</span>-<span class="number">2</span>], <span class="built_in">DX</span></span><br><span class="line">       <span class="keyword">MOV</span> [<span class="built_in">SI</span>], <span class="built_in">AX</span></span><br><span class="line"><span class="symbol">NEXT3:</span> <span class="keyword">DEC</span> <span class="built_in">CL</span></span><br><span class="line">   <span class="keyword">JNZ</span> NEXT2     <span class="comment">;继续内循环</span></span><br><span class="line">   <span class="keyword">DEC</span> <span class="built_in">BL</span></span><br><span class="line">   <span class="keyword">JNZ</span> NEXT1<span class="comment">;    ;继续外循环</span></span><br></pre></td></tr></table></figure><h4 id="在ES段的偏移1000H开始处存有10个ASCII码，搜索‘E’"><a href="#在ES段的偏移1000H开始处存有10个ASCII码，搜索‘E’" class="headerlink" title="在ES段的偏移1000H开始处存有10个ASCII码，搜索‘E’"></a>在ES段的偏移1000H开始处存有10个ASCII码，搜索‘E’</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">DI</span>, <span class="number">1000H</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">0AH</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">AL</span>, <span class="string">'E'</span></span><br><span class="line"><span class="keyword">CLD</span>          <span class="comment">;从低地址到高地址搜索</span></span><br><span class="line"><span class="keyword">REPNZ</span> <span class="keyword">SCASB</span>  <span class="comment">;若未找到，继续搜索</span></span><br></pre></td></tr></table></figure><h4 id="用串传送指令实现MEM1为起始地址到MEM2的200个字节的数据传送"><a href="#用串传送指令实现MEM1为起始地址到MEM2的200个字节的数据传送" class="headerlink" title="用串传送指令实现MEM1为起始地址到MEM2的200个字节的数据传送"></a>用串传送指令实现MEM1为起始地址到MEM2的200个字节的数据传送</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LEA</span> <span class="built_in">SI</span>, MEM1</span><br><span class="line"><span class="keyword">LEA</span> <span class="built_in">DI</span>, MEM2</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">CX</span>, <span class="number">200</span></span><br><span class="line"><span class="keyword">CLD</span></span><br><span class="line"><span class="keyword">REP</span> <span class="keyword">MOVSB</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h4 id=&quot;把内存中首地址为MEM1的200个字节送到首地址为MEM2的区域中&quot;&gt;&lt;a href=&quot;#把内存中首地址为MEM1的200个字节送到首地址为MEM2的区域中&quot; class=&quot;headerlink&quot; title=&quot;把内存中首地址为MEM1的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于Java和Python的一些思考</title>
    <link href="http://yoursite.com/2019/05/30/%E5%85%B3%E4%BA%8EJava%E5%92%8CPython%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/05/30/关于Java和Python的一些思考/</id>
    <published>2019-05-30T11:37:00.000Z</published>
    <updated>2019-05-30T12:28:58.093Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近实习在做的一些项目都是用Python来写的，虽然在之前就有学习过Python的语法，但真正用到的机会很少，而这次通过项目刚好让我对Python有了更进一步的认识，并且在此总结一下Python与之前用的比较多的Java的一些区别。</p><h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>Python与Java很大的一个区别在于Java必须在第一次声明变量时指定其类型，也就是所谓的静态类型，而Python则不一样，Python可以动态改变变量的类型。虽然Python的这个特性显得十分灵活，并且某些场景下可能开发效率更高一些，但稍不注意的话就有可能出错，在写代码时要更加注意。</p><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>Python不像很多语言使用花括号定义函数或类，而是使用的缩进将代码分割成块，使得代码可读性更高一些。</p><h2 id="GIL"><a href="#GIL" class="headerlink" title="GIL"></a>GIL</h2><p>因为在项目中有许多要异步执行的任务，如果不了解Python的话，可能就会想到用多线程来解决问题，但实际上，Python中并不存在真正意义上的多线程，原因就是GIL的存在。GIL即全局解释器锁，Python的每个线程运行时首先要获得该锁，这也就意味着任何时刻仅有一个线程在执行，无法利用到多核的优势，使得多线程的效率甚至还不如单线程。但这也并非绝对的，在I/O操作或别的一些情况下，线程会主动释放GIL，这样别的线程就可以继续工作了，而如果是想完成一些CPU密集的任务的话，就只能通过进程或协程来解决了。</p><h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>不像Java使用的可达性分析算法，Python中的垃圾收集是使用的引用计数法，这也就意味着会有循环引用的问题。比如说，在以下这个代码中：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        c1=ClassA()</span><br><span class="line">        c2=ClassA()</span><br><span class="line">        c1.t=c2</span><br><span class="line">        c2.t=c1</span><br><span class="line">        <span class="keyword">del</span> c1</span><br><span class="line">        <span class="keyword">del</span> c2</span><br></pre></td></tr></table></figure></p><p>在执行完上面的代码后，两个对象的引用计数都为1而非0，虽然它们都应该要被回收销毁的，但由于存在循环引用，所以不会被回收掉，也就导致了内存泄露。要解决这个问题，可以使用gc模块。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近实习在做的一些项目都是用Python来写的，虽然在之前就有学习过Python的语法，但真正用到的机会很少，而这次通过项目刚好让我对Pyt
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>常见查找算法之跳跃表</title>
    <link href="http://yoursite.com/2019/05/28/%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/05/28/常见查找算法之跳跃表/</id>
    <published>2019-05-28T12:06:00.000Z</published>
    <updated>2019-05-28T23:57:04.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p><p>跳跃表支持平均O(logN)和最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。</p><h2 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h2><p>Redis的跳跃表由<code>zskiplistNode</code>和<code>zskiplist</code>两个结构定义，其中<code>zskiplistNode</code>结构用于表示跳跃表节点，而<code>zskiplist</code>结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p><p><img src="http://blog.default.nanwulife.com/graphviz-8fc5de396a5b52c3d0b1991a1e09558ad055dd86.png" alt=""></p><p>图5-1展示了一个跳跃表示例，位于图片最左边的是<code>zskiplist</code>结构，该结构包含以下属性：</p><ul><li><code>header</code>：指向跳跃表的表头节点。</li><li><code>tail</code>：指向跳跃表的表尾节点。</li><li><code>level</code>：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li><li><code>length</code>：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li></ul><p>位于<code>zskiplist</code>结构右方的是四个<code>zskiplistNode</code>结构，该结构包含以下属性：</p><ul><li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层，L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。每次创建一个新跳跃表节点的时候， 程序都根据幂次定律（power law，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为层的高度。跨度是用来计算排位（rank）的，在查找某个节点的过程中，将沿途访问过的所有层的跨度累计起来，得到的结果就是目标节点在跳跃表中的排位。</li><li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。跟可以一次跳过多个节点的前进指针不同，因为每个节点只有一个后退指针，所以每次只能后退至前一个节点。</li><li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li><li>成员对象（obj）：各个节点中的 o1、o2 和 o3 是节点所保存的成员对象。分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面，而成员对象较大的节点则会排在后面。</li></ul><p>注意表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到，所以图中省略了这些部分，只显示了表头节点的各个层。</p><p>虽然仅靠多个跳跃表节点就可以组成一个跳跃表，但通过使用一个<code>zskiplist</code>结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，又或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息。</p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>跳跃表的查找是从最上层的跳跃区间大的层开始的，从头结点开始和前进指针指向的节点进行比较，如果大于前进节点，则继续向前找，如果小于前进节点，则到下一层继续查找，直到找到为止。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>跳跃表的插入操作和链表的插入操作十分相似，大致过程如下：</p><ol><li>查找到需要插入的位置</li><li>申请新的结点</li><li>调整指针</li></ol><p>因为找到插入点之后，新生成节点，新节点的层的高度是随机生成的，故需要保存所有层的后继指针。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除和插入类似，大致过程如下：</p><ol><li>查找到需要删除的结点 </li><li>删除结点</li><li>调整指针</li></ol><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><ul><li>最坏时间复杂度 О(n)</li><li>平均时间复杂度 O(logn)</li></ul><h2 id="Redis中的应用"><a href="#Redis中的应用" class="headerlink" title="Redis中的应用"></a>Redis中的应用</h2><p>Redis使用跳跃表作为有序集合键的底层实现之一：如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。而之所以不使用红黑树，是因为在性能相差不大的情况下，跳跃表实现更为简单。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>跳跃表是有序集合的底层实现之一。</li><li>Redis的跳跃表实现由<code>zskiplist</code>和<code>zskiplistNode</code>两个结构组成，其中<code>zskiplist</code>用于保存跳跃表信息（比如表头节点、表尾节点、长度），而<code>zskiplistNode</code>则用于表示跳跃表节点。</li><li>每个跳跃表节点的层高都是1至32之间的随机数。</li><li>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。</li><li>跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://redisbook.com/preview/skiplist/datastruct.html" target="_blank" rel="noopener">Redis 设计与实现</a></li><li><a href="https://blog.csdn.net/yang_yulei/article/details/46275283" target="_blank" rel="noopener">查找——图文翔解SkipList（跳跃表）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。&lt;/p&gt;
&lt;p&gt;跳跃
      
    
    </summary>
    
      <category term="算法" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="跳跃表" scheme="http://yoursite.com/tags/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Drools规则引擎原理简介</title>
    <link href="http://yoursite.com/2019/05/28/Drools%E8%A7%84%E5%88%99%E5%BC%95%E6%93%8E%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/05/28/Drools规则引擎原理简介/</id>
    <published>2019-05-28T08:21:00.000Z</published>
    <updated>2019-05-28T08:43:37.699Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DRL解释执行流程"><a href="#DRL解释执行流程" class="headerlink" title="DRL解释执行流程"></a>DRL解释执行流程</h2><p>Drools 规则是在 Java 应用程序上运行的，其要执行的步骤顺序由代码确定。为了实现这一点，Drools 规则引擎将业务规则转换成执行树，如下图所示：<br><img src="http://blog.default.nanwulife.com/20170709223809798.jpg" alt=""><br>如上图所示，每个规则条件分为小块，在树结构中连接和重用。每次将数据添加到规则引擎中时，它将在与此类似的树中进行求值，并到达一个动作节点，在该节点处，它们将被标记为准备执行特定规则的数据。</p><h2 id="规则引擎工作方式"><a href="#规则引擎工作方式" class="headerlink" title="规则引擎工作方式"></a>规则引擎工作方式</h2><p>Drools规则引擎基于ReteOO算法（对面向对象系统的Rete算法进行了增强和优化的实现），它将事实（<code>Fact</code>）与规则进行匹配，以推断相应的规则结果，这个过程称之为模式匹配。</p><p><img src="http://blog.default.nanwulife.com/20170709223935035.jpg" alt=""></p><p>当我们到达一个事实（<code>Fact</code>）与规则相匹配的节点时，规则评估会将规则操作与触发数据添加到一个叫作议程（<code>Agenda</code>）的组件中，如果同一个事实（<code>Fact</code>）与多个规则相匹配，就认为这些规则是冲突的，议程（<code>Agenda</code>）使用冲突解决策略（<code>Conflict Resolution strategy</code>）管理这些冲突规则的执行顺序。整个生命周期中，规则评估与规则执行之间有着明确的分割。规则操作的执行可能会导致事实（<code>Fact</code>）的更新，从而与其它规则相匹配，导致它们的触发，称之为前向链接。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/chinrui/article/details/74906748" target="_blank" rel="noopener">Drools 简介</a></li><li><a href="https://blog.csdn.net/lfsf802/article/details/42297469" target="_blank" rel="noopener">rete算法学习</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DRL解释执行流程&quot;&gt;&lt;a href=&quot;#DRL解释执行流程&quot; class=&quot;headerlink&quot; title=&quot;DRL解释执行流程&quot;&gt;&lt;/a&gt;DRL解释执行流程&lt;/h2&gt;&lt;p&gt;Drools 规则是在 Java 应用程序上运行的，其要执行的步骤顺序由代码确定。为
      
    
    </summary>
    
    
      <category term="Drools" scheme="http://yoursite.com/tags/Drools/"/>
    
  </entry>
  
  <entry>
    <title>工厂模式与模板方法的一次实践</title>
    <link href="http://yoursite.com/2019/05/28/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E4%B8%8E%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2019/05/28/工厂模式与模板方法的一次实践/</id>
    <published>2019-05-28T06:26:00.000Z</published>
    <updated>2019-05-28T07:24:44.374Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近做的一个项目是实现一个灰度发布的逻辑，具体来说就是当某个产品更新的时候，根据不同的用户决定是否对新版本可见。该功能本身是很容易实现的，但是考虑到可扩展性的问题，引入了Drools规则引擎，并且通过一些设计模式来进一步提高它的可扩展性，以应对之后可能不断发生变化的规则。</p><h2 id="原始代码"><a href="#原始代码" class="headerlink" title="原始代码"></a>原始代码</h2><p>由于规则并不十分复杂，所以项目中将许多的校验与判断逻辑统一封装到了Fact对象中，而在.drl文件中仅仅是做一些初始化工作，例如这里的场景是给每个用户设置一个新版本可见的延迟天数，达到了这个天数才能获取新版本，那么在.drl中就是将用户与延迟天数的映射关系做初始化。因此，最开始只需要一个Fact就行了：<br><img src="http://blog.default.nanwulife.com/DelayDaysPatternReleaseFact.png" alt=""><br>在.drl文件中，初始化完成之后，仅仅需要调用这个Fact对象的<code>releaseCheck()</code>，然后就可以通过<code>isRelease()</code>方法决定是否发布新版本了。</p><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><p>由上面的简单分析可以看到，判断是否发布新版本的逻辑都封装在了<code>releaseCheck()</code>方法中，但这个方法中的许多步骤其实是冗余的，比如说参数校验、安全校验等等，如果每次增加新的Fact时都去写一模一样的重复代码，就显得十分不简洁且不利于维护了，因此，我们将该方法抽象出来，并且将其中最关键的判断逻辑<code>doReleaseCheck()</code>交由子类去实现，这样不同的Fact子类只需要实现各自的核心判断逻辑即可。此时的UML如下：<br><img src="http://blog.default.nanwulife.com/PatternReleaseFact.png" alt=""><br>除此之外，对于调用方来说，是不需要关心Fact对象的创建过程的，尤其是当参数比较复杂的情况下。这时候就可以通过工厂方法模式，将创建对象的具体过程交给工厂类来完成：<br><img src="http://blog.default.nanwulife.com/PatternReleaseFactFactory.png" alt=""><br>这样，对于调用方来说，只需要传入一个<code>UserInfo</code>对象即可，具体需要用到它的哪些属性以及属性的一些校验工作则交由工厂类来实现，调用方可以直接拿到想要的Fact对象。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过模板方法，可以在抽象父类中先定义好整个方法的框架，并且让不同的子类去实现其中的某些核心步骤，这些核心步骤在父类中是抽象的；而通过工厂方法，使得调用者不再需要关心创建对象的具体过程，将许多繁琐的工作解耦了出去，由工厂类来负责实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近做的一个项目是实现一个灰度发布的逻辑，具体来说就是当某个产品更新的时候，根据不同的用户决定是否对新版本可见。该功能本身是很容易实现的，但
      
    
    </summary>
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="工厂方法" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/"/>
    
      <category term="模板方法" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL建索引的几大原则</title>
    <link href="http://yoursite.com/2019/05/27/%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E5%87%A0%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/05/27/建索引的几大原则/</id>
    <published>2019-05-27T14:28:00.000Z</published>
    <updated>2019-05-27T14:32:17.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>b+树的数据项是复合的数据结构，比如索引为<code>(name, age, sex)</code>的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当<code>(张三, 20, F)</code>这样的数据来检索的时候，b+树会优先比较<code>name</code>来确定下一步的搜索方向，如果<code>name</code>相同再依次比较<code>age</code>和<code>sex</code>，最后得到检索的数据；但当<code>(20, F)</code>这样的没有<code>name</code>的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候<code>name</code>就是第一个比较因子，必须要先根据<code>name</code>来搜索才能知道下一步去哪里查询。比如当<code>(张三, F)</code>这样的数据来检索时，b+树可以用<code>name</code>来指定搜索方向，但下一个字段<code>age</code>的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是<code>F</code>的数据了，这个是非常重要的性质，即索引的最左前缀匹配原则。</p><h2 id="索引建议"><a href="#索引建议" class="headerlink" title="索引建议"></a>索引建议</h2><ol><li>根据最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询（<code>&gt;</code>、<code>&lt;</code>、<code>between</code>、<code>like</code>）就停止匹配，比如<code>a = 1 and b = 2 and c &gt; 3 and d = 4</code>，如果建立<code>(a, b, c, d)</code>顺序的索引，<code>d</code>是用不到索引的，如果建立<code>(a, b, d, c)</code>的索引则都可以用到，<code>a</code>、<code>b</code>、<code>d</code>的顺序可以任意调整。</li><li><code>=</code>和<code>in</code>可以乱序，比如<code>a = 1 and b = 2 and c = 3</code>建立<code>(a, b, c)</code>索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的形式。</li><li>尽量选择区分度高的列作为索引，区分度的公式是<code>count(distinct col)/count(*)</code>，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0。</li><li>索引列不能参与计算，否则将导致引擎放弃使用索引而进行全表扫描，比如<code>select id from t where num/2=100;</code>应优化成<code>select id from t where num=100*2;</code></li><li>尽量的扩展索引，不要新建索引。比如表中已经有<code>a</code>的索引，现在要加<code>(a, b)</code>的索引，那么只需要修改原来的索引即可。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html" target="_blank" rel="noopener">MySQL索引原理及慢查询优化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;最左前缀匹配原则&quot;&gt;&lt;a href=&quot;#最左前缀匹配原则&quot; class=&quot;headerlink&quot; title=&quot;最左前缀匹配原则&quot;&gt;&lt;/a&gt;最左前缀匹配原则&lt;/h2&gt;&lt;p&gt;b+树的数据项是复合的数据结构，比如索引为&lt;code&gt;(name, age, sex)&lt;/c
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB的行锁与表锁</title>
    <link href="http://yoursite.com/2019/05/27/InnoDB%E7%9A%84%E8%A1%8C%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81/"/>
    <id>http://yoursite.com/2019/05/27/InnoDB的行锁与表锁/</id>
    <published>2019-05-27T12:21:00.000Z</published>
    <updated>2019-05-27T14:29:22.094Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在数据库系统中，根据作用范围我们可以将锁分为行级锁与表级锁，下面结合InnoDB与MyISAM引擎分别介绍一下这两种锁。</p><h2 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h2><p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，但发出锁冲突的概率最高，并发度也是最低的。MyISAM就是使用的表级锁，并且因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待，所以是不会发生死锁的。</p><h2 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h2><p>行级锁是MySQL中锁定粒度最小的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突，其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</p><h2 id="InnoDB中的行锁与表锁"><a href="#InnoDB中的行锁与表锁" class="headerlink" title="InnoDB中的行锁与表锁"></a>InnoDB中的行锁与表锁</h2><p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB这种行锁实现特点意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表级锁。除此之外，虽然是访问不同行的记录，但是如果使用相同的索引键，是会出现锁冲突的。但如果MySQL认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。</p><p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p><h2 id="行级锁与死锁"><a href="#行级锁与死锁" class="headerlink" title="行级锁与死锁"></a>行级锁与死锁</h2><p>InnoDB与MyISAM不同，它是遵循的两段锁协议，是逐步获取锁的，也就有可能出现死锁问题。前面说过，InnoDB不是锁记录，而是锁索引。索引分为主键索引和非主键索引两种，如果一条SQL语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.hollischuang.com/archives/914" target="_blank" rel="noopener">MySQL中的行级锁,表级锁,页级锁</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在数据库系统中，根据作用范围我们可以将锁分为行级锁与表级锁，下面结合InnoDB与MyISAM引擎分别介绍一下这两种锁。&lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>MySQL主从复制与分库分表</title>
    <link href="http://yoursite.com/2019/05/27/MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%B8%8E%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>http://yoursite.com/2019/05/27/MySQL主从复制与读写分离/</id>
    <published>2019-05-27T09:12:38.000Z</published>
    <updated>2019-05-27T10:09:41.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog线程：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li>I/O线程：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。</li><li>SQL线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。</li></ul><p><img src="http://blog.default.nanwulife.com/master-slave.png" alt=""></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</p><p>读写分离能提高性能的原因在于</p><ul><li>主从服务器负责各自的读和写，极大程度缓解了锁的争用；</li><li>从服务器可以使用MyISAM，提升查询性能以及节约系统开销；</li><li>增加冗余，提高可用性。</li></ul><p><img src="http://blog.default.nanwulife.com/master-slave-proxy.png" alt=""></p><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><p>当在主从复制、索引优化并且升级硬件后，数据库性能依然无法达到要求，此时就可以考虑数据库的切分，根据其切分类型，可以分为两种切分方式：垂直切分和水平切分。</p><h3 id="垂直切分"><a href="#垂直切分" class="headerlink" title="垂直切分"></a>垂直切分</h3><p>垂直切分又分为垂直分库和垂直分表。</p><p>垂直分库就是根据业务耦合性，将关联度低的不同表存储在不同的数据库。做法与大系统拆分为多个小系统类似，按业务分类进行独立划分。与”微服务治理”的做法相似，每个微服务使用单独的一个数据库。（例如用户User一个库，商品Producet一个库，订单Order一个库）</p><p>垂直分表是针对列进行的。如果某个表的字段较多，可以把不常用的字段或者长度较长的字段拆分到一张新的扩展表中。在字段较多的情况下，通过“大表拆小表”，更有利于维护与开发，也能避免跨页问题（一致性、排序等问题）。MySQL底层是通过数据页存储的，一条记录占用空间过大会导致跨页，造成额外的性能开销。另外数据库以行为单位将数据加载到内存中，这样表中字段长度较短且访问频率较高，内存能加载更多的数据，命中率更高，减少了磁盘IO，从而提升了数据库性能。</p><h3 id="水平切分"><a href="#水平切分" class="headerlink" title="水平切分"></a>水平切分</h3><p>因为垂直切分并没有解决单表数据量过大的问题（1000W行切分后还是1000W行），所以当还是无法满足需求的时候，可以进行水平切分。水平切分有以下几种方式：</p><ul><li>范围切分：比如按照时间区间或ID区间来切分，这可以使得冷热数据分离。由于是顺序存储，天然适合水平扩展，但是无法解决集中写入瓶颈的问题。</li><li>Hash切分：通过Hash取模解决了数据访问不均匀的问题，但是在集群扩容的时候，数据迁移量是很大的（使用一致性hash算法能较好的避免这个问题）。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/butterfly100/p/9034281.html" target="_blank" rel="noopener">数据库分库分表思路</a></li><li><a href="http://codingcms.cn/2019/05/14/MySQL_4/" target="_blank" rel="noopener">MySQL 分库分表策略</a></li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/MySQL?id=%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6" target="_blank" rel="noopener">CS-NOTE</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主从复制&quot;&gt;&lt;a href=&quot;#主从复制&quot; class=&quot;headerlink&quot; title=&quot;主从复制&quot;&gt;&lt;/a&gt;主从复制&lt;/h2&gt;&lt;p&gt;主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;binlog线程：负责将主服
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>GET和POST的区别</title>
    <link href="http://yoursite.com/2019/05/26/PUT%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/26/PUT和POST的区别/</id>
    <published>2019-05-26T11:13:46.000Z</published>
    <updated>2019-05-26T12:06:33.206Z</updated>
    
    <content type="html"><![CDATA[<ol start="0"><li>GET用于资源获取，是安全且幂等的，安全的意思是仅仅会获取资源而不会影响资源状态，幂等则是对同一URL的多次请求应该返回同样的结果；POST主要用来传输数据，多次调用会产生多个新的资源，因此是不安全且非幂等的。</li><li>GET请求的数据会包含在URL中，而POST请求则把数据放置在HTTP请求体中。</li><li>正因为GET请求是通过URL提交数据，所以GET请求可提交的数据量跟URL的长度有关系，而POST请求从理论上讲是没有大小限制，可传较大量的数据。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol start=&quot;0&quot;&gt;
&lt;li&gt;GET用于资源获取，是安全且幂等的，安全的意思是仅仅会获取资源而不会影响资源状态，幂等则是对同一URL的多次请求应该返回同样的结果；POST主要用来传输数据，多次调用会产生多个新的资源，因此是不安全且非幂等的。&lt;/li&gt;
&lt;li&gt;GET请求的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP与UDP的区别</title>
    <link href="http://yoursite.com/2019/05/26/TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/05/26/TCP与UDP的区别/</id>
    <published>2019-05-26T11:11:00.000Z</published>
    <updated>2019-05-26T11:29:54.156Z</updated>
    
    <content type="html"><![CDATA[<p>OSI和TCP/IP模型在传输层定义了两种传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。它们的主要区别如下：</p><ol><li>面向连接与无连接</li><li>TCP保证数据可靠性，错误重发；UDP不可靠，可能丢包 </li><li>TCP保证数据顺序，UDP不保证</li><li>TCP主要提供完整性服务，UDP主要提供及时性服务</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OSI和TCP/IP模型在传输层定义了两种传输协议：TCP（传输控制协议）和 UDP（用户数据报协议）。它们的主要区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;面向连接与无连接&lt;/li&gt;
&lt;li&gt;TCP保证数据可靠性，错误重发；UDP不可靠，可能丢包 &lt;/li&gt;
&lt;li&gt;TCP保证
      
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP" scheme="http://yoursite.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>@Autowired源码分析</title>
    <link href="http://yoursite.com/2019/05/24/Autowired%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/24/Autowired源码分析/</id>
    <published>2019-05-24T06:24:18.000Z</published>
    <updated>2019-05-24T06:24:55.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h2><p><code>@Autowired</code>注解的逻辑是由<code>AutowiredAnnotationBeanPostProcessor</code>实现的，<code>AutowiredAnnotationBeanPostProcessor</code>不是一个简单的<code>BeanPostProcessor</code>，而是一个实现了多重接口的<code>BeanPostProcessor</code>，它主要实现了以下两个接口：</p><ul><li><code>InstantiationAwareBeanPostProcessor</code>：对应<code>postProcessPropertyValues()</code>方法</li><li><code>MergedBeanDefinitionPostProcessor</code>：对应<code>findAutowiringMetadata</code>方法</li></ul><p>下面我们分别来看看这两个接口的实现是如何完成<code>@Autowired</code>的逻辑的。</p><h2 id="作为MergedBeanDefinitionPostProcessor的行为"><a href="#作为MergedBeanDefinitionPostProcessor的行为" class="headerlink" title="作为MergedBeanDefinitionPostProcessor的行为"></a>作为MergedBeanDefinitionPostProcessor的行为</h2><p>首先，我们从<code>ApplicationContext</code>体系最核心的<code>refresh()</code>方法说起：<br><img src="http://blog.default.nanwulife.com/162cc16e4b0eee57.jpg" alt=""></p><p><code>refresh()</code>方法中<code>registerBeanPostProcessors(beanFactory)</code>这一行代码完成了对<code>AutowiredAnnotationBeanPostProcessor</code>的注册，当执行<code>finishBeanFactoryInitialization(beanFactory)</code>方法时，会实例化所有非懒加载的单例Bean，这个过程中会调用<code>AbstractAutowireCapableBeanFactory</code>类的<code>doCreateBean()</code>方法，其中在使用合适的实例化策略实例化完Bean之后，会有下面这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); <span class="comment">// 重点关注这一行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在<code>applyMergedBeanDefinitionPostProcessors()</code>方法中，会判断当前的<code>BeanPostProcessor</code>是否是<code>MergedBeanDefinitionPostProcessor</code>类型的，如果是的话则调用它的<code>postProcessMergedBeanDefinition()</code>方法（显然，这里会判断为真，因为<code>AutowiredAnnotationBeanPostProcessor</code>实现了<code>MergedBeanDefinitionPostProcessor</code>）。我们再来看看<code>AutowiredAnnotationBeanPostProcessor</code>对该方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey); <span class="comment">// 先从缓存中找 InjectionMetadata，诸如 @Autowire，@Inject 等</span></span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;                  <span class="comment">// 如果找不到，则从这里开始，通过分析 bean，去找到它的 InjectionMetadata</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    metadata = buildAutowiringMetadata(clazz);              <span class="comment">// 重点关注：去找，并构建其 InjectionMetadata 对象</span></span><br><span class="line">                    <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);    <span class="comment">// 如果找到了，将其放入 injectionMetadataCache 中返回；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to introspect bean class ["</span> + clazz.getName() +</span><br><span class="line">                            <span class="string">"] for autowiring metadata: could not find class that it depends on"</span>, err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>findAutowiringMetadata()</code>方法先从缓存中判断否已经存在该<code>InjectionMetadata</code>了，如果存在，且无需进行刷新，则返回；如果缓存中不存在（或者存在但需要刷新），那么就需要去构建一个<code>InjectionMetadata</code>。</p><p>接下来就是比较核心的部分了，通过<code>buildAutowiringMetadata()</code>方法构建<code>InjectionMetadata</code>对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        <span class="comment">// 1. 通过反射从 targetClass 的 field 中去找注解</span></span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field); <span class="comment">// 是否存在 @Autowired</span></span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation is not supported on static fields: "</span> + field);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 如果当前处理的属性是静态属性，则直接返回</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 2. 通过反射从 targetClass 的 method 中去找注解</span></span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 上述代码处理 bridged method 相关情况；可忽略；</span></span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); <span class="comment">// 是否存在 @Autowired</span></span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation is not supported on static methods: "</span> + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>; <span class="comment">// 如果方法是静态的，则直接返回；</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation should only be used on methods with parameters: "</span> +</span><br><span class="line">                                    method); <span class="comment">// 警告，方法参数长度为 0</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法分为两部分，通过工具类<code>ReflectionUtils</code>分别从当前Bean实例的<code>fields</code>和<code>methods</code>中去查找<code>@Autowired</code>注解：</p><ol><li>从<code>fields</code>找<code>@Autowired</code>注解，若找到，则创建<code>AutowiredFieldElement</code>实例，并放入<code>currElements</code>队列中</li><li>从<code>methods</code>中找<code>@Autowired</code>注解，若找到，则创建<code>AutowiredMethodElement</code>实例，并放入<code>currElements</code>队列中</li><li>最后，通过Bean的Class对象和<code>curreElements</code>构建<code>InjectionMetadata</code>实例并返回</li></ol><p>此时，将构建好的<code>InjectionMetadata</code>加入缓存<code>injectionMetadataCache</code>中并返回。</p><h2 id="作为InstantiationAwareBeanPostProcessor的行为"><a href="#作为InstantiationAwareBeanPostProcessor的行为" class="headerlink" title="作为InstantiationAwareBeanPostProcessor的行为"></a>作为InstantiationAwareBeanPostProcessor的行为</h2><p>同样，在<code>doCreateBean()</code>方法中执行<code>populateBean()</code>方法填充属性时，<code>populateBean()</code>方法中有如下一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);<span class="comment">// 重点关注这一行</span></span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>pvs = ibp.postProcessPropertyValues()</code>这行代码调用了<code>InstantiationAwareBeanPostProcessor</code>的接口方法，继续跟进去看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"><span class="comment">// &lt;1&gt;</span></span><br><span class="line">InjectionMetadata metadata = findAutowiringMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// &lt;2&gt;</span></span><br><span class="line">metadata.inject(bean, beanName, pvs);</span><br><span class="line">&#125; <span class="keyword">catch</span> (BeanCreationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刚实例化完Bean之后，作为<code>MergedBeanDefinitionPostProcessor</code>，已经调用过<code>findAutowiringMetadata()</code>方法，即从当前Bean对象中的属性和方法中找到了<code>@Autowired</code>注解，并将它们封装成了<code>InjectionMetadata</code>放入了缓存当中，因此，此处直接从缓存中就可以获取到该Bean对应的<code>InjectMetadata</code>。接下来就是通过<code>InjectMetadata</code>进行注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String beanName, @Nullable PropertyValues pvs)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">Collection&lt;InjectedElement&gt; checkedElements = <span class="keyword">this</span>.checkedElements;</span><br><span class="line">Collection&lt;InjectedElement&gt; elementsToIterate =</span><br><span class="line">(checkedElements != <span class="keyword">null</span> ? checkedElements : <span class="keyword">this</span>.injectedElements);</span><br><span class="line"><span class="keyword">if</span> (!elementsToIterate.isEmpty()) &#123;</span><br><span class="line"><span class="keyword">for</span> (InjectedElement element : elementsToIterate) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Processing injected element of bean '"</span> + beanName + <span class="string">"': "</span> + element);</span><br><span class="line">&#125;</span><br><span class="line">element.inject(target, beanName, pvs);<span class="comment">// 重点关注</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target, @Nullable String requestingBeanName, @Nullable PropertyValues pvs)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.isField) &#123;</span><br><span class="line">Field field = (Field) <span class="keyword">this</span>.member;</span><br><span class="line">ReflectionUtils.makeAccessible(field);</span><br><span class="line">field.set(target, getResourceToInject(target, requestingBeanName));<span class="comment">// 重点关注</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (checkPropertySkipping(pvs)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Method method = (Method) <span class="keyword">this</span>.member;</span><br><span class="line">ReflectionUtils.makeAccessible(method);</span><br><span class="line">method.invoke(target, getResourceToInject(target, requestingBeanName));<span class="comment">// 重点关注</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getTargetException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于<code>InjectionMetadata</code>对象本身包含了一系列的<code>AutowiredFieldElement</code>和<code>AutowiredMethodElement</code>，所以这里迭代<code>InjectedElement</code>并依次处理它们，而处理的逻辑都在<code>inject()</code>这一关键方法中，可以看到最终就是根据是属性还是方法来分别使用反射注入，并且对于方法而言，该方法会被调用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.shangyang.me/2017/04/05/spring-core-container-sourcecode-analysis-annotation-autowired/" target="_blank" rel="noopener">Spring Core Container 源码分析五：@Autowired</a></li><li><a href="https://juejin.im/entry/5ad3fda5f265da238d512a98" target="_blank" rel="noopener">深入理解Spring系列之十四：@Autowired是如何工作的</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AutowiredAnnotationBeanPostProcessor&quot;&gt;&lt;a href=&quot;#AutowiredAnnotationBeanPostProcessor&quot; class=&quot;headerlink&quot; title=&quot;AutowiredAnnotationB
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>破坏双亲委派模型</title>
    <link href="http://yoursite.com/2019/05/24/%E7%A0%B4%E5%9D%8F%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/05/24/破坏双亲委派模型/</id>
    <published>2019-05-24T02:34:00.000Z</published>
    <updated>2019-07-12T02:54:35.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="headerlink" title="如何破坏双亲委派模型"></a>如何破坏双亲委派模型</h2><p>双亲委派模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。考虑这么一个问题，如果基础类需要调用用户的代码该怎么办，因为根据双亲委派模型，越基础的类由越上层的加载器进行加载，但是上层的加载器并不认识用户的代码。</p><p>一个典型的例子就是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器去加载（在JDK1.3时就放进<code>rt.jar</code>）,但它需要调用由独立厂商实现并部署在应用程序的ClassPath下的JNDI接口提供者（SPI， Service Provider Interface）的代码，但启动类加载器不可能“认识“这些代码啊。因为这些类不在<code>rt.jar</code>中，但是启动类加载器又需要加载。怎么办呢？</p><p>为了解决这个问题，Java设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置。如果创建线程时未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认即是应用程序类加载器。</p><p>有了线程上下文加载器，JNDI服务使用这个线程上下文加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载的动作，这种行为实际上就是打通了双亲委派模型的层次结构来逆向使用类加载器，实际上已经违背了双亲委派模型的一般性原则。</p><h2 id="Tomcat的类加载器是怎么设计的？"><a href="#Tomcat的类加载器是怎么设计的？" class="headerlink" title="Tomcat的类加载器是怎么设计的？"></a>Tomcat的类加载器是怎么设计的？</h2><p>前面3个类加载器和默认的一致，CommonClassLoader、CatalinaClassLoader、SharedClassLoader和WebappClassLoader则是Tomcat自己定义的类加载器，它们分别加载<code>/common/*</code>、<code>/server/*</code>、<code>/shared/*</code>（在tomcat 6之后已经合并到根目录下的lib目录下）和<code>/WebApp/WEB-INF/*</code>中的Java类库。其中WebApp类加载器和Jsp类加载器通常会存在多个实例，每一个Web应用程序对应一个WebApp类加载器，每一个JSP文件对应一个Jsp类加载器。</p><p><img src="http://blog.default.nanwulife.com/4236553-89bacc3467d513f0.png" alt=""></p><ul><li><code>commonLoader</code>：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问。</li><li><code>catalinaLoader</code>：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见。</li><li><code>sharedLoader</code>：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见。</li><li><code>WebappClassLoader</code>：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见。</li></ul><p>Common ClassLoader能加载的类都可以被Catalina ClassLoader和Shared ClassLoader使用，从而实现了公有类库的共用，而Catalina ClassLoader和Shared ClassLoader自己能加载的类则与对方相互隔离，从而保证了安全性。WebApp ClassLoader可以使用Shared ClassLoader加载到的类，但各个WebApp ClassLoader实例之间相互隔离。JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的HotSwap功能，否则如果类名还是一样，旧的类加载器会直接取方法区中已经存在的，修改后的JSP是不会重新加载的。</p><p>可以看出，Tomcat没有遵循双亲委派模型，每个Webapp ClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/abf6fd4531e7?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation" target="_blank" rel="noopener">深入理解 Tomcat（四）Tomcat 类加载器之为何违背双亲委派模型</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;如何破坏双亲委派模型&quot;&gt;&lt;a href=&quot;#如何破坏双亲委派模型&quot; class=&quot;headerlink&quot; title=&quot;如何破坏双亲委派模型&quot;&gt;&lt;/a&gt;如何破坏双亲委派模型&lt;/h2&gt;&lt;p&gt;双亲委派模型不是一个强制性的约束模型，而是一个建议型的类加载器实现方式。考虑
      
    
    </summary>
    
      <category term="JVM" scheme="http://yoursite.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="双亲委派模型" scheme="http://yoursite.com/tags/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>ApplicationContext体系分析</title>
    <link href="http://yoursite.com/2019/05/23/ApplicationContext%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/23/ApplicationContext源码分析/</id>
    <published>2019-05-23T11:15:41.000Z</published>
    <updated>2019-05-23T13:28:02.707Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ApplicationContext</code>实现了除基本容器外的多个接口，提供了比<code>BeanFactory</code>更为丰富的功能，比如说自动识别<code>BeanPostProcessor</code>以及其它特殊类型Bean、容器启动时自动加载Bean、国际化支持、容器内事件发布等。因此，我们在实际应用中一般会使用<code>ApplicationContext</code>而不是<code>BeanFactory</code>。</p><h2 id="继承体系"><a href="#继承体系" class="headerlink" title="继承体系"></a>继承体系</h2><p><img src="http://blog.default.nanwulife.com/72307-b0c809e1cc035cdb.jpg" alt=""></p><p>从上图可以看出，<code>ApplicationContext</code>继承了<code>BeanFactory</code>，因此拥有<code>BeanFactory</code>的全部功能，实际上，它是将容器的功能委派给<code>DefaultListableBeanFactory</code>来实现。除此之外，<code>ApplicationContext</code>还继承了<code>ResourceLoader</code>、<code>EnvironmentCable</code>、<code>ApplicationEventPublisher</code>、<code>MessageSource</code>等接口，提供了十分丰富的功能。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>创建一个常用的<code>ApplicationContext</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application.xml"</span>);</span><br></pre></td></tr></table></figure></p><p><code>ClassPathXmlApplicationContext</code>的构造函数在设置完配置文件的位置后，紧接着调用<code>refresh()</code>方法，这个方法是整个<code>ApplicationContext</code>体系的核心，是在<code>AbstractApplicationContext</code>中实现的，并且是个典型的模板方法，也就是说其中的一些步骤是交由具体子类来实现的。以下是这个方法的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 1. 准备刷新时的上下文环境</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 刷新并初始化 BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 配置 BeanFactory 中的一些其它信息</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 4. 提供子类覆盖的额外处理，即子类处理自定义的 BeanFactoryPostProcess</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 调用各种 BeanFactoryPostProcessor</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 注册 BeanPostProcessor 到 BeanFactory 中去</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 初始化上下文中的资源文件，如国际化文件的处理等</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 初始化上下文事件广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 初始化其它特殊 Bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 检查 listener 类型的 Bean 并注册</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. 实例化所有非懒加载的单例 Bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12. 发布相应的事件</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="obtainFreshBeanFactory"><a href="#obtainFreshBeanFactory" class="headerlink" title="obtainFreshBeanFactory"></a>obtainFreshBeanFactory</h3><p><code>obtainFreshBeanFactory()</code>方法核心是内部调用<code>refreshBeanFactory()</code>方法并将容器内部的<code>ConfigurableListableBeanFactory</code>返回，从这也看到了<code>ApplicationContext</code>和<code>BeanFactory</code>的关系：<code>ApplicationContext</code>内部包含一个<code>BeanFactory</code>，<code>ApplicationContext</code>所有关于<code>BeanFactory</code>的功能将委派给此<code>BeanFactory</code>处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 清理之前的BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// createBeanFactory方法直接新建一个DefaultListableBeanFactory，也就是说内部使用的是DefaultListableBeanFactory实例</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">      <span class="comment">// 自定义此上下文使用的内部bean工厂</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">      <span class="comment">// 将BeanDefinition加载到给定的bean工厂中，通常通过委托给一个或多个BeanDefinitionReader来实现</span></span><br><span class="line">      <span class="comment">// 子类实现的方法，此处调用的是AbstractXmlApplicationContext的方法</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(...);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这一步是构建<code>ApplicationContext</code>内部的<code>BeanFactory</code>，以及根据配置将<code>BeanDefinition</code>加载到<code>BeanFactory</code>中（此时并没有实例化Bean）。</p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><p>配置内部<code>BeanFactory</code>的一些基础参数，比如<code>ClassLoader</code>等等。</p><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>对<code>BeanFactory</code>预处理，<code>ClassPathXmlApplicationContext</code>未重写，<code>WebXmlApplicationContext</code>有重写，这里不展开。</p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>在任何Bean的实例化之前，实例化并调用所有已注册的<code>BeanFactoryPostProcessor</code>Bean，如果实现了<code>PriorityOrdered</code>或者<code>Ordered</code>接口则按顺序调用。此时允许<code>BeanFactoryPostProcessor</code>在实例化<code>BeanDefinition</code>之前对当前的配置数据进行修改。</p><h3 id="registerBeanPostProcessors"><a href="#registerBeanPostProcessors" class="headerlink" title="registerBeanPostProcessors"></a>registerBeanPostProcessors</h3><p>将当前所有的<code>BeanPostProcessor</code>注册到<code>BeanFactory</code>中去，同样也是按照<code>PriorityOrdered</code>或者<code>Ordered</code>的顺序。这也是<code>ApplicationContext</code>与<code>BeanFactory</code>的一个不同，<code>BeanFactory</code>必须自己手动的调用<code>addBeanPostProcessor()</code>方法。</p><h3 id="initMessageSource"><a href="#initMessageSource" class="headerlink" title="initMessageSource"></a>initMessageSource</h3><p>初始化<code>MessageSource</code>，如果没有定义则使用<code>DelegatingMessageSource</code>，实际是委派给父类的。</p><h3 id="initApplicationEventMulticaster"><a href="#initApplicationEventMulticaster" class="headerlink" title="initApplicationEventMulticaster"></a>initApplicationEventMulticaster</h3><p>初始化<code>ApplicationEventMulticaster</code>，如果没有定义则使用<code>SimpleApplicationEventMulticaster</code>。</p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>模板方法，交给子类来实现，一般是用于在实例化单例Bean之前调用特定Bean的初始化。</p><h3 id="registerListeners"><a href="#registerListeners" class="headerlink" title="registerListeners"></a>registerListeners</h3><p>将所有<code>ApplicationListener</code>注册到<code>ApplicationEventMulticaster</code>中，然后将<code>earlyApplicationEvents</code>中定义的事件进行广播。</p><h3 id="finishBeanFactoryInitialization"><a href="#finishBeanFactoryInitialization" class="headerlink" title="finishBeanFactoryInitialization"></a>finishBeanFactoryInitialization</h3><p>实例化所有剩余的非懒加载的单例Bean，就是遍历所有的<code>beanName</code>，然后挨个调用<code>getBean(beanName)</code>。</p><h3 id="finishRefresh"><a href="#finishRefresh" class="headerlink" title="finishRefresh"></a>finishRefresh</h3><p>完成此上下文的刷新，调用<code>LifecycleProcessor</code>的<code>onRefresh()</code>方法并发布<code>ContextRefreshedEvent</code>。主要是对于有生命周期的Bean，按照分组，调用其<code>start()</code>方法。</p><h2 id="ApplicationContext使用"><a href="#ApplicationContext使用" class="headerlink" title="ApplicationContext使用"></a>ApplicationContext使用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beanFactory</span></span><br><span class="line">UserService userService = context.getBean(<span class="string">"userService"</span>, UserService.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件</span></span><br><span class="line">context.addApplicationListener(<span class="keyword">new</span> WalkListener());</span><br><span class="line">context.publishEvent(<span class="keyword">new</span> WalkEvent(<span class="keyword">new</span> User(<span class="string">"Jerry"</span>)));</span><br><span class="line">context.publishEvent(<span class="keyword">new</span> WalkEvent(<span class="keyword">new</span> User(<span class="string">"Peter"</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// locale</span></span><br><span class="line">context.getMessage(<span class="string">"menu.edit"</span>, <span class="keyword">null</span>, <span class="string">"Edit"</span>, Locale.US);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.jianshu.com/p/d75faa3ddce3" target="_blank" rel="noopener">Spring IOC ApplicationContext 源码分析</a></li><li><a href="">Spring ApplicationContext源码分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ApplicationContext&lt;/code&gt;实现了除基本容器外的多个接口，提供了比&lt;code&gt;BeanFactory&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：加载Bean</title>
    <link href="http://yoursite.com/2019/05/21/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9AgetBean/"/>
    <id>http://yoursite.com/2019/05/21/Simple-IoC开发日志：getBean/</id>
    <published>2019-05-21T10:43:00.000Z</published>
    <updated>2019-05-22T12:32:14.001Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>在之前加载注册<code>BeanDefinition</code>完成后，Spring已经存在一组<code>beanName</code> - &gt;<code>BeanDefinition</code>的映射了，接下来我们就可以根据名称或类型实例化并获取我们想要的Bean，而和这个实例化Bean相关的则是整个<code>BeanFactory</code>体系。接下来我们从<code>doGetBean()</code>这个方法开始分析起，这个方法涵盖了实例化Bean的总流程，大致步骤如下：</p><ol><li>将 alias name、FactoryBean name 转换为对应的<code>beanName</code></li><li>尝试从缓存中获取单例Bean</li><li>如果缓存中不存在，则从父类容器中加载</li><li>合并父类的属性，获取<code>RootBeanDefinition</code></li><li>加载所依赖的Bean</li><li>根据不同的<code>scope</code>实例化Bean</li><li>类型转换处理，如果传递的<code>requiredType</code>不为<code>null</code>，则需要检测所得到的Bean的类型是否与该<code>requiredType</code>一致。</li></ol><p>首先，如果名称是以<code>&amp;</code>开头的，则去掉<code>&amp;</code>，并且根据别名获取到<code>beanName</code>，然后尝试从单例缓存中获取Bean，这也正是解决循环依赖的关键，第一次获取时是没有效果的，继续往下走。此时判断是否发生原型模式的循环依赖，如果发生了，则抛出异常。接下来根据<code>beanName</code>从映射中获取到<code>BeanDefinition</code>（其实是<code>RootBeanDefinition</code>），然后优先加载所依赖的Bean（<code>depends-on</code>标签），然后根据不同的<code>scope</code>分别实例化Bean，完成<code>FactoryBean</code>的相关处理，最后做类型转换即可，不过目前不会去关心这个类型转换。下面开始分析比较重要的几个步骤。</p><h3 id="Bean实例化"><a href="#Bean实例化" class="headerlink" title="Bean实例化"></a>Bean实例化</h3><p>Bean会根据不同的<code>scope</code>采取不同的实例化策略，总共有五种<code>scope</code>：<code>singleton</code>、<code>prototype</code>、<code>request</code>、<code>session</code>、<code>global session</code>，其实比较常用的也就<code>singleton</code>和<code>prototype</code>，而<code>prototype</code>不需要解决循环依赖的问题，直接反射创建就好了，重点需要关注的是<code>singleton</code>的实例化过程。</p><p>接下来从<code>getSingleton()</code>这个方法进入Bean实例化的正戏。这个方法的开始可以看到用到了双重校验锁，因为多个线程可能在之前同时判断缓存中没有Bean，就都进入到了这里，但为了保证不重复实例化Bean（单例模式），在获取锁之后还会再判断一次是否能从缓存中获取，这里是要注意的。接下来通过<code>ObjectFactory#getObject()</code>方法开始实例化，里面会调用<code>doCreateBean()</code>方法，然后经历以下几个步骤：</p><ol><li>使用合适的实例化策略来创建新的实例：工厂方法、构造函数自动注入、简单初始化。此时Bean已经被创建出来了，只是没有进行属性填充和初始化</li><li>如果为单例模式、允许循环依赖且当前单例Bean正在被创建，那么将其加入到三级缓存<code>singletonFactories</code>中</li><li>属性填充</li><li>调用初始化方法<br> 4.1. 激活<code>Aware</code>方法，对特殊的Bean处理<br>4.2. 调用<code>postProcessBeforeInitialization()</code><br>4.3. 如果实现了<code>InitializingBean</code>接口，调用其<code>afterPropertiesSet()</code>方法；如果指定了<code>init-method</code>，则调用指定的<code>init-method</code><br>4.4. 调用<code>postProcessAfterInitialization()</code></li><li>注册Bean的销毁方法。与<code>InitializingBean</code>和<code>init-method</code>用于对象的自定义初始化工作相似，<code>DisposableBean</code>和<code>destroy-method</code>用于对象的自定义销毁工作。但这里并不是立刻执行，而是先注册，等到Spring容器关闭的时候才去调用，并且需要我们主动去告知Spring容器，对于<code>BeanFactory</code>容器需要调用<code>destroySingletons()</code>方法，对于<code>ApplicationContext</code>容器需要调用<code>registerShutdownHook()</code>方法。</li></ol><p>到这里，我们就获取到一个Bean了，下面对其中的一些细节进行解释。</p><h3 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h3><p>在这个方法中，完成了Bean的实例化（注意，此时还没填充属性等等），Spring提供了四种实例化策略：</p><ol><li><code>Supplier</code>回调：从<code>BeanDefinition</code>中获取<code>Supplier</code>对象，如果不为空，则调用<code>obtainFromSupplier()</code>方法完成Bean的初始化</li><li>工厂方法初始化</li><li>构造函数自动注入初始化</li><li>默认构造函数注入</li></ol><p>工厂方法初始化的工厂分为静态工厂和实例工厂，静态工厂的配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eat"</span> <span class="attr">class</span>=<span class="string">"it.spring.liao.com.EatFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p><p>实例工厂的配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eatFactory"</span> <span class="attr">class</span>=<span class="string">"it.spring.liao.com.EatFactory "</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"eat"</span> <span class="attr">factory-bean</span>=<span class="string">"eatFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><p>如果配置了构造函数的自动注入或者配置了构造函数参数，则调用带参的构造函数去实例化Bean。因为一个类有多个构造函数，每个构造函数都有不同的构造参数，需要根据参数个数和类型确定最精确匹配的构造函数，这部分的源码还是十分复杂的。</p><p>对于带参构造函数或默认构造函数，都会先判断是否有覆盖方法，如果有的话则使用CGLIB创建代理对象，否则通过反射来创建Bean（核心代码其实就是<code>constructorToUse.newInstance()</code>）。</p><p>而对于工厂方法，其实也就是通过该<code>Method</code>反射创建Bean（核心代码其实就是<code>factoryMethod.invoke(factoryBean, args)</code>）。</p><h3 id="解决循环依赖"><a href="#解决循环依赖" class="headerlink" title="解决循环依赖"></a>解决循环依赖</h3><p>先看一下Spring中关于这块的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() <span class="comment">// 如果为单例模式</span></span><br><span class="line">&amp;&amp; <span class="keyword">this</span>.allowCircularReferences <span class="comment">// 允许循环依赖</span></span><br><span class="line">&amp;&amp; isSingletonCurrentlyInCreation(beanName));<span class="comment">// 当前单例 Bean 正在被创建</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个方法的调用发生在 createBeanInstance() 方法之后，也就是说这个 bean 其实已经创建出来了，但是没有进行属性填充和初始化，</span></span><br><span class="line"><span class="comment">// 但是此时已经可以根据对象引用定位到堆中该对象了，所以将该对象提前曝光出来，加入到三级缓存 singletonFactories 中</span></span><br><span class="line"><span class="comment">// 这里是为了后期避免循环依赖</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring IoC是通过三级缓存这么个机制解决循环依赖的问题的，每次在调用<code>createBeanInstance()</code>方法实例化一个Bean后，就将这个Bean加入到三级缓存<code>singletonFactories</code>中，而此时如果依赖的属性又依赖于自己，即发生循环依赖的话，那么就会直接从三级缓存中拿到这个Bean，并将其升级到二级缓存中去，如果后续还有循环依赖的话，直接从二级缓存就能获取到结果。需要注意的是，这时候的Bean仅仅只是实例化了出来，并没有进行属性填充等操作，只有当一切都完成后，才会将这个Bean升级到一级缓存中去。</p><h3 id="populateBean"><a href="#populateBean" class="headerlink" title="populateBean"></a>populateBean</h3><p>上面已经实例化出了Bean，并且加入到三级缓存中了，但是这个Bean还有许多事没做完，接下来第一件事就是对其进行属性填充，也就是<code>populateBean()</code>这个方法，它的大体步骤如下：</p><ol><li>获取Bean的属性值，也就是<code>PropertyValues</code></li><li>根据名称或类型解析依赖（此时并未注入到Bean中，仅仅将属性放到了`pvs中）</li><li>调用<code>applyPropertyValues()</code>真正注入属性：<br> 3.1. 检测属性值列表是否已经转换过，若转换过，则直接填充属性，无需再次转换<br>3.2. 遍历属性值列表<code>pvs</code>，解析原始值<code>originalValue</code>，得到解析值<code>resolvedValue</code><br>3.3. 对解析后的属性值<code>resolvedValue</code>进行类型转换<br>3.4. 将类型转换后的属性值设置到<code>PropertyValue</code>对象中，并将<code>PropertyValue</code>对象存入<code>deepCopy</code>集合中<br>3.5. 将<code>deepCopy</code>中的属性信息注入到Bean对象中</li></ol><p>首先讲讲根据名称或类型解析依赖。<code>autowireByName()</code>方法主要完成了以下几件事：</p><ol><li>获取Bean对象中的非简单属性名，即类型为对象类型的属性，<code>String</code>、<code>Enum</code>、<code>Date</code>、<code>URI/URL</code>、<code>Number</code>的继承类如<code>Integer/Long</code>、<code>byte/short/int</code>等基本类型、<code>Locale</code>、以上所有类型的数组形式。</li><li>遍历那些非简单属性名，如果容器中包含该名称对应的Bean，则递归实例化该Bean（也就是调用<code>getBean()</code>方法）</li><li>将递归获取到的Bean存入到属性值列表<code>PropertyValues</code>中</li><li>注册依赖（就是建立映射关系）</li></ol><p><code>autowireByType()</code>方法比<code>autowireByName()</code>方法复杂一些，因为相同类型的Bean可能有多个，它最核心的思路如下：</p><ol><li>根据类型查找所有合适的候选Bean。比如说我们的成员变量是<code>Dao</code>类型的，那么此时<code>MongoDao</code>和<code>MySQLDao</code>这两个Bean可能都属于合适的候选项，因为它们都实现了<code>Dao</code>接口。</li><li>如果没有找到合适的候选Bean，并且<code>autowire</code>的<code>require</code>属性为<code>true</code>，则直接抛出异常</li><li>当候选者不唯一时，则依次根据<code>Primary</code>、<code>Priority</code>决定最终的候选Bean（此时拿到了<code>autowiredBeanName</code>和<code>instanceCandidate</code>）</li><li>当候选者唯一时，可以直接决定候选Bean（此时拿到了<code>autowiredBeanName</code>和<code>instanceCandidate</code>）</li><li>候选Bean可能并没有实例化，也就是<code>instanceCandidate</code>仅仅为<code>Class</code>类型，比如说是<code>MySQLDao.class</code>，此时根据<code>beanFactory.getBean(autowiredBeanName)</code>方法实例化该Bean</li><li>返回已实例化好的Bean</li></ol><p>接下来就和<code>autowireByName()</code>方法一样了，将获取到的Bean存入到属性值列表<code>PropertyValues</code>中，并且注册这个依赖关系。此时，<code>&lt;property&gt;</code>标签表示的属性和自动注入的属性都已经解析到<code>PropertyValues</code>中了，调用<code>applyPropertyValues()</code>开始真正的属性注入，该方法核心步骤如下：</p><ol><li>将<code>ref</code>（在之前解析标签时将其封装成了<code>RuntimeBeanReference</code>）解析为具体的对象，将<code>&lt;list&gt;</code>标签转换为<code>List</code>对象，还会解析<code>&lt;set/&gt;</code>、<code>&lt;map/&gt;</code>、<code>&lt;array/&gt;</code>等标签。</li><li>对属性值的类型进行转换，比如将<code>String</code>类型的属性值<code>&quot;123&quot;</code>转换为<code>Integer</code>类型的<code>123</code></li><li>反射设置<code>PropertyValues</code>中的所有属性</li></ol><p>至此，属性值已经注入到Bean中了。</p><h3 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h3><p>填充完属性，接下来就是调用初始化方法，该方法的步骤如下：</p><ol><li>激活<code>Aware</code>方法：Bean可以实现<code>Aware</code>接口，从而对当前环境进行感知（就是实现了<code>setXXX()</code>方法）。在这里，会针对<code>BeanNameAware</code>、<code>BeanClassLoaderAware</code>、<code>BeanFactoryAware</code>三种<code>Aware</code>接口进行判断，将一些值设置到当前Bean中。</li><li>调用<code>postProcessBeforeInitialization()</code>方法</li><li>调用<code>invokeInitMethods()</code>方法：<br> 3.1. 如果Bean实现了<code>InitializingBean</code>接口，那么会先调用该接口的<code>afterPropertiesSet()</code>方法<br>3.2. 检查是否指定了<code>init-method</code>，如果指定了则通过反射机制调用<code>init-method</code>方法</li><li>调用<code>postProcessAfterInitialization()</code>方法</li></ol><p>至此，几个核心步骤就都介绍完了。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><p>Simple IoC的实现大体思路上与Spring IoC一致，但是尚不支持<code>&lt;list/&gt;</code>等一些集合标签，并且不像Spring实现了一套类型转换体系，这里直接使用了<code>apache</code>的<code>BeanUtils</code>完成类型转换相关的操作。除此之外，暂时还未实现<code>initializeBean()</code>相关的逻辑。</p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>第一个测试是模拟登陆接口的场景，分为<code>Controller</code>、<code>Service</code>、<code>Dao</code>三层，XML配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginController"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.LoginController"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginService"</span> <span class="attr">ref</span>=<span class="string">"loginService"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"loginService"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.LoginServiceImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"userDao"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.login.UserDao"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\login.xml"</span>);</span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line">    LoginController loginController = (LoginController) factory.getBean(<span class="string">"loginController"</span>);</span><br><span class="line">    assertEquals(loginController.login(<span class="string">"Lihua"</span>, <span class="string">"123456789"</span>), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个测试是针对循环依赖问题的，XML配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans-2.0.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.persons.Person"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"Lihua"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idCard"</span> <span class="attr">ref</span>=<span class="string">"idCard"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"idCard"</span> <span class="attr">class</span>=<span class="string">"cn.hecenjie.simpleioc.tests.objects.persons.IdCard"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"441301188875468912"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"owner"</span> <span class="attr">ref</span>=<span class="string">"person"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>测试代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCyclicDependence</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\persons.xml"</span>);</span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    beanDefinitionReader.loadBeanDefinitions(resource);</span><br><span class="line">    Person person = (Person) factory.getBean(<span class="string">"person"</span>);</span><br><span class="line">    IdCard idCard = (IdCard) factory.getBean(<span class="string">"idCard"</span>);</span><br><span class="line">    assertEquals(person.getName(), <span class="string">"Lihua"</span>);</span><br><span class="line">    assertEquals(person.getAge(), <span class="number">18</span>);</span><br><span class="line">    assertEquals(person.getIdCard(), idCard);</span><br><span class="line">    assertEquals(idCard.getId(), <span class="number">441301188875468912L</span>);</span><br><span class="line">    assertEquals(idCard.getOwner(), person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;在之前加载注册&lt;code&gt;BeanDefinition&lt;/c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：注册BeanDefinitions</title>
    <link href="http://yoursite.com/2019/05/19/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9ABeanDefinition%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/19/Simple-IoC开发日志：BeanDefinition加载/</id>
    <published>2019-05-19T14:29:00.000Z</published>
    <updated>2019-05-20T08:04:26.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>在之前已经介绍过Spring IoC对资源的抽象了，也就是<code>Resource</code>接口。当我们加载了指定的资源后，接下来需要做的就是将资源（也就是XML文件）解析成<code>Document</code>实例，并解析成<code>BeanDefinition</code>然后注册。这个过程的整体流程如下：</p><ol><li><code>loadBeanDefinitions(Resource resource)</code>作为方法入口。</li><li><code>doLoadBeanDefinitions(InputSource inputSource, Resource resource)</code>方法实现了真正的加载逻辑，它首先根据XML获取<code>Document</code>实例，然后根据<code>Document</code>实例注册Bean信息。<br> 2.1. <code>doLoadDocument()</code>方法根据XML获取<code>Document</code>实例，其中会牵扯到获取验证模式和错误处理等过程。<br> 2.2. <code>registerBeanDefinitions()</code>遍历XML的每一个节点并注册它们的<code>BeanDefinition</code>。</li></ol><p>接下来就上面获取<code>Document</code>实例和注册<code>BeanDefinition</code>进行分析。</p><h3 id="获取Document"><a href="#获取Document" class="headerlink" title="获取Document"></a>获取Document</h3><p>解析XML有两种方式，一种是DOM解析，另一种则是SAX解析，关于这两个解析方式在网上也有比较充足的资料，就不在这赘述了。在这一个过程还有两个方面是需要关心的，一个是验证模式，另一个是错误处理（还有一个是Spring实现的<code>EntityResolver</code>，自定义了验证文件的获取方式，在本地建立了一个映射而不需要从网络中获取）。</p><p>首先，验证模式同样也有两种，一种是DTD验证模式，另一种是XSD验证模式。因此，在这里需要根据XML文件中的一些信息来探测决定具体使用哪种验证模式，比如说如果内容中包含<code>DOCTYPE</code>则肯定为DTD验证模式，而如果探测不出的话，最终会使用XSD验证模式。错误处理就是当加载<code>Document</code>发生错误时需要做出的反应，简单的实现就是输出错误日志。当以上两个都准备好了后，就先通过<code>DocumentBuilderFactory</code>创建一个<code>DocumentBuilder</code>，再调用<code>DocumentBuilder</code>的<code>parse()</code>方法直接解析并返回一个<code>Document</code>实例即可。</p><h3 id="注册BeanDefinition"><a href="#注册BeanDefinition" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>注册<code>BeanDefinition</code>实际上就是通过上面获取到的<code>Document</code>的根节点开始逐个遍历子节点（要先判断根节点是否使用的默认命名空间），然后根据<code>&lt;import/&gt;</code>、<code>&lt;alias/&gt;</code>、<code>&lt;bean/&gt;</code>、<code>&lt;beans/&gt;</code>这四种标签分别进行解析，其中<code>&lt;beans/&gt;</code>标签的处理是一个递归的过程，而<code>&lt;bean/&gt;</code>标签的处理则是需要重点关注的，在这个过程中主要分为两步：解析出<code>BeanDefinition</code>并且完成注册。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><h3 id="获取Document-1"><a href="#获取Document-1" class="headerlink" title="获取Document"></a>获取Document</h3><p>目前仅支持XSD格式的验证，并且没有实现<code>EntityResolver</code>，也就是说无法根据自定义的策略从本地拿到验证文件，还是默认的从网络中获取。</p><h3 id="注册BeanDefinition-1"><a href="#注册BeanDefinition-1" class="headerlink" title="注册BeanDefinition"></a>注册BeanDefinition</h3><p>在目前的实现中，并没有像Spring IoC一样支持四种标签的解析，这里只解析了<code>&lt;bean/&gt;</code>标签。之后，需要重点关注的一个方法就是<code>parseBeanDefinitionElement()</code>，这是解析<code>&lt;bean/&gt;</code>标签的核心逻辑，主要完成了从<code>&lt;bean/&gt;</code>标签的<code>id</code>属性和<code>name</code>属性还有一些别的属性以及子元素中获取到值并组装成一个<code>BeanDefinition</code>（实际上还会包装一层<code>BeanDefinitionHolder</code>，其中保存了<code>beanName</code>和<code>aliases</code>），下面对这一部分的细节进行分析。</p><h4 id="parseBeanDefinitionElement"><a href="#parseBeanDefinitionElement" class="headerlink" title="parseBeanDefinitionElement"></a>parseBeanDefinitionElement</h4><p>这个方法主要完成以下这些事：</p><ol><li>解析出<code>&lt;bean&gt;</code>标签中的<code>id</code>属性和<code>name</code>属性，在Spring中是以<code>,</code>作为分隔符取得多个别名，但在这里的实现中只考虑一种别名的情况，也就是没有使用<code>,</code>进行分割。</li><li>优先使用id作为<code>beanName</code>，但如果并没有设置<code>id</code>属性的话，就使用第一个别名作为<code>beanName</code>，那么在这里就只有唯一的一个别名，当id没设置时它就是<code>beanName</code>。</li><li>检查<code>beanName</code>和别名的唯一性，如果不唯一，则抛出异常，唯一的话则加入到集合中去。（注意，别名也是需要唯一的）</li><li>解析别的属性以及子元素，开始构造<code>AbstractBeanDefinition</code>。上面几步只是对名称做一些解析，这一步的工作量则相对要大很多，下面是一些比较常见的属性：<br> 4.1. 解析<code>class</code>属性，最重要的了<br>4.2. 解析<code>parent</code>属性，未实现<br>4.3. 解析<code>scope</code>属性<br>4.4. 解析<code>autowire</code>属性<br>4.5. 解析<code>init-method</code>属性<br>4.6. 解析<code>destroy-method</code>属性<br>4.7. 解析<code>factory-bean</code>属性<br>4.8. 解析<code>factory-method</code>属性<br>4.9. 解析<code>&lt;lookup-method/&gt;</code>子元素，未实现<br>4.10. 解析<code>&lt;replaced-method/&gt;</code>子元素，未实现<br>4.11. 解析<code>&lt;property/&gt;</code>子元素，这一步也很重要，它将属性名和属性值封装到了<code>PropertyValue</code>中，并且用<code>PropertyValues</code>封装所有属性（也就是每个<code>BeanDefinition</code>都有一个<code>PropertyValues</code>类型的成员变量）。<br>4.12. 解析<code>&lt;constructor-arg/&gt;</code>子元素，未实现</li><li>此时已经构造出了一个相对完整的<code>BeanDefinition</code>了，这时候将其和<code>beanName</code>与别名一起封装成<code>BeanDefinitionHolder</code>对象。</li><li>注册<code>beanName</code> -&gt; <code>BeanDefinition</code>以及<code>alias</code> -&gt; <code>beanName</code>的映射关系（个人认为，这正是IoC的本质所在，通过一个映射表维护一个名称到<code>BeanDefinition</code>的关系，而这个<code>BeanDefinition</code>中封装了这个Bean的各种信息）。这里要注意的是，在注册<code>alias</code> -&gt; <code>beanName</code>的映射关系时，Spring考虑了别名循环指向的问题，它是通过递归来进行判断的。</li><li>此时，这个<code>BeanDefinition</code>已经注册成功，可以等待使用了</li></ol><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>针对根据XML获取<code>Document</code>实例并注册<code>BeanDefinition</code>的过程做一些简单的测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadBeanDefinitions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\simple.xml"</span>);</span><br><span class="line">    BeanDefinitionRegistry registry = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    BeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(registry);</span><br><span class="line">    assertEquals(beanDefinitionReader.loadBeanDefinitions(resource), <span class="number">2</span>);</span><br><span class="line">    assertEquals(((DefaultListableBeanFactory) registry).getBeanDefinition(<span class="string">"first"</span>).getBeanClassName(),</span><br><span class="line">            <span class="string">"beans.First"</span>);</span><br><span class="line">    assertEquals(((DefaultListableBeanFactory) registry).getBeanDefinition(<span class="string">"second"</span>).getBeanClassName(),</span><br><span class="line">            <span class="string">"beans.Second"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;在之前已经介绍过Spring IoC对资源的抽象了，也就是&lt;
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="IoC" scheme="http://yoursite.com/tags/IoC/"/>
    
  </entry>
  
  <entry>
    <title>Simple IoC开发日志：资源加载</title>
    <link href="http://yoursite.com/2019/05/19/Simple-IoC%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97%EF%BC%9A%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD/"/>
    <id>http://yoursite.com/2019/05/19/Simple-IoC开发日志：资源加载/</id>
    <published>2019-05-19T13:51:40.000Z</published>
    <updated>2019-05-19T14:04:00.667Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring-IoC实现"><a href="#Spring-IoC实现" class="headerlink" title="Spring IoC实现"></a>Spring IoC实现</h2><p>Spring对资源文件和资源的加载都做了统一的抽象，以下是资源文件的继承体系：<br><img src="http://blog.default.nanwulife.com/spring-201805091003.jpg" alt=""></p><p>其中，顶层接口<code>InputStreamSource</code>只包含一个<code>getInputStream()</code>方法用于返回指定资源的<code>InputStream</code>；而<code>Resource</code>是对资源的一个抽象，里面提供了判断资源是否存在、资源是否可读、资源大小等常见接口，并且大部分接口由抽象子类<code>AbstractResource</code>提供了默认实现，而一些方法则由具体的子类如<code>FileSystemResource</code>、<code>ClassPathResource</code>等覆写，以满足特定的场景需求。</p><p>接下来看看Spring对资源加载的统一抽象，同样从它的继承体系说起：<br><img src="http://blog.default.nanwulife.com/FileSystemResourceLoader.png" alt=""></p><p>与<code>AbstractResource</code>相似，<code>DefaultResourceLoader</code>是<code>ResourceLoader</code>的默认实现。其中<code>getResource()</code>方法是其核心（两个子类都没覆盖该方法），它根据方法参数<code>location</code>的内容来决定到底是返回<code>ClassPathResource</code>还是<code>FileSystemResource</code>还是<code>Resource</code>其它的一些子类。由于在默认的实现策略中，凡是以<code>/</code>开头的都会返回<code>ClassPathContextResource</code>类型的资源，但对于<code>/user/hecenjie/test.xml</code>这样的路径我们更加希望是<code>FileSystemResource</code>类型的资源，因此在子类<code>FileSystemResourceLoader</code>中覆写了相关方法，使之可以从文件系统中获取资源；而另一个子类<code>ClassRelativeResourceLoader</code>则扩展了功能，可以根据给定的Class所在包或者所在包的子包下加载资源。</p><p><code>ResourceLoader</code>的另一个重要实现是<code>ResourcePatternResolver</code>，与上面的<code>ResourceLoader</code>实现类不同的是，它支持根据指定的资源路径匹配模式每次返回多个<code>Resource</code>实例（也就是<code>Resource</code>数组），并且它也新增了一种新的协议前缀<code>classpath*:</code>，该前缀表示可以加载多个jar包中相同的资源文件，而<code>classpath:</code>只能加载找到的第一个文件。</p><p><code>PathMatchingResourcePatternResolver</code>除了支持<code>ResourceLoader</code>和<code>ResourcePatternResolver</code>新增的<code>classpath*:</code>前缀外，还支持Ant风格的路径匹配模式（类似于<code>**/*.xml</code>）。</p><h2 id="Simple-IoC实现"><a href="#Simple-IoC实现" class="headerlink" title="Simple IoC实现"></a>Simple IoC实现</h2><p>目前自己实现的IoC容器中，只实现了文件系统的资源与加载抽象，以下为它们各自的类图：<br><img src="http://blog.default.nanwulife.com/FileSystemResource.png" alt=""> </p><p><img src="http://blog.default.nanwulife.com/FileSystemResourceLoader1.png" alt=""></p><h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><p>我们可以尝试写一些简单的单元测试从文件系统中加载指定的资源，并对该资源做一些基本操作。首先，准备一个<code>test.xml</code>文件，然后编写以下测试方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSystemResource</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Resource resource = <span class="keyword">new</span> FileSystemResource(<span class="string">"C:\\Users\\canjie\\Desktop\\test.xml"</span>);</span><br><span class="line">    assertTrue(resource.exists());</span><br><span class="line">    assertEquals(resource.contentLength(), <span class="number">992</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFileSystemResourceLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ResourceLoader resourceLoader = <span class="keyword">new</span> FileSystemResourceLoader();</span><br><span class="line">    Resource resource = resourceLoader.getResource(<span class="string">"C:\\Users\\canjie\\Desktop\\test.xml"</span>);</span><br><span class="line">    assertTrue(resource.exists());</span><br><span class="line">    assertEquals(resource.contentLength(), <span class="number">992</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring-IoC实现&quot;&gt;&lt;a href=&quot;#Spring-IoC实现&quot; class=&quot;headerlink&quot; title=&quot;Spring IoC实现&quot;&gt;&lt;/a&gt;Spring IoC实现&lt;/h2&gt;&lt;p&gt;Spring对资源文件和资源的加载都做了统一的抽象，以下是资
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Mybatis之Mapper接口</title>
    <link href="http://yoursite.com/2019/05/19/Mybatis%E4%B9%8BMapper%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2019/05/19/Mybatis之Mapper接口/</id>
    <published>2019-05-19T11:26:00.000Z</published>
    <updated>2019-05-19T11:27:08.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MyBatis有两种方式能和数据库打交道，一种是直接调用<code>SqlSession</code>的<code>select()</code>、<code>update()</code>等方法，传入statementId参数即可；另一种则是通过Mapper接口，这种方式在实际应用中更加常见，因为它使我们可以使用面向接口编程的方式操作数据库。</p><h2 id="XML映射文件"><a href="#XML映射文件" class="headerlink" title="XML映射文件"></a>XML映射文件</h2><p>Mybatis将所有XML配置信息都封装到<code>Configuration</code>内部，在XML映射文件中：</p><ul><li><code>&lt;parameterMap&gt;</code>标签，会被解析为<code>ParameterMap</code>对象，其每个子元素会被解析为<code>ParameterMapping</code>对象</li><li><code>&lt;resultMap&gt;</code>标签，会被解析为<code>ResultMap</code>对象，其每个子元素会被解析为<code>ResultMapping</code>对象</li><li>每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，均会被解析为一个<code>MappedStatement</code>对象，标签内的SQL会被解析为一个<code>BoundSql</code>对象</li></ul><h2 id="Mapper接口"><a href="#Mapper接口" class="headerlink" title="Mapper接口"></a>Mapper接口</h2><p>在MyBatis中，Mapper接口是与XML映射文件相对应的，它们之间的对应关系如下：</p><ul><li>接口的全限名，就是映射文件中的<code>namespace</code>的值</li><li>接口的方法名，就是映射文件中<code>MappedStatement</code>的<code>id</code>值</li><li>接口方法内的参数，就是传递给SQL的参数</li></ul><p>当调用接口方法时，通过接口全限名+方法名可唯一定位一个对应的<code>MappedStatement</code>，MyBatis会使用JDK动态代理自动为该Mapper接口生成代理对象，而这个代理对象会拦截接口的方法，从而调用对应的<code>MappedStatement</code>方法，最终执行SQL语句并返回执行结果。</p><p>也正因为是全限名+方法名的保存和寻找策略，所以Mapper接口里的方法是不能重载的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://svip.iocoder.cn/MyBatis/Interview/" target="_blank" rel="noopener">精尽 MyBatis 面试题</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MyBatis有两种方式能和数据库打交道，一种是直接调用&lt;code&gt;SqlSession&lt;/code&gt;的&lt;code&gt;select()&lt;/co
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Spring MVC：请求处理流程</title>
    <link href="http://yoursite.com/2019/05/19/Spring-MVC%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/05/19/Spring-MVC：请求处理流程/</id>
    <published>2019-05-19T09:12:00.000Z</published>
    <updated>2019-05-19T10:01:03.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p><img src="http://blog.default.nanwulife.com/20180708224853769.png" alt=""></p><h2 id="FrameworkServlet"><a href="#FrameworkServlet" class="headerlink" title="FrameworkServlet"></a>FrameworkServlet</h2><p>虽然在上面的整体流程图中，我们看到请求首先是被<code>DispatcherServlet</code>所处理，但是实际上，<code>FrameworkServlet</code>才是真正的入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// &lt;1&gt; 获得请求方法</span></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line"><span class="comment">// &lt;2.1&gt; 处理 PATCH 请求</span></span><br><span class="line"><span class="keyword">if</span> (httpMethod == HttpMethod.PATCH || httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line"><span class="comment">// &lt;2.2&gt; 调用父类，处理其它请求</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">super</span>.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当不是<code>PATCH</code>请求时，会调用父类<code>HttpServlet</code>的<code>service()</code>方法，在这个方法中调用由子类<code>FrameworkServlet</code>实现的<code>doGet()</code>、<code>doPost()</code>、<code>doPut()</code>、<code>doDelete()</code>等各种方法上，而这些方法最终会调用<code>processRequest()</code>方法，处理请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">doService(request, response);   <span class="comment">// 执行真正的逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象方法，交由子类 DispatcherServlet 实现</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doService</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p><code>DispatcherServlet</code>实现了<code>FrameworkServlet</code>的<code>doService()</code>方法，这个方法中会调用到<code>doDispatch()</code>执行请求的分发，而这个过程正是处理请求的核心逻辑，也对应着本文最开始的流程图：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);<span class="comment">// 检查是否是上传请求</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取可处理当前请求的处理器</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// 如果获取不到，则调用 noHandlerFound 根据配置抛出异常或返回 404</span></span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 获取可执行处理器逻辑的适配器</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">String method = request.getMethod();    <span class="comment">// 处理 last-modified 消息头</span></span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行拦截器 preHandle 方法</span></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 真正调用处理器逻辑（一般就是在这里调用我们的 Controller 方法）</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 controller 未返回 view 名称，这里生成默认的 view 名称</span></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行拦截器 postHandle 方法</span></span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">dispatchException = ex;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line"><span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line"><span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 4. 解析并渲染视图</span></span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line"><span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line"><span class="comment">// 如果是上传请求，清理资源</span></span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个过程涉及以下几个核心组件：</p><ul><li><code>DispatcherServlet</code>：请求入口，负责协调各个组件工作</li><li><code>HandlerMapping</code>：内部维护了一些&lt;访问路径，处理器&gt;映射，负责为请求找到合适的处理器</li><li><code>HandlerAdapter</code>：处理器的适配器。Spring中的处理器的实现多变，比如用户处理器可以实现<code>Controller</code>接口，也可以用<code>@RequestMapping</code>注解将方法作为一个处理器等，这就导致 Spring 不止到怎么调用用户的处理器逻辑。所以这里需要一个处理器适配器，由处理器适配器去调用处理器的逻辑</li><li><code>ViewResolver</code>：根据视图名查找获得视图对象<code>View</code></li><li><code>View</code>：视图对象用于将模板渲染成html或其他类型的文件。比如<code>InternalResourceView</code>可将jsp渲染成 html。</li></ul><p>完整流程虽然像上面那样，但在目前主流的架构中，前后端已经彻底分离了，所以也就将View移交给了前端，上面的视图解析与渲染步骤已不再需要，而是当Handler（Controller）执行完后，判断方法是否有<code>@ResponseBody</code>注解，有的话则直接将结果写回给用户。但是由于HTTP是不支持返回Java POJO对象的，所以还需要将结果使用<code>HttpMessageConverter</code>进行转换后才能返回。</p><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>根据请求获得相应的处理器和拦截器们（<code>HandlerInterceptor</code>数组 )，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerMapping.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerMapping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String PATH_WITHIN_HANDLER_MAPPING_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".pathWithinHandlerMapping"</span>;</span><br><span class="line">String BEST_MATCHING_PATTERN_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".bestMatchingPattern"</span>;</span><br><span class="line">String INTROSPECT_TYPE_LEVEL_MAPPING = HandlerMapping.class.getName() + <span class="string">".introspectTypeLevelMapping"</span>;</span><br><span class="line">String URI_TEMPLATE_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".uriTemplateVariables"</span>;</span><br><span class="line">String MATRIX_VARIABLES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".matrixVariables"</span>;</span><br><span class="line">String PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE = HandlerMapping.class.getName() + <span class="string">".producibleMediaTypes"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得请求对应的处理器和拦截器们</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的对象类型是<code>HandlerExecutionChain</code>，它包含处理器（<code>handler</code>）和拦截器们（<code>HandlerInterceptor</code>数组），简单代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandlerExecutionChain.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 处理器 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 拦截器数组 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br></pre></td></tr></table></figure></p><p>这里要注意的是处理器的类型是<code>Object</code>。</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>因为处理器<code>handler</code>的类型是<code>Object</code>类型，需要有一个调用者来实现<code>handler</code>是怎么被使用，怎么被执行，而<code>HandlerAdapter</code>的用途就在于此：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 是否支持该处理器 */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 执行处理器，返回 ModelAndView 结果 */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 返回请求的最新更新时间。如果不支持该操作，则返回 -1 即可 */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getLastModified</span><span class="params">(HttpServletRequest request, Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="HandlerInterceptor"><a href="#HandlerInterceptor" class="headerlink" title="HandlerInterceptor"></a>HandlerInterceptor</h2><p><code>HandlerInterceptor</code>是Spring MVC中的拦截器接口，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行之前</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter#handle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拦截处理器，在 &#123;<span class="doctag">@link</span> HandlerAdapter&#125; 执行完之后，无论成功还是失败，</span></span><br><span class="line"><span class="comment"> * 并且，只有 &#123;<span class="doctag">@link</span> #preHandle(HttpServletRequest, HttpServletResponse, Object)&#125; 执行成功之后，才会被执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结来说：</p><ul><li><code>preHandle()</code>方法，按拦截器定义顺序调用，若任一拦截器返回<code>false</code>，则后面的拦截器不再执行，且Controller方法不再调用，处理请求流程结束</li><li><code>postHandle()</code>方法，按拦截器定义逆序调用，在调用Controller方法成功之后执行</li><li><code>afterCompletion()</code>方法，按拦截器定义逆序调用，只有该拦截器在<code>preHandle()</code>方法返回<code>true</code>，Controller方法执行完后才能够被调用（不管是否执行成功），且一定会被调用（过程中出现的异常仅会记录到日志中，不会打断下一个拦截器的<code>afterCompletion()</code>执行）。</li></ul><h2 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h2><p>在Spring MVC中，可以使用<code>@RequestBody</code>和<code>@ResponseBody</code>两个注解，分别完成请求报文到对象和对象到响应报文的转换，底层这种灵活的消息转换机制就是通过<code>HttpMessageConverter</code>完成的。</p><p>我们知道，在Servlet标准中，可以用<code>javax.servlet.ServletRequest</code>接口中的以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletInputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>来得到一个<code>ServletInputStream</code>，从这个<code>ServletInputStream</code>中，可以读取到一个原始请求报文的所有内容。同样的，在<code>javax.servlet.ServletResponse</code>接口中，可以用以下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServletOutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure></p><p>来得到一个<code>ServletOutputStream</code>，从这个<code>ServletOutputSteam</code>中，可以输出Http的响应报文内容。</p><p>当请求报文来到Java世界，它会被封装成为一个<code>ServletInputStream</code>的输入流，供我们读取报文，而响应报文则是通过一个<code>ServletOutputStream</code>的输出流，来输出响应报文。由于从输入流中只能读取到原始的字符串报文，同样，往输出流中也只能写原始的字符，但在处理业务逻辑时更多都是以一个个对象作为处理维度的，因此在SpringMVC中，由<code>HttpMessageConverter</code>完成这中间的一个转换工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpMessageConverter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canRead</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canWrite</span><span class="params">(Class&lt;?&gt; clazz, MediaType mediaType)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;MediaType&gt; <span class="title">getSupportedMediaTypes</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">read</span><span class="params">(Class&lt;? extends T&gt; clazz, HttpInputMessage inputMessage)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMessageNotReadableException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(T t, MediaType contentType, HttpOutputMessage outputMessage)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMessageNotWritableException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>HttpMessageConverter</code>接口的定义出现了成对的<code>canRead()</code>+<code>read()</code> 和<code>canWrite()</code>+<code>write()</code> 方法，而参数中的<code>HttpInputMessage</code>和<code>HttpOutputMessage</code>则分别是Spring MVC内部对Http请求报文和响应报文的抽象。下面通过一个例子解释消息转换的过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/string"</span>, method = RequestMethod.POST)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">String <span class="title">readString</span><span class="params">(@RequestBody String string)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Read string '"</span> + string + <span class="string">"'"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在SpringMVC进入<code>readString(@RequestBody String string)</code>方法前，会根据<code>@RequestBody</code>注解选择适当的<code>HttpMessageConverter</code>实现类来将请求参数解析到<code>string</code>变量中，具体来说是使用了<code>StringHttpMessageConverter</code>类，它的<code>canRead()</code>方法返回<code>true</code>，然后它的<code>read()</code>方法会从请求中读出请求参数，绑定到<code>readString(@RequestBody String string)</code>方法的<code>string</code>变量中。</p><p>当Spring MVC执行<code>readString(@RequestBody String string)</code>方法后，由于返回值标识了<code>@ResponseBody</code>注解，Spring MVC将使用<code>StringHttpMessageConverter</code>的<code>write()</code>方法，将结果作为<code>String</code>值写入响应报文，当然，此时<code>canWrite()</code>方法返回<code>true</code>。</p><h3 id="RequestResponseBodyMethodProcessor"><a href="#RequestResponseBodyMethodProcessor" class="headerlink" title="RequestResponseBodyMethodProcessor"></a>RequestResponseBodyMethodProcessor</h3><p><code>RequestResponseBodyMethodProcessor</code>同时实现了<code>HandlerMethodArgumentResolver</code>和<code>HandlerMethodReturnValueHandler</code>两个接口，前者是将请求报文绑定到处理方法形参的策略接口，后者则是对处理方法返回值进行处理的策略接口。</p><p>对<code>HandlerMethodArgumentResolver</code>接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestResponseBodyMethodProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> parameter.hasParameterAnnotation(RequestBody.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">Object argument = readWithMessageConverters(webRequest, parameter, parameter.getGenericParameterType());</span><br><span class="line"></span><br><span class="line">String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line">WebDataBinder binder = binderFactory.createBinder(webRequest, argument, name);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (argument != <span class="keyword">null</span>) &#123;</span><br><span class="line">validate(binder, parameter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> argument;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对<code>HandlerMethodReturnValueHandler</code>接口的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RequestResponseBodyMethodProcessor.java</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> returnType.getMethodAnnotation(ResponseBody.class) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, HttpMediaTypeNotAcceptableException </span>&#123;</span><br><span class="line"></span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">if</span> (returnValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">writeWithMessageConverters(returnValue, returnType, webRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个接口的实现，分别是以是否有<code>@RequestBody</code>和<code>@ResponseBody</code>为条件，然后分别调用<code>HttpMessageConverter</code>来进行消息的读写。</p><h2 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h2><p>Spring MVC提供了异常解析器<code>HandlerExceptionResolver</code>接口，将处理器执行时发生的异常，转换成对应的<code>ModelAndView</code>结果。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析异常，转换成对应的 ModelAndView 结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, @Nullable Object handler, Exception ex)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，如果异常被解析成功，则会返回<code>ModelAndView</code>对象。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tianxiaobo.com/2018/06/29/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E7%9A%84%E6%97%85%E8%A1%8C%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 一个请求的旅行过程</a></li><li><a href="http://svip.iocoder.cn/Spring-MVC/DispatcherServlet-process-request-intro/#3-3-processDispatchResult" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 请求处理一览</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;处理流程&quot;&gt;&lt;a href=&quot;#处理流程&quot; class=&quot;headerlink&quot; title=&quot;处理流程&quot;&gt;&lt;/a&gt;处理流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://blog.default.nanwulife.com/20180708224853769.
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC" scheme="http://yoursite.com/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>深入分析Spring MVC：WebApplicationContext容器初始化</title>
    <link href="http://yoursite.com/2019/05/19/WebApplicationContext%E5%AE%B9%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://yoursite.com/2019/05/19/WebApplicationContext容器初始化/</id>
    <published>2019-05-19T04:39:00.000Z</published>
    <updated>2019-05-19T09:13:07.598Z</updated>
    
    <content type="html"><![CDATA[<h2 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 省略非关键的配置 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [1] Spring配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Spring Bean的配置文件所在目录，默认配置在WEB-INF目录下。该 &lt;context-param&gt; 标签会被设置到 ServletContext 中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ====================================== --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- [2] Spring MVC配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 可以自定义servlet.xml配置文件的位置和名称，默认为WEB-INF目录下，名称为[&lt;servlet-name&gt;]-servlet.xml，如spring-servlet.xml</span></span><br><span class="line"><span class="comment">    &lt;init-param&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment">        &lt;param-value&gt;/WEB-INF/spring-servlet.xml&lt;/param-value&gt; // 默认</span></span><br><span class="line"><span class="comment">    &lt;/init-param&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>spring<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>[1]</code>处配置了<code>org.springframework.web.context.ContextLoaderListener</code>对象，它实现了<code>javax.servlet.ServletContextListener</code>接口，会初始化一个Root WebApplicationContext容器；</li><li><code>[2]</code>处配置了<code>org.springframework.web.servlet.DispatcherServlet</code>对象，它实现了<code>javax.servlet.http.HttpServlet</code>，除了拦截我们制定的<code>*.do</code>请求外，也会初始化一个属于它的 Servlet WebApplicationContext 容器，并且这个容器是以 [1] 处的 Root 容器作为父容器。</li></ul><p>下面就以上两个容器进行分析，一个是业务容器，一个是Web容器。</p><h2 id="Root-WebApplicationContext"><a href="#Root-WebApplicationContext" class="headerlink" title="Root WebApplicationContext"></a>Root WebApplicationContext</h2><p>Root WebApplicationContext也就是业务容器，用于加载业务逻辑相关的类，比如service、dao层的一些类。它的初始化是通过<code>ContextLoaderListener</code>来实现，在Servlet容器启动时，例如Tomcat、Jetty启动，则会被<code>ContextLoaderListener</code>监听到，从而调用<code>contextInitialized(ServletContextEvent event)</code>方法，初始化Root WebApplicationContext容器。它的核心配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [1] Spring配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定Spring Bean的配置文件所在目录。默认配置在WEB-INF目录下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如上，<code>ContextLoaderListener</code>可通过<code>ServletContext</code>获取到<code>contextConfigLocation</code>配置。这样，业务容器就可以加载<code>application.xml</code>配置文件了。</p><h3 id="ContextLoaderListener"><a href="#ContextLoaderListener" class="headerlink" title="ContextLoaderListener"></a>ContextLoaderListener</h3><p><code>org.springframework.web.context.ContextLoaderListener</code>，实现<code>ServletContextListener</code>接口，继承<code>ContextLoader</code>类，上面说过，它实现了Servlet容器启动和关闭时，分别初始化和销毁<code>WebApplicationContext</code>容器。</p><p><img src="http://blog.default.nanwulife.com/01.png" alt=""></p><p>对于<code>ContextLoaderListener</code>，它的初始化和销毁的真正逻辑其实是由父类<code>ContextLoader</code>实现的。</p><ul><li><p>初始化<code>WebApplicationContext</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextLoaderListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 WebApplicationContext，调用父类实现的方法</span></span><br><span class="line">    initWebApplicationContext(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>销毁<code>WebApplicationContext</code>容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ContextLoaderListener.java</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">    closeWebApplicationContext(event.getServletContext());</span><br><span class="line">    ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Servlet-WebApplicationContext"><a href="#Servlet-WebApplicationContext" class="headerlink" title="Servlet WebApplicationContext"></a>Servlet WebApplicationContext</h2><p>Servlet WebApplicationContext也就是Web容器，它的初始化是在<code>DispatcherServlet</code>初始化的过程中执行，并且会将业务容器作为父容器，之所以这样是因为Web容器中的一些Bean会依赖于业务容器中的Bean，比如我们的controller层接口通常会依赖service层的业务逻辑类。</p><p><img src="http://blog.default.nanwulife.com/01%20%281%29.png" alt=""></p><p>以下是这个继承体系中各个类负责的任务，结构还是比较清晰的：</p><ul><li><p><code>HttpServletBean</code>：覆写了父类<code>HttpServlet</code>中的<code>init()</code>方法，是创建Web容器的入口，负责将<code>ServletConfig</code>设置到<code>HttpServletBean</code>的子类对象中（比如<code>DispatcherServlet</code>）。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HttpServletBean.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Simple extension of &#123;<span class="doctag">@link</span> javax.servlet.http.HttpServlet&#125; which treats</span></span><br><span class="line"><span class="comment"> * its config parameters (&#123;<span class="doctag">@code</span> init-param&#125; entries within the</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> servlet&#125; tag in &#123;<span class="doctag">@code</span> web.xml&#125;) as bean properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>FrameworkServlet</code>：覆写了父类<code>HttpServletBean</code>中的<code>initServletBean()</code>方法，负责初始化Servlet WebApplicationContext容器。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FrameworkServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base servlet for Spring's web framework. Provides integration with</span></span><br><span class="line"><span class="comment"> * a Spring application context, in a JavaBean-based overall solution.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li><li><p><code>DispatcherServlet</code>：负责初始化Spring MVC的各个组件，以及处理客户端的请求。类上的简单注释如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DispatcherServlet.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central dispatcher for HTTP request handlers/controllers, e.g. for web UI controllers</span></span><br><span class="line"><span class="comment"> * or HTTP-based remote service exporters. Dispatches to registered handlers for processing</span></span><br><span class="line"><span class="comment"> * a web request, providing convenient mapping and exception handling facilities.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Root-WebApplicationContext/" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 容器的初始化（一）之 Root WebApplicationContext 容器</a></li><li><a href="http://svip.iocoder.cn/Spring-MVC/context-init-Servlet-WebApplicationContext/#5-SourceFilteringListener" target="_blank" rel="noopener">精尽 Spring MVC 源码分析 —— 容器的初始化（二）之 Servlet WebApplicationContext 容器</a></li><li><a href="https://www.tianxiaobo.com/2018/06/30/Spring-MVC-%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A7%98-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/" target="_blank" rel="noopener">Spring MVC 原理探秘 - 容器的创建过程</a>)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;web-xml&quot;&gt;&lt;a href=&quot;#web-xml&quot; class=&quot;headerlink&quot; title=&quot;web.xml&quot;&gt;&lt;/a&gt;web.xml&lt;/h2&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring MVC" scheme="http://yoursite.com/tags/Spring-MVC/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis插件机制</title>
    <link href="http://yoursite.com/2019/05/17/MyBatis%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/17/MyBatis插件机制/</id>
    <published>2019-05-17T14:31:00.000Z</published>
    <updated>2019-05-17T14:33:27.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。MyBatis所允许拦截的接口与方法如下：</p><ul><li><code>Executor</code> </li><li><code>ParameterHandler</code> </li><li><code>ResultSetHandler</code> </li><li><code>StatementHandler</code> </li></ul><h2 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h2><p>如果我们要实现一个插件，比如我们想要拦截<code>Executor</code>的<code>query</code>方法，那么可以这样定义插件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">    <span class="meta">@Signature</span>(</span><br><span class="line">        type = Executor.class,</span><br><span class="line">        method = <span class="string">"query"</span>,</span><br><span class="line">        args =&#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span><br><span class="line">    ),</span><br><span class="line">    <span class="meta">@Signature</span>(...),</span><br><span class="line">    <span class="meta">@Signature</span>(...)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的注解是必须的，<code>@Intercepts</code>注解装载一个<code>@Signature</code>列表，一个<code>@Signature</code>其实就是一个需要拦截的方法封装。那么，当一个拦截器要拦截多个方法，自然就是一个<code>@Signature</code>列表。</p><p>除此之外，我们还需将插件配置到相关文件中，这样MyBatis在启动时可以加载插件，并保存插件实例到拦截器链<code>InterceptorChain</code>中。待准备工作做完后，MyBatis处于就绪状态。我们在执行SQL时，需要先通过<code>DefaultSqlSessionFactory</code>创建<code>SqlSession</code>。<code>Executor</code>实例会在创建<code>SqlSession</code>的过程中被创建，<code>Executor</code>实例创建完毕后，MyBatis会通过JDK动态代理为实例生成代理类。这样，插件逻辑即可在<code>Executor</code>相关方法被调用前执行。配置示例如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.mybatis3.interceptor.ExamplePlugin"</span>&gt;</span></span><br><span class="line">                // ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h2><p><code>Executor</code>实例是在开启<code>SqlSession</code>时被创建的，<code>Executor</code>的创建过程封装在<code>Configuration</code>中，注册插件也正是这个时候：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据 executorType 创建相应的 Executor 实例</span></span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;...&#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册插件</span></span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面创建好<code>Executor</code>后，紧接着通过拦截器链<code>interceptorChain</code>为<code>Executor</code>实例注册代理逻辑（注意是注册而非执行）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Object <span class="title">pluginAll</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 遍历拦截器集合</span></span><br><span class="line">        <span class="keyword">for</span> (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">          <span class="comment">// 调用拦截器的 plugin 方法植入相应的插件逻辑</span></span><br><span class="line">          target = interceptor.plugin(target);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>它的<code>pluginAll()</code>方法会调用具体插件的<code>plugin()</code>方法注册相应的插件逻辑。如果有多个插件，则会多次调用<code>plugin()</code>方法，最终生成一个层层嵌套的代理类。<code>plugin()</code>方法是由具体的插件类实现，以下是一个示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamplePlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrap</span><span class="params">(Object target, Interceptor interceptor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取插件类 @Signature 注解内容</span></span><br><span class="line">    Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap = getSignatureMap(interceptor);</span><br><span class="line">    Class&lt;?&gt; type = target.getClass();</span><br><span class="line">    <span class="comment">// 获取目标类实现的接口</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = getAllInterfaces(type, signatureMap);</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line">      <span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">          type.getClassLoader(),</span><br><span class="line">          interfaces,</span><br><span class="line">          <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上，<code>plugin</code>方法在内部调用了<code>Plugin</code>类的<code>wrap()</code>方法，用于为目标对象生成代理。<code>Plugin</code>类实现了<code>InvocationHandler</code>接口，因此它可以作为参数传给<code>Proxy</code>的<code>newProxyInstance()</code>方法。</p><h2 id="执行插件"><a href="#执行插件" class="headerlink" title="执行插件"></a>执行插件</h2><p>在上面注册插件的过程中，我们在<code>wrap()</code>方法中看到了如下代码，它传入了一个<code>Plugin</code>对象作为参数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 JDK 动态代理为目标类生成代理类</span></span><br><span class="line"><span class="keyword">return</span> Proxy.newProxyInstance(</span><br><span class="line">    type.getClassLoader(),</span><br><span class="line">    interfaces,</span><br><span class="line">    <span class="keyword">new</span> Plugin(target, interceptor, signatureMap));</span><br></pre></td></tr></table></figure></p><p><code>Plugin</code>实现了<code>InvocationHandler</code>接口，因此它的<code>invoke()</code>方法会拦截所有的方法调用。<code>invoke()</code>方法会对所拦截的方法进行检测，以决定是否执行插件逻辑。该方法的逻辑如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plugin</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object target;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Interceptor interceptor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Set&lt;Method&gt;&gt; signatureMap;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取被拦截方法列表</span></span><br><span class="line">      Set&lt;Method&gt; methods = signatureMap.get(method.getDeclaringClass());</span><br><span class="line">     <span class="comment">// 检测方法列表是否包含当前被拦截的方法</span></span><br><span class="line">      <span class="keyword">if</span> (methods != <span class="keyword">null</span> &amp;&amp; methods.contains(method)) &#123;</span><br><span class="line">        <span class="comment">// 执行插件逻辑，在 ExamplePlugin 实现中仅仅为执行被拦截的方法</span></span><br><span class="line">        <span class="keyword">return</span> interceptor.intercept(<span class="keyword">new</span> Invocation(target, method, args));</span><br><span class="line">      &#125;  </span><br><span class="line">      <span class="comment">// 执行被拦截的方法</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.tianxiaobo.com/2018/08/26/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E6%8F%92%E4%BB%B6%E6%9C%BA%E5%88%B6/" target="_blank" rel="noopener">MyBatis 源码分析 - 插件机制</a></li><li><a href="https://my.oschina.net/zudajun/blog/738973" target="_blank" rel="noopener">Mybatis3.4.x技术内幕（十九）：Mybatis之plugin插件设计原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;插件增加了框架的灵活性，使得我们可以根据需要自行对功能进行拓展。在MyBatis中，插件就类似于拦截器，通过拦截相应的方法从而执行插件逻辑。
      
    
    </summary>
    
      <category term="MyBatis" scheme="http://yoursite.com/categories/MyBatis/"/>
    
    
      <category term="MyBatis" scheme="http://yoursite.com/tags/MyBatis/"/>
    
  </entry>
  
</feed>
