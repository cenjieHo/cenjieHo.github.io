<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-04T13:58:07.600Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Netty源码分析：NioEventLoop</title>
    <link href="http://yoursite.com/2019/04/04/etty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ANioEventLoop/"/>
    <id>http://yoursite.com/2019/04/04/etty源码分析：NioEventLoop/</id>
    <published>2019-04-04T12:24:00.000Z</published>
    <updated>2019-04-04T13:58:07.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务端Demo"><a href="#服务端Demo" class="headerlink" title="服务端Demo"></a>服务端Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childAttr(AttributeKey.newInstance(<span class="string">"childAttr"</span>), <span class="string">"childAttrValue"</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> AuthHandler());</span><br><span class="line">                            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(<span class="number">8888</span>).sync();</span><br><span class="line"></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelRegistered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handlerAdded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 耗时的操作</span></span><br><span class="line">                String result = loadFromDB();</span><br><span class="line"></span><br><span class="line">                ctx.channel().writeAndFlush(result);</span><br><span class="line">                ctx.executor().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">loadFromDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><ul><li>默认情况下，Netty服务端起多少线程？何时启动？</li><li>Netty是如何解决jdk空轮询bug的？</li><li>Netty如何保证异步串行无锁化？</li></ul><h2 id="三个部分"><a href="#三个部分" class="headerlink" title="三个部分"></a>三个部分</h2><ul><li>NioEventLoop创建</li><li>NioEventLoop启动</li><li>NioEventLoop执行逻辑</li></ul><h2 id="NioEventLoop创建"><a href="#NioEventLoop创建" class="headerlink" title="NioEventLoop创建"></a>NioEventLoop创建</h2><p><code>new NioEventLoopGroup() [线程组，默认2 * cpu]</code>-&gt;<code>new ThreadPerTaskExecutor() [线程执行器]</code>-&gt;<code>for(){ newChild() } [构造NioEventLoop]</code>-&gt;<code>chosserFactory.newChosser() [线程选择器]</code></p><p>在上面服务端demo代码的开头两行，我们可以看到创建了<code>NioEventLoopGroup</code>，一路跟进我们会来到<code>MultithreadEventLoopGroup</code>的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当我们不传参的时候，<code>nThreads</code>是等于0的，这时候就会使用默认值<code>DEFAULT_EVENT_LOOP_THREADS</code>，也就是cpu核心数的两倍，这也就回答了本文开头的一个问题：默认情况下Netty服务端起多少线程。</p><p>接下来会调用父类<code>MultithreadEventExecutorGroup</code>的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; i ++) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> Think about if this is a good exception type</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++) &#123;</span><br><span class="line">                    EventExecutor e = children[j];</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">while</span> (!e.isTerminated()) &#123;</span><br><span class="line">                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException interrupted) &#123;</span><br><span class="line">                        <span class="comment">// Let the caller handle the interruption.</span></span><br><span class="line">                        Thread.currentThread().interrupt();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;</span><br><span class="line">                terminationFuture.setSuccess(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) &#123;</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet&lt;EventExecutor&gt;(children.length);</span><br><span class="line">    Collections.addAll(childrenSet, children);</span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来重点分析这个构造函数，它完成了NioEventLoop创建的后三个过程。</p><h3 id="ThreadPerTaskExecutor"><a href="#ThreadPerTaskExecutor" class="headerlink" title="ThreadPerTaskExecutor"></a>ThreadPerTaskExecutor</h3><p>每次执行任务都会创建一个线程实体：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadPerTaskExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        threadFactory.newThread(command).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们传入的<code>ThreadFactory</code>是<code>newDefaultThreadFactory()</code>时，对应的<code>newThread</code>方法实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Thread t = newThread(<span class="keyword">new</span> DefaultRunnableDecorator(r), prefix + nextId.incrementAndGet());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Thread <span class="title">newThread</span><span class="params">(Runnable r, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FastThreadLocalThread(threadGroup, r, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，Netty底层使用的不是原生的线程，而是对其进行了一个封装，<code>FastThreadLocalThread</code>继承了原生的<code>Thread</code>，但是对<code>ThreadLocal</code>相关的参数进行了优化，并且自己包装了一个<code>threadLocalMap</code>。???</p><p>还要注意的是，NioEventLoop线程命名规则nioEventLoop-1-xx。</p><h3 id="newChild"><a href="#newChild" class="headerlink" title="newChild()"></a>newChild()</h3><ul><li>保存线程执行器<code>ThreadPerTaskExecutor</code></li><li>创建一个<code>MpscQueue</code></li><li>创建一个selector</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,</span><br><span class="line">             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;</span><br><span class="line">    <span class="keyword">super</span>(parent, executor, <span class="keyword">false</span>, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);</span><br><span class="line">    <span class="keyword">if</span> (selectorProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectorProvider"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (strategy == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"selectStrategy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    provider = selectorProvider;</span><br><span class="line">    selector = openSelector();</span><br><span class="line">    selectStrategy = strategy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用了父类的构造函数后，通过<code>openSelector()</code>方法创建了一个<code>selector</code>，并且和<code>nioEventLoop</code>做了唯一的绑定。再看看父类的构造器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">SingleThreadEventExecutor</span><span class="params">(EventExecutorGroup parent, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    <span class="keyword">boolean</span> addTaskWakesUp, <span class="keyword">int</span> maxPendingTasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    RejectedExecutionHandler rejectedHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.addTaskWakesUp = addTaskWakesUp;</span><br><span class="line">    <span class="keyword">this</span>.maxPendingTasks = Math.max(<span class="number">16</span>, maxPendingTasks);</span><br><span class="line">    <span class="keyword">this</span>.executor = ObjectUtil.checkNotNull(executor, <span class="string">"executor"</span>);</span><br><span class="line">    taskQueue = newTaskQueue(<span class="keyword">this</span>.maxPendingTasks);</span><br><span class="line">    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, <span class="string">"rejectedHandler"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里首先将线程执行器保存了起来，并且创建了一个<code>taskQueue</code>。<code>taskQueue</code>主要用在外部线程在执行Netty的任务时，是将任务塞到任务队列中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Queue&lt;Runnable&gt; <span class="title">newTaskQueue</span><span class="params">(<span class="keyword">int</span> maxPendingTasks)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This event loop never calls takeTask()</span></span><br><span class="line">    <span class="keyword">return</span> PlatformDependent.newMpscQueue(maxPendingTasks);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>？？？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务端Demo&quot;&gt;&lt;a href=&quot;#服务端Demo&quot; class=&quot;headerlink&quot; title=&quot;服务端Demo&quot;&gt;&lt;/a&gt;服务端Demo&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty源码分析：服务端启动</title>
    <link href="http://yoursite.com/2019/04/02/Netty%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%90%AF%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/04/02/Netty源码分析：服务端启动/</id>
    <published>2019-04-02T13:09:00.000Z</published>
    <updated>2019-04-04T12:37:42.780Z</updated>
    
    <content type="html"><![CDATA[<h2 id="服务端Demo"><a href="#服务端Demo" class="headerlink" title="服务端Demo"></a>服务端Demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            b.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                    .childAttr(AttributeKey.newInstance(<span class="string">"childAttr"</span>), <span class="string">"childAttrValue"</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ServerHandler())</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> </span>&#123;</span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> AuthHandler());</span><br><span class="line">                            <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f = b.bind(<span class="number">8888</span>).sync();</span><br><span class="line"></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelActive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRegistered</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"channelRegistered"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"handlerAdded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(<span class="keyword">final</span> ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 耗时的操作</span></span><br><span class="line">                String result = loadFromDB();</span><br><span class="line"></span><br><span class="line">                ctx.channel().writeAndFlush(result);</span><br><span class="line">                ctx.executor().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// ...</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">loadFromDB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端启动"><a href="#服务端启动" class="headerlink" title="服务端启动"></a>服务端启动</h2><p>服务端的启动主要分为四个过程：</p><ul><li>创建服务端Channel</li><li>初始化服务端Channel</li><li>注册Selector</li><li>端口绑定</li></ul><p>接下来将依次介绍这四个过程。</p><h2 id="创建服务端Channel"><a href="#创建服务端Channel" class="headerlink" title="创建服务端Channel"></a>创建服务端Channel</h2><p>服务端Channel创建过程：<code>bind() [用户代码入口]</code>-&gt;<code>initAndRegister() [初始化并注册]</code>-&gt;<code>newChannel() [创建服务端Channel]</code>。</p><p>首先我们从上面的服务端启动demo中的<code>ChannelFuture f = b.bind(8888).sync();</code>这一行进入。经过调用最终会走到<code>doBind()</code>这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();<span class="comment">//从这里进入初始化并注册，创建服务端Channel正是在这个方法里</span></span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的第一行<code>final ChannelFuture regFuture = initAndRegister();</code>其实做了很重要的三件事：创建channel、初始化channel以及将channel注册到selector上，这正是服务端启动的前三个步骤。这里首先关注创建channel的过程，跟进<code>initAndRegister()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Channel channel = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         channel = channelFactory.newChannel();<span class="comment">//在此处创建了服务端Channel</span></span><br><span class="line">         init(channel);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">...</span><br><span class="line">     &#125;</span><br><span class="line">...</span><br><span class="line">     <span class="keyword">return</span> regFuture;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>可以看出服务端channel实际是通过工厂模式创建出来的，<code>newChannel()</code>是<code>channelFactory</code>唯一的方法，并且它是通过反射机制完成的创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectiveChannelFactory</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>&gt; <span class="keyword">implements</span> <span class="title">ChannelFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends T&gt; clazz;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class&lt;? extends T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"clazz"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Unable to create Channel from class "</span> + clazz, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么这个工厂类的<code>clazz</code>对象是在哪传入的呢？其实是通过上面demo中的<code>.channel(NioServerSocketChannel.class)</code>传入的，这个<code>channel</code>方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"channelClass"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory&lt;C&gt;(channelClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这里直接使用了<code>ReflectiveChannelFactory</code>的构造函数，并且将<code>NioServerSocketChannel.class</code>作为参数传入了。因此，我们才能通过<code>newChannel()</code>工厂方法使用反射机制创建出这么一个服务端channel。</p><p>接下来我们看看<code>NioServerSocketChannel</code>这个类的构造函数，因为反射实际就是使用了它的无参构造函数。这个构造函数的过程：<code>newSocket() [通过jdk来创建底层jdk channel]</code>-&gt;<code>NioServerSocketChannelConfig() [tcp参数配置类]</code>-&gt;<code>AbstractNioChannel()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> provider.openServerSocketChannel();<span class="comment">//创建出了jdk底层的channel</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(</span><br><span class="line">                <span class="string">"Failed to open a server socket."</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="keyword">null</span>, channel, SelectionKey.OP_ACCEPT);</span><br><span class="line">    config = <span class="keyword">new</span> NioServerSocketChannelConfig(<span class="keyword">this</span>, javaChannel().socket());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的无参构造函数会通过<code>newSocket()</code>方法创建出jdk底层的channel，然后将其作为参数传给重载的构造函数，再调用父类的构造函数将channel设置成非阻塞模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="keyword">this</span>.ch = ch;</span><br><span class="line">    <span class="keyword">this</span>.readInterestOp = readInterestOp;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ch.configureBlocking(<span class="keyword">false</span>);<span class="comment">//设置成非阻塞模式</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e2) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里还会再进一步调用父类<code>AbstractChannel</code>的构造函数，这个构造函数是对服务端与客户端channel的抽象，给channel设置了id、提供了tcp操作的一个类，并且绑定了pipeline这个组件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();<span class="comment">//channel的唯一标识</span></span><br><span class="line">    unsafe = newUnsafe();<span class="comment">//tcp相关底层操作的一个类</span></span><br><span class="line">    pipeline = newChannelPipeline();<span class="comment">//之后会讲到的非常重要的组件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="初始化服务端Channel"><a href="#初始化服务端Channel" class="headerlink" title="初始化服务端Channel"></a>初始化服务端Channel</h2><p>创建好服务端channel后，就会开始channel的初始化，初始化的入口同样是在<code>initAndRegister</code>中，过程如下：<br><code>init() [初始化入口]</code>-&gt;<code>set ChannelOptions, Channel Attrs</code>-&gt;<code>set ChildOptions, ChildAttrs</code>-&gt;<code>config handler [配置服务端pipeline]</code>-&gt;<code>add ServerBootstrapAcceptor [添加连接器]</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        channel.config().setOptions(options);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(childOptions.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(childAttrs.size()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化就是保存用户自定义的一些属性，通过这些属性创建一个连接接入器，每次<code>accept</code>的时候都会使用这些属性，对用户的连接做一些配置。</p><h2 id="注册selector"><a href="#注册selector" class="headerlink" title="注册selector"></a>注册selector</h2><p>channel创建并初始化完成后，会将其注册到selector上去，这里是大致的过程：<code>AbstractChannel.register(channel) [入口]</code>-&gt;<code>this.eventLoop = eventLoop [绑定线程]</code>-&gt;<code>register0() [实际注册]</code>-&gt;<code>doRegister() [调用jdk底层注册]</code>-&gt;<code>invokeHandlerAddedIfNeeded()</code>-&gt;<code>fireChannelRegistered() [传播事件]</code></p><p>首先依然是在<code>initAndRegister</code>这个方法中，当创建了channel并且初始化完后，会走到以下这行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture regFuture = config().group().register(channel);</span><br></pre></td></tr></table></figure><p>而这一行最终会调用到<code>AbstractChannel.register(EventLoop eventLoop, final ChannelPromise promise);</code>接下来看看这个注册做了哪些事：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;<span class="comment">//告诉AbstractChannel后续的IO事件都交给这个eventLoop处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);<span class="comment">//在这里做了实际的注册</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面比较关键的一行代码是<code>AbstractChannel.this.eventLoop = eventLoop;</code>，之后在以下这个方法中做了实际的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">            doRegister();<span class="comment">//实际的注册</span></span><br><span class="line">            neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">            registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在此连续触发两个事件</span></span><br><span class="line">            pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">            safeSetSuccess(promise);</span><br><span class="line">            pipeline.fireChannelRegistered();</span><br><span class="line">            <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                    pipeline.fireChannelActive();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                    ...</span><br><span class="line">                    beginRead();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().selector, <span class="number">0</span>, <span class="keyword">this</span>);<span class="comment">//调用jdk底层的channel注册，并且将包装了的netty的channel作为attachment绑定到selector上</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!selected) &#123;</span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面服务端demo的代码中可以看到<code>.handler(new ServerHandler())</code>绑定了三个handler，分别是<code>channelRegistered</code>、<code>handlerAdded</code>、<code>channelActive</code>，其中前两个对应着<code>pipeline.fireChannelRegistered();</code>、<code>pipeline.invokeHandlerAddedIfNeeded();</code>，但由于此时端口还未绑定，因此<code>isActive()</code>是返回<code>false</code>的，并不会执行到<code>pipeline.fireChannelActive();</code>，而在端口完成了绑定以后才会真正回调<code>channelActive</code>。</p><h2 id="端口绑定"><a href="#端口绑定" class="headerlink" title="端口绑定"></a>端口绑定</h2><p>在<code>initAndRegister</code>中完成创建、初始化和注册后，接下来就开始绑定端口。绑定的过程大致如下：<br><code>AbstractUnsafe.bind() [入口]</code>-&gt;<code>doBind()</code>-&gt;<code>javaChannel().bind() [jdk底层绑定]</code>-&gt;<code>pipeline.fireChannelActive() [传播事件]</code>-&gt;<code>HeadContext.readIfIsAutoRead()</code>。</p><p>首先走到<code>doBind0()</code>，最终会调用到<code>AbstractChannel</code>的<code>bind()</code>方法。这个<code>bind()</code>方法主要做两件事请：jdk底层绑定、调用<code>fireChannelActive</code>触发相应事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> wasActive = isActive();<span class="comment">//这里由于还未绑定，所以返回false</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doBind(localAddress);<span class="comment">//jdk底册绑定</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<span class="comment">//端口绑定之后，返回true</span></span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下方法调用了jdk底层的绑定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在做完端口绑定之后，会触发<code>channelActive()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法会调用<code>readIfIsAutoRead()</code>，并且触发<code>read</code>事件:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">        channel.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里会传播到<code>tail</code>节点，并且最终会调用到<code>AbstractNioChannel</code>的<code>doBeginRead()</code>方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();<span class="comment">//在之前这里绑定的是0，因此下面的判断为true</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的<code>readInterestOp</code>其实就是一个<code>OP_ACCEPT</code>（一个整型常量<code>1 &lt;&lt; 4</code>），之前在<code>NioServerSocketChannel</code>的构造函数中我们调用了父类的构造函数，并且将<code>OP_ACCEPT</code>传入给了<code>readInterestOp</code>变量，所以这里其实就是向<code>selector</code>注册了一个<code>accept</code>事件。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>服务端启动的核心过程就是这四个：<code>newChannel()</code>-&gt;<code>init()</code>-&gt;<code>doRegister()</code>-&gt;<code>doBind()</code>。</p><p>首先通过工厂方法<code>newChannel()</code>使用反射创建了一个netty的服务端channel，在创建的过程中实际上就是通过<code>newSocket()</code>这个方法使用jdk底层创建了jdk的channel，并且之后还创建了一些基本的组件绑定在netty的服务端channel上，比如<code>pipeline</code>。</p><p><code>init()</code>初始化服务端channel，这个过程最重要的是保存用户自定义的一些属性，并通过这些属性为channel添加一个连接处理器。</p><p>注册过程就是将jdk底层的channel注册到<code>selector</code>上面，并且将netty的channel作为<code>attachment</code>绑定上去。</p><p>最后调用jdk底层实现对本地端口的监听，netty会重新向selector注册一个<code>accept</code>事件，这样netty就可以接受新的连接了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;服务端Demo&quot;&gt;&lt;a href=&quot;#服务端Demo&quot; class=&quot;headerlink&quot; title=&quot;服务端Demo&quot;&gt;&lt;/a&gt;服务端Demo&lt;/h2&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存设计与优化</title>
    <link href="http://yoursite.com/2019/03/31/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/31/Redis缓存设计与优化/</id>
    <published>2019-03-31T12:28:00.000Z</published>
    <updated>2019-03-31T14:45:22.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>Redis过期策略是：定期删除+惰性删除。</p><p>所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置了过期时间的key（全部都检查的话十分消耗CPU资源），检查其是否过期，如果过期了就删除。但仅依赖此策略会有许多过期的key未被检查到，因此Redis还使用惰性删除策略，即在读/写key的时候再检查其是否过期，如果过期了则删除。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果某些key没有被定期删除，也没及时去读/写以触发惰性删除，那么Redis的内存会越来越高，当已用内存超过<code>maxmemory</code>限定时，就会根据内存淘汰机制删除部分key。Redis内存淘汰机制有以下几个：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>一般的缓存系统，都是根据key去缓存查询，如果不存在对应的value，就应该去数据库查找。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对数据库造成很大的压力，这就叫做缓存穿透。</p><p>第一个解决办法是对查询结果为空的键也进行缓存，由于这种方式需要更多的键，所以可以设置一个短一点的过期时间。</p><p>第二个解决方案则是使用布隆过滤器拦截。布隆过滤器的原理是，当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位数组中的K个点，并把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素有可能在。</p><p><img src="http://blog.default.nanwulife.com/booleanfilter.png" alt=""></p><p>通过布隆过滤器，一个一定不存在的数据会被它拦截掉，从而避免了对数据库的查询压力。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，所有请求都会查询数据库，也会给数据库带来很大压力，这就叫做缓存雪崩。对于缓存雪崩有以下几种解决方案：</p><ul><li>可以给缓存设置过期时间时加上一个随机时间，使得每个key的过期时间分散开来，不会集中在同一时刻失效。</li><li>进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li><li>使用分布式缓存。</li><li>提前演练。</li></ul><h2 id="热点key重建"><a href="#热点key重建" class="headerlink" title="热点key重建"></a>热点key重建</h2><p>当前key是一个热点key（比如说某个热门的娱乐新闻），如果在缓存失效时有大量线程并发请求，那么这些线程会同时去访问数据库并重建key，导致后端系统负载过大，甚至因此崩溃。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180629202036949-8223995.png" alt=""></p><p>为此有以下几种解决方案：</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>可以使用互斥锁的方式实现，直接利用redis的<code>set</code>命令即可（如<code>SET mutexKey &quot;1&quot; EX 10086 NX</code>），为了防止该锁未被正确释放，还应给该锁设置一个过期时间。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703003410961-1677269917.png" alt=""></p><p>这种方式的缺点在于重建的过程中别的线程都会处于等待状态，整体性能不高。</p><h3 id="永远不过期"><a href="#永远不过期" class="headerlink" title="永远不过期"></a>永远不过期</h3><p>我们不为每个key设置一个过期时间，但会添加一个逻辑过期时间属性，每次去读的时候都判断一下当前时间是否已经大于逻辑过期时间，如果是的话就使用单独的线程去构建缓存。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703004145474-1329843618.png" alt=""></p><p>这种方式的缺点在于缓存的构建是异步的，因此别的线程在这个过程中依然会取到老值，不保证数据的一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">缓存穿透与缓存雪崩</a></li><li><a href="https://blog.csdn.net/fouy_yun/article/details/81075432" target="_blank" rel="noopener">分布式缓存击穿（布隆过滤器 Bloom Filter）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过期策略&quot;&gt;&lt;a href=&quot;#过期策略&quot; class=&quot;headerlink&quot; title=&quot;过期策略&quot;&gt;&lt;/a&gt;过期策略&lt;/h2&gt;&lt;p&gt;Redis过期策略是：定期删除+惰性删除。&lt;/p&gt;
&lt;p&gt;所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster</title>
    <link href="http://yoursite.com/2019/03/31/Redis-Cluster/"/>
    <id>http://yoursite.com/2019/03/31/Redis-Cluster/</id>
    <published>2019-03-31T05:21:00.000Z</published>
    <updated>2019-03-31T12:22:57.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster作用"><a href="#Redis-Cluster作用" class="headerlink" title="Redis Cluster作用"></a>Redis Cluster作用</h2><p>Redis Cluster是Redis 3.0开始引入的分布式存储方案，集群由多个节点组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制。集群的作用，可以归纳为两点：</p><ul><li>数据分片：集群将数据分散到多个节点，突破了Redis单机内存大小的限制，存储容量大大增加。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。</li></ul><h2 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h2><p>常见的哈希分区方案包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。</p><ul><li>哈希取余分区：哈希取余分区思路非常简单，首先计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</li><li>一致性哈希分区：一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，范围为<code>0 ~ 2^32-1</code>。对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。<br><img src="http://blog.default.nanwulife.com/U%7BKC_N~EU%5DO%5B9_%7B3KK03U58.png" alt=""></li><li>一致性哈希分区（虚拟节点机制）：普通的一致性哈希在服务器节点数量较少时容易产生数据倾斜问题，各个服务器的负载不均匀。为解决这个问题，引入了虚拟节点机制，每台机器可以负责更多节点，数据负担更加均匀。<br><img src="http://blog.default.nanwulife.com/Y90YE9D$%29CU%7B6AA%604QP~VEB.png" alt=""></li><li>虚拟槽分区：Redis Cluser底层使用的虚拟槽分区，有一个长度为16384的虚拟槽，每个Master节点都会负责一部分的槽，Redis对key计算哈希值，使用的算法是CRC16，然后根据哈希值计算数据属于哪个槽，最后根据槽与节点的映射关系，计算数据属于哪个节点。其中哪个节点负责哪个槽，这是可以由用户指定的。<br><img src="http://blog.default.nanwulife.com/1174710-20181025213453407-302249562.png" alt=""></li></ul><h2 id="节点通信机制"><a href="#节点通信机制" class="headerlink" title="节点通信机制"></a>节点通信机制</h2><h3 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h3><p>在redis sentinel中，节点分为数据节点和sentinel节点：前者存储数据，后者实现额外的控制功能。在redis cluster中，没有数据节点与非数据节点之分，所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点都提供了两个TCP端口，普通端口主要用于为客户端提供服务，集群端口用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信。</p><h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>Gossip过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p><img src="http://blog.default.nanwulife.com/v2-575e785e7d03ad317e5bce4e36debb03_b.gif" alt=""></p><p>Gossip协议的优点：</p><ul><li>负载低：比广播低，广播每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li><li>去中心化：Gossip协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li><li>容错性高：网络中任何节点的宕机和重启都不会影响Gossip消息的传播，Gossip协议具有天然的分布式系统容错特性。<br>Gossip协议的缺点：</li><li>消息的延迟：由于节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用Gossip协议会造成不可避免的消息延迟，不适合用在对实时性要求较高的场景下。</li></ul><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>集群节点间发送的消息有以下几种类型：</p><ul><li>meet：在节点握手阶段，当节点收到客户端的<code>cluster meet</code>命令时，会向新加入的节点发送meet消息，请求新节点加入到当前集群，新节点收到meet消息后会回复一个pong消息。</li><li>ping：集群里每个节点每秒钟会选择部分节点发送ping消息，接收者收到消息后会回复一个pong消息。ping消息使用Gossip协议发送，内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。</li><li>pong：pong消息封装了自身状态数据，可以分为两种：第一种是在接到meet/ping消息后回复的pong消息，第二种是指节点向集群广播pong消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播pong消息。</li><li>fail：当一个主节点判断另一个主节点客观下线后，会向集群广播这一fail消息，通知集群中所有节点标记故障节点为客观下线，并通知故障节点的从节点触发故障转移流程。</li><li>publish：节点收到publish命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该publish命令。</li></ul><h2 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h2><h3 id="moved重定向"><a href="#moved重定向" class="headerlink" title="moved重定向"></a>moved重定向</h3><p>moved异常代表槽已经确认迁移至别的节点。</p><p><img src="http://blog.default.nanwulife.com/1.png" alt=""><br><img src="http://blog.default.nanwulife.com/3.png" alt=""></p><h3 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h3><p>在集群缩容扩容的时候，要对槽进行迁移，在迁移的过程中访问一个key，但是key已经迁移到目标节点，那么就会返回一个ask异常。</p><p><img src="http://blog.default.nanwulife.com/6.png" alt=""></p><h3 id="Smart-Client"><a href="#Smart-Client" class="headerlink" title="Smart Client"></a>Smart Client</h3><p>redis-cli这一类客户端称为Dummy客户端，因为它们在执行命令前不知道数据在哪个节点上，因此需要借助moved异常重定向。为了追求性能，我们不可能每次都随机访问一个节点，再根据moved或ask异常去重定向到目标节点，因此需要实现一个Smart客户端，比如说JedisCluster。JedisCluster的基本原理大致如下：</p><ol><li>从集群中选一个可运行节点，使用<code>cluster slots</code>命令并将结果映射到本地，这样本地就有了slot-&gt;node的映射关系缓存。</li><li>JedisCluster为每个节点创建连接池(即JedisPool)。</li><li>当执行命令时，JedisCluster根据key-&gt;slot-&gt;node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现moved错误时，刷新本地的映射关系缓存。</li></ol><p>这里需要注意的是，JedisCluster中已经包含所有节点的连接池，因此JedisCluster要使用单例。</p><h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>集群伸缩的核心是槽迁移，通过修改槽与节点的对应关系，实现槽（即数据）在节点之间的移动。例如，如果槽均匀分布在集群的3个节点中，此时增加一个节点，则需要从3个节点中分别拿出一部分槽给新节点，从而实现槽在4个节点中的均匀分布。</p><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><ol><li>启动节点</li><li>加入集群：使用<code>cluster meet</code>命令。</li><li>迁移槽和数据</li></ol><h3 id="减少节点"><a href="#减少节点" class="headerlink" title="减少节点"></a>减少节点</h3><ol><li>迁移槽和数据</li><li>忘记节点：使用<code>cluster forget</code>命令</li><li>关闭节点</li></ol><p>这里要注意应先下线从节点再下线主节点，因为若主节点先下线，会触发故障的自动转移。</p><p>在槽迁移未完成时，客户端访问了负责该槽的节点，但key此时已经迁移到了别的节点下，这时候会返回ask异常，通过这个机制使得redis cluster可以无痛的完成扩缩容操作。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>集群对故障发现与故障转移的实现与哨兵思路类似：通过定时任务发送ping消息检测其他节点状态，若某个主节点发现另一个主节点不可用（与参数<code>cluster-node-timeout</code>有关），则标记该节点进行主观下线，而当半数以上持有槽的主节点都标记该节点主观下线，则对该节点进行客观下线，并向集群广播fail消息，让集群中所有节点都将其标记为客观下线，并触发从节点的故障转移。</p><p>在故障转移阶段，主要有以下几个步骤：</p><ul><li>检查资格：每个从节点都会检查与故障主节点的断线时间，如果超过默认值150s（<code>cluster-node-timeout * cluster-slave-validity-factor</code>）则会取消资格。</li><li>准备选举时间：为了保证偏移量比较大的从节点更有可能成为主节点，会将该从节点的延迟时间设置更小一些。</li><li>选举投票：从节点选举胜出需要的票数为N/2+1，其中N为主节点数量（包括故障主节点），但故障主节点实际上不能投票。因此为了能够在故障发生时顺利选出从节点，集群中至少需要3个主节点。</li><li>替换主节点。</li></ul><p>与哨兵一样，集群只实现了主节点的故障转移，从节点故障时只会被下线，不会进行故障转移。因此，使用集群时，应谨慎使用读写分离技术，因为从节点故障会导致读服务不可用，可用性变差。</p><h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><h3 id="cluster-node-timeout"><a href="#cluster-node-timeout" class="headerlink" title="cluster_node_timeout"></a>cluster_node_timeout</h3><p><code>cluster_node_timeout</code>的默认值是15s，影响包括：</p><ul><li>值越大对延迟容忍度越高，并且由于节点发现与其它节点最后通信时间超过<code>cluster_node_timeout / 2</code>时会直接发送ping消息，因此调大该参数还可以降低带宽消耗，但同时也会降低收敛速度。</li><li>影响故障转移的判定和时间，值越大越不容易误判，但完成转移消耗时间越长。</li></ul><h3 id="cluster-require-full-coverage"><a href="#cluster-require-full-coverage" class="headerlink" title="cluster-require-full-coverage"></a>cluster-require-full-coverage</h3><p><code>cluster-require-full-coverage</code>参数设置为yes时，当主节点发生故障而故障转移尚未完成，原主节点中的槽不在任何节点中，此时集群会处于下线状态，无法响应客户端的请求。但在实际应用中为了保证服务的高可用性，都会将该参数设置为no。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://duqingfeng.net/2018/06/12/%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%E6%8A%80%E6%9C%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E3%80%81Redis%20cluster%E8%99%9A%E6%8B%9F%E6%A7%BD%EF%BC%89/" target="_blank" rel="noopener">哈希分区技术之间的对比（一致性哈希、Redis cluster虚拟槽）</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a></li><li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener">P2P 网络核心技术：Gossip 协议</a></li><li><a href="https://enpsl.top/2019/01/24/2019-01-24-redis-cluster-route/" target="_blank" rel="noopener">Redis cluster 客户端路由</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Cluster作用&quot;&gt;&lt;a href=&quot;#Redis-Cluster作用&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster作用&quot;&gt;&lt;/a&gt;Redis Cluster作用&lt;/h2&gt;&lt;p&gt;Redis Cluster是Redi
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper集群节点为什么推荐为奇数</title>
    <link href="http://yoursite.com/2019/03/31/Zookeeper%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E4%B8%BA%E5%A5%87%E6%95%B0/"/>
    <id>http://yoursite.com/2019/03/31/Zookeeper集群节点为什么推荐为奇数/</id>
    <published>2019-03-31T03:36:00.000Z</published>
    <updated>2019-03-31T03:58:27.604Z</updated>
    
    <content type="html"><![CDATA[<p>不止包括Zookeeper集群，其它大多数集群都推荐节点数最好为奇数个，因此本文将详细说明其中的缘由。首先我们需要明白一个概念“脑裂”：</p><blockquote><p>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，每个小集群都认为其它小集群的节点是不可用的，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。</p></blockquote><p>在zookeeper的选举过程中，有个规则是要求可用节点数量&gt;总节点数量/2。之所以会有这样的要求，就是为了防止集群出现脑裂的时候，可能会出现多个子集群同时服务的情况（即子集群各组选举出自己的leader）。如果遵守这个规则，那么只会有一个子集群能进行Leader选举，因为当前集群中只可能有一个子集群的节点数能超过总节点数的一半。</p><p>说明了可用节点数量&gt;总节点数量/2这个规则后，我们再进一步探索为什么Zookeeper集群节点数推荐为奇数个。主要有以下两个原因：</p><h2 id="1-防止脑裂造成集群不可用"><a href="#1-防止脑裂造成集群不可用" class="headerlink" title="1. 防止脑裂造成集群不可用"></a>1. 防止脑裂造成集群不可用</h2><p>如果集群的数量为偶数个，那么在发生脑裂的时候，可能两个子集群的数量都无法超过总节点数量的一半，也就无法满足Zookeeper进行选举的规则，这时候整个服务对外是彻底不可用的。但是如果集群的数量为奇数个的话，发生脑裂时必然有一个子集群的节点数目大于总节点数目的一半，这时候可以保证当前服务对外依然是可用的。</p><h2 id="2-在容错能力相同的情况下，奇数台更节省资源"><a href="#2-在容错能力相同的情况下，奇数台更节省资源" class="headerlink" title="2. 在容错能力相同的情况下，奇数台更节省资源"></a>2. 在容错能力相同的情况下，奇数台更节省资源</h2><p>比如说，如果当前集群有四个节点，要想完成Leader选举，只允许一个节点不可用，这样才能保证可用的节点数大于总节点数的一半。但如果当前集群有三个节点，要想完成Leader选举，同样也只允许一个节点不可用，因为只有当两个节点都存活的时候才能满足可用节点数大于总节点数的一半。可以看出，以上两个集群都只有一个节点的容错能力，但是第二个集群比第一个集群节约了更多的资源，因此，更推荐Zookeeper的节点数为奇数个。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不止包括Zookeeper集群，其它大多数集群都推荐节点数最好为奇数个，因此本文将详细说明其中的缘由。首先我们需要明白一个概念“脑裂”：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，每个小集群都认为其它
      
    
    </summary>
    
      <category term="Zookeeper" scheme="http://yoursite.com/categories/Zookeeper/"/>
    
    
      <category term="Zookeeper" scheme="http://yoursite.com/tags/Zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Redis Sentinel</title>
    <link href="http://yoursite.com/2019/03/30/Redis-Sentinel/"/>
    <id>http://yoursite.com/2019/03/30/Redis-Sentinel/</id>
    <published>2019-03-30T13:45:00.000Z</published>
    <updated>2019-03-31T05:33:44.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Sentinel架构"><a href="#Redis-Sentinel架构" class="headerlink" title="Redis Sentinel架构"></a>Redis Sentinel架构</h2><p>复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的，但它故障恢复无法自动化，因此Redis提供了哨兵（Sentinel）这么一个高可用方案。Redis Sentinel由两部分组成，哨兵节点和数据节点：</p><ul><li>哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的redis节点，不存储数据。</li><li>数据节点：主节点和从节点都是数据节点。</li></ul><p><img src="http://blog.default.nanwulife.com/1174710-20180908182924632-1069251418.png" alt=""></p><p>Redis Sentinel具有以下功能：</p><ul><li>监控：哨兵通过心跳检测会不断地检查主节点和从节点是否运作正常。</li><li>自动故障转移：当主节点不能正常工作时，哨兵会开始自动故障转移操作，它会将失效主节点的其中一个从节点升级为新的主节点，并让其他从节点改为复制新的主节点。</li><li>配置提供者：客户端在初始化时，通过连接哨兵来获得当前Redis服务的主节点地址。</li><li>通知：哨兵可以将故障转移的结果发送给客户端。</li></ul><h2 id="客户端连接Redis-Sentinel"><a href="#客户端连接Redis-Sentinel" class="headerlink" title="客户端连接Redis Sentinel"></a>客户端连接Redis Sentinel</h2><p>对于Redis Sentinel，它仅仅完成了服务端的高可用，当master挂掉时能选举出一个新的master节点来完成故障转移，但是我们客户端并没有去连接新的master节点，因此我们还要使得客户端也是高可用的。</p><p>Jedis客户端对Redis Sentinel提供了很好的支持。我们只需要向Jedis提供sentinel节点集合和<code>masterName</code>，构造<code>JedisSentinelPool</code>对象，然后便可以像使用普通redis连接池一样来使用了：通过<code>pool.getResource()</code>获取连接，执行具体的命令。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSentinel</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">         String masterName = <span class="string">"mymaster"</span>;</span><br><span class="line">         Set&lt;String&gt; sentinels = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26379"</span>);</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26380"</span>);</span><br><span class="line">         sentinels.add(<span class="string">"192.168.92.128:26381"</span>);</span><br><span class="line"> </span><br><span class="line">         JedisSentinelPool pool = <span class="keyword">new</span> JedisSentinelPool(masterName, sentinels); <span class="comment">//初始化过程做了很多工作</span></span><br><span class="line">         Jedis jedis = pool.getResource();</span><br><span class="line">         jedis.set(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">         pool.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在整个过程中，我们的代码不需要显式的指定主节点的地址，就可以连接到主节点。代码中对故障转移也没有任何体现，就可以在sentinel完成故障转移后自动的切换主节点。之所以可以做到这些，是因为客户端完成了以下几个工作：</p><ul><li>遍历sentinel节点，找到一个可用的sentinel节点，通过<code>sentinel get-master-addr-by-name</code>命令获取master节点的信息（IP和端口），之后再对master节点执行<code>role</code>命令判断其是否真的为master节点。</li><li>客户端和sentinel使用了一个发布订阅模式，客户端订阅sentinel的某一个频道，当master发生变化时，sentinel向这个频道发布一条消息，客户端就可以获取再对新的master进行一个连接。</li></ul><p>前面说过sentinel相当于配置提供者，我们得到了sentinel的集合后就可以通过sentinel节点获取到master的地址。这里要注意sentinel只是配置提供者，而不是代理，二者的区别在于如果是配置提供者，客户端在通过sentinel获得master信息后，会直接建立到master的连接，后续的请求会直接发向master，而如果是代理，客户端的每一次请求都会发向sentinel，sentinel再通过主节点处理请求。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="三个定时任务"><a href="#三个定时任务" class="headerlink" title="三个定时任务"></a>三个定时任务</h3><ul><li>10秒每个sentinel对master和slave执行info，以此发现slave节点并确认主从关系。</li><li>2秒每个sentinel通过master节点的channel交换信息（因此sentinel节点之间能够自动感知）。</li><li>每1秒每个sentinel对其它sentinel和redis执行ping也就是心跳检测。</li></ul><h3 id="主观下线和客观下线"><a href="#主观下线和客观下线" class="headerlink" title="主观下线和客观下线"></a>主观下线和客观下线</h3><ul><li>主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线。</li><li>客观下线：哨兵节点在对主节点进行主观下线后，会通过<code>sentinel is-master-down-by-addr</code>命令询问其他哨兵节点该主节点的状态。如果判断主节点下线的哨兵数量达到设置的法定人数（quorum），则对该主节点进行客观下线。</li></ul><p>需要特别注意的是，客观下线是主节点才有的概念，如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</p><h3 id="领导者选举"><a href="#领导者选举" class="headerlink" title="领导者选举"></a>领导者选举</h3><p>由于只需要一个sentinel节点完成故障转移，因此sentinel内部需要选举出一个节点作为领导者，同样也是通过<code>sentinel is-master-down-by-addr</code>这个命令完成领导者的选举（这正是这条命令的第二个作用）。过程如下：</p><ol><li>每个做主观下线的sentinel节点向其它sentinel节点发送命令，要求将它设置为领导者。</li><li>收到命令的sentinel节点如果没有同意通过其它sentinel节点发送的命令，那么将同意该请求，否则拒绝。</li><li>如果该sentinel节点发现自己的票数已经超过sentinel集合半数并且超过quorum，那么将它成为领导者。</li></ol><p>需要特别注意的是，客观下线是主节点才有的概念，如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。</p><h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>完成了领导者选举后，由领导者进行故障转移操作：</p><ol><li>从slave节点中选出一个“合适的”节点作为新的master节点：选择优先级最高的从节点(由<code>slave-priority</code>指定)；如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。</li><li>对上面slave节点执行<code>slaveof no one</code>命令让其成为master节点。</li><li>向剩余的slave节点发送命令，让它们成为新master节点的slave节点，复制规则和<code>parallel-syncs</code>参数有关。</li><li>更新原来master节点配置为slave，并保持着对其“关注”，当其恢复后命令它去复制新的master节点。</li></ol><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><p>Redis Sentinel无法对从节点进行自动故障转移，在读写分离场景下，从节点故障会导致读服务不可用，需要我们对从节点做额外的监控、切换操作。除此之外，它的存储能力受到单机限制的问题，因此如果我们对扩容有需求的话，应当使用Redis Cluster这么一个高可用的集群方案。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9609938.html#t33" target="_blank" rel="noopener">深入学习Redis（4）：哨兵</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Sentinel架构&quot;&gt;&lt;a href=&quot;#Redis-Sentinel架构&quot; class=&quot;headerlink&quot; title=&quot;Redis Sentinel架构&quot;&gt;&lt;/a&gt;Redis Sentinel架构&lt;/h2&gt;&lt;p&gt;复制是高可用Redis的基础
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis主从复制</title>
    <link href="http://yoursite.com/2019/03/30/dis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    <id>http://yoursite.com/2019/03/30/dis主从复制/</id>
    <published>2019-03-30T08:06:00.000Z</published>
    <updated>2019-03-31T05:34:03.229Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>主从复制是指将主节点（master）的数据复制到从节点（slave）中，数据的复制是单向的，只能由主节点到从节点。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>主从复制过程大体可以分为3个阶段：连接建立阶段、数据同步阶段、命令传播阶段。</p><h3 id="连接建立阶段"><a href="#连接建立阶段" class="headerlink" title="连接建立阶段"></a>连接建立阶段</h3><p>主从复制的开启，完全是在从节点发起的（通过<code>slaveof</code>命令），不需要我们在主节点做任何事情。需要注意的是，<code>slaveof</code>是异步命令，从节点完成主节点ip和port的保存后，向发送<code>slaveof</code>命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p><h3 id="数据同步阶段"><a href="#数据同步阶段" class="headerlink" title="数据同步阶段"></a>数据同步阶段</h3><p>主从节点之间的连接建立以后，便可以开始进行数据同步。数据同步阶段是主从复制最核心的阶段，由从节点向主节点发送<code>psync</code>命令开始同步，并且根据主从节点当前状态的不同，可以分为全量复制和部分复制。</p><p><img src="http://blog.default.nanwulife.com/psync.jpg" alt=""></p><h4 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h4><p>全量复制用于初次复制或其他无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。执行过程如下：</p><ul><li>主节点收到全量复制的命令后，执行<code>bgsave</code>，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</li><li>主节点的<code>bgsave</code>执行完成后，将RDB文件发送给从节点，从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行<code>bgsave</code>时的数据库状态。</li><li>主节点将复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</li><li>如果从节点开启了AOF，则会触发<code>bgrewriteaof</code>的执行，从而保证AOF文件更新至主节点的最新状态。</li></ul><h4 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h4><p>复制偏移量：主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数。主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。</p><p>复制缓冲区：复制缓冲区是由主节点维护的、固定长度的、先进先出队列，默认大小1MB，当主节点开始有从节点时创建。在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制缓冲区，作为写命令的备份。除了存储写命令，复制缓冲区中还存储了其中的每个字节对应的复制偏移量（offset）。由于复制缓冲区定长且是先进先出，所以它保存的是主节点最近执行的写命令，时间较早的写命令会被挤出缓冲区，因此当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。</p><p>服务器运行ID（runid）：每个Redis节点（无论主从），在启动时都会自动生成一个随机ID（每次启动都不一样），runid用来唯一识别一个Redis节点。主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来。当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p><ul><li>如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li><li>如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li></ul><h3 id="命令传播阶段"><a href="#命令传播阶段" class="headerlink" title="命令传播阶段"></a>命令传播阶段</h3><p>数据同步阶段完成后，主从节点进入命令传播阶段。在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复，因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>在没有使用哨兵或集群的场景下，当主节点挂掉了以后，从节点没法完成master选举，从而导致整个服务对外不可用。我们需要自行选择一个从节点作为主节点并继续对外提供服务，并将其它从节点的主节点设为它，由于这些过程都需要手动完成，出错率比较高，因此在真实场景中往往都会使用哨兵或者集群来实现系统的高可用。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9236731.html" target="_blank" rel="noopener">深入学习Redis（3）：主从复制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;主从复制是指将主节点（master）的数据复制到从节点（slave）中，数据的复制是单向的，只能由主节点到从节点。&lt;/p&gt;
&lt;h2 id=&quot;
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis持久化：AOF与RDB</title>
    <link href="http://yoursite.com/2019/03/30/Redis%E4%BA%94%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/30/Redis五种数据类型/</id>
    <published>2019-03-30T03:30:00.000Z</published>
    <updated>2019-03-30T08:05:54.264Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h2><p>Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将Redis中的数据以某种形式(数据或命令)从内存保存到硬盘，当下次Redis重启时，利用持久化文件实现数据恢复。</p><p>Redis持久化分为RDB持久化和AOF持久化：前者将当前数据保存到硬盘，后者则是将每次执行的写命令保存到硬盘（类似于MySQL的binlog）。</p><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>RDB持久化是将当前进程中的数据生成快照保存到硬盘，保存的文件后缀是rdb，当Redis重新启动时，可以读取快照文件恢复数据。RDB持久化分为手动触发和自动触发两种方式：</p><h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>手动触发可以使用<code>save</code>命令和<code>bgsave</code>命令，都可以生成rdb文件。它们的区别在于<code>save</code>命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理任何命令请求；而<code>bgsave</code>命令会创建一个子进程，由子进程来负责创建RDB文件，父进程（即Redis主进程）则继续处理请求，整个过程中只有<code>fork</code>子进程时会阻塞服务器。</p><h3 id="自动触发"><a href="#自动触发" class="headerlink" title="自动触发"></a>自动触发</h3><p>自动触发最常见的情况是在配置文件中通过<code>save m n</code>，指定当m秒内发生n次变化时，会触发<code>bgsave</code>。例如默认配置文件中有以下三行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></p><p>只要上面三行任意一条满足时，就会执行<code>bgsave</code>。除此之外，在主从复制的场景下，如果从节点执行全量复制操作，则主节点会执行<code>bgsave</code>命令，并将rdb文件发送给从节点。执行<code>shutdown</code>命令时，也会自动执行rdb持久化。</p><h3 id="启动时加载"><a href="#启动时加载" class="headerlink" title="启动时加载"></a>启动时加载</h3><p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。但是由于AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>RDB持久化是将进程数据写入文件，而AOF持久化则是将Redis执行的每次写命令记录到单独的日志文件中（有点像MySQL的binlog），当Redis重启时再次执行AOF文件中的命令来恢复数据。与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</p><h3 id="三种策略"><a href="#三种策略" class="headerlink" title="三种策略"></a>三种策略</h3><p>为了提高文件写入效率，在现代操作系统中，当用户将数据写入文件时（<code>write</code>命令），操作系统通常会将数据暂存到一个内存缓冲区里，当缓冲区被填满或超过了指定时限，才真正将缓冲区的数据写入到硬盘里。这样的操作虽然提高了效率，但如果系统崩溃，内存缓冲区中的数据将会丢失。因此可以设置同步选项，强制操作系统什么时候将缓冲区中的数据写入到硬盘中（<code>fsync</code>命令），Redis提供了以下三种同步策略：</p><ul><li>always：每个写命令都同步</li><li>everysec：每秒同步一次</li><li>no：让操作系统来决定何时同步</li></ul><p>always会严重降低服务器的性能，而no的不可控性太强，因此Redis使用everysec作为默认配置，但在系统崩溃时可能会丢失一秒的数据。</p><h3 id="文件重写"><a href="#文件重写" class="headerlink" title="文件重写"></a>文件重写</h3><p>随着Redis服务器执行的写命令越来越多，AOF文件也会越来越大，过大的AOF文件不仅会影响服务器的正常运行，也会导致数据恢复需要的时间过长。文件重写是指定期重写AOF文件，减小AOF文件的体积。需要注意的是，AOF重写是把Redis进程内的数据转化为写命令，同步到新的AOF文件，而不会对旧的AOF文件进行任何读取、写入操作。</p><p>文件重写主要是针对以下一些语句：</p><ul><li>过期的数据（如<code>expire</code>），可以不用再写入文件。</li><li>多次<code>INCR</code>命令可以合并为一个<code>SET</code>命令。</li><li>无效的命令不再写入文件，比如有些数据被删除了。</li></ul><h3 id="手动触发-1"><a href="#手动触发-1" class="headerlink" title="手动触发"></a>手动触发</h3><p>可以直接调用<code>bgrewriteaof</code>命令重写文件，该命令的执行与<code>bgsave</code>有些类似，都是<code>fork</code>子进程进行具体的工作，且都只有在<code>fork</code>时阻塞。</p><h3 id="自动触发-1"><a href="#自动触发-1" class="headerlink" title="自动触发"></a>自动触发</h3><p>默认配置是当AOF文件大小是上次重写后大小的一倍（<code>auto-aof-rewrite-min-size</code>）且文件大于64M时触发（<code>auto-aof-rewrite-percentage</code>）。</p><h3 id="具体流程"><a href="#具体流程" class="headerlink" title="具体流程"></a>具体流程</h3><ol><li>父进程执行<code>fork</code>操作创建子进程，这个过程中父进程是阻塞的。</li><li>子进程创建后，Redis的所有写命令依然写入AOF缓冲区，并根据设置策略同步到硬盘，保证原有AOF机制的正确。</li><li>由于<code>fork</code>操作使用写时复制技术，子进程只能共享<code>fork</code>操作时的内存数据。由于父进程依然在响应命令，因此Redis使用AOF重写缓冲区（图中的aof_rewrite_buf）保存这部分数据，防止新AOF文件生成期间丢失这部分数据。也就是说，bgrewriteaof执行期间，Redis的写命令同时追加到aof_buf和aof_rewirte_buf两个缓冲区。</li><li>子进程根据内存快照，按照命令合并规则写入到新的AOF文件。</li><li>子进程写完新的AOF文件后，向父进程发信号，父进程把AOF重写缓冲区的数据写入到新的AOF文件，这样就保证了新AOF文件所保存的数据库状态和服务器当前状态一致。</li><li>使用新的AOF文件替换老文件，完成AOF重写。</li></ol><p><img src="http://blog.default.nanwulife.com/1174710-20180605092001589-1724580361.png" alt=""></p><h2 id="RDB与AOF对比"><a href="#RDB与AOF对比" class="headerlink" title="RDB与AOF对比"></a>RDB与AOF对比</h2><ul><li>RDB持久化：RDB文件紧凑，体积小，恢复速度比AOF快很多，但数据的实时性较低。</li><li>AOF持久化：实时性较高，但是文件大，并且恢复速度较慢，且对性能有一定影响。</li></ul><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="fork阻塞：CPU的阻塞"><a href="#fork阻塞：CPU的阻塞" class="headerlink" title="fork阻塞：CPU的阻塞"></a>fork阻塞：CPU的阻塞</h3><p>在Redis中，无论是RDB持久化的<code>bgsave</code>，还是AOF重写的<code>bgrewriteaof</code>，都需要<code>fork</code>出子进程来进行操作，而在操作系统<code>fork</code>的实现中，基本都采用了写时复制技术，即在父/子进程试图修改数据空间之前，父子进程实际上共享数据空间，但是当父/子进程的任何一个试图修改数据空间时，操作系统会为修改的那一部分（内存的一页）制作一个副本。</p><p>也就是说，虽然<code>fork</code>时子进程不会复制父进程的数据空间，但是会复制内存页表，如果Redis内存过大，会导致fork操作时复制内存页表耗时过多，而Redis主进程在进行<code>fork</code>时是完全阻塞的，意味着无法响应客户端的请求，造成请求延迟过大。</p><p>为了防止该问题的发生，我们需要控制Redis单机内存的大小，并且适当放宽AOF重写的触发条件，尽量在写入较少的时间段完成重写。</p><h3 id="AOF追加阻塞：硬盘的阻塞"><a href="#AOF追加阻塞：硬盘的阻塞" class="headerlink" title="AOF追加阻塞：硬盘的阻塞"></a>AOF追加阻塞：硬盘的阻塞</h3><p>AOF持久化过程中，通过<code>fsync</code>命令每秒一次将缓冲区的数据写入磁盘中，但在硬盘负载过高时，<code>fsync</code>操作可能会超过1s，当继续向缓冲区内写入数据时，磁盘负载会越来越大，如果此时Redis进程异常退出，丢失的数据也有可能远超1s。</p><p>为此，Redis的处理策略是这样的：主线程每次进行AOF会对比距离上次<code>fsync</code>成功的时间，如果距上次不到2s，主线程直接返回；如果超过2s，则主线程阻塞直到<code>fsync</code>同步完成。因此，如果系统硬盘负载过大导致<code>fsync</code>速度太慢，会导致Redis主线程的阻塞。这里还要注意的是，如果使用everysec策略，AOF最多可能丢失2s的数据，而不是1s。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="https://www.cnblogs.com/kismetv/p/9137897.html" target="_blank" rel="noopener">深入学习Redis（2）：持久化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis持久化&quot;&gt;&lt;a href=&quot;#Redis持久化&quot; class=&quot;headerlink&quot; title=&quot;Redis持久化&quot;&gt;&lt;/a&gt;Redis持久化&lt;/h2&gt;&lt;p&gt;Redis是内存数据库，数据都是存储在内存中，为了避免进程退出导致数据的永久丢失，需要定期将
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Linux五种IO模型</title>
    <link href="http://yoursite.com/2019/03/27/Linux-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2019/03/27/Linux-五种IO模型/</id>
    <published>2019-03-27T02:39:00.000Z</published>
    <updated>2019-03-27T05:05:05.220Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>对于一次IO访问，会分为两个阶段，首先等待数据准备好后被拷贝到操作系统内核的缓冲区中，然后再从操作系统内核的缓冲区拷贝到用户空间。IO模型可以分为以下五种类型：</p><ul><li>阻塞式I/O（Blocking I/O）</li><li>非阻塞式I/O（Non-blocking I/O）</li><li>多路复用I/O（Multiplexing I/O）</li><li>信号驱动I/O（Signal-driven I/O）</li><li>异步I/O（Asynchronous I/O）</li></ul><p>其中信号驱动式IO并不常用，所以重点关注另外四种IO模型。</p><h2 id="阻塞式I-O"><a href="#阻塞式I-O" class="headerlink" title="阻塞式I/O"></a>阻塞式I/O</h2><p>在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的IO。</p><p>阻塞IO的特点就是能够及时的返回数据，但是在IO执行的两个阶段都被阻塞了，只有当数据从内核复制到了用户空间中，进程才能继续往下执行，因此对性能有所牺牲。</p><p><img src="http://blog.default.nanwulife.com/1492928416812_4.png" alt=""></p><h2 id="非阻塞式I-O"><a href="#非阻塞式I-O" class="headerlink" title="非阻塞式I/O"></a>非阻塞式I/O</h2><p>应用进程执行系统调用之后，内核会立即返回一个错误码，但IO操作还没完成。此时应用进程并没有被阻塞，可以继续执行，但是需要不断的执行系统调用来获知IO操作是否完成，这种方式称为轮询。</p><p>这种模型的CPU利用率比较低，并且因为每过一段时间才去轮询一次，所以存在一个响应延迟。还需要注意的是，拷贝数据的整个过程，进程仍然是属于阻塞的状态。</p><p><img src="http://blog.default.nanwulife.com/1492929000361_5.png" alt=""></p><h2 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h2><p>使用<code>select</code>或者<code>poll</code>对多个IO端口进行监听，只要多个套接字中的任何一个数据准备好了，就能返回可读，之后应用进程再执行recvfrom系统调用把数据从内核复制到进程中。</p><p>I/O复用模型让单个进程具有处理多个I/O事件的能力，因此相比多进程和多线程技术，它的系统开销小了许多。但是<code>select</code>，<code>poll</code>，<code>epoll</code>函数依然会阻塞应用进程，并且由于多路复用可以处理多个IO，那么多个IO之间的顺序就变得不确定了。</p><p><img src="http://blog.default.nanwulife.com/1492929444818_6.png" alt=""></p><h2 id="信号驱动I-O"><a href="#信号驱动I-O" class="headerlink" title="信号驱动I/O"></a>信号驱动I/O</h2><p>应用进程使用sigaction系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送SIGIO信号，应用进程收到之后在信号处理程序中调用recvfrom将数据从内核复制到应用进程中。</p><p>相比于非阻塞式I/O的轮询方式，信号驱动I/O的CPU利用率更高。</p><p><img src="http://blog.default.nanwulife.com/1492929553651_7.png" alt=""></p><h2 id="异步非阻塞I-O"><a href="#异步非阻塞I-O" class="headerlink" title="异步非阻塞I/O"></a>异步非阻塞I/O</h2><p>用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户进程就可以去做别的事情。等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。这个IO模式的两个阶段，进程都是非阻塞的。</p><p><img src="http://blog.default.nanwulife.com/1492930243286_8.png" alt=""></p><h2 id="五种I-O模型对比"><a href="#五种I-O模型对比" class="headerlink" title="五种I/O模型对比"></a>五种I/O模型对比</h2><ul><li>阻塞式I/O：同步阻塞</li><li>非阻塞式I/O：同步非阻塞（轮询）</li><li>I/O多路复用：同步阻塞（可以监听多个IO）</li><li>信号驱动I/O：同步非阻塞（收到SIGIO信号后才执行recvfrom并阻塞）</li><li>异步I/O：异步非阻塞（两个阶段都不会阻塞）</li></ul><p><img src="http://blog.default.nanwulife.com/1492928105791_3.png" alt=""></p><h2 id="I-O多路复用中的select、poll、epoll"><a href="#I-O多路复用中的select、poll、epoll" class="headerlink" title="I/O多路复用中的select、poll、epoll"></a>I/O多路复用中的select、poll、epoll</h2><p>select，poll，epoll都是IO多路复用的机制，select出现的最早，之后是poll，再是epoll。I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。</p><blockquote><p>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p></blockquote><ul><li><strong>select</strong>：它仅仅知道有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，测试每个流是否有事件发生，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的时间复杂度，同时处理的流越多，无差别轮询时间就越长。</li><li><strong>poll</strong>：poll本质上和select没有区别，需要查询每个fd对应的设备状态，但是它没有最大连接数的限制，因为select的描述符类型使用数组实现，而poll的描述符类型使用链表实现。</li><li><strong>epoll</strong>：epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">Linux IO模式及 select、poll、epoll详解</a></li><li><a href="https://www.cnblogs.com/aspirant/p/9166944.html" target="_blank" rel="noopener">select、poll、epoll之间的区别(搜狗面试)</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;IO模型&quot;&gt;&lt;a href=&quot;#IO模型&quot; class=&quot;headerlink&quot; title=&quot;IO模型&quot;&gt;&lt;/a&gt;IO模型&lt;/h2&gt;&lt;p&gt;对于一次IO访问，会分为两个阶段，首先等待数据准备好后被拷贝到操作系统内核的缓冲区中，然后再从操作系统内核的缓冲区拷贝到用户
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="IO" scheme="http://yoursite.com/tags/IO/"/>
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>NIO知识点总结</title>
    <link href="http://yoursite.com/2019/03/10/NIO%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/03/10/NIO知识点总结/</id>
    <published>2019-03-10T12:55:00.000Z</published>
    <updated>2019-03-11T13:08:04.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Java NIO是一个可以替代标准Java IO API的IO API，主要有以下三个核心组件：</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>NIO与IO的主要区别在于：</p><ul><li>IO是面向流的，NIO是面向缓冲区的。</li><li>IO是阻塞的，NIO是非阻塞的。</li><li>NIO有选择器，允许一个单独的线程来管理多个输入通道。</li></ul><a id="more"></a><h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><p>Java NIO的通道类似流，主要区别在于：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>NIO中有以下几个重要的通道实现。</p><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p><p>注意：FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开FileChannel</span></span><br><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//在FileChannel的某个特定位置进行数据的读/写操作</span></span><br><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以使用FileChannel.truncate()方法截取一个文件，指定长度后面的部分将被删除</span></span><br><span class="line">channel.truncate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上，而通过FileChannel.force()方法则可以将通道里尚未写入磁盘的数据强制写到磁盘上</span></span><br><span class="line">channel.force(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel：</p><ul><li>打开一个SocketChannel并连接到互联网上的某台服务器。</li><li>一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。</li></ul><p>SocketChannel是可以设置为非阻塞模式的，设置之后，就可以在异步模式下调用<code>connect()</code>, <code>read()</code>和<code>write()</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开并连接</span></span><br><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//非阻塞模式可以调用finishConnect()的方法确定连接是否建立</span></span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">   <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>ServerSocketChannel是一个可以监听新进来的TCP连接的通道。在打开了ServerSocketChannel之后，可以通过<code>accept()</code>方法监听新进来的连接，当<code>accept()</code>方法返回的时候，它返回一个包含新进来的连接的<code>SocketChannel</code>。因此，<code>accept()</code>方法会一直阻塞到有新连接到达。</p><p>ServerSocketChannel也可以设置成非阻塞模式。在非阻塞模式下，<code>accept()</code>方法会立刻返回，如果还没有新进来的连接,返回的将是<code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开通道并监听新进来的连接</span></span><br><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DatagramChannel"><a href="#DatagramChannel" class="headerlink" title="DatagramChannel"></a>DatagramChannel</h2><p>DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开DatagramChannel</span></span><br><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过receive()方法从DatagramChannel接收数据到指定的Buffer，如果Buffer容不下收到的数据，多出的数据将被丢弃</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过send()方法从DatagramChannel发送数据</span></span><br><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure><h1 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h1><p>Buffer本质是一块可以写入数据，并可以从中读取数据的内存，用于和通道进行交互，过程如下：</p><ul><li>写入数据到Buffer</li><li>调用<code>flip()</code>方法</li><li>从Buffer中读取数据</li><li>调用<code>clear()</code>方法或者<code>compact()</code>方法</li></ul><p>其中<code>flip()</code>方法是将Buffer从写模式切换到读模式，<code>clear()</code>方法会清空整个缓冲区，<code>compact()</code>方法只会清除已经读过的数据并将所有未读的数据拷贝到Buffer起始处。</p><p>Buffer有三个属性：</p><ul><li>capacity</li><li>position：当写数据到Buffer中时，position表示当前的位置；当从Buffer读取数据时，也是从当前位置开始读；将Buffer从写模式切换到读模式，position会被重置为0。</li><li>limit：在写模式下，limit表示你最多能往Buffer里写多少数据，此时limit等于capacity；在读模式下，limit表示最多能读到多少数据，因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。</li></ul><p>Buffer有以下几种类型，它们代表了不同的数据类型：</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h2 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h2><p>要想获得一个Buffer对象首先要进行分配。每一个Buffer类都有一个allocate方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure></p><h2 id="向Buffer写数据"><a href="#向Buffer写数据" class="headerlink" title="向Buffer写数据"></a>向Buffer写数据</h2><p>写数据到Buffer有两种方式：</p><ul><li>从Channel写到Buffer。</li><li>通过Buffer的<code>put()</code>方法写到Buffer里。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"></span><br><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure><h2 id="从Buffer读数据"><a href="#从Buffer读数据" class="headerlink" title="从Buffer读数据"></a>从Buffer读数据</h2><p>从Buffer中读取数据有两种方式：</p><ul><li>从Buffer读取数据到Channel。</li><li>使用get()方法从Buffer中读取数据。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure><h2 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h2><p><code>rewind()</code>将position设回0，所以可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素。</p><h1 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h1><p>Selector是NIO中能够检测一到多个通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h2 id="创建并注册"><a href="#创建并注册" class="headerlink" title="创建并注册"></a>创建并注册</h2><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Selector的创建</span></span><br><span class="line">Selector selector = Selector.open();</span><br><span class="line">   </span><br><span class="line">  <span class="comment">//向Selector注册通道</span></span><br><span class="line">  channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,</span><br><span class="line">  Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>注意<code>register()</code>方法的第二个参数。这是一个interest集合，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件，用SelectionKey的四个常量来表示:</p><ul><li><code>SelectionKey.OP_CONNECT</code>：某个channel成功连接到另一个服务器称为“连接就绪”</li><li><code>SelectionKey.OP_ACCEPT</code>：一个server socket channel准备好接收新进入的连接称为“接收就绪”</li><li><code>SelectionKey.OP_READ</code>：一个有数据可读的通道可以说是“读就绪”</li><li><code>SelectionKey.OP_WRITE</code>：等待写数据的通道可以说是“写就绪”。</li></ul><p>如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如<code>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;</code></p><h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>当向Selector注册Channel时，<code>register()</code>法会返回一个SelectionKey对象，这个对象包含以下几个属性：</p><ul><li>terest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><h3 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h3><p>可以用位与操作interest集合和给定的SelectionKey常量来确定某个事件是否在interest集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure><h3 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h3><p>ready集合是通道已经准备就绪的操作的集合。可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪，也可以通过如下的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p><h3 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel Selector"></a>Channel Selector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h3 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h3><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><h2 id="选择通道"><a href="#选择通道" class="headerlink" title="选择通道"></a>选择通道</h2><p>一旦向Selector注册了一或多个通道，就可以调用<code>select()</code>方法选择就绪的通道，方法返回已经就绪的通道数目。<code>select()</code>阻塞到至少有一个通道在你注册的事件上就绪了，而<code>selectNow()</code>不会阻塞。</p><p>一旦调用了<code>select()</code>方法，并且返回值表明有一个或更多个通道就绪了，就可以通过调用<code>selectedKeys()</code>方法返回就绪通道的集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>之后就可以通过遍历这个集合来访问就绪的通道：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意每次迭代末尾的<code>keyIterator.remove()</code>调用。Selector不会自己从集合中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入集合中。</p><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p>用完Selector后调用其<code>close()</code>方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效，但通道本身并不会关闭。</p><h1 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h1><p>Java NIO支持scatter/gather，scatter是指数据从一个channel读取到多个buffer中，而gather则是指数据从多个buffer写入到同一个channel。scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样可以方便的处理消息头和消息体。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.read(bufferArray);</span><br><span class="line"></span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure><p>注意，Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这意味着它不适用于动态消息，而Gathering Writes只有position和limit之间的数据才会被写入，因此能较好的处理动态消息。</p><h1 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h1><p>如果两个通道中有一个是FileChannel，那么可以直接将数据从一个通道传输到另外一个通道。</p><h2 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h2><p><code>transferFrom()</code>方法可以将数据从源channel传输到FileChannel中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure></p><h2 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h2><p><code>transferTo()</code>方法将数据从FileChannel传输到其他的channel中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure><h1 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h1><p>Path接口表示的是一个与平台无关的路径，既可以是绝对路径也可以是相对路径，文件和目录都用Path表示。</p><h2 id="创建Path"><a href="#创建Path" class="headerlink" title="创建Path"></a>创建Path</h2><p>可以使用Paths工具类的工厂方法创建一个Path对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"C:\\DATA\\test.txt"</span>);</span><br><span class="line"></span><br><span class="line">Path projects = Paths.get(<span class="string">"d:\\data"</span>, <span class="string">"projects"</span>);</span><br><span class="line"></span><br><span class="line">Path currentDir = Paths.get(<span class="string">"."</span>);</span><br><span class="line">Path parentDir = Paths.get(<span class="string">".."</span>);</span><br></pre></td></tr></table></figure><h2 id="normalize"><a href="#normalize" class="headerlink" title="normalize()"></a>normalize()</h2><p><code>normalize()</code>方法可以标准化路径，它会处理路径中的相对路径，去除<code>.</code> <code>..</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"c:/Z_DATA/./test.txt"</span>);</span><br><span class="line">System.out.println(<span class="string">"path = "</span> + path);</span><br><span class="line"></span><br><span class="line">path = path.normalize();</span><br><span class="line">System.out.println(<span class="string">"path = "</span> + path);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">path = c:\Z_DATA\.\test.txt</span><br><span class="line">path = c:\Z_DATA\test.txt</span><br></pre></td></tr></table></figure></p><h1 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h1><p>Files工具类封装提供了一些操作文件系统中文件的工具方法，往往和和Path一起使用。</p><h2 id="exists"><a href="#exists" class="headerlink" title="exists()"></a>exists()</h2><p><code>exists()</code>可以判断一个Path在文件系统中是否存在。</p><h2 id="createDirctory"><a href="#createDirctory" class="headerlink" title="createDirctory()"></a>createDirctory()</h2><p>在调用创建方法前最好先检查是否存在，如果已经存在会抛出<code>FileAlreadyExistsException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Path newDir = Paths.get(<span class="string">"c:/Z_DATA/newDir"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!Files.exists(newDir)) &#123;</span><br><span class="line">        Files.createDirectory(newDir);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="copy"><a href="#copy" class="headerlink" title="copy()"></a>copy()</h2><p><code>copy()</code>只能复制到不存在的路径，如果复制的目标文件已存在则会抛出异常。强制覆盖已存在文件也是可以的，需要增加相应参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(classPath,<span class="string">"nio-data.txt"</span>);</span><br><span class="line">Path targetPath = Paths.get(classPath,<span class="string">"nio-data-copy.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); <span class="comment">// 复制并覆盖已有文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="move"><a href="#move" class="headerlink" title="move()"></a>move()</h2><p>Java NIO Files类同样提供了移动文件的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath = Paths.get(classPath,<span class="string">"nio-data.txt"</span>);</span><br><span class="line">Path targetPath = Paths.get(classPath,<span class="string">"nio-data-copy.txt"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); <span class="comment">// 移动并覆盖已有文件</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete()"></a>delete()</h2><p>删除文件或目录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.delete(targetPath);</span><br></pre></td></tr></table></figure><p>如果删除的文件或目录不存在会抛出<code>IOException</code>异常。</p><h1 id="AsynchronousFileChannel"><a href="#AsynchronousFileChannel" class="headerlink" title="AsynchronousFileChannel"></a>AsynchronousFileChannel</h1><p>使用AsynchronousFileChannel可以实现异步地读取和写入文件数据。</p><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>我们可以使用AsynchronousFileChannel提供的静态方法<code>open()</code>创建它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test.xml"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel =</span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br></pre></td></tr></table></figure><h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><p>AsynchronousFileChannel提供了两种读取数据的方式，都是调用它本身的<code>read()</code>方法。</p><h3 id="使用Futrue读取数据"><a href="#使用Futrue读取数据" class="headerlink" title="使用Futrue读取数据"></a>使用Futrue读取数据</h3><p>第一种方式是调用AsynchronousFileChannel的<code>read()</code>方法，该方法返回一个<code>Future</code>类型的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.READ);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.limit()];</span><br><span class="line">buffer.get(data);</span><br><span class="line">System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">buffer.clear();</span><br></pre></td></tr></table></figure><p>以上代码<code>read()</code>方法会立即返回，即使整个读的过程还没有完全结束。我们可以通过<code>Future.isDone()</code>来检查读取是否完成。</p><h3 id="使用CompletionHandler读取数据"><a href="#使用CompletionHandler读取数据" class="headerlink" title="使用CompletionHandler读取数据"></a>使用CompletionHandler读取数据</h3><p>第二种读取数据的方式是调用AsynchronousFileChannel的另一个<code>read()</code>方法，该方法需要一个<code>CompletionHandler</code>作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fileChannel.read(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line"></span><br><span class="line">        attachment.flip();</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[attachment.limit()];</span><br><span class="line">        attachment.get(data);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(data));</span><br><span class="line">        attachment.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一旦读取操作完成，<code>CompletionHandler</code>的<code>complete()</code>方法将会被调用。它的第一个参数是个<code>Integer</code>类型，表示读取的字节数。第二个参数<code>attachment</code>是<code>ByteBuffer</code>类型的，用来存储读取的数据(<code>ByteBuffer</code>也可以换成其他合适的对象方便数据写入)。它其实就是由<code>read()</code>方法的第三个参数。读取失败的时候，<code>CompletionHandler</code>的<code>failed()</code>方法会被调用。</p><h2 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h2><p>就像读取一样，我们同样有两种方式向AsynchronousFileChannel写入数据。</p><h3 id="使用Future读取数据"><a href="#使用Future读取数据" class="headerlink" title="使用Future读取数据"></a>使用Future读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">Future&lt;Integer&gt; operation = fileChannel.write(buffer, position);</span><br><span class="line">buffer.clear();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!operation.isDone());</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Write done"</span>);</span><br></pre></td></tr></table></figure><p>注意，写入目标文件要提前创建好，如果它不存在的话，<code>write()</code>方法会抛出一个 <code>NoSuchFileException</code>。</p><h3 id="使用CompletionHandler写入数据"><a href="#使用CompletionHandler写入数据" class="headerlink" title="使用CompletionHandler写入数据"></a>使用CompletionHandler写入数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/test-write.txt"</span>);</span><br><span class="line"><span class="keyword">if</span>(!Files.exists(path))&#123;</span><br><span class="line">    Files.createFile(path);</span><br><span class="line">&#125;</span><br><span class="line">AsynchronousFileChannel fileChannel = </span><br><span class="line">    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);</span><br><span class="line"></span><br><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">buffer.put(<span class="string">"test data"</span>.getBytes());</span><br><span class="line">buffer.flip();</span><br><span class="line"></span><br><span class="line">fileChannel.write(buffer, position, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bytes written: "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Write failed"</span>);</span><br><span class="line">        exc.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当写入程序完成时，CompletionHandler的<code>completed()</code>方法将会被调用，相反的如果写入失败则会调用<code>failed()</code>方法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">Java NIO 系列教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Java NIO是一个可以替代标准Java IO API的IO API，主要有以下三个核心组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Channels&lt;/li&gt;
&lt;li&gt;Buffers&lt;/li&gt;
&lt;li&gt;Selectors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO与IO的主要区别在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IO是面向流的，NIO是面向缓冲区的。&lt;/li&gt;
&lt;li&gt;IO是阻塞的，NIO是非阻塞的。&lt;/li&gt;
&lt;li&gt;NIO有选择器，允许一个单独的线程来管理多个输入通道。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="NIO" scheme="http://yoursite.com/categories/NIO/"/>
    
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS的过程与原理</title>
    <link href="http://yoursite.com/2019/02/17/HTTPS%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/17/HTTPS的过程与原理/</id>
    <published>2019-02-17T03:05:00.000Z</published>
    <updated>2019-02-17T03:36:25.883Z</updated>
    
    <content type="html"><![CDATA[<p>由于HTTP存在明文通信、无法验证服务器的真实性等弊端，使用HTTPS的人变得越来越多。HTTPS并不是新的协议，而是在HTTP基础之上加一层TLS模块，TLS提供了加密、认证以及消息完整性校验的服务，从而保证通信的安全性。</p><a id="more"></a><h2 id="HTTPS过程"><a href="#HTTPS过程" class="headerlink" title="HTTPS过程"></a>HTTPS过程</h2><p>HTTPS总的流程就相当于使用非对称加密的方式来传递对称私钥，之后的通信就可以使用这个私钥进行对称加密了。</p><p><img src="http://blog.default.nanwulife.com/2012072310244445.png" alt="HTTPS的过程与原理"></p><h3 id="客户端发起HTTPS请求"><a href="#客户端发起HTTPS请求" class="headerlink" title="客户端发起HTTPS请求"></a>客户端发起HTTPS请求</h3><p>用户在浏览器里输入一个https网址，然后连接到server的443端口。</p><h3 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h3><p>采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。</p><h3 id="传送证书"><a href="#传送证书" class="headerlink" title="传送证书"></a>传送证书</h3><p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p><h3 id="客户端解析证书"><a href="#客户端解析证书" class="headerlink" title="客户端解析证书"></a>客户端解析证书</h3><p>这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。</p><h3 id="传送加密信息"><a href="#传送加密信息" class="headerlink" title="传送加密信息"></a>传送加密信息</h3><p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p><h3 id="服务段解密信息"><a href="#服务段解密信息" class="headerlink" title="服务段解密信息"></a>服务段解密信息</h3><p>服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p><h3 id="传输加密后的信息"><a href="#传输加密后的信息" class="headerlink" title="传输加密后的信息"></a>传输加密后的信息</h3><p>这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。</p><h3 id="客户端解密信息"><a href="#客户端解密信息" class="headerlink" title="客户端解密信息"></a>客户端解密信息</h3><p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。</p><h2 id="证书认证"><a href="#证书认证" class="headerlink" title="证书认证"></a>证书认证</h2><p>单纯的加密是无法保证通信安全的，TLS还需要通过证书机制来保证访问的服务器是真实的。</p><p><img src="http://blog.default.nanwulife.com/2402164-db6c5a0d348fcc15.png" alt=""></p><p>证书是由权威机构颁发的，服务端如果能够提供一个合法的证书，说明这个服务端是合法的，可以被信任。整个证书的认证过程如下：</p><ul><li>客户端获取到了站点证书，拿到了站点的公钥</li><li>要验证站点可信后，才能使用其公钥，因此客户端找到其站点证书颁发者的信息</li><li>站点证书的颁发者验证了服务端站点是可信的，但客户端依然不清楚该颁发者是否可信</li><li>再往上回溯，找到了认证了中间证书商的根证书颁发者。由于根证书颁发者非常少，我们浏览器之前就认识了，因此可以认为根证书颁发者是可信的</li><li>一路倒推，证书颁发者可信，那么它所颁发的所有站点也是可信的，最终确定我们所要访问的服务端是可信的</li><li>客户端使用证书中包含的公钥，继续完成TLS的握手过程</li></ul><p>如果证书过期了、颁发机构不受信任或者证书绑定的域名和请求的域名不一致等原因，浏览器会抛出异常信息，说明此时的访问是不安全的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank" rel="noopener">图解HTTPS</a></li><li><a href="https://www.jianshu.com/p/24af67c40e8d" target="_blank" rel="noopener">TLS整理（下）：TLS如何保证安全</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于HTTP存在明文通信、无法验证服务器的真实性等弊端，使用HTTPS的人变得越来越多。HTTPS并不是新的协议，而是在HTTP基础之上加一层TLS模块，TLS提供了加密、认证以及消息完整性校验的服务，从而保证通信的安全性。&lt;/p&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="HTTPS" scheme="http://yoursite.com/tags/HTTPS/"/>
    
      <category term="TLS" scheme="http://yoursite.com/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB和MyISAM的区别</title>
    <link href="http://yoursite.com/2019/02/16/InnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/02/16/InnoDB和MyISAM的区别/</id>
    <published>2019-02-16T07:05:00.000Z</published>
    <updated>2019-02-16T07:11:45.835Z</updated>
    
    <content type="html"><![CDATA[<ol><li>InnoDB支持事务，MyISAM不支持。</li><li>InnoDB支持外键，而MyISAM不支持。</li><li>InnoDB是聚集索引，而MyISAM是非聚集索引。</li><li>InnoDB不保存表的具体行数，执行<code>select count(*) from table</code>时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;InnoDB支持事务，MyISAM不支持。&lt;/li&gt;
&lt;li&gt;InnoDB支持外键，而MyISAM不支持。&lt;/li&gt;
&lt;li&gt;InnoDB是聚集索引，而MyISAM是非聚集索引。&lt;/li&gt;
&lt;li&gt;InnoDB不保存表的具体行数，执行&lt;code&gt;select c
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="MyISAM" scheme="http://yoursite.com/tags/MyISAM/"/>
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
  </entry>
  
  <entry>
    <title>访问一个网页的全过程</title>
    <link href="http://yoursite.com/2019/02/13/%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/13/访问一个网页的全过程/</id>
    <published>2019-02-13T10:09:00.000Z</published>
    <updated>2019-02-18T03:18:09.754Z</updated>
    
    <content type="html"><![CDATA[<ol><li>客户端用户从浏览器输入<code>www.google.com</code>网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的。</li></ol><a id="more"></a><ol start="3"><li><p>如果hosts与DNS缓存都没有解析记录时，系统会把浏览器的解析请求交给客户端本地设置的DNS服务器地址解析，如果本地DNS服务器的本地缓存有对应的解析记录，就会直接返回IP地址。</p></li><li><p>如果本地DNS服务器没有对应的解析记录，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(<code>google.com</code>)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找<code>google.com</code>域服务器，重复上面的动作，进行查询，直至找到<code>www.google.com</code>主机。</p></li><li><p>如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。</p></li><li><p>通过DNS解析拿到了ip之后，就可以通过ip向服务器发送http请求了，因为http工作在应用层，tcp工作在传输层，所以发生http请求之前，还会进行tcp的三次握手建立连接。</p></li><li><p>在连接成功建立后，开始向web服务器发送请求，当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求报文，请求报文由<code>请求方法 URI 协议/版本</code>、<code>请求头</code>、<code>请求正文</code>三部分组成。</p></li><li><p>请求报文由应用层向下，依次经过传输层、网络层、数据链路层与物理层。应用层的任务是通过应用进程间的交互来完成特定网络应用，有HTTP、DNS等众多协议，传输层的主要任务则是负责向两台主机进程之间的通信提供通用的数据传输服务，包括TCP与UDP两种协议，TCP是面向连接的、可靠的的数据传输服务，而UDP提供无连接的、不可靠的数据传输服务，TCP主要提供完整性服务，UDP主要提供及时性服务；传输层是为主机中的进程提供数据传输服务，而网络层则是为不同主机提供数据传输服务，这一层有IP协议，由于主机之间可以有很多链路，数据链路层则是为同一链路的主机提供数据传输服务。最终物理层考虑怎样在传输媒体上传输数据比特流。数据通过以太网电缆传送到服务器，服务器拿到数据包后同样再由数据链路层、网络层、传输层依次向上解析，应用层最终收到请求内容。</p></li><li><p>服务器收到请求报文之后，就会将响应报文返回给客户端，响应报文由<code>协议/版本 状态码 描述</code>、<code>响应头</code>、<code>响应正文</code>三部分组成。这里的状态码分为1XX（信息类）、2XX（成功类）、3XX（重定向类）、4XX（客户端错误）、5XX（服务器错误）。</p></li><li><p>当浏览器加载一个完整的页面时，还需要与服务器断开连接，这个过程就是tcp的四次挥手。</p></li><li><p>在HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。因此，每次的请求都会造成无谓的TCP连接建立与断开，增加通信量的开销。为了解决这个问题，HTTP/1.1使用长连接减少开销，只要任意一端没有明确提出断开连接，就保持TCP连接状态，当客户端再次访问这个服务器上的网页时，会继续使用这一条已经建立的连接。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;客户端用户从浏览器输入&lt;code&gt;www.google.com&lt;/code&gt;网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>多线程断点续传下载器</title>
    <link href="http://yoursite.com/2019/02/12/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%99%A8/"/>
    <id>http://yoursite.com/2019/02/12/多线程断点续传下载器/</id>
    <published>2019-02-12T08:58:00.000Z</published>
    <updated>2019-02-12T11:13:32.667Z</updated>
    
    <content type="html"><![CDATA[<p>最近在研究多线程的断点续传下载。断点续传的原理其实很简单，就是在下载时将下载进度保存到一个临时文件中，如果下载过程遇到什么意外中断了，下次下载同一个文件时就可以从临时文件中读取到上次下载发生中断时的进度，然后从这个进度开始继续下载。</p><a id="more"></a><p>要使用断点续传下载首先要判断服务器是否支持范围请求，假如在响应中存在<code>Accept-Ranges</code>首部并且它的值不为 <code>none</code>，那么表示该服务器支持范围请求。通常情况下Web服务器会默认开启对范围请求的支持，我们只需要在请求头中加入<code>Range</code>首部来指示服务器应该返回文件的哪一部分，例如使用<code>Range: bytes=0-1023</code>返回某个资源的前1024个字节，在代码中体现为：<code>httpcon.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + startPos + &quot;-&quot; + endPos);</code>，这时候服务器会返回状态码为<code>206 Partial Content</code>的响应表示成功。</p><p>项目中还使用了多线程进行分块下载，要注意的是并非线程数越多下载就越快（受限于带宽），一般开十个线程就差不多了，多线程之所以能提高下载速度的原因也很复杂，具体可以参考<a href="https://www.zhihu.com/question/19914902" target="_blank" rel="noopener">为什么多线程下载能加速？</a>以及<a href="https://www.zhihu.com/question/21813579" target="_blank" rel="noopener">为什么多 TCP 连接分块下载比单连接下载快？</a>。简单来说就是当链路存在争用的情况下，由于传输网络的带宽有限，每个TCP连接可以得到均等的带宽。在多用户环境下，一个用户拥有越多TCP连接，获得的带宽越大。除此之外，由于TCP的拥塞控制机制被设计的十分友好，只要丢了点包就会极大的减慢速率，而此时可能并没有发生拥塞，导致单个连接没法最大化的利用带宽。</p><p>下图为该项目的执行流程：</p><p><img src="http://blog.algorithms.nanwulife.com/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0.jpg" alt=""></p><p>以下为项目源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</span><br><span class="line"><span class="keyword">import</span> java.net.MalformedURLException;</span><br><span class="line"><span class="keyword">import</span> java.net.URL;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Project</span>: breakpoint</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: Cenjie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: Created in 2019/2/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Downloader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String urlStr;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> threadNum;</span><br><span class="line">    <span class="keyword">private</span> String filename;</span><br><span class="line">    <span class="keyword">private</span> String filename_tmp;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileLength;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lenPerThread;  <span class="comment">//每个线程的下载大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] start;    <span class="comment">//保留每个线程下载的起始位置。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] end;      <span class="comment">//保留每个线程下载的结束位置。</span></span><br><span class="line">    <span class="keyword">private</span> URL url;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Downloader</span><span class="params">(String urlStr, <span class="keyword">int</span> threadNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.urlStr = urlStr;</span><br><span class="line">        <span class="keyword">this</span>.threadNum = threadNum;</span><br><span class="line">        start = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="keyword">this</span>.threadNum];</span><br><span class="line">        end = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="keyword">this</span>.threadNum];</span><br><span class="line">        latch = <span class="keyword">new</span> CountDownLatch(<span class="keyword">this</span>.threadNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 文件下载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">download</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        File file = <span class="keyword">null</span>;</span><br><span class="line">        File file_tmp = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从文件链接中获取文件名</span></span><br><span class="line">        filename = urlStr.substring(urlStr.lastIndexOf(<span class="string">'/'</span>) + <span class="number">1</span>, urlStr</span><br><span class="line">                .contains(<span class="string">"?"</span>) ? urlStr.lastIndexOf(<span class="string">'?'</span>) : urlStr.length());</span><br><span class="line">        <span class="comment">//设置临时文件的文件名</span></span><br><span class="line">        filename_tmp = filename + <span class="string">"_tmp"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建url</span></span><br><span class="line">            url = <span class="keyword">new</span> URL(urlStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//打开下载链接，并且得到一个HttpURLConnection的一个对象httpcon</span></span><br><span class="line">            HttpURLConnection httpcon = (HttpURLConnection) url.openConnection();</span><br><span class="line">            httpcon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取请求资源的总长度，为Long型</span></span><br><span class="line">            fileLength = httpcon.getContentLengthLong();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下载文件和临时文件</span></span><br><span class="line">            file = <span class="keyword">new</span> File(filename);</span><br><span class="line">            file_tmp = <span class="keyword">new</span> File(filename_tmp);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//每个线程需下载的资源大小；由于文件大小不确定，为避免数据丢失</span></span><br><span class="line">            lenPerThread = fileLength % threadNum == <span class="number">0</span> ? fileLength / threadNum : fileLength / threadNum + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//打印下载信息</span></span><br><span class="line">            System.out.println(<span class="string">"文件名: "</span> + filename + <span class="string">"，"</span> + <span class="string">"文件大小："</span></span><br><span class="line">                    + fileLength + <span class="string">"字节，每个线程下载大小："</span> + lenPerThread + <span class="string">"字节"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (file.exists() &amp;&amp; file.length() == fileLength) &#123;</span><br><span class="line">                System.out.println(<span class="string">"文件已存在"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setBreakPoint(file_tmp);</span><br><span class="line">                ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    exec.execute(<span class="keyword">new</span> DownLoadThread(start[i], end[i],</span><br><span class="line">                            <span class="keyword">this</span>, i));</span><br><span class="line">                &#125;</span><br><span class="line">                latch.await();  <span class="comment">//当所有线程下载完毕后，才会从此阻塞中返回</span></span><br><span class="line">                System.out.println(<span class="string">"文件下载完成"</span>);</span><br><span class="line">                exec.shutdown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下载完成后，判断文件是否完整，并删除临时文件</span></span><br><span class="line">        <span class="keyword">if</span> (file.length() == fileLength) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file_tmp.exists()) &#123;</span><br><span class="line">                file_tmp.delete();</span><br><span class="line">                System.out.println(<span class="string">"删除临时文件完成，下载结束"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该文件不完整"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取临时文件中记录的断点，加载每个线程的任务区间，若临时文件不存在，则重新分配每个线程的任务区间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> file_tmp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBreakPoint</span><span class="params">(File file_tmp)</span> </span>&#123;</span><br><span class="line">        RandomAccessFile random_file_tmp = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(<span class="string">"开始分配任务区间："</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//如果存在临时文件，则从临时文件记录的位置继续下载</span></span><br><span class="line">            <span class="keyword">if</span> (file_tmp.exists()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"找到临时文件，将从断点处恢复下载..."</span>);</span><br><span class="line">                random_file_tmp = <span class="keyword">new</span> RandomAccessFile(file_tmp, <span class="string">"rw"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    random_file_tmp.seek(i * <span class="number">8</span>);</span><br><span class="line">                    start[i] = random_file_tmp.readLong();</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(<span class="number">1000</span> + i * <span class="number">8</span>);</span><br><span class="line">                    end[i] = random_file_tmp.readLong();</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + i + <span class="string">" 起始位置："</span></span><br><span class="line">                            + start[i] + <span class="string">"，结束位置："</span> + end[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"未找到临时文件，开始一个新的下载..."</span>);</span><br><span class="line">                random_file_tmp = <span class="keyword">new</span> RandomAccessFile(file_tmp, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">                    <span class="comment">//设置线程i的下载起始位置</span></span><br><span class="line">                    start[i] = lenPerThread * i;</span><br><span class="line">                    <span class="keyword">if</span> (i == threadNum - <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">//当线程i为最后一个线程时，设置线程i的下载结束位置为文件长度</span></span><br><span class="line">                        end[i] = fileLength - <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        end[i] = lenPerThread * (i + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(i * <span class="number">8</span>);</span><br><span class="line">                    random_file_tmp.writeLong(start[i]);</span><br><span class="line"></span><br><span class="line">                    random_file_tmp.seek(<span class="number">1000</span> + i * <span class="number">8</span>);</span><br><span class="line">                    random_file_tmp.writeLong(end[i]);</span><br><span class="line"></span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + i + <span class="string">" 起始位置："</span></span><br><span class="line">                            + start[i] + <span class="string">"，结束位置："</span> + end[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (random_file_tmp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    random_file_tmp.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownLoadThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;         <span class="comment">//线程id</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> startPos;  <span class="comment">//线程下载起始位置</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> endPos;    <span class="comment">//线程下载结束位置</span></span><br><span class="line">        <span class="keyword">private</span> Downloader task;</span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile rand_file;</span><br><span class="line">        <span class="keyword">private</span> RandomAccessFile rand_file_tmp;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DownLoadThread</span><span class="params">(<span class="keyword">long</span> startPos, <span class="keyword">long</span> endPos,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Downloader task, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.startPos = startPos;</span><br><span class="line">            <span class="keyword">this</span>.endPos = endPos;</span><br><span class="line">            <span class="keyword">this</span>.task = task;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.rand_file = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.task.filename, <span class="string">"rw"</span>);</span><br><span class="line">                <span class="keyword">this</span>.rand_file_tmp = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">this</span>.task.filename_tmp, <span class="string">"rw"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            HttpURLConnection httpcon;</span><br><span class="line">            InputStream is = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> length;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 开始下载..."</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    httpcon = (HttpURLConnection) task.url.openConnection();</span><br><span class="line">                    httpcon.setRequestMethod(<span class="string">"GET"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//防止网络阻塞，设置指定的超时时间；单位都是ms。超过指定时间，就会抛出异常</span></span><br><span class="line">                    httpcon.setReadTimeout(<span class="number">20000</span>);<span class="comment">//读取数据的超时设置</span></span><br><span class="line">                    httpcon.setConnectTimeout(<span class="number">20000</span>);<span class="comment">//连接的超时设置</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (startPos &lt; endPos) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//向服务器请求指定区间段的数据，这是实现断点续传的根本。</span></span><br><span class="line">                        httpcon.setRequestProperty(<span class="string">"Range"</span>, <span class="string">"bytes="</span> + startPos + <span class="string">"-"</span> + endPos);</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 长度："</span> + (endPos - startPos + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">                        rand_file.seek(startPos);</span><br><span class="line"></span><br><span class="line">                        is = httpcon.getInputStream();<span class="comment">//获取服务器返回的资源流</span></span><br><span class="line">                        <span class="keyword">long</span> count = <span class="number">0L</span>;</span><br><span class="line">                        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">while</span> ((length = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            count += length;</span><br><span class="line">                            rand_file.write(buf, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//不断更新每个线程下载资源的起始位置，并写入临时文件</span></span><br><span class="line">                            startPos += length;</span><br><span class="line">                            rand_file_tmp.seek(id * <span class="number">8</span>);</span><br><span class="line">                            rand_file_tmp.writeLong(startPos);</span><br><span class="line">                        &#125;</span><br><span class="line">                        System.out.println(<span class="string">"线程"</span> + id</span><br><span class="line">                                + <span class="string">" 总下载大小: "</span> + count);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//关闭流</span></span><br><span class="line">                        is.close();</span><br><span class="line">                        httpcon.disconnect();</span><br><span class="line">                        rand_file.close();</span><br><span class="line">                        rand_file_tmp.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                    latch.countDown();</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span> + id + <span class="string">" 下载完成"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            is.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line">        String url = <span class="string">"http://blog.default.nanwulife.com/pexels-photo-640947.jpeg"</span>;</span><br><span class="line"></span><br><span class="line">        Downloader load = <span class="keyword">new</span> Downloader(url, threadNum);</span><br><span class="line">        load.download();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在研究多线程的断点续传下载。断点续传的原理其实很简单，就是在下载时将下载进度保存到一个临时文件中，如果下载过程遇到什么意外中断了，下次下载同一个文件时就可以从临时文件中读取到上次下载发生中断时的进度，然后从这个进度开始继续下载。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
      <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="断点续传" scheme="http://yoursite.com/tags/%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池与Executor框架</title>
    <link href="http://yoursite.com/2019/02/10/Executor%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2019/02/10/Executor框架/</id>
    <published>2019-02-10T10:27:00.000Z</published>
    <updated>2019-02-15T12:25:56.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么要使用线程池"><a href="#为什么要使用线程池" class="headerlink" title="为什么要使用线程池"></a>为什么要使用线程池</h2><ul><li>降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性：线程是稀缺资源，使用线程池可以进行统一分配、调优和监控。</li></ul><a id="more"></a><h2 id="线程池的实现原理"><a href="#线程池的实现原理" class="headerlink" title="线程池的实现原理"></a>线程池的实现原理</h2><p><img src="http://blog.default.nanwulife.com/1787733-248f411a83669fff.webp" alt=""></p><ol><li>如果当前运行的线程少于<code>corePoolSize</code>，则创建新线程来执行任务（这一步需获取全局锁）。</li><li>如果运行的线程等于或多于<code>corePoolSize</code>，则将任务加入<code>BlockingQueue</code>。</li><li>如果队列已满，则创建新的线程来处理任务（这一步需获取全局锁）。</li><li>如果创建新线程将使当前运行的线程超出<code>maximumPoolSize</code>，任务将被拒绝，并使用相关饱和策略进行处理，默认是直接抛出异常。</li></ol><p>之所以采用这个步骤，是因为在执行<code>execute()</code>方法时，尽可能地避免获取全局锁。在线程池完成预热之后（当前运行的线程数大于等于<code>corePoolSize</code>），几乎所有的<code>execute()</code>方法调用都是执行步骤2，而步骤2不需要获取全局锁。</p><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor框架内部使用了线程池机制，它在<code>java.util.cocurrent</code>包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，通过<code>Executor</code>来启动线程比使用<code>Thread</code>的<code>start()</code>方法更易管理且效率更好。</p><h2 id="Executor框架的结构与成员"><a href="#Executor框架的结构与成员" class="headerlink" title="Executor框架的结构与成员"></a>Executor框架的结构与成员</h2><p><img src="http://blog.default.nanwulife.com/6021163-4e29a753826e7d23.webp" alt=""></p><h3 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h3><p><code>ThreadPoolExecutor</code>是Executor框架的最核心的类，是线程池的实现类，用来执行被提交的任务，通常使用工厂类<code>Executors</code>来创建，有以下三种类型：</p><ul><li><code>FixedThreadPool</code>：线程数固定。适用于为了满足资源管理而需要限制线程数的场景，适用于负载比较重的服务器。</li><li><code>SingleThreadExecutor</code>：只有一个线程。适用于需要保证顺序地执行各个任务，并且在任意时间点不会有多个线程是活动的场景。</li><li><code>CachedThreadPool</code>：根据需要创建新线程。空闲线程等待新任务超过60秒就会被终止。适用于执行很多短期异步任务的小程序，或者是负载较轻的服务器。</li></ul><p><code>FixedThreadPool</code>和<code>SingleThreadExecutor</code>使用无界队列<code>LinkedBlockingQueue</code>作为线程池的工作队列。<code>CachedThreadPool</code>使用没有容量的<code>SynchronousQueue</code>作为线程池的工作队列。</p><h3 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h3><p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>，主要用来在给定的延迟之后运行任务，或者定期执行任务。<code>ScheduledThreadPoolExecutor</code>的功能与<code>Timer</code>类似，但<code>ScheduledThreadPoolExecutor</code>功能更强大、更灵活，<code>Timer</code>对应的是单个后台线程，而<code>ScheduledThreadPoolExecutor</code>可以在构造函数中指定多个对应的后台线程数。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p><code>Future</code>接口和实现<code>Future</code>接口的<code>FutureTask</code>类，代表异步计算的结果。<code>FutureTask</code>除了实现<code>Future</code>接口外，还实现了<code>Runnable</code>接口。可以把<code>FutureTask</code>交给<code>Executor</code>执行，也可以通过<code>submit()</code>方法返回一个<code>FutureTask</code>，然后执行<code>FutureTask.get()</code>方法。</p><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过<code>ThreadPoolExecutor</code>来创建一个线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler);</span><br></pre></td></tr></table></figure><p>当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。</p><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>可以使用<code>execute()</code>方法提交任务，但是<code>execute()</code>方法没有返回值，所以无法判断任务是否被线程池执行成功。也可以使用<code>submit()</code>方法来提交任务，它会返回一个<code>future</code>，可以通过这个<code>future</code>的<code>get()</code>方法来获取返回值，<code>get()</code>方法会阻塞直到任务完成。</p><h3 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h3><p>可以通过调用线程池的<code>shutdown()</code>或<code>shutdownNow()</code>方法来关闭线程池。</p><ul><li><code>shutdown()</code>先将线程池状态置为<code>SHUTDOWN</code>，停止接受外部提交的新任务，而等到正在执行的任务以及队列中等待的任务执行完才真正停止。</li><li><code>shutdownNow()</code>先将线程池状态置为<code>STOP</code>，停止接受外部提交的新任务，忽略队列里等待的任务，使用<code>interrupt()</code>方法尝试将正在跑的任务中断，然后返回未执行的任务列表。</li></ul><p>注意，如果线程中没有<code>sleep</code>、<code>wait</code>、<code>Condition</code>等应用，<code>interrupt()</code>方法是无法中断当前的线程的。所以，<code>shutdownNow()</code>并不代表线程池一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/java-threadpool/" target="_blank" rel="noopener">聊聊并发（三）Java线程池的分析和使用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;为什么要使用线程池&quot;&gt;&lt;a href=&quot;#为什么要使用线程池&quot; class=&quot;headerlink&quot; title=&quot;为什么要使用线程池&quot;&gt;&lt;/a&gt;为什么要使用线程池&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性：线程是稀缺资源，使用线程池可以进行统一分配、调优和监控。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Executor" scheme="http://yoursite.com/tags/Executor/"/>
    
      <category term="线程池" scheme="http://yoursite.com/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>Java中的并发工具类</title>
    <link href="http://yoursite.com/2019/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/02/10/Java中的并发工具类/</id>
    <published>2019-02-10T06:27:00.000Z</published>
    <updated>2019-02-10T09:00:32.614Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p><code>CountDownLatch</code>是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。</p><a id="more"></a><p><code>CountDownLatch</code>是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CountDownLatch c = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">                System.out.println(<span class="number">2</span>);</span><br><span class="line">                c.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过创建一个初始计数为1的<code>CountDownLatch</code>，并让所有线程都在这个锁上等待，随后调用<code>countDown()</code>方法来同时启动多个线程。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>同步屏障<code>CyclicBarrier</code>可以让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> CyclicBarrier c = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    c.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            c.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h2><p><code>CountDownLatch</code>的计数器只能使用一次，而<code>CyclicBarrier</code>的计数器可以使用<code>reset()</code>方法重置。所以<code>CyclicBarrier</code>能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p><code>Semaphore</code>是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<code>Semaphore</code>的构造方法接受一个整型的数字，表示可用的许可证数量，线程使用<code>acquire()</code>方法获取一个许可证，如果没有许可证能够获得则被阻塞，使用完后调用<code>release()</code>方法归还许可证。还可以使用<code>tryAcquire()</code>方法尝试获取许可证，若获取成功，则立即返回true，若获取失败，则立即返回false。</p><p><code>Semaphore</code>可以用于流量控制，特别是公用资源有限的应用场景，比如数据库连接。如果线程数有几十个，而数据库的连接只有十个，那么就可以使用<code>Semaphore</code>控制同时获取数据库连接的个数。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java并发编程的艺术》</li><li><a href="http://www.importnew.com/15731.html" target="_blank" rel="noopener">什么时候使用CountDownLatch</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;CountdownLatch&quot;&gt;&lt;a href=&quot;#CountdownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountdownLatch&quot;&gt;&lt;/a&gt;CountdownLatch&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/code&gt;是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程基础</title>
    <link href="http://yoursite.com/2019/02/09/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2019/02/09/Java并发编程基础/</id>
    <published>2019-02-09T02:24:00.000Z</published>
    <updated>2019-02-10T06:02:05.828Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>Java线程在运行的生命周期中可能处于以下6种不同的状态：</p><table><thead><tr><th>状态名称</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>初始状态，线程被构建，但是还没调用<code>start()</code>方法</td></tr><tr><td>RUNNABLE</td><td>运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”</td></tr><tr><td>BLOCKED</td><td>阻塞状态，表示线程阻塞于锁</td></tr><tr><td>WAITING</td><td>无限期等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定动作（通知或中断）</td></tr><tr><td>TIME_WAITING</td><td>限期等待状态，可以在指定的时间自行返回</td></tr><tr><td>TERMINATED</td><td>终止状态，表示当前线程已经执行完毕</td></tr></tbody></table><a id="more"></a><p><img src="http://blog.default.nanwulife.com/212748_11NT_1789589.jpg" alt=""></p><p>Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入<code>synchronized</code>关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在<code>Lock</code>接口的线程状态是等待状态。</p><h2 id="Daemon线程"><a href="#Daemon线程" class="headerlink" title="Daemon线程"></a>Daemon线程</h2><p>用户线程是我们平常创建的普通线程，而守护线程则是用来服务于用户线程的一种支持型线程。当一个Java虚拟机中只存在守护线程的时候，Java虚拟机将会退出。可以在启动线程之前通过调用<code>Thread.setDaemon(true)</code>将该线程设置为守护线程。</p><p>守护线程可用于实时监控和管理系统中的可回收资源。例如，Java垃圾回收线程就是一个典型的守护线程，当我们的程序中不再有任何运行中的Thread，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动退出。</p><h2 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h2><p>有三种使用线程的方法：</p><ol><li>实现<code>Runnable</code>接口；</li><li>实现<code>Callable</code>接口；</li><li>继承<code>Thread</code>类。</li></ol><p>实现<code>Runnable</code>和<code>Callable</code>接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过<code>Thread</code>来调用。可以说任务是通过线程驱动从而执行的。</p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>需要实现<code>run()</code>方法。通过<code>Thread</code>调用<code>start()</code>方法来启动线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>与<code>Runnable</code>相比，<code>Callable</code>可以有返回值，返回值通过<code>FutureTask</code>进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    MyCallable mc = <span class="keyword">new</span> MyCallable();</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(mc);</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(ft);</span><br><span class="line">    thread.start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>同样也是需要实现<code>run()</code>方法，因为<code>Thread</code>类也实现了<code>Runable</code>接口。</p><p>当调用<code>start()</code>方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的<code>run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">    mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>实现接口会更好一些，因为：</p><ul><li>Java不支持多重继承，因此继承了<code>Thread</code>类就无法继承其它类，但是可以实现多个接口。</li><li>类可能只要求可执行就行，继承整个<code>Thread</code>类开销过大。</li></ul><h2 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h2><p>等待/通知机制是指一个线程A调用了对象O的<code>wait()</code>方法进入等待状态，而另一个线程B调用了对象O的<code>notify()</code>或者<code>notifyAll()</code>方法，线程A收到通知后从对象O的<code>wait()</code>方法返回，进而执行后续操作。以下为等待/通知的经典范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//等待方</span></span><br><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line"><span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">    对象.wait();</span><br><span class="line">   &#125;</span><br><span class="line">   对应的处理逻辑;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知方</span></span><br><span class="line"><span class="keyword">synchronized</span>(对象)&#123;</span><br><span class="line">改变条件</span><br><span class="line">   对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>wait()</code>，<code>notify()</code>，<code>notifyAll()</code>方法只能用在同步方法或者同步控制块中使用，否则会在运行时抛出<code>IllegalMonitorStateException</code>。使用<code>wait()</code>挂起期间，线程会释放锁，这是因为如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行<code>notify()</code>或者<code>notifyAll()</code>来唤醒挂起的线程，造成死锁。</p><p>注意，<code>wait()</code>是<code>Object</code>的方法，而<code>sleep()</code>是<code>Thread</code>的静态方法；<code>wait()</code>会释放锁，<code>sleep()</code>不会。</p><h2 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h2><h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><p>在线程中调用另一个线程的<code>join()</code>方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。</p><h3 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await() signal() signalAll()"></a>await() signal() signalAll()</h3><p><code>java.util.concurrent</code>类库中提供了<code>Condition</code>类来实现线程之间的协调，可以在<code>Condition</code>上调用<code>await()</code>方法使线程等待，其它线程调用<code>signal()</code>或<code>signalAll()</code>方法唤醒等待的线程。</p><p>相比于<code>wait()</code>这种等待方式，<code>await()</code>可以指定等待的条件，因此更加灵活。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AwaitSignalExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"before"</span>);</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">            System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">      AwaitSignalExample example = <span class="keyword">new</span> AwaitSignalExample();</span><br><span class="line">      executorService.execute(() -&gt; example.after());</span><br><span class="line">      executorService.execute(() -&gt; example.before());</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p><code>ThreadLocal</code>即线程变量，是一个以<code>ThreadLocal</code>对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个<code>ThreadLocal</code>对象查询到绑定在这个线程上的一个值。可以通过<code>set(T)</code>方法来设置一个值，在当前线程下再通过<code>get()</code>方法获取到原先设置的值。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java并发编程的艺术》</li><li><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91?id=%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">CS-Notes</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线程状态&quot;&gt;&lt;a href=&quot;#线程状态&quot; class=&quot;headerlink&quot; title=&quot;线程状态&quot;&gt;&lt;/a&gt;线程状态&lt;/h2&gt;&lt;p&gt;Java线程在运行的生命周期中可能处于以下6种不同的状态：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;NEW&lt;/td&gt;
&lt;td&gt;初始状态，线程被构建，但是还没调用&lt;code&gt;start()&lt;/code&gt;方法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUNNABLE&lt;/td&gt;
&lt;td&gt;运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中”&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;BLOCKED&lt;/td&gt;
&lt;td&gt;阻塞状态，表示线程阻塞于锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WAITING&lt;/td&gt;
&lt;td&gt;无限期等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定动作（通知或中断）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TIME_WAITING&lt;/td&gt;
&lt;td&gt;限期等待状态，可以在指定的时间自行返回&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TERMINATED&lt;/td&gt;
&lt;td&gt;终止状态，表示当前线程已经执行完毕&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>final域的内存语义</title>
    <link href="http://yoursite.com/2019/02/09/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90final%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/02/09/深入分析final关键字/</id>
    <published>2019-02-09T01:26:00.000Z</published>
    <updated>2019-02-09T02:12:20.152Z</updated>
    
    <content type="html"><![CDATA[<p>对于<code>final</code>域，编译器和处理器要遵守两个重排序规则。</p><ol><li>在构造函数内对一个<code>final</code>域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li><li>初次读一个包含<code>final</code>域的对象的引用，与随后初次读这个<code>final</code>域，这两个操作之间不能重排序。</li></ol><a id="more"></a><p>以上规则保证只要对象是正确构造的，那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个<code>final</code>域在构造函数中被初始化之后的值。要实现这个效果，还需要保证在构造函数内部，不能让这个被构造对象的引用为其它线程所见，也就是对象引用不能在构造函数中“逸出”，因为此时的<code>final</code>域由于重排序等原因可能还没被初始化。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于&lt;code&gt;final&lt;/code&gt;域，编译器和处理器要遵守两个重排序规则。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在构造函数内对一个&lt;code&gt;final&lt;/code&gt;域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。&lt;/li&gt;
&lt;li&gt;初次读一个包含&lt;code&gt;final&lt;/code&gt;域的对象的引用，与随后初次读这个&lt;code&gt;final&lt;/code&gt;域，这两个操作之间不能重排序。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="final" scheme="http://yoursite.com/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>顺序一致性模型与happens-before原则</title>
    <link href="http://yoursite.com/2019/02/09/%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E4%B8%8Ehappens-before%E8%A7%84%E5%88%99/"/>
    <id>http://yoursite.com/2019/02/09/顺序一致性模型与happens-before规则/</id>
    <published>2019-02-09T00:27:00.000Z</published>
    <updated>2019-02-09T01:09:44.343Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序一致性模型"><a href="#顺序一致性模型" class="headerlink" title="顺序一致性模型"></a>顺序一致性模型</h2><p>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。顺序一致性内存模型有两大特性：</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行。</li><li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行并且立刻对所有线程可见。</li></ul><p>JMM保证如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。</p><a id="more"></a><p>而对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有的冒出来。为了实现最小安全性，JVM在堆上分配内存时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。</p><p>注意：对于未同步程序，JMM不保证对64位的long型和double型变量的写操作具有原子性。</p><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before原则定义如下：</p><ol><li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li><li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</li></ol><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java并发编程的艺术》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;顺序一致性模型&quot;&gt;&lt;a href=&quot;#顺序一致性模型&quot; class=&quot;headerlink&quot; title=&quot;顺序一致性模型&quot;&gt;&lt;/a&gt;顺序一致性模型&lt;/h2&gt;&lt;p&gt;顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。顺序一致性内存模型有两大特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个线程中的所有操作必须按照程序的顺序来执行。&lt;/li&gt;
&lt;li&gt;不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行并且立刻对所有线程可见。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JMM保证如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="happens-before" scheme="http://yoursite.com/tags/happens-before/"/>
    
  </entry>
  
  <entry>
    <title>深入分析synchronized关键字</title>
    <link href="http://yoursite.com/2019/02/08/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90synchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/02/08/深入分析synchronized关键字/</id>
    <published>2019-02-08T02:27:00.000Z</published>
    <updated>2019-02-16T01:13:57.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>synchronized</code>是Java中的关键字，是一种同步锁，可作用于一段代码或方法，既可以保证可见性，又能够保证原子性。Java中的每一个对象都可以作为锁：</p><ul><li>对于同步方法，锁是当前实例对象。</li><li>对于静态同步方法，锁是当前对象的Class对象。</li><li>对于同步方法块，锁是Synchonized括号里配置的对象。</li></ul><p>当一个线程试图访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁，而没获取到锁的线程将被阻塞。</p><a id="more"></a><h2 id="synchronized实现原理"><a href="#synchronized实现原理" class="headerlink" title="synchronized实现原理"></a>synchronized实现原理</h2><p>每个对象有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态。</p><p>代码块同步是使用<code>monitorenter</code>和<code>monitorexit</code>指令实现的，线程执行<code>monitorenter</code>指令时尝试获取monitor的所有权，过程如下：</p><ol><li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li><li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.</li><li>如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li></ol><p>而对于<code>monitorexit</code>指令，指令执行时monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。 </p><p>方法同步不是使用<code>monitorenter</code>和<code>monitorexit</code>指令来完成，但同样是基于进入和退出monitor对象来实现，在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><h2 id="锁的升级"><a href="#锁的升级" class="headerlink" title="锁的升级"></a>锁的升级</h2><p>JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的加锁解锁开销，因为轻量级锁的获取及释放依赖多次CAS操作，而偏向锁只需要在置换线程ID的时候依赖一次CAS操作。</p><p><strong>偏向锁获取过程：</strong></p><ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，以此确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。</li><li>如果线程ID并未指向当前线程，则通过CAS操作获取锁。如果获取成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果获取失败，执行（4）。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。</li><li>执行同步代码。</li></ol><p>线程不会主动去释放偏向锁，只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p><strong>轻量级锁的加锁过程：</strong></p><ol><li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，拷贝对象头中的Mark Word到锁记录中，官方称之为Displaced Mark Word。</li><li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针，并将锁记录里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。</li><li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态，而当前线程便尝试使用自旋来获取锁。</li></ol><p>在最后一步线程获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的，由于自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。JDK采用适应性自旋的方式解决这个问题，指定自旋的次数，如果超过次数如果还没获取到锁就进入阻塞状态。线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p><strong>轻量级锁的解锁过程：</strong></p><ol><li>通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。</li><li>如果替换成功，整个同步过程就完成了。</li><li>如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。</li></ol><h2 id="锁的对比"><a href="#锁的对比" class="headerlink" title="锁的对比"></a>锁的对比</h2><table><thead><tr><th style="text-align:center">锁</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用场景</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td style="text-align:center">如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td style="text-align:center">只有一个线程执行同步块。</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高了程序的响应速度。</td><td style="text-align:center">如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td style="text-align:center">多个线程交替执行同步块。</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">线程竞争不使用自旋，不会消耗CPU。</td><td style="text-align:center">线程阻塞，响应时间缓慢。</td><td style="text-align:center">多个线程同时执行同步块。</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://ifeve.com/java-synchronized/" target="_blank" rel="noopener">聊聊并发（二）Java SE1.6中的Synchronized</a></li><li><a href="https://www.cnblogs.com/paddix/p/5367116.html" target="_blank" rel="noopener">Java并发编程：Synchronized及其实现原理</a></li><li><a href="https://www.cnblogs.com/paddix/p/5405678.html" target="_blank" rel="noopener">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是Java中的关键字，是一种同步锁，可作用于一段代码或方法，既可以保证可见性，又能够保证原子性。Java中的每一个对象都可以作为锁：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于同步方法，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;对于静态同步方法，锁是当前对象的Class对象。&lt;/li&gt;
&lt;li&gt;对于同步方法块，锁是Synchonized括号里配置的对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当一个线程试图访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁，而没获取到锁的线程将被阻塞。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="http://yoursite.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://yoursite.com/tags/synchronized/"/>
    
      <category term="锁" scheme="http://yoursite.com/tags/%E9%94%81/"/>
    
  </entry>
  
</feed>
