<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>水木今山的博客</title>
  
  <subtitle>Coding the World</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-05-06T03:18:04.379Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>水木今山</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中的装箱与拆箱</title>
    <link href="http://yoursite.com/2019/05/06/Java%E4%B8%AD%E7%9A%84%E8%A3%85%E7%AE%B1%E4%B8%8E%E6%8B%86%E7%AE%B1/"/>
    <id>http://yoursite.com/2019/05/06/Java中的装箱与拆箱/</id>
    <published>2019-05-06T03:16:00.000Z</published>
    <updated>2019-05-06T03:18:04.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自动装箱和拆箱从Java 1.5开始引入，目的是让原始类型值与对应的包装对象之间可以自动的相互转换，比如将<code>int</code>类型值转换成<code>Integer</code>对象称为装箱，反之将<code>Integer</code>对象转换成<code>int</code>类型值称为拆箱。因为这里的装箱和拆箱是自动进行的而非人为转换，所以就称为自动装箱和拆箱。</p><p>在Java中，原始类型<code>byte</code>、<code>short</code>、<code>char</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code>分别对应的包装类为<code>Byte</code>、<code>Short</code>、<code>Character</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Boolean</code>。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>自动装箱与拆箱其实是编译器自动为我们调用了相关方法，自动装箱是通过调用包装类的<code>valueOf()</code>方法实现的，而自动拆箱是通过调用包装类的<code>xxxValue()</code>方法实现的（xxx代表对应的基本数据类型）。</p><h2 id="何时发生自动装箱和拆箱"><a href="#何时发生自动装箱和拆箱" class="headerlink" title="何时发生自动装箱和拆箱"></a>何时发生自动装箱和拆箱</h2><p>自动装箱和拆箱主要发生在两种情况，一种是赋值时，另一种是在方法调用时。</p><h3 id="赋值时"><a href="#赋值时" class="headerlink" title="赋值时"></a>赋值时</h3><p>这是最常见的一种情况，在Java 1.5以前我们需要手动地进行转换才行，而现在所有的转换都是由编译器来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//before autoboxing</span></span><br><span class="line">Integer iObject = Integer.valueOf(<span class="number">3</span>);</span><br><span class="line">Int iPrimitive = iObject.intValue()</span><br><span class="line"></span><br><span class="line"><span class="comment">//after java5</span></span><br><span class="line">Integer iObject = <span class="number">3</span>; <span class="comment">//autobxing - primitive to wrapper conversion</span></span><br><span class="line"><span class="keyword">int</span> iPrimitive = iObject; <span class="comment">//unboxing - object to primitive conversion</span></span><br></pre></td></tr></table></figure><h3 id="方法调用时"><a href="#方法调用时" class="headerlink" title="方法调用时"></a>方法调用时</h3><p>这是另一个常用的情况，当我们在方法调用时，我们可以传入原始数据值或者对象，同样编译器会帮我们进行转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">show</span><span class="params">(Integer iParam)</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">"autoboxing example - method invocation i: "</span> + iParam);</span><br><span class="line">   <span class="keyword">return</span> iParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//autoboxing and unboxing in method invocation</span></span><br><span class="line">show(<span class="number">3</span>); <span class="comment">//autoboxing</span></span><br><span class="line"><span class="keyword">int</span> result = show(<span class="number">3</span>); <span class="comment">//unboxing because return type of method is Integer</span></span><br></pre></td></tr></table></figure><p><code>show</code>方法接受<code>Integer</code>对象作为参数，当调用<code>show(3)</code>时，会将<code>int</code>值转换成对应的<code>Integer</code>对象，这就是所谓的自动装箱，<code>show</code>方法返回<code>Integer</code>对象，而<code>int result = show(3);</code>中<code>result</code>为<code>int</code>类型，所以这时候发生自动拆箱操作，将<code>show</code>方法的返回的<code>Integer</code>对象转换成<code>int</code>值。</p><h2 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h2><p>自动装箱与拆箱虽然为我们省下了很多不必要的工作，使代码更加简洁清晰，但是如果使用不当，则会引起性能问题。</p><h3 id="循环中的自动装箱"><a href="#循环中的自动装箱" class="headerlink" title="循环中的自动装箱"></a>循环中的自动装箱</h3><p>自动装箱有一个问题，那就是在一个循环中进行自动装箱操作的情况，如下面的例子就会创建多余的对象，影响程序的性能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1000</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">   sum+=i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码<code>sum+=i</code>可以看成<code>sum = sum + i</code>，但是<code>+</code>这个操作符不适用于<code>Integer</code>对象，首先<code>sum</code>进行自动拆箱操作，进行数值相加操作，最后发生自动装箱操作转换成<code>Integer</code>对象。其内部变化如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = sum.intValue() + i;</span><br><span class="line">Integer sum = Integer.valueOf(result);</span><br></pre></td></tr></table></figure></p><p>由于我们这里声明的<code>sum</code>为<code>Integer</code>类型，在上面的循环中会创建将近4000个无用的<code>Integer</code>对象，在这样庞大的循环中，会降低程序的性能并且加重了垃圾回收的工作量。因此在我们编程时，需要注意到这一点，正确地声明变量类型，避免因为自动装箱引起的性能问题。</p><h3 id="对象和原始类型值的比较"><a href="#对象和原始类型值的比较" class="headerlink" title="对象和原始类型值的比较"></a>对象和原始类型值的比较</h3><p>包装类对象和原始类型值的比较是很容易出错的一个地方，需要注意的是，<code>==</code>可以用于原始值的比较，也可以用于对象的比较，但是用于对象之间的比较时，比较的不是对象代表的值，而是检查两个对象是否是同一对象。而当其中一个操作数是原始类型值或算术运算时，则比较的是数值（触发自动拆箱）。以下几个例子基本可以涵盖所有情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        Long h = <span class="number">2L</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(c==d);               <span class="comment">// 比较对象是否为同一个，因为 Integer 会缓存-128~127之间的对象</span></span><br><span class="line">        System.out.println(e==f);               <span class="comment">// 比较对象是否为同一个，数值在缓存之外</span></span><br><span class="line">        System.out.println(c==(a+b));         <span class="comment">// a+b运算触发自动拆箱，之后数值比较</span></span><br><span class="line">        System.out.println(c.equals(a+b));    <span class="comment">// a+b运算触发自动拆箱，之后自动装箱</span></span><br><span class="line">        System.out.println(g==(a+b));        <span class="comment">// a+b运算触发自动拆箱，之后数值比较</span></span><br><span class="line">        System.out.println(g.equals(a+b));   <span class="comment">// a+b运算触发自动拆箱，之后自动装箱，由于不是同一类型，equals() 返回 false</span></span><br><span class="line">        System.out.println(g.equals(a+h));  <span class="comment">// a+h运算触发自动拆箱，int类型晋升为long，之后自动装箱为Long，equals() 返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其运行结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/" target="_blank" rel="noopener">Java中的自动装箱与拆箱</a></li><li><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">深入剖析Java中的装箱和拆箱</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;自动装箱和拆箱从Java 1.5开始引入，目的是让原始类型值与对应的包装对象之间可以自动的相互转换，比如将&lt;code&gt;int&lt;/code&gt;类
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>InnoDB的MVCC实现原理</title>
    <link href="http://yoursite.com/2019/05/05/InnoDB%E7%9A%84MVCC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/05/05/InnoDB的MVCC实现原理/</id>
    <published>2019-05-05T13:45:00.000Z</published>
    <updated>2019-05-05T13:49:42.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="锁的种类"><a href="#锁的种类" class="headerlink" title="锁的种类"></a>锁的种类</h2><p>在数据库中经常能听到各种各样的锁，比如说悲观锁、乐观锁、行锁、表锁等等，但实际上前两者是从思想上进行划分的，而后两者是从锁粒度上进行划分的，真正的锁有共享锁和排他锁，也就是常说的读锁（S锁）和写锁（X锁）。</p><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象进行加锁时，还需要约定一些规则，例如何时申请X锁或S锁、持锁时间、何时释放等，这些规则称为封锁协议，对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>一级封锁协议即事务在修改某行数据时必须先对其加X锁，直到事务结束才释放，事务结束包括正常结束（COMMIT）和非正常结束（ROLLBACK）。一级封锁协议可以防止丢失修改，因为此时别的事务要想修改该数据将会阻塞到对方释放X锁，但如果仅仅是读数据不对其进行修改，是不需要加锁的，也就不能保证可重复读和脏读问题。</p><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><p>二级封锁协议即在一级封锁协议的基础上，事务读取某数据之前必须先对其加S锁，读完后即可释放S锁。二级封锁协议除了防止丢失修改，还可以进一步防止脏读问题，但在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。</p><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><p>三级封锁协议即在一级封锁协议的基础上，事务读取某数据之前必须先对其加S锁，直到事务结束才释放。三级封锁协议除了防止丢失修改和脏读问题以外，还进一步防止了不可重复读。</p><h2 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h2><p>一次性锁协议指的是在事务开始时，一次性申请所有的锁，之后不会再申请任何锁，如果其中某个锁不可用，则整个申请就不成功，事务就不会执行，一次性释放所有的锁。一次性锁协议不会产生死锁的问题，但事务的并发度不高。</p><p>数据库遵循的是两段锁协议，将事务分成两个阶段，加锁阶段和解锁阶段（所以叫两段锁）：</p><ul><li>加锁阶段：事务只能加锁，也可以操作数据，但不能解锁，直到事务释放第一个锁，就进入解锁阶段</li><li>解锁阶段：事务只能解锁，也可以操作数据，但不能加锁</li></ul><p>两段锁协议使得事务具有较高的并发度，但是没有解决死锁的问题，因为它在加锁阶段没有顺序要求，如两个事务分别申请了A、B锁，接着又申请了对方的锁，此时进入死锁状态。</p><h2 id="多版本并发控制（MVCC）"><a href="#多版本并发控制（MVCC）" class="headerlink" title="多版本并发控制（MVCC）"></a>多版本并发控制（MVCC）</h2><p>InnoDB采用的是两段锁协议，开始时不断加锁，最后COMMIT或ROLLBACK时一次性释放所有锁，实质上是一种悲观并发控制，而在实际场景下更多都是读多写少的情况，此时悲观的方式会降低系统的并发性能。为了提高并发性能，InnoDB同时实现了MVCC，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高数据库系统的并发性能。</p><h3 id="redo-undo-log"><a href="#redo-undo-log" class="headerlink" title="redo/undo log"></a>redo/undo log</h3><p>为了支持事务，InnoDB实现了redo log与undo log：</p><ul><li>redo log：保存执行的sql语句到一个指定的log文件，当MySQL执行recovery时重新执行redo log记录的sql操作即可，当客户端执行每条sql时，redo log首先会被写入log buffer，当客户端执行COMMIT时，log buffer中的内容会被视情况刷新到磁盘。redo log在磁盘上作为一个独立的文件存在，即InnoDB的log文件。</li><li>undo log：与redo log相反，undo log是为回滚而用，把该行修改前的值copy到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在.ibd数据文件中。</li></ul><h3 id="隐藏字段"><a href="#隐藏字段" class="headerlink" title="隐藏字段"></a>隐藏字段</h3><p>在MySQL中，InnoDB为每行记录都实现了三个隐藏字段：</p><ul><li>6字节的<code>DB_TRX_ID</code>：事务ID，每处理一个事务，其值自动+1</li><li>7字节的<code>DATA_ROLL_PTR</code>：回滚指针，指向该行修改前的上一个历史版本</li><li>6字节的<code>DB_ROW_ID</code>：如果表中没有显示定义主键或者没有唯一非空索引时InnoDB会自动创建</li></ul><p>当插入一条新数据时，记录上对应的回滚指针为null：</p><p><img src="http://blog.default.nanwulife.com/20170401151910811.jpg" alt=""></p><p>更新记录时，原记录将被放入到undo log中，并通过<code>DATA_ROLL_PT</code>指向该记录：</p><p><img src="http://blog.default.nanwulife.com/20170401151927986.jpg" alt=""></p><p>MySQL就是根据记录上的回滚指针及事务ID判断记录是否可见，如果不可见则按照<code>DATA_ROLL_PT</code>继续回溯查找。</p><h3 id="通过read-view判断行记录是否可见"><a href="#通过read-view判断行记录是否可见" class="headerlink" title="通过read view判断行记录是否可见"></a>通过read view判断行记录是否可见</h3><p><img src="http://blog.default.nanwulife.com/20170401151940733.jpg" alt="">)</p><p>相关源码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">changes_visible</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">trx_id_t</span>    id,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">const</span> <span class="keyword">table_name_t</span>&amp; name)</span> <span class="keyword">const</span></span></span><br><span class="line">MY_ATTRIBUTE((warn_unused_result))</span><br><span class="line">&#123;</span><br><span class="line">ut_ad(id &gt; <span class="number">0</span>);</span><br><span class="line"><span class="comment">//如果ID小于Read View中最小的, 则这条记录是可以看到。说明这条记录是在select这个事务开始之前就结束的</span></span><br><span class="line"><span class="keyword">if</span> (id &lt; m_up_limit_id || id == m_creator_trx_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line">check_trx_id_sanity(id, name);</span><br><span class="line"><span class="comment">//如果比Read View中最大的还要大，则说明这条记录是在事务开始之后进行修改的，所以此条记录不应查看到</span></span><br><span class="line"><span class="keyword">if</span> (id &gt;= m_low_limit_id) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">false</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_ids.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">ids_t</span>::value_type*    p = m_ids.data();</span><br><span class="line"><span class="keyword">return</span>(!<span class="built_in">std</span>::binary_search(p, p + m_ids.size(), id)); <span class="comment">//判断是否在Read View中， 如果在说明在创建Read View时 此条记录还处于活跃状态则不应该查询到，否则说明创建Read View是此条记录已经是不活跃状态则可以查询到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要注意的是，InnoDB的MVCC仅针对RR和RC这两种隔离级别而言。对于<code>Read Uncommitted</code>，由于读取到的总是最新的数据，不管该记录是否已经提交，因此不会遍历版本链，也就不需要MVCC；而对于<code>Serializable</code>级别，使用的仍是悲观并发控制，读加共享锁，写加排他锁，读写相互阻塞。而对于RR和RC级别，它们对于MVCC的可见性实现也是不同的：</p><ul><li>RC：事务内的每个查询语句都会重新创建read view，这样就会产生不可重复读的现象发生</li><li>RR：事务开始时创建read view，直到事务结束的这段时间内每一次查询都不会重建read view，从而实现了可重复读</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVCC是一种用来解决读-写冲突的无锁并发控制机制，它所支持的RR和RC两种隔离级别，读写之间不会被阻塞，大大提高了并发性能。InnoDB实现的四种隔离级别，总体就是通过MVCC+2PL实现的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/joy0921/article/details/80128857" target="_blank" rel="noopener">MVCC原理探究及MySQL源码实现分析</a></li><li><a href="http://www.cnblogs.com/chenpingzhao/p/5065316.html" target="_blank" rel="noopener">【mysql】关于innodb中MVCC的一些理解</a></li><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html" target="_blank" rel="noopener">Innodb中的事务隔离级别和锁的关系</a></li><li><a href="https://www.zhihu.com/question/27876575" target="_blank" rel="noopener">乐观锁和 MVCC 的区别？</a></li><li><a href="https://www.zhihu.com/question/263820564" target="_blank" rel="noopener">MySQL 是如何实现四大隔离级别的？</a></li><li><a href="https://www.cnblogs.com/zszmhd/p/3365220.html" target="_blank" rel="noopener">两阶段锁协议</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;锁的种类&quot;&gt;&lt;a href=&quot;#锁的种类&quot; class=&quot;headerlink&quot; title=&quot;锁的种类&quot;&gt;&lt;/a&gt;锁的种类&lt;/h2&gt;&lt;p&gt;在数据库中经常能听到各种各样的锁，比如说悲观锁、乐观锁、行锁、表锁等等，但实际上前两者是从思想上进行划分的，而后两者是从锁粒
      
    
    </summary>
    
      <category term="MySQL" scheme="http://yoursite.com/categories/MySQL/"/>
    
    
      <category term="InnoDB" scheme="http://yoursite.com/tags/InnoDB/"/>
    
      <category term="MVCC" scheme="http://yoursite.com/tags/MVCC/"/>
    
      <category term="封锁协议" scheme="http://yoursite.com/tags/%E5%B0%81%E9%94%81%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化与反序列化机制</title>
    <link href="http://yoursite.com/2019/05/04/Java%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/05/04/Java序列化与反序列化机制/</id>
    <published>2019-05-04T14:32:00.000Z</published>
    <updated>2019-05-05T13:47:20.096Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>序列化是一种对象持久化的手段，使用Java对象序列化，保存对象时会将其状态保存为一组字节，在之后可以再将这些字节组装成对象。简单来说，要实现Java对象的序列化，我们只需要让被序列化类实现<code>Serializable</code>接口，并且使用<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>进行对象的读写即可。但是，关于Java序列化和反序列化其实还有一些更深层次的特性需要了解。</p><h2 id="如何实现对象的序列化"><a href="#如何实现对象的序列化" class="headerlink" title="如何实现对象的序列化"></a>如何实现对象的序列化</h2><p>首先，先介绍一下如何将对象序列化并反序列化。在Java中，被序列化的类必须实现<code>Serializable</code>接口，然后通过<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>进行对象的读写即可实现对象的序列化与反序列化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Person(<span class="string">"LiHua"</span>, <span class="number">19</span>);</span><br><span class="line"></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        oo.writeObject(person);</span><br><span class="line">        oo.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>));</span><br><span class="line">        Person anotherPerson = (Person) oi.readObject();</span><br><span class="line">        oi.close();</span><br><span class="line"></span><br><span class="line">        System.out.println(person);</span><br><span class="line">        System.out.println(anotherPerson);</span><br><span class="line">        System.out.println(person == anotherPerson);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name=&apos;LiHua&apos;, age=19&#125;</span><br><span class="line">Person&#123;name=&apos;LiHua&apos;, age=19&#125;</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><p>可以看出，对象在序列化到文件后，可以再通过反序列化重新加载进内存，不过虽然这两个对象的属性值都相同，可是它们并不是同一个对象，它们的内存地址并不相同。</p><p>这里需要注意的是，被序列化类虽然实现了<code>Serializable</code>接口，但这个接口并不包含任何方法，仅仅起到标识的作用，那么它是在什么地方起到作用的呢？这里就要从<code>ObjectOutputStream</code>的<code>writeObject</code>方法的调用栈去寻找：<code>writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeSerialData-&gt;invokeWriteObject</code>，在<code>writeObject0</code>这个方法中有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    writeString((String) obj, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (cl.isArray()) &#123;</span><br><span class="line">    writeArray(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Enum) &#123;</span><br><span class="line">    writeEnum((Enum&lt;?&gt;) obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Serializable) &#123;</span><br><span class="line">    writeOrdinaryObject(obj, desc, unshared);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (extendedDebugInfo) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(</span><br><span class="line">            cl.getName() + <span class="string">"\n"</span> + debugInfoStack.toString());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotSerializableException(cl.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是说，在序列化时该方法会先判断被序列化的类是否是<code>String</code>、<code>Array</code>、<code>Enum</code>或<code>Serializable</code>类型，如果不是则直接抛出<code>NotSerializableException</code>异常。</p><h2 id="serialVersionUID"><a href="#serialVersionUID" class="headerlink" title="serialVersionUID"></a>serialVersionUID</h2><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，还有一个非常重要的一点是两个类的序列化ID是否一致，也就是我们可以在被序列化的类中加上<code>private static final long serialVersionUID = 1L;</code>来控制该类的序列化版本号，如果序列化与反序列化的该属性不同，则会抛出异常。这个序列化ID可以是随机的一个不重复的<code>long</code>型数值，但是如果没有特殊需求的话，使用默认的<code>1L</code>就可以了。</p><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><p><code>transient</code>关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，<code>transient</code>变量的值被设为初始值，如<code>int</code>型的是0，对象型的是<code>null</code>。但是，其实我们也可以使用自定义的序列化和反序列化策略，将<code>transient</code>修饰过的变量序列化到文件中，在<code>ArrayList</code>中就有这样的应用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br></pre></td></tr></table></figure></p><p>我们知道，<code>ArrayList</code>的本质其实就是通过数组存储元素，但是查看源码会发现这个存储元素的数组<code>elementData</code>被<code>transient</code>修饰了，这并不意味着它就无法被序列化了，相反，<code>ArrayList</code>通过<code>writeObject</code>和<code>readObject</code>方法以自定义的方式将其序列化并反序列化：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</span><br><span class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></span><br><span class="line">    s.writeInt(size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write out all elements in the proper order.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        s.writeObject(elementData[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">    elementData = EMPTY_ELEMENTDATA;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in size, and any hidden stuff</span></span><br><span class="line">    s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read in capacity</span></span><br><span class="line">    s.readInt(); <span class="comment">// ignored</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></span><br><span class="line">        <span class="keyword">int</span> capacity = calculateCapacity(elementData, size);</span><br><span class="line">        SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, capacity);</span><br><span class="line">        ensureCapacityInternal(size);</span><br><span class="line"></span><br><span class="line">        Object[] a = elementData;</span><br><span class="line">        <span class="comment">// Read in all elements in the proper order.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            a[i] = s.readObject();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在序列化的过程中，如果被序列化的类定义了<code>writeObject</code>和<code>readObject</code>方法，虚拟机会试图调用这两个方法进行用户自定义的序列化和反序列化，如果没有这两个方法，则默认调用是<code>ObjectOutputStream</code>的<code>defaultWriteObject</code>方法以及<code>ObjectInputStream</code>的<code>defaultReadObject</code>方法。</p><p>因此，如果我们想在序列化的过程中动态改变序列化的数值，就可以定义这两个方法。典型的应用场景就是在序列化对象数据时，有一些数据是敏感的，我们想在序列化时进行加密，而在反序列化时进行解密，那么此时就可以通过这两个方法来实现。</p><p>那么在上面的<code>ArrayList</code>中，又为什么要用这种方式实现序列化呢？原因是因为<code>ArrayList</code>实际上是动态数组，每次放满元素后都会自动扩容，此时如果实际的元素个数小于容量大小时，会将<code>null</code>元素也序列化到文件中。为了保证只序列化实际存在的元素，<code>ArrayList</code>把<code>elementData</code>用<code>transient</code>关键字修饰，并自定义了序列化反序列化的策略。</p><p>那么这个自定义的序列化反序列化策略又是在哪调用的？还是上面的调用栈<code>writeObject-&gt;writeObject0-&gt;writeOrdinaryObject-&gt;writeSerialData-&gt;invokeWriteObject</code>，在<code>writeSerialData</code>方法中我们可以看到这样一段逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (slotDesc.hasWriteObjectMethod()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        curContext = <span class="keyword">new</span> SerialCallbackContext(obj, slotDesc);</span><br><span class="line">        bout.setBlockDataMode(<span class="keyword">true</span>);</span><br><span class="line">        slotDesc.invokeWriteObject(obj, <span class="keyword">this</span>);</span><br><span class="line">        bout.setBlockDataMode(<span class="keyword">false</span>);</span><br><span class="line">        bout.writeByte(TC_ENDBLOCKDATA);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    curPut = oldPut;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    defaultWriteFields(obj, slotDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它会先通过<code>hasWriteObjectMethod</code>判断存在用户自定义的<code>writeObject</code>方法后，调用<code>invokeWriteObject</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeWriteObject</span><span class="params">(Object obj, ObjectOutputStream out)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, UnsupportedOperationException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    requireInitialized();</span><br><span class="line">    <span class="keyword">if</span> (writeObjectMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeObjectMethod.invoke(obj, <span class="keyword">new</span> Object[]&#123; out &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable th = ex.getTargetException();</span><br><span class="line">            <span class="keyword">if</span> (th <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (IOException) th;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                throwMiscException(th);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="comment">// should not occur, as access checks have been suppressed</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中<code>writeObjectMethod.invoke(obj, new Object[]{ out });</code>是关键，正是在这里通过反射的方式调用自定义的<code>writeObject</code>方法的。</p><h2 id="父类与静态变量序列化"><a href="#父类与静态变量序列化" class="headerlink" title="父类与静态变量序列化"></a>父类与静态变量序列化</h2><p>关于序列化反序列化机制还有几点需要注意的是，静态变量是无法被序列化的，原因在于序列化保存的是对象的状态，而静态变量属于类的状态。除此之外，如果被序列化的类的父类没有实现<code>Serializable</code>接口时，虚拟机是不会序列化父对象的，要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code>接口。因此，如果我们想要让某些字段不被序列化，可以将这些字段抽取出来放到父类中，且让子类实现<code>Serialzable</code>接口，父类不实现。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在Java中，只要一个类实现了<code>Serializable</code>接口，那么就可以通过<code>ObjectInputStream</code>和<code>ObjectOutputStream</code>将其对象进行序列化与反序列化。</li><li>如果两个类的<code>serialVersionUID</code>不同，则无法被反序列化，此时会抛出异常。</li><li>序列化不保存静态变量。</li><li>要想将父类对象也序列化，就需要让父类也实现<code>Serializable</code>接口。</li><li>将被序列化的类的字段用<code>transient</code>关键字修饰，可以阻止该字段被序列化，在被反序列化时，该变量的值会被设为初始值。</li><li>可以通过定义<code>writeObject</code>和<code>readObject</code>方法实现自定义的序列化反序列化策略，如对敏感数据进行加密与解密。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-serial/" target="_blank" rel="noopener">Java 序列化的高级认识</a></li><li><a href="http://www.importnew.com/18024.html" target="_blank" rel="noopener">深入分析Java的序列化与反序列化</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;序列化是一种对象持久化的手段，使用Java对象序列化，保存对象时会将其状态保存为一组字节，在之后可以再将这些字节组装成对象。简单来说，要实现
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>Java中的深拷贝与浅拷贝</title>
    <link href="http://yoursite.com/2019/05/04/Java%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2019/05/04/Java中的深拷贝与浅拷贝/</id>
    <published>2019-05-04T10:09:00.000Z</published>
    <updated>2019-05-04T10:10:20.756Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝。</li><li>深拷贝：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象并复制其内容，做到了真正完全的拷贝。</li></ul><h2 id="浅拷贝实现"><a href="#浅拷贝实现" class="headerlink" title="浅拷贝实现"></a>浅拷贝实现</h2><p>以下场景中有两个类，一个是<code>Parent</code>，一个是<code>Child</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要实现浅拷贝，只需要让<code>Parent</code>实现<code>Cloneable</code>接口，并覆盖<code>Object</code>的<code>clone()</code>方法即可。以下为测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Parent parent1 = <span class="keyword">new</span> Parent(<span class="string">"parent name"</span>, <span class="keyword">new</span> Child(<span class="string">"child name"</span>));</span><br><span class="line">        Parent parent2 = (Parent) parent1.clone();</span><br><span class="line">        System.out.println(parent1 == parent2);</span><br><span class="line">        System.out.println(parent1.parentName);</span><br><span class="line">        System.out.println(parent2.parentName);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        System.out.println(parent1.child == parent2.child);</span><br><span class="line">        System.out.println(parent1.child.childName);</span><br><span class="line">        System.out.println(parent2.child.childName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">true</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p><p>可以看出，浅拷贝确实创建了一个新的<code>Parent</code>对象，并且属性<code>parentName</code>的值也一模一样，但是对于为引用类型的属性<code>child</code>，实际上与之前引用的是同一个对象。</p><h2 id="深拷贝实现"><a href="#深拷贝实现" class="headerlink" title="深拷贝实现"></a>深拷贝实现</h2><p>要实现深拷贝，常用的方案有以下两种：</p><ol><li>序列化这个对象，再反序列化回来，就可以得到新的对象。</li><li>让属性也实现<code>Cloneable</code>。</li></ol><h3 id="属性实现Cloneable"><a href="#属性实现Cloneable" class="headerlink" title="属性实现Cloneable"></a>属性实现Cloneable</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Parent parentClone = (Parent) <span class="keyword">super</span>.clone();</span><br><span class="line">        parentClone.child = (Child) <span class="keyword">this</span>.child.clone();</span><br><span class="line">        <span class="keyword">return</span> parentClone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和之前的浅拷贝不同之处在于这里<code>Child</code>也实现了<code>Cloneable</code>，并覆盖了<code>clone()</code>方法，而<code>Parent</code>的<code>clone()</code>方法也有略微不同，在调用了<code>clone()</code>方法后还调用了属性<code>child</code>的<code>clone()</code>方法重新设置属性，从而实现完完全全的拷贝。</p><p>此时控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">false</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p><p>注意到此时原始对象和拷贝对象的<code>child</code>属性所引用的不再是同一个对象了。</p><h3 id="序列化方式"><a href="#序列化方式" class="headerlink" title="序列化方式"></a>序列化方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String parentName;</span><br><span class="line">    Child child;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Parent</span><span class="params">(String parentName, Child child)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parentName = parentName;</span><br><span class="line">        <span class="keyword">this</span>.child = child;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 将对象写到流里</span></span><br><span class="line">        OutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        <span class="comment">//OutputStream op = new ObjectOutputStream();</span></span><br><span class="line">        ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">        oo.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从流里读对象出来</span></span><br><span class="line">        InputStream bi = <span class="keyword">new</span> ByteArrayInputStream(((ByteArrayOutputStream) bo).toByteArray());</span><br><span class="line">        ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">        <span class="keyword">return</span> (oi.readObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String childName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Child</span><span class="params">(String childName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.childName = childName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时两个类都不需要再实现<code>Cloneable</code>接口并覆盖<code>clone()</code>方法了，但是它们都需要实现<code>Serializable</code>接口，并且在<code>Parent</code>的克隆方法中要实现序列化反序列化的逻辑，此时控制台输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">false</span><br><span class="line">parent name</span><br><span class="line">parent name</span><br><span class="line">==================</span><br><span class="line">false</span><br><span class="line">child name</span><br><span class="line">child name</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;浅拷贝：对基本数据类型进行值传递，对引用数据类型进行引用传递的拷贝。&lt;/li&gt;
&lt;li&gt;深拷贝：对基本数据类型进行值传递，对引用
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>StringBuilder与StringBuffer源码分析</title>
    <link href="http://yoursite.com/2019/05/03/StringBuilder%E4%B8%8EStringBuffer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/StringBuilder与StringBuffer源码分析/</id>
    <published>2019-05-03T13:32:00.000Z</published>
    <updated>2019-05-06T03:19:04.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>StringBuilder</code>与<code>StringBuffer</code>是两个常用的字符串操作类，与<code>String</code>的不同之处在于他们是可变的，不像<code>String</code>的<code>value</code>数组被<code>final</code>修饰的严严实实的，而<code>StringBuilder</code>和<code>StringBuffer</code>的<code>value</code>数组没有被<code>final</code>修饰过，并且这两个类的实现几乎一样，主要的区别在于<code>StringBuffer</code>的方法由<code>synchronized</code>关键字修饰过，所以是线程安全的。这里先贴出整个体系的UML类图：</p><p><img src="http://blog.default.nanwulife.com/AbstractStringBuilder.png" alt=""></p><h2 id="AbstractStringBuilder"><a href="#AbstractStringBuilder" class="headerlink" title="AbstractStringBuilder"></a>AbstractStringBuilder</h2><p>从上面的类图也能看到，<code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，<code>AbstractStringBuilder</code>为子类提供了大部分的实现，因此，我们有必要先分析一下<code>AbstractStringBuilder</code>的源码。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p><code>AbstractStringBuilder</code>主要有以下两个成员变量，值得注意的是<code>value</code>并没有被<code>final</code>修饰，意味着它是可变的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与 String 一样维护一个字符数组</span></span><br><span class="line"><span class="keyword">char</span>[] value;</span><br><span class="line"><span class="comment">// 字符的个数</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>在这里顺便将构造函数的源码也分析了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">AbstractStringBuilder() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];     <span class="comment">// 初始化为指定容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>在分析关键的<code>append()</code>方法前，我们先分析一下数组的扩容操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity &gt; <span class="number">0</span>)</span><br><span class="line">        ensureCapacityInternal(minimumCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;   <span class="comment">// 如果所需容量大于当前容量，则进行扩容</span></span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;  <span class="comment">// 计算新容量为原来容量的两倍加2</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;           <span class="comment">// 如果计算出的新容量不够大</span></span><br><span class="line">        newCapacity = minCapacity;                  <span class="comment">// 直接将新容量设为所需容量</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)    <span class="comment">// 如果新容量大于 MAX_ARRAY_SIZE，还要做进一步判断</span></span><br><span class="line">        : newCapacity;                      <span class="comment">// 否则，返回新容量即可</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果所需容量大于整型最大值，则直接抛出 OutOfMemoryError</span></span><br><span class="line">    <span class="keyword">if</span> (Integer.MAX_VALUE - minCapacity &lt; <span class="number">0</span>) &#123; <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果所需容量大于 MAX_ARRAY_SIZE 且小于整型最大值时，返回所需容量</span></span><br><span class="line">    <span class="comment">// 如果所需容量小于 MAX_ARRAY_SIZE，返回 MAX_ARRAY_SIZE</span></span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE)</span><br><span class="line">        ? minCapacity : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的扩容操作逻辑有点复杂，这里先总结下流程：</p><ol><li>默认的新容量大小为原容量大小的两倍加2，如果还不够，就直接设为所需要的容量大小</li><li>如果新容量大小比<code>MAX_ARRAY_SIZE</code>小，那么直接返回该新容量大小</li><li>否则，检查需要的容量大小是否超过整型最大值，如果超过则抛出异常</li><li>如果需要的容量大小比<code>MAX_ARRAY_SIZE</code>大，则直接返回需要的容量大小；否则，返回<code>MAX_ARRAY_SIZE</code></li></ol><p>其实这个扩容操作和<code>ArrayList</code>的扩容操作逻辑基本一致，这里的<code>MAX_ARRAY_SIZE</code>的值为<code>Integer.MAX_VALUE - 8</code>也就是整型的最大值减8，那么为什么要设置成这个值呢？其实在注释中也有说明，一些虚拟机的实现可能会在数组中存储header words，因此如果分配比这个值更大的容量的话，有可能会导致<code>OutOfMemoryError</code>。</p><h3 id="append"><a href="#append" class="headerlink" title="append()"></a>append()</h3><p>接下来看看<code>append()</code>方法，<code>append()</code>方法是整个类的核心，我们在实际中也经常使用。实际上它有很多个重载方法，这里就只分析参数为<code>String</code>类型的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)                <span class="comment">// 如果参数为 null</span></span><br><span class="line">        <span class="keyword">return</span> appendNull();    <span class="comment">// 实际上是添加 'n' 、'u'、'l' 、'l' 四个字符到 value 数组中</span></span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);    <span class="comment">// 扩容</span></span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);        <span class="comment">// 调用 String 的 getChars() 方法将 str 追加到 value 末尾</span></span><br><span class="line">    count += len;   <span class="comment">// 更新字符长度</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;       <span class="comment">// 返回自身，支持链式调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractStringBuilder <span class="title">appendNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = count;</span><br><span class="line">    ensureCapacityInternal(c + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">    value[c++] = <span class="string">'n'</span>;</span><br><span class="line">    value[c++] = <span class="string">'u'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    value[c++] = <span class="string">'l'</span>;</span><br><span class="line">    count = c;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>append()</code>方法其实逻辑挺简单的，但有两点是需要注意到的，一个是追加字符串的操作是通过<code>String</code>的<code>getChars()</code>完成的，但最后还是调用的<code>System.arraycopy()</code>这个native方法；另一个是该方法返回的是自身<code>this</code>，通过这种方式，我们可以实现<code>append()</code>方法的链式调用。</p><h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>上面分析的<code>AbstractStringBuilder</code>已经实现了大部分需要的方法了，接下来开始分析第一个子类<code>StringBuilder</code>，先看看构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(capacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuilder</span><span class="params">(CharSequence seq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(seq.length() + <span class="number">16</span>);</span><br><span class="line">    append(seq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>StringBuilder</code>有四个重载的构造函数，并且默认的初始化容量为16，当然我们也可以指定初始化容量，或者直接传入一个已有的字符序列。</p><h3 id="append-1"><a href="#append-1" class="headerlink" title="append()"></a>append()</h3><p><code>StringBuilder</code>的<code>append()</code>方法有非常多的重载，但其实都是调用父类<code>AbstractStringBuilder</code>的方法，在上面已经分析过了，所以这里就简单看一个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p><code>StringBuffer</code>和<code>StringBuilder</code>的实现基本一样，只不过方法被<code>synchronized</code>关键字修饰了，因此是线程安全的，比如下面的<code>append()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到方法中有个<code>toStringCache</code>变量，这个变量是最近一次<code>toString()</code>方法的缓存，任何写操作都会将该缓存重设为<code>null</code>，我们看下这个<code>toString()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (toStringCache == <span class="keyword">null</span>) &#123;</span><br><span class="line">        toStringCache = Arrays.copyOfRange(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(toStringCache, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果缓存为空的话，那么就会先填充缓存，否则直接使用缓存<code>new</code>一个新的<code>String</code>对象并返回，但要注意的是，这里并不会有复制操作，而是直接将<code>String</code>对象中的<code>value</code>指向这个缓存数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>与<code>String</code>不同，<code>StringBuilder</code>和<code>StringBuffer</code>都是可变字符串，底层<code>value</code>数组没有使用<code>final</code>关键字修饰</li><li><code>StringBuilder</code>和<code>StringBuffer</code>均继承自抽象类<code>AbstractStringBuilder</code>，它完成了大部分方法的实现，因此子类只需要调用父类的方法即可</li><li><code>StringBuilder</code>和<code>StringBuffer</code>的默认容量都为16，并且默认的扩容大小是原来的两倍加2</li><li><code>StringBuilder</code>不是线程安全的，而<code>StringBuffer</code>通过<code>synchronized</code>关键字保证了线程安全</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;StringBuilder&lt;/code&gt;与&lt;code&gt;StringBuffer&lt;/code&gt;是两个常用的字符串操作类，与&lt;cod
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="StringBuilder" scheme="http://yoursite.com/tags/StringBuilder/"/>
    
      <category term="StringBuffer" scheme="http://yoursite.com/tags/StringBuffer/"/>
    
  </entry>
  
  <entry>
    <title>CountDownLatch与CyclicBarrier源码分析</title>
    <link href="http://yoursite.com/2019/05/03/CountDownLatch%E4%B8%8ECyclicBarrier%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/CountDownLatch与CyclicBarrier源码分析/</id>
    <published>2019-05-03T10:07:00.000Z</published>
    <updated>2019-05-03T10:10:35.308Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p><code>CountDownLatch</code>是基于AQS实现的，它使用AQS中的<code>state</code>成员变量作为计数器，在<code>state</code>不为0的情况下，凡是调用<code>await()</code>方法的线程将会被阻塞，并放入AQS维护的同步队列中，而当<code>state</code>减至0时，队列中的节点会被唤醒，被阻塞的线程即可恢复运行。先来看看它的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，它创建了一个<code>Sync</code>对象，并将参数传入，这个参数就是计数器的值。因此，关于<code>CountDownLatch</code>的分析将从这个<code>Sync</code>类开始。</p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p><code>CountDownLatch</code>中有个<code>Sync</code>内部类，它实现了AQS中的几个重要方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">        setState(count);    <span class="comment">// 设置 AQS 的 state 变量，也就是计数器的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState();  <span class="comment">// 获取 AQS 的 state 变量值，也就是计数器的值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法主要是在 await() 中用到</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用 getState() 方法获取 state 变量的值，</span></span><br><span class="line">        <span class="comment">// 如果等于0，则返回正数，后续将不会阻塞线程</span></span><br><span class="line">        <span class="comment">// 如果不等于0，则返回负数，后续将会阻塞线程</span></span><br><span class="line">        <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该方法主要是在 countDown() 中用到</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为可能有多个线程同时调用该方法</span></span><br><span class="line">        <span class="comment">// 所以这里使用 CAS + 循环的方式保证线程安全</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(c, nextc))   <span class="comment">// CAS 将 state 的值减一</span></span><br><span class="line">                <span class="keyword">return</span> nextc == <span class="number">0</span>;                  <span class="comment">// 如果减到0了，就返回true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h3><p>使用<code>CountDownLatch</code>同步组件时，基本都会使用到<code>await()</code>方法，当计数器不为0时，这可以阻塞调用该方法的线程。同时，通过这个方法我们也将知道上面介绍的<code>tryAcquireShared()</code>是在何处被调用的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 AQS 的 acquireSharedInterruptibly() 方法</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法在AQS中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 响应中断 </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)             <span class="comment">// 该方法由子类 Sync 实现，如果返回值大于0，那么将直接返回</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);  <span class="comment">// 否则，将会放入同步队列中被阻塞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法在AQS中实现</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);  <span class="comment">// 由 CountDownLatch 的 Sync 具体实现</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;                         </span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="countDown"><a href="#countDown" class="headerlink" title="countDown()"></a>countDown()</h3><p>这个方法也是使用<code>CountDownLatch</code>组件时必不可少的一个方法，当一个线程调用上面的<code>await()</code>方法而被阻塞时，通过<code>countDown()</code>方法能将计数器的值（也就是变量<code>state</code>的值）减一，当计数器的值减为0时，阻塞在<code>await()</code>上的线程也就可以正常返回了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 就像 await() 调用 AQS 的 acquireSharedInterruptibly() 方法一样</span></span><br><span class="line">    <span class="comment">// 这里调用 AQS 的 releaseShared() 方法</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;    <span class="comment">// 该方法由子类 Sync 实现，会将 state--，如果 state 为0了，就返回 true</span></span><br><span class="line">        doReleaseShared();          <span class="comment">// 唤醒同步队列中的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p><code>CyclicBarrier</code>的作用和<code>CountDownLatch</code>类似，它是在计数器（等待线程数）达到指定数量后，再唤醒等待线程。它的实现和<code>CountDownLatch</code>不同，并没有直接通过AQS实现同步功能，而是在重入锁<code>ReentrantLock</code>的基础上实现的。先来了解一下它的几个成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当 parties 个线程到达屏障后，屏障才会放行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 还剩下没到达屏障的线程数，会在新一轮开启或者当前屏障被破坏时重置为 parties</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当第 parties 个线程到达时回调</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 代表每一轮的运行状况，仅有一个成员变量 broken 表示屏障是否被破坏</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>接下来看看它的构造函数，与<code>CountDownLatch</code>一样需要传入一个计数器的初始值，除此之外，还可以传入一个回调对象，当最后一个线程到达屏障时会执行该回调逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;   <span class="comment">// 初始时有 parties 个线程未到达屏障</span></span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="await-1"><a href="#await-1" class="headerlink" title="await()"></a>await()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">// 如果 g.broken = true，表示屏障被破坏了，这里直接抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">// 如果线程中断，则调用 breakBarrier() 破坏屏障</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// index 表示线程到达屏障的顺序，如果为 parties-1 表明当前是第一个到达屏障的</span></span><br><span class="line">        <span class="comment">// 如果 index 为0，表示当前线程是最后一个到达屏障的</span></span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// 如果 index 为0，唤醒所有处于等待状态的线程</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();   <span class="comment">// 重置屏障状态，使其进入新一轮的运行过程中</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;              <span class="comment">// 返回</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction) <span class="comment">// 若执行过程中发生异常，则调用 breakBarrier() 破坏屏障</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行到此处的线程都会被屏障挡住，并进入等待状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)         <span class="comment">// timed 一般传入 false，因此这里条件成立</span></span><br><span class="line">                    trip.await();   <span class="comment">// 阻塞在 Condition 上</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏障被破坏，抛出 BrokenBarrierException 异常</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 屏障进入新的运行轮次，此时返回线程在上一轮次到达屏障的顺序</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时判断</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开启新的一轮运行过程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 唤醒所有处于等待状态中的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 重置 count</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重新创建 Generation</span></span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 破坏屏障</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置屏障被破坏的标志</span></span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 重置 count</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 唤醒所有处于等待状态中的线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p><code>CyclicBarrier</code>的计数器可以在正常结束一轮后自动重置，当然我们也可以使用<code>reset()</code>方法强制重置，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();      <span class="comment">// 破坏屏障</span></span><br><span class="line">        nextGeneration(); <span class="comment">// 开启新一轮的运行过程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h2><p>总的来说，<code>CountDownLatch</code>和<code>CyclicBarrier</code>能够实现的功能差不多，但是<code>CyclicBarrier</code>可以循环使用，并且可以设置回调，因此对于复杂的业务场景，使用<code>CyclicBarrier</code>更合适一些。关于具体的使用场景可以参考之前的一篇文章：<a href="http://hecenjie.cn/2019/02/10/Java%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB/" target="_blank" rel="noopener">Java中的并发工具类</a> 。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.tianxiaobo.com/2018/05/10/Java-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%BB%84%E4%BB%B6-CountDownLatch-%E4%B8%8E-CyclicBarrier-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#32-cyclicbarrier-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" target="_blank" rel="noopener">Java 线程同步组件 CountDownLatch 与 CyclicBarrier 原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CountDownLatch&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="CountDownLatch" scheme="http://yoursite.com/tags/CountDownLatch/"/>
    
      <category term="CyclicBarrier" scheme="http://yoursite.com/tags/CyclicBarrier/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock源码分析</title>
    <link href="http://yoursite.com/2019/05/03/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/05/03/ReentrantLock源码分析/</id>
    <published>2019-05-03T06:39:00.000Z</published>
    <updated>2019-05-03T06:40:50.438Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>ReentrantLock</code>可重入锁功能与<code>synchronized</code>类似，用于协调多线程间的同步，并且提供比<code>synchronized</code>更为丰富的功能，比如可响应中断、锁超时等。<code>ReentrantLock</code>本身的实现其实较为简单，因为大部分的复杂逻辑方法已经由AQS实现了，它只需要实现少部分的关键方法即可，所以在学习<code>ReentrantLock</code>之前，个人认为有必要先去了解AQS。</p><p>本文将先说明重入锁的含义、公平锁与非公平锁的对比，然后进入<code>ReentrantLock</code>源码的分析，最后再将其与<code>synchronized</code>关键字进行对比。</p><h2 id="重入锁"><a href="#重入锁" class="headerlink" title="重入锁"></a>重入锁</h2><p>可重入指的是同一个线程可以对同一把锁进行重复加锁，比如线程A获取到了锁并进入了临界区，然后调用另一个同样需要该锁的方法时，它可以成功的再次获取该锁，而不会被阻塞住。那么如果锁不可重入会发生什么问题呢？很简单，还是以上面的这个例子，此时线程A再次尝试获取锁时会被阻塞，此时就发生了死锁。</p><p><code>ReentrantLock</code>和<code>synchronized</code>关键字一样是可重入的，它的内部通过AQS的<code>state</code>变量记录同步状态，每当一个线程进行加锁时<code>state++</code>，而释放锁时<code>state--</code>。因此，当同一个线程重入该锁时，<code>state</code>就表示着该线程重入的次数。</p><h2 id="公平与非公平"><a href="#公平与非公平" class="headerlink" title="公平与非公平"></a>公平与非公平</h2><p><code>ReentrantLock</code>是可以设置公平或非公平模式的，事实上，JDK中的许多锁实现都默认为非公平模式。在这里先简单对比一下两种模式的区别：</p><ul><li>公平锁：公平锁保障了多线程获取锁时的顺序，先到的线程先获取到锁，正常情况下每个线程都能获取到锁</li><li>非公平锁：非公平锁不保障多线程获取锁时的顺序，也就是后来的线程有可能抢占了前面先来的线程获取锁的机会</li></ul><p>公平锁保证了每个线程都能按顺序的获取到锁，而非公平锁则有可能导致前面等待许久的线程不停被后来的线程抢占，从而出现“饥饿”问题。但是从效率上来说，非公平锁会比公平锁高出许多，原因在于唤醒一个线程是需要一定时间的，此时后来的线程可以利用这段时间获取锁并执行代码逻辑，当后来的线程释放完锁后，前面的线程可能正好完全苏醒并成功获取到锁，这就有一个充分的优势：原本因为苏醒而浪费的时间被后来的线程充分利用了，而后来的线程也不会因为进入阻塞而导致线程切换的开销。因此，非公平锁的效率其实是高于公平锁的。</p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>了解了重入锁和公平与非公平锁后，接下来进入正式的源码分析阶段。</p><p>前面说过，<code>ReentrantLock</code>其实是基于AQS实现的，那么具体是怎么实现的呢？先来看看它的UML类图：</p><p><img src="http://blog.default.nanwulife.com/ReentrantLock.png" alt=""></p><p>可以看出，<code>ReentrantLock</code>的抽象内部类<code>Sync</code>实现了AQS，而<code>Sync</code>有两个具体的子类<code>FairSync</code>和<code>NonfairSync</code>，从名字就可以看出它们分别表示公平模式和非公平模式。通过构造函数的参数可以决定选择哪种模式，如果不传入参数，则默认为非公平模式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Sync"><a href="#Sync" class="headerlink" title="Sync"></a>Sync</h3><p>先看下实现了AQS的抽象内部类，相关方法在下面会介绍，这里先省略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 交由子类去实现，也就是 FairSync 和 NonfairSync</span></span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;  <span class="comment">// ...  &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;  <span class="comment">// ...  &#125;</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h3><p><code>FairSync</code>继承自<code>Sync</code>，实现了公平模式的<code>ReentrantLock</code>的相关逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 直接调用 AQS 的 acquire() 方法获取锁</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此方法在 AQS 中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; <span class="comment">// 在 AQS 中并未实现该方法，而交由这里的 FairSync 实现</span></span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread current = Thread.currentThread();  <span class="comment">// 获取当前线程</span></span><br><span class="line">        <span class="keyword">int</span> c = getState(); <span class="comment">// 获取同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;        <span class="comment">// 如果同步状态为0，表示没有任何一个线程持有锁</span></span><br><span class="line">            <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;         <span class="comment">// 判断前面是否有等待更长时间的线程</span></span><br><span class="line">                compareAndSetState(<span class="number">0</span>, acquires)) &#123;  <span class="comment">// 如果没有，通过CAS设置同步状态</span></span><br><span class="line">                setExclusiveOwnerThread(current);   <span class="comment">// 如果设置成功了，则将当前线程设置为锁持有者</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果同步状态不为0，并且当前线程就是锁的持有者，那么进行锁的重入操作</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextc = c + acquires;   <span class="comment">// 计算重入后的同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            setState(nextc);               <span class="comment">// 设置重入后的同步状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取锁失败，会执行AQS的加入同步队列的逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail; </span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;    <span class="comment">// 如果头节点的后继节点不是当前线程，说明有等待时间更长的线程，返回true</span></span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上过过程总结如下：</p><ol><li>执行AQS的<code>acquire()</code>方法</li><li>调用<code>FairSync</code>实现的<code>tryAcquire()</code>方法，如果同步状态为0，则判断有没等待时间更长的线程，如果没有的话就成功获取；若同步状态不为0，且当前线程为持锁线程，则重入该锁</li><li>其它情况，一律返回<code>false</code>并将当前线程加入到同步队列，该过程由AQS实现</li></ol><h3 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h3><p><code>NonfairSync</code>同样继承自<code>Sync</code>，实现了非公平模式的<code>ReentrantLock</code>的相关逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里先直接CAS设置同步状态，如果设置成功，则加锁成功，不需要管同步队列前面是否有等待时间更长的线程</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="comment">// CAS失败了，则调用此方法进入 tryAcquire() 的逻辑</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 与公平模式的唯一不同，不会检查前面是否有等待时间更长的线程，直接CAS</span></span><br><span class="line">        <span class="comment">// CAS 成功就获取锁成功，失败则加入到AQS的同步队列中</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123; </span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比公平模式的<code>FairSync</code>和非公平模式的<code>NonfairSync</code>可以发现，它们的差别其实并不大，主要体现在非公平模式在获取锁时不会先检查前面有没有其它等待的线程，而是直接野蛮式CAS，成则获取锁，败则加入同步队列。</p><h3 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h3><p>释放锁的逻辑比较简单，并且没有公平和非公平之分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此方法在 AQS 中实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;      <span class="comment">// 交由子类 Sync 实现</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 唤醒后继节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算释放锁后的同步状态</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 如果当前线程没有持有锁，调用该方法会抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;   <span class="comment">// 如果释放后的同步状态为0，表示该锁完全释放了</span></span><br><span class="line">        free = <span class="keyword">true</span>;    </span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);  <span class="comment">// 将锁持有者设为 null</span></span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);    <span class="comment">// 设置新的同步状态</span></span><br><span class="line">    <span class="keyword">return</span> free;    <span class="comment">// 返回该锁是否被完全释放了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="与synchronized的异同"><a href="#与synchronized的异同" class="headerlink" title="与synchronized的异同"></a>与synchronized的异同</h2><p><code>ReentrantLock</code>和<code>synchronized</code>都是用于线程的同步控制，它们的共同点是都可重入，并且<code>synchronized</code>也是非公平锁（<code>ReentrantLock</code>默认为非公平）。而它们之间的不同主要在于以下几点：</p><ul><li><code>ReentrantLock</code>响应中断，而<code>synchronized</code>不响应</li><li><code>ReentrantLock</code>支持超时等待，而<code>synchronized</code>不支持</li><li><code>ReentrantLock</code>可设置成公平锁，而<code>synchronized</code>不可以</li><li>发生异常时，<code>synchronized</code>会自动释放锁，而<code>ReentrantLock</code>需要手动释放锁</li></ul><p>除此之外，<code>ReentrantLock</code>还提供了丰富的接口用于获取锁的状态，比如可以通过<code>isLocked()</code>查询<code>ReentrantLock</code>对象是否处于绑定状态，也可以通过<code>getHoldCount()</code>获取<code>ReentrantLock</code>的加锁次数，也就是重入次数，不过它们的本质都是调用AQS实现的<code>getState()</code>方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.tianxiaobo.com/2018/05/07/Java-%E9%87%8D%E5%85%A5%E9%94%81-ReentrantLock-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/#21-%E4%B8%8E-synchronized-%E7%9A%84%E5%BC%82%E5%90%8C" target="_blank" rel="noopener">Java 重入锁 ReentrantLock 原理分析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt;可重入锁功能与&lt;code&gt;synchronized&lt;/code&gt;类似，用于协调多线程间的
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
      <category term="ReentrantLock" scheme="http://yoursite.com/tags/ReentrantLock/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析：Condition</title>
    <link href="http://yoursite.com/2019/05/02/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9ACondition/"/>
    <id>http://yoursite.com/2019/05/02/AQS源码分析：Condition/</id>
    <published>2019-05-02T14:32:00.000Z</published>
    <updated>2019-05-03T06:42:19.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Condition</code>是一个与<code>Object</code>中的<code>wait() / nofity() / notifyAll()</code>功能相似的接口，AQS的内部类<code>ConditionObject</code>实现了该接口。它与<code>Object</code>提供的这些方法一样用来协调线程间的同步关系，而不同之处在于<code>Object</code>中的这些方法需要配合<code>Synchronized</code>关键字使用（否则会抛出异常），而<code>Condition</code>中的方法则要配合锁（独占锁）来使用（否则也会抛出异常），并且<code>Condition</code>中的方法功能更为丰富一些，比如说可以设置响应或不响应中断、可以设定超时时间等。</p><p><code>ConditionObject</code>内部维护了一个条件队列，当线程不满足某些条件的时候就会通过<code>await()</code>方法将当前线程加入到条件队列中，而当条件队列上等待的线程被<code>signal() / signalAll()</code>后，又会被转移到AQS的同步队列中尝试获取锁。接下来就其中最核心的三个方法<code>await()</code>、<code>signal()</code>、<code>signalAll()</code>说起，它们也分别对标了<code>Object</code>中的那三个方法。</p><h2 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h2><p><code>await()</code>方法负责将当前线程包装成一个<code>Node</code>后加入到条件队列中，并且需要释放持有的独占锁进入阻塞状态。这里先总结一下它的大致流程：</p><ol><li>将当前线程加入到条件队列中</li><li>完全释放互斥锁</li><li>如果当前线程未在同步队列中，就将其阻塞</li><li>否则，重新获取锁并根据是否发生中断而做出不同反应（抛出异常或重新中断）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 响应中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 将当前线程包装成 Node 并加入到条件队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 完全释放互斥锁（不论锁是否可以重入），如果没有持锁，会抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">         <span class="comment">// &lt;3&gt; 只要仍未转移到同步队列就阻塞，转移的情况如下：</span></span><br><span class="line">        <span class="comment">// 1. 其它线程调用 signal 将当前线程节点转移到同步队列并唤醒当前线程</span></span><br><span class="line">        <span class="comment">// 2. 其它线程调用 signalAll</span></span><br><span class="line">        <span class="comment">// 3. 其它线程中断了当前线程，当前线程会自行尝试进入同步队列</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 获取中断模式。在线程从park中被唤醒的时候，需要判断此时是否被中断，若中断则尝试转移到同步队列</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;4&gt; 重新获取互斥锁过程中如果发生中断并且 interruptMode 不为 THROW_IE，则将 interruptMode 设置为 REINTERRUPT</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="comment">// 如果线程发生过中断则根据 THROW_IE 或是 REINTERRUPT 分别抛出异常或者重新中断</span></span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addConditionWaiter"><a href="#addConditionWaiter" class="headerlink" title="addConditionWaiter()"></a>addConditionWaiter()</h3><p>首先看看第一个关键步骤，也就是将当前线程加入到条件队列中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果条件队列中最后一个节点的状态是 CANCELLED</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();   <span class="comment">// 清理队列</span></span><br><span class="line">        t = lastWaiter;                 <span class="comment">// 重读 lastWaiter</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前线程封装为一个 Node</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  <span class="comment">// 如果当前队列没有节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span>            <span class="comment">// 将当前队列的尾节点连接到新节点</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    <span class="comment">// 将新节点作为新尾节点</span></span><br><span class="line">    lastWaiter = node;  </span><br><span class="line">    <span class="comment">// 返回新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里会先判断条件队列中的最后一个节点是否为取消状态，如果是的话就调用<code>unlinkCancelledWaiters()</code>进行清理，清理的过程其实就是将条件队列中所有取消的节点都移除。之后将当前线程封装成<code>Node</code>后与当前队列最后一个节点的<code>nextWaiter</code>关联即可。</p><h3 id="fullyRelease"><a href="#fullyRelease" class="headerlink" title="fullyRelease()"></a>fullyRelease()</h3><p>此时已经将线程加入到条件队列中了，调用<code>fullyRelease()</code>方法完全释放同步状态。这里的“完全”指的是对于重入锁来说，每次加锁都会将AQS的整型成员变量<code>state++</code>，而每次解锁时会将<code>state--</code>，因此这里将<code>state</code>的数量完全释放掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullyRelease</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取同步状态数值</span></span><br><span class="line">        <span class="keyword">int</span> savedState = getState();</span><br><span class="line">        <span class="comment">// 调用 release() 释放指定数量的同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (release(savedState)) &#123;</span><br><span class="line">            failed = <span class="keyword">false</span>; </span><br><span class="line">            <span class="keyword">return</span> savedState;  <span class="comment">// 返回释放的数量</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果释放时出现异常，将该 Node 的等待状态设置为 CANCELLED</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            node.waitStatus = Node.CANCELLED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isOnSyncQueue"><a href="#isOnSyncQueue" class="headerlink" title="isOnSyncQueue()"></a>isOnSyncQueue()</h3><p>该方法用于判断某个节点是否转移到了同步队列上（因为别的线程有可能通过<code>signal() / signalAll()</code>将其转移了），如果没有就将其阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待状态如果是 CONDITION 则一定是在条件队列，或者如果 prev 为 null 也一定是在条件队列</span></span><br><span class="line">    <span class="comment">// （同步队列新入队的节点的 prev 值是不可能为 null 的，因为有dummy节点的存在）</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;   <span class="comment">// 不在同步队列中，直接返回 false</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 条件队列的节点是通过 nextWaiter 来维护的，不用 next 和 prev，因此如果节点在条件队列中则 next 和 prev 应该都为 null</span></span><br><span class="line">    <span class="comment">// 如果 next 不为 null，则说明一定是在同步队列中</span></span><br><span class="line">    <span class="comment">// 这里还要说明的是在 cancelAcquire() 方法中，一个节点取消的时候会把自己的 next 域指向自己，即 node.next = next; 而不是node.next = null;</span></span><br><span class="line">    <span class="comment">// 通过这种方式，在这里就可以将其和在同步队列上的情况归一化判断，都返回 true</span></span><br><span class="line">    <span class="comment">// 如果 cancelAcquire() 方法中写成 node.next = null; 的形式，这里的判断不满足条件，那么又要往底下进一步判断</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 虽然 node.prev 为 null 可以说明此时节点不在同步队列中，</span></span><br><span class="line">    <span class="comment">// 但如果 node.next 为 null 并不能说明 node 就不在同步队列中，因为新节点入队时会先设置 prev 然后再设置 next</span></span><br><span class="line">    <span class="comment">// 此时由 tail 节点开始从后向前遍历一次，确定节点是否真的不在同步队列中</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="checkInterruptWhileWaiting"><a href="#checkInterruptWhileWaiting" class="headerlink" title="checkInterruptWhileWaiting()"></a>checkInterruptWhileWaiting()</h3><p><code>checkInterruptWhileWaiting()</code>方法用于检测线程在等待期间是否发生了中断，注意该方法是在<code>LockSupport.park(this);</code>这一行之后，也就是说此时线程已经从阻塞中返回了，返回的原因有可能是因为中断，也有可能是因为<code>signal() / signalAll()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">checkInterruptWhileWaiting</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检测线程在等待期间是否发生了中断，如果未发生中断，直接返回0</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted() ?</span><br><span class="line">        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</span><br><span class="line">        <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断中断发生的时期，分为两种：</span></span><br><span class="line"><span class="comment"> * 1. 中断在节点被转移到同步队列前发生，此时返回 true</span></span><br><span class="line"><span class="comment"> * 2. 中断在节点被转移到同步队列后发生，此时返回 false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferAfterCancelledWait</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一种情况，中断在节点被转移到同步队列前发生</span></span><br><span class="line">    <span class="comment">// 此时自行将节点转移到同步队列上，并返回 true</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>)) &#123;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果上面的CAS失败了，说明已经有线程调用 signal() / signalAll() 方法了，</span></span><br><span class="line">    <span class="comment">// 这两个方法都会先将节点等待状态由 CONDITION 设为0后，再调用 enq() 方法转移节点</span></span><br><span class="line">    <span class="comment">// 此时有可能仅设置了等待状态而没来得及将节点转移到同步队列中就被切换走了，</span></span><br><span class="line">    <span class="comment">// 此时自旋等待节点成功进入同步队列</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node))</span><br><span class="line">        Thread.yield(); <span class="comment">// 让出 CPU</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行完上面几个方法，当从<code>while (!isOnSyncQueue(node))</code>循环中跳出时，说明节点已经转移到了同步队列中了，此时通过<code>acquireQueued(node, savedState)</code>方法重新获取锁，并且如果线程发生过中断则根据<code>THROW_IE</code>或是<code>REINTERRUPT</code>分别抛出异常或者重新中断。</p><h2 id="signal-signalAll"><a href="#signal-signalAll" class="headerlink" title="signal() / signalAll()"></a>signal() / signalAll()</h2><p>上面的<code>await()</code>方法中从<code>while (!isOnSyncQueue(node))</code>循环跳出可不是自己独立就能做到的，它是需要<code>signal() / signalAll()</code>配合的。<code>signal() / signalAll()</code>的工作就是负责将条件队列中的节点转移到同步队列中，两个方法的区别在于<code>signal()</code>只会转移首节点，而<code>signalAll()</code>会转移队列上的所有节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查线程是否获取了独占锁，未获取独占锁调用 signal 方法是不允许的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)      <span class="comment">// 头节点不为 null</span></span><br><span class="line">        doSignal(first);  <span class="comment">// 将头节点转移到同步队列中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果下面这个条件满足了，说明条件队列中只有一个节点，此时 lastWaiter 设为 null</span></span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 调用 transferForSignal() 将节点转移到同步队列中，如果失败，且 firstWaiter 不为null，则继续尝试，transferForSignal() 成功了或者队列中没节点了，while 循环就结束了 </span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法用于将条件队列中的节点转移到同步队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果将节点的等待状态由 CONDITION 设为0失败，则表明节点被取消</span></span><br><span class="line">    <span class="comment">// 注意：因为 transferForSignal() 不存在竞争的问题，所以唯一的可能就是节点被取消</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 enq() 方法将 node 转移到同步队列中，并返回 node 的前驱节点（原尾节点）p</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前驱结点状态为取消或者无法将状态CAS到SIGNAL，</span></span><br><span class="line">    <span class="comment">// 则需要唤醒参数node节点对应的线程，使其能开始尝试争锁</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>signal()</code>一定会转移条件队列中的一个节点，除非队列中彻底空了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// // 检查线程是否获取了独占锁，未获取独占锁调用 signalAll() 方法是不允许的</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignalAll(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignalAll</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    lastWaiter = firstWaiter = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将条件队列中所有节点都转移到同步队列中，与 doSignal() 的主要区别在于 while 循环条件上</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        Node next = first.nextWaiter;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">        transferForSignal(first);   <span class="comment">// 调用 transferForSignal() 将节点转移到同步队列中</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (first != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signalAll()</code>与<code>signal()</code>的主要不同在于循环条件中，因为它会将条件队列中的所有节点都转移，因此实现起来稍微简单一些。</p><h2 id="JDK-BUG"><a href="#JDK-BUG" class="headerlink" title="JDK BUG"></a>JDK BUG</h2><p>这里再讲一下jdk在上面实现中的一个bug。对比上面<code>await()</code>和<code>signal() / signalAll()</code>的源码可以发现，<code>await()</code>方法并没有做同步控制，也就是<code>signal() / signalAll()</code>方法开头的<code>if (!isHeldExclusively())  throw new IllegalMonitorStateException();</code>。因此，如果没有获取锁就调用该方法，会产生线程竞争的情况，导致条件队列的结构被破坏。例如，以下添加节点到条件队列的方法：</p><pre><code class="java"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>{    Node t = lastWaiter;    <span class="comment">// 如果条件队列中最后一个节点的状态是 CANCELLED</span>    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) {        unlinkCancelledWaiters();   <span class="comment">// 清理队列</span>        t = lastWaiter;                 <span class="comment">// 重读 lastWaiter</span>    }    <span class="comment">// 将当前线程封装为一个 Node</span>    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);    <span class="keyword">if</span> (t == <span class="keyword">null</span>)  <span class="comment">// 如果当前队列没有节点</span>        firstWaiter = node;    <span class="keyword">else</span>            <span class="comment">// 将当前队列的尾节点连接到新节点</span>        t.nextWaiter = node;    <span class="comment">// 将新节点作为新尾节点</span>    lastWaiter = node;      <span class="comment">// 返回新节点</span>    <span class="keyword">return</span> node;}</code></pre><p>如果有两个线程同时执行到<code>if (t == null)</code>时，可能会造成<code>firstWaiter</code>先指向其中一个，之后却被另一个给覆盖了，那么此时其中一个线程将会一直阻塞下去，因为这个线程的node并不在条件队列中，也就永远不会被<code>signal() / signalAll()</code>转移到同步队列上，唯一能从阻塞中返回的可能就是被中断。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.cnblogs.com/micrari/p/7219751.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读–续篇之Condition</a></li><li><a href="http://www.tianxiaobo.com/2018/05/04/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-Condition-%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - Condition 实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Condition&lt;/code&gt;是一个与&lt;code&gt;Object&lt;/code&gt;中的&lt;code&gt;wait() / nofity()
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
      <category term="JUC" scheme="http://yoursite.com/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>AQS源码分析：独占与共享同步状态</title>
    <link href="http://yoursite.com/2019/05/02/AQS%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9A%E7%8B%AC%E5%8D%A0%E4%B8%8E%E5%85%B1%E4%BA%AB%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://yoursite.com/2019/05/02/AQS源码分析：独占与共享同步状态/</id>
    <published>2019-05-02T07:59:00.000Z</published>
    <updated>2019-05-02T14:25:12.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>AQS就是<code>java.util.concurrent.locks</code>包下的<code>AbstractQueuedSynchronizer</code>类，这个类也是整个并发包的核心之一。并发包中像<code>ReentrantLock</code>、<code>CountDownLatch</code>等同步组件都有一个内部类<code>Sync</code>，而所有的<code>Sync</code>都是继承自<code>AbstractQueuedSynchronizer</code>，因此，可以看出AQS的重要性是十分高的。</p><p>AQS主要的工作是维护线程同步队列（CLH）并且负责线程的阻塞和唤醒，它的方法基本可以分为三类：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li><li>查询同步队列中的等待线程情况</li></ul><p>所谓独占就是一次只有一个线程能够获取，其它线程必须等它释放，共享则可以有多个线程同时获取。</p><h2 id="CLH队列"><a href="#CLH队列" class="headerlink" title="CLH队列"></a>CLH队列</h2><p>AQS内部维护着一个FIFO双向队列，该队列就是CLH同步队列，AQS依赖它来完成同步状态的管理：</p><ul><li>当前线程如果获取同步状态失败时，AQS会将当前线程以及等待状态等信息构成一个节点<code>Node</code>并将其加入到CLH同步队列，同时会阻塞当前线程。</li><li>当同步状态释放时，会把首节点唤醒，使其再次尝试获取同步状态。</li></ul><p>CLH同步队列的结构图如下：<br><img src="http://blog.default.nanwulife.com/0DFE7AA88DBEA0365F5532B4AC4FFF17.jpg" alt=""></p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p><code>Node</code>是AQS的静态内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享式节点，标记节点在共享模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 独占式节点，标记节点在独占模式下等待</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为超时或中断，节点会被设置为取消状态，不会参与到竞争当中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点在条件队列中，节点线程等待在 Condition 上，当其它线程对 Condition 调用了 signal() / signalAll() 后，该节点会从条件队列转移到同步队列，加入到同步状态的获取中</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一次共享模式的同步状态获取会无条件地传播下去</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态，也就是上面这几个，不过初始值为0</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱结点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此节点的线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 见 ConditionObject</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>入队操作过程是很简单的，只需要将<code>tail</code>指向新节点、新节点的<code>prev</code>指向当前最后的节点、当前最后的节点的<code>next</code>指向当前节点即可。但是在CLH的实现中需要考虑并发的情况，它通过CAS的方式，来保证正确的添加<code>Node</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode); <span class="comment">// 新建节点</span></span><br><span class="line">    <span class="comment">// 记录原尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置新Node的前驱结点为原尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;   <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">            <span class="keyword">return</span> node;          <span class="comment">// 返回新节点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);      <span class="comment">// 失败，多次尝试直到成功</span></span><br><span class="line">    <span class="keyword">return</span> node;   <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 多次尝试直到成功</span></span><br><span class="line">        Node t = tail;  <span class="comment">// 记录原尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 原尾节点不存在</span></span><br><span class="line">            <span class="comment">// 创建首尾节点都为 new Node()，作为一个占位节点（空节点）</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node())) </span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 原尾节点存在</span></span><br><span class="line">            <span class="comment">// 将原尾节点设置为新节点的前驱节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;  <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">                <span class="keyword">return</span> t;         <span class="comment">// 返回新节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总体来说就是使用CAS设置新节点为尾节点，如果设置成功则返回新节点，如果失败则继续不断自旋CAS设置新节点为尾节点直到成功。</p><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>首节点的线程释放同步状态后，会唤醒它的后继节点，后继节点在获取同步状态成功时将自己设置为首节点，因为只有一个线程能够成功获取到同步状态，所以该过程不需要CAS来保证：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>; <span class="comment">// 将未使用的字段设为null以帮助GC</span></span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>在进入AQS的核心源码之前有必要先了解一下大量使用到的<code>LockSupport</code>类。</p><p><code>LockSupport</code>也是基于<code>UNSAFE</code>的操作，提供<code>park()</code>用来阻塞线程和<code>unpark()</code>用来唤醒线程，<code>LockSupport</code>的机制是每次<code>unpark()</code>给线程一个“许可”，并且这个许可最多只能为1，如果当前线程有许可，那么<code>park()</code>方法会消耗一个并返回，否则会阻塞线程直到线程重新获得许可，在线程启动之前调用<code>park() / unpark()</code>没有任何效果。</p><p>这里简单的讲一下<code>LockSupport.park() / unpark()</code>与<code>object.wait() / notify()</code>的区别，他们主要的区别在于语义上的不同，阻塞和唤醒是对于线程来说的，<code>LockSupport</code>的<code>park() / unpark()</code>以线程作为方法的参数，更符合这个语义；而<code>notify()</code>只能随机唤醒一个线程，<code>notifyAll()</code>会唤醒所有线程，无法准确的控制某一个线程。</p><h3 id="Thread-interrupt"><a href="#Thread-interrupt" class="headerlink" title="Thread.interrupt"></a>Thread.interrupt</h3><p>AQS中大量用了中断，也就是<code>Thread</code>的<code>interrupt()</code>方法，但要注意的是该方法并不会中断一个正在运行的线程：当调用一个线程的该方法时，如果该线程处于被阻塞状态（如<code>Object.wait()</code>、<code>Thread.join()</code>、<code>Thread.sleep()</code>），那么线程将立即退出被阻塞状态，并抛出一个<code>InterruptedException</code>异常；而如果线程正在运行，那么会将该线程的中断标志设置为<code>true</code>，此时线程将继续正常运行。</p><p><code>LockSupport.park()</code>也能响应中断信号，但它不会抛出<code>InterruptedException</code>异常，因此要想知道线程是被<code>unpark()</code>还是中断，就依赖于该线程的中断标志，可以通过<code>Thread</code>的<code>interrupted()</code>或<code>isInterrupted()</code>方法获取该值，两个方法的区别是<code>interrupted()</code>获取后会将标志位重置为<code>false</code>。</p><h2 id="同步状态的获取与释放"><a href="#同步状态的获取与释放" class="headerlink" title="同步状态的获取与释放"></a>同步状态的获取与释放</h2><p>接下来进入AQS比较关键的部分：同步状态的获取与释放。这里主要分为以下两类进行分析：</p><ul><li>独占式获取与释放同步状态</li><li>共享式获取与释放同步状态</li></ul><h3 id="独占式获取"><a href="#独占式获取" class="headerlink" title="独占式获取"></a>独占式获取</h3><p>独占就是一次只有一个线程能够获取到同步状态。首先来看独占式同步状态获取的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法是一个模板方法，其中<code>tryAcquire(arg)</code>方法需要自定义同步组件（子类）自己去实现，它尝试获取同步状态，获取成功则设置锁状态并返回<code>true</code>，此时该方法就可以直接返回了；否则获取失败返回<code>false</code>，调用<code>addWaiter(Node mode)</code>方法将当前线程包装成<code>Node</code>加入到CLH同步队列尾部（上面已经介绍过），并且<code>mode</code>参数为<code>Node.EXCLUSIVE</code>，表示独占模式。</p><p>接下来会调用<code>boolean acquireQueued(final Node node, int arg)</code>方法，每个线程包装成<code>Node</code>进入同步队列后都会在该方法中自旋，一旦条件满足，获取到同步状态后，就可以从这个自旋过程中退出，否则会一直执行下去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;  <span class="comment">// 记录是否获取同步状态成功</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;    <span class="comment">// 记录该过程中是否发生过线程中断</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;  <span class="comment">// 开始自旋</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123; <span class="comment">// 当前线程的前驱节点是头节点，且获取同步状态成功</span></span><br><span class="line">                setHead(node);   <span class="comment">// 将当前线程设置为头节点</span></span><br><span class="line">                p.next = <span class="keyword">null</span>;     <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果获取同步状态失败，则根据条件判断是否应该阻塞自己</span></span><br><span class="line">            <span class="comment">// 如果不阻塞，CPU 就会处于忙等状态，这样会浪费 CPU 资源</span></span><br><span class="line">            <span class="comment">// 并且从阻塞中返回时，要判断是否是因为中断造成的</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>; <span class="comment">// 因为 parkAndCheckInterrupt 方法中会将中断标志清除，所以这里重新设为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed) <span class="comment">// 获取同步状态发生异常，取消获取</span></span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;   <span class="comment">// 获得前驱节点的等待状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)   </span><br><span class="line">         <span class="comment">// 表示pred的下一个节点也就是node的线程需要阻塞等待。在pred的线程释放同步状态时会对node的线程进行唤醒通知，所以这里返回true表示当前线程可以放心的被park</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;   <span class="comment">// Node.CANCELLED</span></span><br><span class="line">        <span class="comment">// 等待状态为CANCELLED时，表示此时前驱结点已经等待超时或者被中断了，需要从CLH队列中将前驱节点删除，循环回溯，直到前一个节点状态 &lt;= 0</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 0 或 Node.PROPAGATE</span></span><br><span class="line">        <span class="comment">// CAS将状态修改为Node.SIGNAL，但是会返回false，这一次不会park</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);         <span class="comment">// 上面的方法一旦返回true了，就会执行此方法将当前线程park</span></span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();   <span class="comment">// 判断是否因为中断而醒的，并且将中断标志清除</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 节点的等待线程置空</span></span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳过已经取消了的前驱结点</span></span><br><span class="line">    Node pred = node.prev;</span><br><span class="line">    <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">        node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录非取消状态的前驱节点的后继节点，注意不是当前节点node </span></span><br><span class="line">    Node predNext = pred.next;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前节点等待状态设为 CANCELLED</span></span><br><span class="line">    node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前节点是尾节点，则通过CAS设置前驱节点pred为尾节点</span></span><br><span class="line">    <span class="comment">// 以下两个CAS即使失败了也没关系，失败了说明pred此时已经是尾节点了</span></span><br><span class="line">    <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">        <span class="comment">// 如果设置成功，就通过CAS将pred的next置空，那么中间被取消的节点就“消失”了</span></span><br><span class="line">        compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> ws;</span><br><span class="line">        <span class="comment">// 根据条件判断是唤醒后继节点，还是将前驱节点和后继节点连接到一起</span></span><br><span class="line">        <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">            ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">             (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">            pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Node next = node.next;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里使用 CAS 设置 pred 的 next，表明多个线程同时在取消，这里存在竞争。</span></span><br><span class="line">           <span class="comment">// 不过此处没针对 compareAndSetNext 方法失败后做一些处理，表明即使失败了也没关系。</span></span><br><span class="line">           <span class="comment">// 实际上，多个线程同时设置 pred 的 next 引用时，只要有一个能设置成功即可</span></span><br><span class="line">            <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                compareAndSetNext(pred, predNext, next);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 唤醒后继节点对应的线程。这里简单讲一下为什么要唤醒后继线程，考虑下面一种情况：</span></span><br><span class="line"><span class="comment">         *        head          node1         node2         tail</span></span><br><span class="line"><span class="comment">         *        ws=0          ws=1          ws=-1         ws=0</span></span><br><span class="line"><span class="comment">         *      +------+  prev +-----+  prev +-----+  prev +-----+</span></span><br><span class="line"><span class="comment">         *      |      | &lt;---- |     | &lt;---- |     | &lt;---- |     |  </span></span><br><span class="line"><span class="comment">         *      |      | ----&gt; |     | ----&gt; |     | ----&gt; |     |</span></span><br><span class="line"><span class="comment">         *      +------+  next +-----+  next +-----+  next +-----+</span></span><br><span class="line"><span class="comment">         *      </span></span><br><span class="line"><span class="comment">         * 头结点初始状态为 0，node1、node2 和 tail 节点依次入队。node1 自旋过程中调用 </span></span><br><span class="line"><span class="comment">         * tryAcquire 出现异常，进入 cancelAcquire。head 节点此时等待状态仍然是 0，它</span></span><br><span class="line"><span class="comment">         * 会认为后继节点还在运行中，所它在释放同步状态后，不会去唤醒后继等待状态为非取消的</span></span><br><span class="line"><span class="comment">         * 节点 node2。如果 node1 再不唤醒 node2 的线程，该线程面临无法被唤醒的情况。此</span></span><br><span class="line"><span class="comment">         * 时，整个同步队列就回全部阻塞住。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">            unparkSuccessor(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        node.next = node; <span class="comment">// help GC</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过 CAS 将等待状态设为 0，让后继节点线程多一次尝试获取同步状态的机会</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 后继节点为null或者其状态 &gt; 0（表示超时或者被中断了）</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从tail节点开始向前遍历找到最前面的可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 唤醒后继节点</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的<code>unparkSuccessor()</code>方法中有一个地方很有意思，就是当判断当前节点的<code>next</code>引用为<code>null</code>的时候，还需要从<code>tail</code>节点向前遍历找到可用的节点，之所以要这么做的原因在于：在之前的<code>addWaiter()</code>方法将新节点入队时，有这么一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置新Node的前驱结点为原尾节点</span></span><br><span class="line">node.prev = pred;</span><br><span class="line"><span class="comment">// CAS设置新Node为新的尾节点</span></span><br><span class="line"><span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">    pred.next = node;   <span class="comment">// 设置成功，将原尾节点的后继节点设为新节点</span></span><br><span class="line">    <span class="keyword">return</span> node;          <span class="comment">// 返回新节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是此时可能已经将新节点的<code>prev</code>指向了原尾节点，但原尾节点的<code>next</code>还并未指向新节点，因此不能从前往后遍历，而应从后往前遍历。</p><p>以下是上述步骤的流程图总结：<br><img src="http://blog.default.nanwulife.com/2018120811001.png" alt=""></p><p>可以看出，虽然获取同步状态的过程表面上是自旋的操作，但是为了避免CPU资源的浪费，在获取同步状态失败后大部分情况还是进入了阻塞，但由于从阻塞中醒来不一定代表就可以获得同步状态了（有可能因为中断），所以此时会通过这个自旋循环再一次的去尝试获取同步状态，看看能不能获取成功。</p><h3 id="独占式获取（响应中断）"><a href="#独占式获取（响应中断）" class="headerlink" title="独占式获取（响应中断）"></a>独占式获取（响应中断）</h3><p>上面的<code>acquire(int arg)</code>方法对中断不响应，也就是线程被中断后，仅仅会通过<code>selfInterrupt()</code>方法（其实就是<code>Thread.currentThread().interrupt()</code>）将该线程的中断标志设置为<code>true</code>，然后线程继续正常运行。为了响应中断，AQS提供了<code>acquireInterruptibly(int arg)</code>方法，该方法在线程等待获取同步状态时如果被中断了，会立刻响应中断，抛出<code>InterruptedException</code>异常：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 首先判断线程是否已经中断了，如果是的话就直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))       <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;   <span class="comment">// 方法声明抛出异常</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;     <span class="comment">// 不再返回是否发生过中断</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="comment">// 与之前不响应中断的acquireQueued()方法唯一的区别在于这里判断发生了中断后会直接抛出异常</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独占式获取（超时）"><a href="#独占式获取（超时）" class="headerlink" title="独占式获取（超时）"></a>独占式获取（超时）</h3><p>AQS除了提供上面两个独占式获取的方法外，还提供了一个增强版的方法<code>tryAcquireNanos()</code>，该方法除了能响应中断外，还提供了超时控制，即如果当前线程没有在指定时间内获取同步状态，则会返回<code>false</code>，否则返回<code>true</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 首先判断线程是否已经中断了，如果是的话就直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||   <span class="comment">// 尝试获取同步状态</span></span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 走到这说明获取失败，重新计算需要休眠的时间（剩余时间）</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 如果已经超时了，那么返回false</span></span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 如果没有超时，判断了可以被park，并且nanosTimeout大于一个阈值，那么就进入休眠</span></span><br><span class="line">            <span class="comment">// 当nanosTimeout小于阈值的时候不需要休眠，直接快速自旋</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();   <span class="comment">// 响应中断，抛出异常</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="独占式释放"><a href="#独占式释放" class="headerlink" title="独占式释放"></a>独占式释放</h3><p>当线程获取了同步状态，执行完相应逻辑后，就需要释放同步状态。AQS提供了<code>release(int arg)</code>方法，释放同步状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;  <span class="comment">// 由自定义同步组件自己实现</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">// 如果头节点不为null且状态不为0（等于0说明后继节点正在运行中，不需要唤醒）</span></span><br><span class="line">            unparkSuccessor(h); <span class="comment">// 将后继节点唤醒</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="共享式获取"><a href="#共享式获取" class="headerlink" title="共享式获取"></a>共享式获取</h3><p>与独占模式不同，共享模式下，同一时刻会有多个线程获取共享同步状态。共享模式是实现读写锁中的读锁、<code>CountDownLatch</code>和<code>Semaphore</code>等同步组件的基础。</p><p>共享式同步状态获取的方法是<code>acquireShared()</code>，对标独占式的<code>acquire()</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)  <span class="comment">// 由自定义同步组件自己实现。返回负数表示获取失败；返回0表示成功，但是后继争用线程不会成功；返回正数表示获取成功，并且后继争用线程也可能成功。</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 与之前独占式的参数不同，这里传入一个Node.SHARED</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();  <span class="comment">// 获取当前线程的前驱节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;   <span class="comment">// 前驱节点是头节点并且获取同步状态成功</span></span><br><span class="line">                    <span class="comment">// 设置当前节点为头节点并且向后传播，不断唤醒下一个共享式节点，从而实现多个节点线程同时获取共享同步状态</span></span><br><span class="line">                    setHeadAndPropagate(node, r); </span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; <span class="comment">// 记录原首节点</span></span><br><span class="line">    setHead(node);  <span class="comment">// 设置当前节点为新首节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里除了使用条件 propagate &gt; 0 判断是否唤醒后继节点，还有其它的一些判断依据</span></span><br><span class="line">    <span class="comment">// 比如 propagate 是 tryAcquireShared() 的返回值，也是这是决定是否传播唤醒的依据之一</span></span><br><span class="line">    <span class="comment">// 更为详细的解释可以参考 https://www.cnblogs.com/micrari/p/6937995.html</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。</span></span><br><span class="line"><span class="comment"> * 后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate，将唤醒传播下去。</span></span><br><span class="line"><span class="comment"> * 这个函数的作用是保障在 acquire 和 release 存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 以下的循环做的事情就是，在队列存在后继线程的情况下，唤醒后继线程；</span></span><br><span class="line"><span class="comment"> * 或者由于多线程同时释放共享锁由于处在中间过程，读到head节点等待状态为0的情况下，</span></span><br><span class="line"><span class="comment"> * 虽然不能unparkSuccessor，但为了保证唤醒能够正确稳固传递下去，设置节点状态为PROPAGATE。</span></span><br><span class="line"><span class="comment"> * 这样的话获取锁的线程在执行setHeadAndPropagate时可以读到PROPAGATE，从而由获取锁的线程去释放后继等待线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">             * ws = 0 的情况下，这里要尝试将状态从 0 设为 PROPAGATE，保证唤醒向后</span></span><br><span class="line"><span class="comment">             * 传播。setHeadAndPropagate 在读到 h.waitStatus &lt; 0 时，可以继续唤醒</span></span><br><span class="line"><span class="comment">             * 后面的节点。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="共享式释放"><a href="#共享式释放" class="headerlink" title="共享式释放"></a>共享式释放</h3><p>共享式释放同步状态的主要逻辑都在上面的<code>doReleaseShared()</code>方法中，共享节点线程在获取同步状态和释放同步状态时都会调用<code>doReleaseShared()</code>，所以<code>doReleaseShared</code>是多线程竞争集中的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于共享式同步状态的获取与释放，其实这里介绍的较为简单了，由于时间原因，很多细节没有解释清楚，更为详细的分析可以参考这篇优质博客：<a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.iocoder.cn/JUC/sike/aqs-2/" target="_blank" rel="noopener">【死磕 Java 并发】—– J.U.C 之 AQS：同步状态的获取与释放</a></li><li><a href="http://www.tianxiaobo.com/2018/05/01/AbstractQueuedSynchronizer-%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F/#421-%E8%8E%B7%E5%8F%96%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">AbstractQueuedSynchronizer 原理分析 - 独占/共享模式</a></li><li><a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;AQS就是&lt;code&gt;java.util.concurrent.locks&lt;/code&gt;包下的&lt;code&gt;AbstractQueuedSyn
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="AQS" scheme="http://yoursite.com/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>Java异常机制总结</title>
    <link href="http://yoursite.com/2019/04/30/Java%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/04/30/Java异常机制/</id>
    <published>2019-04-30T15:25:32.000Z</published>
    <updated>2019-04-30T16:11:35.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java错误和异常"><a href="#Java错误和异常" class="headerlink" title="Java错误和异常"></a>Java错误和异常</h2><p>在Java中，所有的异常都有一个共同的祖先<code>Throwable</code>，它有两个重要的子类：<code>Exception</code>（异常）和<code>Error</code>（错误），二者都是Java异常处理的重要子类，各自都包含大量子类:<br><img src="http://blog.default.nanwulife.com/Exception.png" alt=""></p><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p><code>Error</code>是程序无法处理的错误，表示代码运行时Java虚拟机出现的问题。例如，当Java虚拟机不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>，而另外还有一个常见的错误是<code>StackOverflowError</code>。这些错误是不可查的，也不应试图去捕获它，当这些错误发生时，Java虚拟机一般会选择终止。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p><code>Exception</code>异常是程序本身可以处理的异常，它有一个重要的子类<code>RuntimeException</code>，表示JVM常用操作引发的异常。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常<code>NullPointerException</code>、<code>ArithmeticException</code>和<code>ArrayIndexOutOfBoundException</code>。</p><h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p><code>Exception</code>这种异常分为运行时异常和非运行时异常（编译异常）两大类：</p><ul><li>运行时异常：都是<code>RuntimeException</code>类及其子类异常，如<code>NullPointerException</code>（空指针异常）、<code>IndexOutOfBoundsException</code>（下标越界异常）等。这些异常是不检查异常，Java编译器不会检查它，即使没有用<code>try-catch</code>语句捕获它，也没有用<code>throws</code>子句声明抛出它，也会编译通过。</li><li>非运行时异常：是<code>RuntimeException</code>以外的异常，类型上都属于<code>Exception</code>类及其子类。从程序语法角度讲是必须进行处理的异常（<code>try-catch</code>捕捉或者方法上声明<code>throws</code>抛出），如果不处理，程序就不能编译通过，如<code>IOException</code>、<code>SQLException</code>等。</li></ul><h2 id="处理异常机制"><a href="#处理异常机制" class="headerlink" title="处理异常机制"></a>处理异常机制</h2><p>在Java应用程序中，异常处理机制为：抛出异常，捕捉异常。</p><ul><li>抛出异常：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息，运行时系统负责寻找处置异常的代码并执行。</li><li>捕获异常：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适的异常处理器，则运行时系统终止，同时意味着Java程序的终止。</li></ul><p>一旦某个<code>catch</code>捕获到匹配的异常类型，将进入异常处理代码。一经处理结束，就意味着整个<code>try-catch</code>语句结束，其他的<code>catch</code>子句不再有匹配和捕获异常类型的机会。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.csdn.net/hguisu/article/details/6155636" target="_blank" rel="noopener">深入理解java异常处理机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java错误和异常&quot;&gt;&lt;a href=&quot;#Java错误和异常&quot; class=&quot;headerlink&quot; title=&quot;Java错误和异常&quot;&gt;&lt;/a&gt;Java错误和异常&lt;/h2&gt;&lt;p&gt;在Java中，所有的异常都有一个共同的祖先&lt;code&gt;Throwable&lt;/code
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JDK与CGLIB动态代理</title>
    <link href="http://yoursite.com/2019/04/30/JDK%E4%B8%8ECGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/30/JDK与CGLIB动态代理/</id>
    <published>2019-04-30T09:19:00.000Z</published>
    <updated>2019-04-30T10:05:39.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间看了Spring AOP的源码，其底层就是通过JDK与CGLIB动态代理实现的，因此在这里对两种代理方式进行实践和总结。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>首先创建一个代理创建器<code>ProxyCreator</code>接口，我们将分别实现<code>JdkProxyCreator</code>与<code>CglibProxyCreator</code>，通过实现<code>getProxy()</code>方法返回一个代理对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProxyCreator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建一个<code>UserService</code>接口，提供登陆<code>login()</code>和退出<code>logout()</code>两个方法，并创建一个它的实现类<code>UserServiceImpl</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户"</span> + userId + <span class="string">"登陆成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户"</span> + userId + <span class="string">"退出成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来，我们将分为JDK与CGLIB这两种动态代理方式，为上面的登陆与退出两个方法前后打印日志。</p><h2 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h2><p>首先，创建一个<code>JdkProxyCreator</code>并实现<code>ProxyCreator</code>和<code>InvocationHandler</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyCreator</span> <span class="keyword">implements</span> <span class="title">ProxyCreator</span>, <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdkProxyCreator</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces = target.getClass().getInterfaces();</span><br><span class="line">        <span class="keyword">if</span>(interfaces.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"目标对象必须实现接口"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = target.getClass();</span><br><span class="line">        <span class="comment">// 该类本身实现了 InvocationHandler 接口，所以将自身作为参数传入</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆前日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出前日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object res = method.invoke(target, args); <span class="comment">// 调用目标方法</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆后日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出后日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，创建代理对象的核心其实就是这一行代码：<code>Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</code>，其中第一个参数是目标对象的类加载器，第二个参数是目标对象实现的接口，第三个参数则是一个<code>InvocationHandler</code>，因为该类已经实现了这个接口，且打印日志的逻辑都封装在了该接口的<code>invoke</code>方法中了，所以直接传入<code>this</code>即可。</p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyCreator proxyCreator = <span class="keyword">new</span> JdkProxyCreator(<span class="keyword">new</span> UserServiceImpl());</span><br><span class="line">        UserService userServiceProxy = (UserService) proxyCreator.getProxy();</span><br><span class="line">        System.out.println(<span class="string">"代理对象的类型："</span> + userServiceProxy.getClass());</span><br><span class="line">        userServiceProxy.login(<span class="number">1</span>);</span><br><span class="line">        userServiceProxy.logout(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理对象的类型：<span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">sun</span>.<span class="title">proxy</span>.$<span class="title">Proxy0</span></span></span><br><span class="line"><span class="class">登陆前日志打印...</span></span><br><span class="line"><span class="class">用户1登陆成功</span></span><br><span class="line"><span class="class">登陆后日志打印...</span></span><br><span class="line"><span class="class">退出前日志打印...</span></span><br><span class="line"><span class="class">用户1退出成功</span></span><br><span class="line"><span class="class">退出后日志打印...</span></span><br></pre></td></tr></table></figure></p><h2 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h2><p>CGLIB是一款优秀的Java字节码生成框架，它可以生成并操纵Java字节码。因此，CGLIB的动态代理其实就是使用字节码技术为目标类创建子类，并且在子类中拦截父类方法的调用，并且顺势织入横切逻辑。</p><p>首先，在pom.xml中引入CGLIB的依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!-- https://mvnrepository.com/artifact/cglib/cglib --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;cglib&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;cglib&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><p>然后创建一个<code>MethodInterceptor</code>接口的实现类，将打印日志的操作封装在<code>intercept()</code>方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserMethodInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆前日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出前日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object res = methodProxy.invokeSuper(o, objects);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"login"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"登陆后日志打印..."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(method.getName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"退出后日志打印..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，<code>Object res = methodProxy.invokeSuper(o, objects);</code>这一行将会调用父类的实现，也就是目标对象的原始方法。这里要注意的是一定不要写成了<code>method.invoke(o, objects);</code>，否则会造成死循环。</p><p>接着，创建一个<code>CglibProxyCreator</code>实现<code>ProxyCreator</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyCreator</span> <span class="keyword">implements</span> <span class="title">ProxyCreator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MethodInterceptor methodInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CglibProxyCreator</span><span class="params">(Object target, MethodInterceptor methodInterceptor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.methodInterceptor = methodInterceptor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        enhancer.setCallback(methodInterceptor);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不同于JDK动态代理使用<code>Proxy.newProxyInstance(clazz.getClassLoader(), clazz.getInterfaces(), this);</code>的方式，这里创建了一个<code>Enhancer</code>对象，并且设置了目标对象的类作为父类，还设置了之前的方法拦截器<code>UserMethodInterceptor</code>（其实这里也可以让该类本身实现<code>MethodInterceptor</code>接口），最后通过<code>enhancer.create()</code>方法返回代理对象。</p><p>测试代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProxyCreator proxyCreator = <span class="keyword">new</span> CglibProxyCreator(<span class="keyword">new</span> UserServiceImpl(), <span class="keyword">new</span> UserMethodInterceptor());</span><br><span class="line">        UserService userServiceProxy = (UserService) proxyCreator.getProxy();</span><br><span class="line">        System.out.println(<span class="string">"代理对象的类型："</span> + userServiceProxy.getClass());</span><br><span class="line">        userServiceProxy.login(<span class="number">2</span>);</span><br><span class="line">        userServiceProxy.logout(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>控制台输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代理对象的类型：class cn.hecenjie.UserServiceImpl$$EnhancerByCGLIB$$76be9bea</span><br><span class="line">登陆前日志打印...</span><br><span class="line">用户2登陆成功</span><br><span class="line">登陆后日志打印...</span><br><span class="line">退出前日志打印...</span><br><span class="line">用户2退出成功</span><br><span class="line">退出后日志打印...</span><br></pre></td></tr></table></figure></p><p>从上面的输出可以看出，代理对象其实是目标对象的一个子类。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JDK代理要求目标对象有实现接口，而CGLIB则不需要。从性能上来说，CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;前段时间看了Spring AOP的源码，其底层就是通过JDK与CGLIB动态代理实现的，因此在这里对两种代理方式进行实践和总结。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="动态代理" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
      <category term="CGLIB" scheme="http://yoursite.com/tags/CGLIB/"/>
    
  </entry>
  
  <entry>
    <title>Spring AOP源码笔记</title>
    <link href="http://yoursite.com/2019/04/30/Spring-AOP%E6%BA%90%E7%A0%81%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/04/30/Spring-AOP源码笔记/</id>
    <published>2019-04-30T03:52:00.000Z</published>
    <updated>2019-04-30T08:08:47.426Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文是看了田小波博主的<a href="www.tianxiaobo.com/2018/06/17/Spring-AOP-源码分析系列文章导读">Spring AOP源码分析系列</a>后自己总结整理的笔记，内容会更偏向于流程上的总结，具体源码细节并未深入研究，并且关于AOP的相关术语这里也不会再说明。</p><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><p>本文将会从AOP的入口开始分析，主要涉及以下四个流程：</p><ol start="0"><li>入口分析</li><li>筛选合适的通知器</li><li>创建代理对象</li><li>拦截器链的执行过程</li></ol><h2 id="入口分析"><a href="#入口分析" class="headerlink" title="入口分析"></a>入口分析</h2><p>Spring是通过后置处理器<code>BeanPostProcessor</code>接口在<code>init-method</code>的前后通过切点对bean类中的方法进行匹配后织入的，这个接口是Spring提供的一个扩展接口，通过实现该接口，用户可在Bean初始化前后做一些自定义的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 激活Aware相关的方法</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &lt;2&gt; 后处理器，before</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// &lt;3&gt; 激活用户自定义的 init 方法</span></span><br><span class="line"><span class="comment">// 对应 &lt;bean&gt; 标签中的 init-method 属性</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">(mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">// &lt;2&gt; 后处理器，after</span></span><br><span class="line"><span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring AOP抽象代理创建器<code>AbstractAutoProxyCreator</code>实现了<code>BeanPostProcessor</code>接口，并在Bean初始化后置处理过程中向Bean织入通知：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title">ProxyProcessorSupport</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">SmartInstantiationAwareBeanPostProcessor</span>, <span class="title">BeanFactoryAware</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(@Nullable Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">Object cacheKey = getCacheKey(bean.getClass(), beanName);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;</span><br><span class="line"><span class="comment">// 如果需要，为 Bean 生成代理对象</span></span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">wrapIfNecessary</span><span class="params">(Object bean, String beanName, Object cacheKey)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName) &amp;&amp; <span class="keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前已经判断过了不需要生成代理，直接返回 Bean</span></span><br><span class="line"><span class="keyword">if</span> (Boolean.FALSE.equals(<span class="keyword">this</span>.advisedBeans.get(cacheKey))) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;1&gt; 如果是基础设施类（Pointcut、Advice、Advisor 等接口的实现类），或是应该跳过的类（默认为false，由子类覆盖），</span></span><br><span class="line"><span class="comment">// 则不应该生成代理，此时直接返回 Bean</span></span><br><span class="line"><span class="keyword">if</span> (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123;</span><br><span class="line"><span class="comment">// 将 &lt;cacheKey, FALSE&gt; 键值对放入缓存中，供上面的if使用</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt;2&gt; 为目标 Bean 查找合适的通知器（通知器持有通知）</span></span><br><span class="line"><span class="comment">// Create proxy if we have advice.</span></span><br><span class="line">Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">// &lt;3&gt; 如果找到了合适的通知器，则为 Bean 生成代理对象，否则直接返回 Bean</span></span><br><span class="line"><span class="keyword">if</span> (specificInterceptors != DO_NOT_PROXY) &#123;</span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.TRUE);</span><br><span class="line"><span class="comment">// 创建代理</span></span><br><span class="line">Object proxy = createProxy(</span><br><span class="line">bean.getClass(), beanName, specificInterceptors, <span class="keyword">new</span> SingletonTargetSource(bean));</span><br><span class="line"><span class="keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());</span><br><span class="line"><span class="comment">// 返回代理对象，此时IoC容器中 beanName 对应的 bean 是代理对象，而非原始的 bean</span></span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 &lt;cacheKey, FALSE&gt; 键值对放入缓存中，供上面的if使用</span></span><br><span class="line"><span class="keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);</span><br><span class="line"><span class="comment">// &lt;4&gt; specificInterceptors == null，直接返回 bean</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，<code>postProcessAfterInitialization</code>主要过程分为四步：</p><ol><li>若Bean是AOP基础设施类型（Pointcut、Advice、Advisor 等接口的实现类），则直接返回</li><li>为目标Bean查找匹配的通知器（通知器持有通知）</li><li>如果找到了匹配的通知器，则为Bean生成代理对象，并返回该对象</li><li>否则，返回原始bean</li></ol><h2 id="筛选合适的通知器"><a href="#筛选合适的通知器" class="headerlink" title="筛选合适的通知器"></a>筛选合适的通知器</h2><p>上文说过，在创建代理对象前，首先要查找合适的通知器<code>Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);</code>，这一行代码对应着<code>postProcessAfterInitialization</code>的第二步，具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object[] getAdvicesAndAdvisorsForBean(</span><br><span class="line">Class&lt;?&gt; beanClass, String beanName, <span class="meta">@Nullable</span> TargetSource targetSource) &#123;</span><br><span class="line"><span class="comment">// 查找合适的通知器</span></span><br><span class="line">List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (advisors.isEmpty()) &#123;<span class="comment">// 如果没有找到</span></span><br><span class="line"><span class="keyword">return</span> DO_NOT_PROXY;<span class="comment">// 则返回 null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors.toArray();<span class="comment">// 否则，返回找到的通知器</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findEligibleAdvisors</span><span class="params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 查找所有的通知器</span></span><br><span class="line">List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();</span><br><span class="line"><span class="comment">// 筛选可应用在 beanClass 上的 Advisor，通过 ClassFilter 和 MethodMatcher</span></span><br><span class="line"><span class="comment">// 对目标类和方法进行匹配</span></span><br><span class="line">List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);</span><br><span class="line"><span class="comment">// 拓展操作</span></span><br><span class="line">extendAdvisors(eligibleAdvisors);</span><br><span class="line"><span class="keyword">if</span> (!eligibleAdvisors.isEmpty()) &#123;</span><br><span class="line">eligibleAdvisors = sortAdvisors(eligibleAdvisors);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> eligibleAdvisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该过程首先会查询出所有的通知器，然后再通过<code>ClassFilter</code>和<code>MethodMatcher</code>对目标类和方法进行匹配，筛选出可应用到当前bean的通知器。下面分析查询出所有的通知器的过程。</p><h3 id="查找所有通知器"><a href="#查找所有通知器" class="headerlink" title="查找所有通知器"></a>查找所有通知器</h3><p>这个方法在子类<code>AnnotationAwareAspectJAutoProxyCreator</code>中被覆写过，增加了对<code>@Aspect</code>注解的解析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;Advisor&gt; <span class="title">findCandidateAdvisors</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 调用父类方法从容器中查找所有的通知器</span></span><br><span class="line">List&lt;Advisor&gt; advisors = <span class="keyword">super</span>.findCandidateAdvisors();</span><br><span class="line"><span class="comment">// 解析 @Aspect 注解，并构建通知器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.aspectJAdvisorsBuilder != <span class="keyword">null</span>) &#123;</span><br><span class="line">advisors.addAll(<span class="keyword">this</span>.aspectJAdvisorsBuilder.buildAspectJAdvisors());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> advisors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两行代码分别做了两件事：</p><ol><li>第一步从容器中获取所有类型为<code>Advisor</code>的bean</li><li>第二步获取容器中所有beanName以及每个beanName对应的bean类型，遍历判断当前bean是否是一个Aspect注解类，若是则调用<code>advisorFactory.getAdvisors</code>获取所有通知器列表，其中会为每个方法调用<code>getAdvisor</code>方法，这个方法会获取AspectJ表达式切点（也就是获取方法上的相关注解如<code>@Before</code>、<code>@After</code>等并创建一个<code>AspectJExpressionPointcut</code>对象），并且创建<code>Advisor</code>实现类（这其中会先根据注解类型创建相应的通知<code>Advice</code>实现类）。</li></ol><h2 id="创建代理对象"><a href="#创建代理对象" class="headerlink" title="创建代理对象"></a>创建代理对象</h2><p>当Bean实现了接口时，Spring会基于JDK动态代理为目标Bean创建代理对象，若未实现任何接口，Spring则会通过CGLIB创建代理，而当<code>proxy-target-class</code>属性设为<code>true</code>时，则会强制Spring通过CGLIB的方式创建代理对象，即使目标Bean实现了接口。</p><h3 id="AopProxy"><a href="#AopProxy" class="headerlink" title="AopProxy"></a>AopProxy</h3><p>为目标Bean创建代理对象前，需要先创建<code>AopProxy</code>对象，然后再调用该对象的<code>getProxy</code>方法创建实际的代理类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AopProxy</span> </span>&#123;</span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function">Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在Spring中，有两个类实现了<code>AopProxy</code>，一个是<code>CglibAopProxy</code>，另一个是<code>JdkDynamicAopProxy</code>。在<code>postProcessAfterInitialization</code>的第三步<code>Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));</code>会根据bean是否实现接口以及一些其它配置来决定使用<code>AopProxy</code>的哪一个实现类为目标bean创建代理对象。</p><h2 id="拦截器链的执行过程"><a href="#拦截器链的执行过程" class="headerlink" title="拦截器链的执行过程"></a>拦截器链的执行过程</h2><p>在上面两个步骤中，Spring AOP已经为目标bean筛选出合适的通知器，创建好了代理对象，接下来就是要执行通知逻辑了。通知可能在目标方法前执行，也可能在目标方法后执行，当目标方法被多个通知匹配到时，Spring通过引入拦截器链来保证每个通知的正常执行。</p><h3 id="JDK动态代理逻辑分析"><a href="#JDK动态代理逻辑分析" class="headerlink" title="JDK动态代理逻辑分析"></a>JDK动态代理逻辑分析</h3><p>对于JDK动态代理，代理逻辑封装在<code>InvocationHandler</code>接口实现类的<code>invoke</code>中，而<code>JdkDynamicAopProxy</code>实现了<code>InvocationHandler</code>接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicAopProxy</span> <span class="keyword">implements</span> <span class="title">AopProxy</span>, <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">MethodInvocation invocation;</span><br><span class="line">Object oldProxy = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> setProxyContext = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">TargetSource targetSource = <span class="keyword">this</span>.advised.targetSource;</span><br><span class="line">Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Object retVal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advised.exposeProxy) &#123;</span><br><span class="line"><span class="comment">// Make invocation available if necessary.</span></span><br><span class="line">oldProxy = AopContext.setCurrentProxy(proxy);</span><br><span class="line">setProxyContext = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get as late as possible to minimize the time we "own" the target,</span></span><br><span class="line"><span class="comment">// in case it comes from a pool.</span></span><br><span class="line">target = targetSource.getTarget();</span><br><span class="line">Class&lt;?&gt; targetClass = (target != <span class="keyword">null</span> ? target.getClass() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取适合当前方法的拦截器链</span></span><br><span class="line">List&lt;Object&gt; chain = <span class="keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (chain.isEmpty()) &#123;<span class="comment">// 如果拦截器链为空，则直接执行目标方法</span></span><br><span class="line">Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<span class="comment">// 通过反射执行目标方法</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 创建一个方法调用器，并将拦截器链传入其中</span></span><br><span class="line">invocation = <span class="keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);</span><br><span class="line"><span class="comment">// 执行拦截器链</span></span><br><span class="line">retVal = invocation.proceed();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该方法的主要流程如下：</p><ol><li>获取适合当前方法的拦截器（将advisor中的advice转成相应的拦截器）</li><li>如果拦截器链为空，则直接通过反射执行目标方法</li><li>否则，创建方法调用器<code>ReflectiveMethodInvocation</code>对象，将拦截器链传入其中</li><li>调用<code>ReflectiveMethodInvocation</code>对象的<code>proceed()</code>方法启动拦截器链</li><li>处理返回值，并返回该值</li></ol><p>其中，启动拦截器是核心步骤，<code>ReflectiveMethodInvocation</code>的<code>proceed</code>方法用于启动拦截器链，这里直接引用一副图很好的解释了拦截器链的执行过程：<br><img src="http://blog.default.nanwulife.com/15296571948329.jpg" alt=""></p><p>由上图可以看出，方法调用器每次调用下一个拦截器的<code>invoke</code>方法时，都会将自己作为参数传给该方法，并且通过方法调用器不断调用下一个拦截器，直到拦截器链中的最后一个拦截器执行完后，通过反射的方式执行目标方法，然后再返回到后置拦截器的方法中执行后置拦截器的一些逻辑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文是看了田小波博主的&lt;a href=&quot;www.tianxiaobo.com/2018/06/17/Spring-AOP-源码分析系列文章导
      
    
    </summary>
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
      <category term="AOP" scheme="http://yoursite.com/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ高级特性</title>
    <link href="http://yoursite.com/2019/04/26/RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/26/RabbitMQ高级特性/</id>
    <published>2019-04-26T05:03:00.000Z</published>
    <updated>2019-04-28T03:05:22.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息返回"><a href="#消息返回" class="headerlink" title="消息返回"></a>消息返回</h2><p><code>mandatory</code>和<code>immediate</code>是发布消息时的两个参数，它们都有当消息传递过程中不可达目的地时将消息返回给生产者的功能。<code>mandatory</code>参数告诉服务器该消息至少能路由到一个队列中，而<code>immediate</code>参数告诉服务器要投递的队列必须有消费者。</p><h3 id="mandatory"><a href="#mandatory" class="headerlink" title="mandatory"></a>mandatory</h3><p>当<code>mandatory</code>参数设为<code>true</code>时，交换器无法根据自身的类型和路由键找到一个符合条件的队列，那么RabbitMQ会调用<code>Basic.Return</code>命令将消息返回给生产者；当<code>mandatory</code>参数设置为<code>false</code>时，出现上述情形，则消息直接被丢弃。</p><p>对于没有被正确路由而返回给生产者的消息，可以通过给channel添加监听器获取到那些消息。</p><h3 id="immediate"><a href="#immediate" class="headerlink" title="immediate"></a>immediate</h3><p>当<code>immediate</code>参数设为<code>true</code>时，如果交换器在将消息路由到队列时发现队列上并不存在任何消费者，那么这条消息将不会存入队列中。当与路由键匹配的所有队列都没有消费者时，该消息会通过<code>Basic.Return</code>命令返回给生产者。</p><p>RabbitMQ从3.0的版本开始去掉了对<code>immediate</code>参数的支持。</p><h3 id="备份交换器"><a href="#备份交换器" class="headerlink" title="备份交换器"></a>备份交换器</h3><p>生产者在发送消息的时候如果不设置<code>mandatory</code>参数，那么消息在未被路由的情况下将会丢失；如果设置了<code>mandatory</code>参数，那么需要添加监听器的编程逻辑，生产者的代码会很复杂。如果既不想丢失消息，也不想使代码复杂化，那么可以使用备份交换器，将未被路由的消息存储在RabbitMQ中，需要的时候再去处理。</p><p>备份交换器和普通的交换器没有什么太大的区别，声明一个备份交换器后，在声明普通交换器时添加<code>alternate-exchange</code>参数即可建立它们之间的联系。为了方便使用，备份交换器建议设置为fanout类型的。</p><p><img src="http://blog.default.nanwulife.com/20181207093904597.jpg" alt=""></p><h2 id="过期时间（TTL）"><a href="#过期时间（TTL）" class="headerlink" title="过期时间（TTL）"></a>过期时间（TTL）</h2><p>RabbitMQ可以对消息和队列设置TTL。</p><h3 id="设置消息的TTL"><a href="#设置消息的TTL" class="headerlink" title="设置消息的TTL"></a>设置消息的TTL</h3><p>如果不设置TTL，则表示此消息不会过期，而如果将TTL设置为0，则表示除非此时可以直接将消息投递到消费者，否则该消息会被立即丢弃。设置消息的TTL有两种方式：</p><ol><li>通过队列属性设置，此时队列中所有消息都有相同的过期时间。</li><li>对消息本身进行单独设置，每条消息的TTL可以不同。</li></ol><p>如果两种方法一起使用，则消息的TTL以两者之间较小的那个数值为准，消息在队列中的生存时间一旦超过设置的TTL时，就会变成死信。</p><p>还要注意的是，对于第一种设置队列TTL属性的方法，一旦消息过期，就会从队列中抹去，因为队列中己过期的消息肯定在队列头部；而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期，如果过期再进行删除即可。</p><h3 id="设置队列的TTL"><a href="#设置队列的TTL" class="headerlink" title="设置队列的TTL"></a>设置队列的TTL</h3><p>在声明队列时可以通过<code>x-expires</code>参数控制队列被自动删除前处于未使用状态的时间，未使用的意思是队列上没有任何消费者，队列也没有被重新声明，并且在过期时间段内也未调用过<code>Basic.Get</code>命令。队列的TTL不能像消息一样设置为0。</p><h2 id="死信队列"><a href="#死信队列" class="headerlink" title="死信队列"></a>死信队列</h2><p>当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX（Dead-Letter-Exchange，死信交换器），绑定DLX的队列就称之为死信队列。消息变成死信一般是由于以下几种情况：</p><ul><li>消息被拒绝（<code>Basic.Reject</code> / <code>Basic.Nack</code>），并且设置<code>requeue</code>参数为<code>false</code></li><li>消息过期</li><li>队列达到最大长度值</li></ul><p>DLX也是一个正常的交换器，和一般的交换器没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。当这个队列中存在死信时，RabbitMQ就会自动地将这个消息重新发布到设置的DLX上去，进而被路由到死信队列中。</p><p><img src="http://blog.default.nanwulife.com/20181207094035629.png" alt=""></p><h2 id="延迟队列"><a href="#延迟队列" class="headerlink" title="延迟队列"></a>延迟队列</h2><p>延迟队列存储的对象是对应的延迟消息，即当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。RabbitMQ本身并没有直接支持延迟队列的功能，但是可以通过DLX和TTL模拟出延迟队列的功能。</p><p>生产者将消息发送到过期时间为n毫秒的队列中，这个队列并未有消费者来消费消息，当过期时间到达时，消息会通过死信交换器转发到死信队列中，而消费者从死信队列中消费消息。这个时候就达到了“生产者发布了消息，过了n毫秒后消费者消费了消息”的延迟队列的效果。</p><p><img src="http://blog.default.nanwulife.com/20181207094103998.jpg" alt=""></p><h2 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h2><p>可以将队列声明为优先级队列，即在创建队列的时候添加参数<code>x-max-priority</code>指定最大的优先级，值为0-255，此时的规则如下：</p><ul><li>优先级高的消息具备优先被消费的特权</li><li>没有指定优先级的消息会将优先级以0对待</li><li>对于超过优先级队列所定最大优先级的消息，优先级以最大优先级对待</li><li>对于相同优先级的消息，后进的排在前面</li></ul><p>如果在消费者的消费速度大于生产者的速度且Broker中没有消息堆积的情况下， 对发送的消息设置优先级也就没有什么实际意义。因为生产者刚发送完一条消息就被消费者消费了，那么就相当于Broker中至多只有一条消息，对于单条消息来说优先级是没有什么意义的。</p><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><p>持久化用以解决因为服务器的异常崩溃导致的消息丢失。RabbitMQ的持久化分为交换器的持久化、队列的持久化和消息的持久化：</p><ul><li>交换器持久化：交换器的持久化是通过在声明交换器时将<code>durable</code>参数置为<code>true</code>实现的。</li><li>队列持久化：队列的持久化是通过在声明队列时将<code>durable</code>参数置为<code>true</code>实现的。如果队列不设置持久化，那么在RabbitMQ服务重启之后，相关队列的元数据会丢失，此时数据也会丢失。但即使设置了该队列为持久化的，也不能保证内部存储的消息不会丢失。</li><li>消息持久化：要确保消息不会丢失，需要通过将消息的投递模式（<code>BasicProperties</code>中的<code>deliveryMode</code>属性）设置为2即可实现消息的持久化。</li></ul><p>就算将交换器、队列、消息都设置了持久化之后也不能百分百保证数据不会丢失。比如说消费者在订阅消费队列时将<code>autoAck</code>参数设置为<code>true</code>，那么当消费者接受到相关消息之后，还没来得及处理就宕机了，这样数据就丢失了。要解决这个问题可以将<code>autoAck</code>参数设置为<code>false</code>，并进行手动确认。</p><p>其次，在持久化的消息正确存入RabbitMQ之后，RabbitMQ并不会为每条消息都进行同步存盘（调用内核的<code>fsync</code>方法），此时仅仅保存到操作系统缓存之中，如果这时候发生了宕机，那么消息将会丢失。要解决这个问题可以使用RabbitMQ的镜像队列机制。</p><h2 id="生产者确认"><a href="#生产者确认" class="headerlink" title="生产者确认"></a>生产者确认</h2><p>当消息的生产者将消息发送出去之后，如果不进行特殊配置，默认情况下发送消息的操作是不会返回任何信息给生产者的，这样生产者也就不知道消息有没有正确到达服务器。RabbitMQ针对这个问题，提供了两种解决方式：</p><ol><li>通过事务机制实现</li><li>通过发送方确认（publisher confirm）机制实现</li></ol><h3 id="事务机制"><a href="#事务机制" class="headerlink" title="事务机制"></a>事务机制</h3><p>RabbitMQ客户端中与事务机制相关的方法有三个：<code>channel.txSelect</code>、<code>channel.txCommit</code>、<code>channel.txRollback</code>。其中<code>channel.txSelect</code>用于将当前的信道设置成事务模式，<code>channel.txCommit</code>用于提交事务，<code>channel.txRollback</code>用于事务回滚。</p><p>当开启事务并且提交成功，那么消息就一定到达了RabbitMQ中了，如果在事务提交之前由于RabbitMQ异常崩溃或者其它原因抛出异常，这个时候便可以将其捕获，进而通过执行<code>channel.txRollback</code>方法来实现事务回滚，与此同时可以进行消息重发。</p><h3 id="发送方确认机制"><a href="#发送方确认机制" class="headerlink" title="发送方确认机制"></a>发送方确认机制</h3><p>事务机制会严重降低RabbitMQ的消息吞吐量，而发送方确认机制则更加轻量级。</p><p>生产者通过<code>Confirm.Select</code>命令将信道设置成confirm（确认）模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），当消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（<code>Basic.ACK</code>）给生产者（包含消息的唯一ID），生产者可以通过回调方法来处理该确认消息。如果消息和队列是可持久化的，那么确认消息会在消息写入磁盘之后发出。如果RabbitMQ因为内部错误导致消息丢失，就会发送一条<code>Basic.Nack</code>命令，生产者同样也可以在回调方法中处理该命令。</p><p>RabbitMQ回传给生产者的确认消息中的<code>deliveryTag</code>包含了确认消息的序号，此外RabbitMQ也可以设置<code>channel.basicAck</code>方法中的<code>multiple</code>参数（默认为<code>true</code>，也就是批量确认），表示到这个序号之前的所有消息都已经得到了处理。</p><p><img src="http://blog.default.nanwulife.com/1352849-20190223221457597-1239923675.png" alt=""></p><p>事务机制在一条消息发送之后会使发送端阻塞，以等待RabbitMQ的回应，之后才能继续发送下一条消息。而发送方确认机制如果使用同步串行的编程方式实现，其实并没有比事务机制好多少，但是该机制的优势是在于并不一定需要同步确认，对此有以下两种改进方案：</p><ul><li>批量confirm方法：每发送一批消息后，调用<code>channel.waitForConfirms</code>方法，等待服务器的确认返回（该方法会阻塞到最后一条消息得到确认或者得到nack才结束）。</li><li>异步confirm方法：提供一个回调方法，服务端确认了一条或者多条消息后客户端会回调这个方法进行处理。</li></ul><p>对于批量confirm方法，客户端程序需要定期或者定量（达到多少条），亦或者两者结合起来调用<code>channel.waitForConfirms</code>来等待RabbitMQ的确认返回，但是如果出现返回<code>Basic.Nack</code>或者超时情况时，客户端需要将这一批次的消息全部重发。</p><p>而对于异步confirm方法，它的编程比较复杂一些，但因为不会被阻塞，所以性能也略好一些。</p><h2 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h2><p>上面的生产者确认是保证生产者的消息正确的到达了服务器，而为了保证消息从队列可靠地到达消费者，消费者在订阅队列时可以指定<code>autoAck</code>参数，当<code>autoAck</code>等于<code>true</code>时，RabbitMQ会自动把发送出去的消息设置为确认，然后从内存（或者磁盘）中删除，而不管消费者是否真正地消费了这些消息；当<code>autoAck</code>为<code>false</code>时，RabbitMQ会等待消费者显示地回复确认信号后才从内存（或者磁盘）中移除消息。RabbitMQ不会为未确认的消息设置过期时间，除非消费此消息的消费者已经断开连接，此时RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者。</p><h3 id="消费者拒绝"><a href="#消费者拒绝" class="headerlink" title="消费者拒绝"></a>消费者拒绝</h3><p>在消费者接受到消息后，如果想明确拒绝当前的消息而不是确认，那么可以使用<code>Basic.Reject</code>命令，其中如果将参数<code>requeue</code>设置为<code>false</code>，则RabbitMQ立即会把消息从队列中删除，否则，RabbitMQ会重新将这条消息存入队列，以便可以发送给下一个订阅的消费者。</p><p><code>Basic.Reject</code>命令一次只能拒绝一条消息，如果想要批量拒绝消息，则可以使用<code>Basic.Nack</code>这个命令，将<code>multiple</code>设为<code>true</code>则表示拒绝<code>deliveryTag</code>编号之前所有未被当前消费者确认的信息。</p><blockquote><p>注意：如果<code>requeue</code>设置为<code>false</code>，那么可以启用死信队列的功能。</p></blockquote><p><code>Basic.Recover</code>命令用来请求RabbitMQ重新发送还未被确认的消息，也具备可重入队列的特性。如果将其参数<code>requeue</code>设置为<code>true</code>，则未被确认的消息会被重新加入到队列中，这样对于同一条消息来说，可能会被分配给与之前不同的消费者。如果将<code>requeue</code>参数设置为<code>false</code>，那么同一条消息会被分配给与之前相同的消费者。</p><h3 id="消息分发"><a href="#消息分发" class="headerlink" title="消息分发"></a>消息分发</h3><p>当RabbitMQ队列拥有多个消费者时，队列收到的消息将以轮询的分发方式发送给消费者，但轮询的分发机制在各台机器性能差异较大时效率很低，那么就可以使用<code>Basic.Qos</code>命令限制信道上的消费者所能保持的最大未确认消息的数量，此时RabbitMQ会保存一个消费者的列表，每发送一条消息都会为对应的消费者计数，如果达到了所设定的上限，那么RabbitMQ就不会向这个消费者再发送任何消息，直到消费者确认了某条消息后，RabbitMQ将相应的计数减一，之后消费者才可以继续接收消息。</p><h2 id="可靠性总结"><a href="#可靠性总结" class="headerlink" title="可靠性总结"></a>可靠性总结</h2><p>为了提升数据的可靠性，从上文分析可以总结出以下几个途径：</p><ul><li>设置<code>mandatory</code>参数或者备份交换器来处理未能正确路由到队列的消息。</li><li>设置事务机制或者publisher confirm机制保证生产者的消息正确的到达了RabbitMQ。</li><li>设置交换器、队列和消息为持久化。</li><li>设置消费端对应的<code>autoAck</code>参数为<code>false</code>，在消费完消息后手动确认。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li><li><a href="https://dbaplus.cn/news-159-2326-1.html" target="_blank" rel="noopener">玩转不同业务场景，这些RabbitMQ特性会是得力助攻</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息返回&quot;&gt;&lt;a href=&quot;#消息返回&quot; class=&quot;headerlink&quot; title=&quot;消息返回&quot;&gt;&lt;/a&gt;消息返回&lt;/h2&gt;&lt;p&gt;&lt;code&gt;mandatory&lt;/code&gt;和&lt;code&gt;immediate&lt;/code&gt;是发布消息时的两个参数，它们都有当
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ基本概念</title>
    <link href="http://yoursite.com/2019/04/26/RabbitMQ%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/04/26/RabbitMQ基本概念/</id>
    <published>2019-04-26T02:12:00.000Z</published>
    <updated>2019-04-26T04:50:28.207Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>RabbitMQ整体上是一个生产者-消费者模型，主要负责接收、存储和转发消息。整体架构如下：</p><p><img src="http://blog.default.nanwulife.com/rabbitmq_example.png" alt=""></p><p>这里省略生产者、消费者等最基础的概念，主要介绍队列、交换器、路由键等。</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>队列（Queue）是RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一个队列，这时队列中的消息会被分摊（轮询）给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><h2 id="交换器"><a href="#交换器" class="headerlink" title="交换器"></a>交换器</h2><p>生产者不是直接将消息发送到队列中，而是发送给交换器（Exchange），由交换器将消息路由到一个或者多个队列中。交换器主要有fanout、direct、topic、headers四种类型：</p><ul><li>fanout：它会把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。</li><li>direct：它会把消息路由到那些BindingKey和RoutingKey完全匹配的队列中。</li><li>topic：对direct类型的扩展，允许BindingKey和RoutingKey不严格的匹配它约定：<ul><li>RoutingKey和BindingKey为一个点号<code>.</code>分隔的字符串，如<code>com.rabbitmq.client</code></li><li>BindingKey中可以存在两种特殊字符串<code>*</code>和<code>#</code>，用于做模糊匹配，其中<code>*</code>用于匹配一个单词，<code>#</code>用于匹配多规格单词（可以是零个）。</li></ul></li><li>headers：headers类型的交换器不依赖于路由键的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。在绑定队列和交换器时指定一组键值对，当发送消息到交换器时，RabbitMQ会获取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配队列和交换器绑定时指定的键值对，如果完全匹配则消息会路由到该队列，否则不会路由到该队列。这个类型基本不会使用。</li></ul><h2 id="路由键"><a href="#路由键" class="headerlink" title="路由键"></a>路由键</h2><p>生产者将消息发送给交换器的时候一般会指定一个RoutingKey，用来指定这个消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效。这里要注意BindingKey并不是所有情况下都生效，它依赖于交换器类型，比如fanout类型的交换器就会无视BindingKey，而是将信息路由到所有绑定到该交换器的队列中。</p><h2 id="Connection与Channel"><a href="#Connection与Channel" class="headerlink" title="Connection与Channel"></a>Connection与Channel</h2><p>无论是生产者还是消费者，都需要和RabbitMQ Broker建立连接，这个连接就是一条TCP连接，也就是Connection。一旦TCP连接建立起来，客户端紧接着可以创建一个AMQP信道（Channel），每个信道都会被指派一个唯一的ID，它是建立在Connection之上的虚拟连接，RabbitMQ处理的每条AMQP指令都是通过信道完成的。</p><p><img src="http://blog.default.nanwulife.com/connection_channel.png" alt=""></p><p>因为操作系统建立和销毁TCP连接是非常昂贵的开销，所以RabbitMQ采用TCP连接复用的方式，减少性能开销。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>RabbitMQ实战指南. 朱忠华</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本架构&quot;&gt;&lt;a href=&quot;#基本架构&quot; class=&quot;headerlink&quot; title=&quot;基本架构&quot;&gt;&lt;/a&gt;基本架构&lt;/h2&gt;&lt;p&gt;RabbitMQ整体上是一个生产者-消费者模型，主要负责接收、存储和转发消息。整体架构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src
      
    
    </summary>
    
      <category term="RabbitMQ" scheme="http://yoursite.com/categories/RabbitMQ/"/>
    
    
      <category term="RabbitMQ" scheme="http://yoursite.com/tags/RabbitMQ/"/>
    
      <category term="消息队列" scheme="http://yoursite.com/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门：单线程及五大数据类型</title>
    <link href="http://yoursite.com/2019/04/21/Redis%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2019/04/21/Redis五大数据类型及应用场景/</id>
    <published>2019-04-21T07:29:00.000Z</published>
    <updated>2019-04-21T09:57:32.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为什么Redis是单线程的"><a href="#为什么Redis是单线程的" class="headerlink" title="为什么Redis是单线程的"></a>为什么Redis是单线程的</h2><p>首先对于Redis的网络通信模块，它是基于I/O多路复用模型实现的，也就是说只使用一个线程就可以处理多个连接，避免了传统方案使用多线程处理多条连接时的上下文切换开销。而对于命令的执行，因为Redis是基于内存的操作，CPU不是Redis的瓶颈，单线程的处理效率就是最高的，使用多线程反而会增大切换开销，并且引入线程安全的问题，因此Redis使用单线程的方案。</p><p>那什么时候应该使用多线程呢？其实对于类似磁盘I/O读写的操作，如果使用单线程执行，当耗时较长时，后面的所有其它请求都会被阻塞在这，这时候就可以使用新的线程去异步的处理之后的一些请求，提高系统的性能。</p><h2 id="为什么Redis这么快"><a href="#为什么Redis这么快" class="headerlink" title="为什么Redis这么快"></a>为什么Redis这么快</h2><ul><li>Redis是基于内存的操作</li><li>Redis底层使用C语言实现，效率更高</li><li>Redis使用I/O多路复用，不像传统方案开多个线程处理多个I/O，大大降低了线程切换的开销</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是最基础的类型，字符串长度不能超过512MB。常用的API有如下几个：</p><ul><li><code>get key</code>：获取一个<code>key</code>的<code>value</code></li><li><code>set key value</code>：设置一个<code>key</code>的<code>value</code></li><li><code>del key</code>：删除一个<code>key</code></li><li><code>incr key</code>：<code>key</code>自增1，如果<code>key</code>不存在，自增后<code>key</code>的<code>value</code>为1</li><li><code>decr key</code>：<code>key</code>自减1，如果<code>key</code>不存在，自减后<code>key</code>的<code>value</code>为-1</li><li><code>incrby key k</code>：<code>key</code>自增k，如果<code>key</code>不存在，自增后<code>key</code>的<code>value</code>为k</li><li><code>set key value</code>：不管<code>key</code>是否存在，都设置<code>value</code></li><li><code>setnx key value</code>：当<code>key</code>不存在时才设置<code>value</code></li><li><code>mget key1 key2 key3...</code>：批量获取<code>key</code>，原子操作</li><li><code>mset key1 value1 key2 value2 key3 value3</code>：批量设置<code>key</code>的<code>value</code></li></ul><p>适用场景：</p><ul><li>记录某个用户的页面访问量：<code>incr userid:pageview</code></li><li>实现分布式锁</li></ul><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>哈希可以理解为Map中的Map，因为它每个key对应的value都是一个Map结构，每个field不能相同，但value可以相同。常用的API有如下几个：</p><ul><li><code>hget key field</code>：获取<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hgetall key</code>：返回<code>key</code>对应所有的<code>field</code>和<code>value</code></li><li><code>hset key field value</code>：设置<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hdel key field</code>：删除<code>key</code>对应的<code>field</code>的<code>value</code></li><li><code>hmget key field1 field2 ... fieldN</code>：批量获取<code>key</code>的一批<code>field</code>对应的<code>value</code></li><li><code>hmset key field1 value1 field2 value2 ... fieldN valueN</code>：批量设置<code>key</code>的一批<code>field</code>对应的<code>value</code></li></ul><p>要注意的是，哈希结构无法针对某个指定的<code>field</code>设置超时时间，TTL不好控制。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）用来存储多个有序（插入顺序）的字符串，每个字符串称为元素，并且元素是可以重复的。常用的API有如下几个：</p><ul><li><code>rpush key value1 value2 ... valuen</code>：从列表右端插入元素</li><li><code>lpush key value1 value2 ... valuen</code>：从列表左端插入元素</li><li><code>linsert key before|after value newValue</code>：在某个<code>key</code>下的<code>list</code>指定的<code>value</code>前|后插入<code>newValue</code></li><li><code>lpop key</code>：从列表左侧弹出一个元素</li><li><code>rpop key</code>：从列表右侧弹出一个元素</li><li><code>lrem key count value</code>：根据<code>count</code>的值，从列表中删除所有<code>value</code>相等的元素。当<code>count</code> &gt; 0时，从左到右删除最多<code>count</code>个<code>value</code>相等的元素；当<code>count</code> &lt; 0时，从右到左删除最多<code>Math.abs(count)</code>个<code>value</code>相等的元素；当<code>count</code> = 0时，删除所有<code>value</code>相等的元素。</li><li><code>ltrim key start end</code>：按照索引范围修剪列表，即删除索引范围之外的元素</li><li><code>lrange key start end</code>：获取列表索引范围内的所有元素，包含<code>end</code></li><li><code>blpop key timeout</code>：<code>lpop</code>阻塞版本，<code>timeout</code>是阻塞超时时间，<code>timeout</code>为0表示永不阻塞</li><li><code>brpop key timeout</code>：<code>rpop</code>阻塞版本，<code>timeout</code>是阻塞超时时间，<code>timeout</code>为0表示永不阻塞</li></ul><p>适用场景：</p><ul><li>用户动态的时间轴：当用户更新动态的时候可以使用<code>lpush</code>命令加入列表，使用<code>lrange</code>命令展示一定数量的动态，并且使用<code>ltrim</code>限制动态的数量。</li><li>使用<code>lpush</code> + <code>lpop</code>实现一个栈，使用<code>lpush</code> + <code>rpop</code>实现一个队列。</li><li>使用<code>lpush</code> + <code>brpop</code>实现一个消息队列。</li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）与列表类似，都是用来保存多个字符串，但集合中的元素是无序的，因此不能通过索引来操作元素，并且集合中的元素不能有重复。常用的API有如下几个：</p><ul><li><code>sadd key element</code>：向<code>key</code>添加<code>element</code>，如果<code>element</code>已经存在，则添加失败</li><li><code>srem key element</code>：将<code>key</code>中的<code>element</code>移除掉</li><li><code>sinter key1 key2</code>：取交集</li><li><code>sdiff key1 key2</code>：取差集</li><li><code>sunion key1 key2</code>：取并集</li><li><code>scard key</code>：返回集合中元素的数量</li><li><code>sismember key member</code>：判断集合<code>key</code>中是否存在<code>member</code></li><li><code>spop key</code>：从集合中随机弹出一个元素</li></ul><p>适用场景：</p><ul><li>使用<code>sadd</code>命令给用户添加标签，或者给标签添加用户，通过<code>sinter</code>命令实现共同关注等功能。</li></ul><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>有序集合与集合一样，元素都不能重复，但有序集合中的元素是有顺序的，与列表使用索引下标作为排序依据不同，有序集合为每个元素设置一个分数（score）作为排序依据。常用的API有如下几个：</p><ul><li><code>zadd key score element</code>：添加<code>score</code>和<code>element</code>，<code>score</code>是可以重复的，但<code>element</code>是不能重复的。</li><li><code>zrem key element</code>：删除元素<code>element</code></li><li><code>zscore key element</code>：返回元素<code>element</code>的分数<code>score</code></li><li><code>zincrby key increScore element</code>：增加或减少元素<code>element</code>的分数<code>score</code></li><li><code>zcard key</code>：返回元素的总个数</li><li><code>zrange key start end [WITHSCORES]</code>：返回指定索引范围内的升序元素（相当于排名）</li><li><code>zrangebyscore key minScore maxScore [WITHSCORES]</code>：返回指定分数范围内的升序元素</li><li><code>zcount key minScore maxScore</code>：返回有序集合内在指定分数范围内的个数</li></ul><p>适用场景：</p><ul><li>排行榜：可以将销售量、关注人数、时间戳作为<code>score</code>进行元素的排序</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为什么Redis是单线程的&quot;&gt;&lt;a href=&quot;#为什么Redis是单线程的&quot; class=&quot;headerlink&quot; title=&quot;为什么Redis是单线程的&quot;&gt;&lt;/a&gt;为什么Redis是单线程的&lt;/h2&gt;&lt;p&gt;首先对于Redis的网络通信模块，它是基于I/O多路
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Pipeline</title>
    <link href="http://yoursite.com/2019/04/21/Redis-%E7%AE%A1%E9%81%93/"/>
    <id>http://yoursite.com/2019/04/21/Redis-管道/</id>
    <published>2019-04-21T06:28:00.000Z</published>
    <updated>2019-04-21T07:13:14.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><p>Redis客户端执行一条命令分为以下四个步骤:</p><ol><li>发送命令</li><li>命令排队</li><li>命令执行</li><li>返回结果</li></ol><p>其中，第一步加第四步称为Round Trip Time（RTT，往返时间）。</p><h2 id="性能瓶颈"><a href="#性能瓶颈" class="headerlink" title="性能瓶颈"></a>性能瓶颈</h2><p>Redis提供了批量操作命令（例如<code>mget</code>、<code>mset</code>等），有效的节约了RTT，但大部分命令是不支持批量操作的。由于Redis命令执行本身是很快的（微妙级别），而发送命令以及返回结果的网络耗时往往更大，所以说Redis的性能瓶颈其实是网络。</p><h2 id="Pipeline机制"><a href="#Pipeline机制" class="headerlink" title="Pipeline机制"></a>Pipeline机制</h2><p>Pipeline机制能改善上面这类问题，它能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令按照顺序执行并装填结果返回给客户端。</p><p>Pipeline虽然好用，但是每次Pipeline组装的命令个数不能没有节制，否则一次组装Pipeline数据量过大，一方面会增加客户端的等待时机，另一方面会造成一定的网络阻塞，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p><h2 id="对比原生批量命令"><a href="#对比原生批量命令" class="headerlink" title="对比原生批量命令"></a>对比原生批量命令</h2><ul><li>原生批量命令是原子性，Pipeline是非原子性的。</li><li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li><li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端与客户端的共同实现。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.cnblogs.com/yixianyixian/p/8353563.html" target="_blank" rel="noopener">redis学习笔记 - Pipeline与事务</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;命令执行&quot;&gt;&lt;a href=&quot;#命令执行&quot; class=&quot;headerlink&quot; title=&quot;命令执行&quot;&gt;&lt;/a&gt;命令执行&lt;/h2&gt;&lt;p&gt;Redis客户端执行一条命令分为以下四个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;发送命令&lt;/li&gt;
&lt;li&gt;命令排队&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis实现分布式锁</title>
    <link href="http://yoursite.com/2019/04/21/Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    <id>http://yoursite.com/2019/04/21/Redis实现分布式锁/</id>
    <published>2019-04-21T03:03:00.000Z</published>
    <updated>2019-04-21T06:23:57.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通实现"><a href="#普通实现" class="headerlink" title="普通实现"></a>普通实现</h2><p>下面的加锁操作直接使用一条原子命令即可，而解锁操作需要用到Lua脚本保证原子性，该实现只适用于在单节点上操作。</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>加锁可以使用Redis提供的一条原子命令完成：<code>SET key value NX PX 30000</code>。</p><p>这里对其中的一些参数做一些解释：</p><ul><li><code>key</code>：我们使用key来当锁，因为key是唯一的。</li><li><code>value</code>：为保证可靠性，加锁和解锁要是同一个客户端，客户端自己不能把别人加的锁给解了。所以这里<code>value</code>可用于标识客户端，解锁时需要进行比较。</li><li><code>NX</code>：当key不存在时才进行set操作，若key已经存在，则不做任何操作。这个参数保证了只有一个人能拿到锁。</li><li><code>PX</code>：这里其实可以传入<code>EX</code>或<code>PX</code>，主要目的是设置一个过期时间，锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。</li></ul><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>为确保原子性，这里使用Lua脚本实现Redis分布式锁的解锁操作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if redis.call(&quot;get&quot;, KEYS[1]) == ARGV[1] then</span><br><span class="line">return redis.call(&quot;del&quot;, KEYS[1])</span><br><span class="line">else</span><br><span class="line">return 0</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>实现的关键在于一定要先比较<code>value</code>是否相等，这也是上面加锁时提到的客户端自己不能把别人加的锁给解了，如果是同一个客户端那么就直接将<code>key</code>删除即可。</p><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>事实上，上面的分布式锁实现在Redis单机部署的场景下工作是没问题的。但是如果Redis有多个节点的话，加锁就只能作用在一个Redis节点上，即使使用了哨兵或者集群方案保证高可用，如果master节点由于某些原因发生了主从切换，依然会出现锁丢失的情况：</p><ol><li>在Redis的master节点上获取到锁</li><li>这个锁的key还没来得及同步到slave节点</li><li>master故障，发生故障转移，slave节点升级为master节点</li><li>导致锁丢失</li></ol><h2 id="Redlock实现"><a href="#Redlock实现" class="headerlink" title="Redlock实现"></a>Redlock实现</h2><p>由于上述的分布式锁只适用于单机环境，Redis作者基于分布式环境提出了一种更高级的实现方式：Redlock。</p><p>在Redis的分布式环境中，我们假设有N个Redis master节点，这些节点完全互相独立，不存在主从复制或者其他集群协调机制。之前我们已经描述了在Redis单实例下怎么安全地获取和释放锁，我们确保将在每个实例上使用此方法获取和释放锁。这里假设有5个Redis master节点，并且运行在5台不同的服务器上以保证他们不会同时都宕掉。以下为加锁操作：</p><ol><li>首先获取当前的本地时间</li><li>使用相同的key和value依次尝试在5个实例上申请锁。在获得锁的过程中，为每一个锁操作设置一个快速失败时间（如果想要获得一个10秒的锁，那么每一个锁操作的失败时间设为5-50ms）。这样可以避免客户端与一个已经故障的master节点通信占用太长时间，通过快速失败的方式尽快与集群中的其他节点完成锁操作。</li><li>客户端计算出与master获得锁操作过程中消耗的时间（即当前时间减去第一步记录的时间），当且仅当客户端获得锁的过程中消耗的时间小于锁的存活时间，并且在一半以上的master节点中都获得锁，才认为client成功的获得了锁。</li><li>如果已经获得了锁，客户端执行任务的有效时间是锁的存活时间减去获得锁的过程中所消耗的时间。</li><li>如果客户端获得锁的数量不足一半以上，或获得锁的时间超时，那么认为获得锁失败，客户端应尽快地释放（部分）已经成功取到的锁，这样其他的客户端就不必非得等到锁过完有效时间才能取到。</li></ol><p>这个算法的核心思想其实在于只可能有一个客户端能获取到大部分master节点中的锁，也就避免了多个客户端都能获取到锁的情况。对于释放锁来说，过程就相对简单一些了：向所有的Redis实例发送释放锁命令即可，不用关心之前有没有从Redis实例成功获取到锁。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.redis.cn/topics/distlock.html" target="_blank" rel="noopener">Redis分布式锁</a></li><li><a href="http://cmsblogs.com/?p=3266#Redlock-2" target="_blank" rel="noopener">Redlock：Redis分布式锁最牛逼的实现</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;普通实现&quot;&gt;&lt;a href=&quot;#普通实现&quot; class=&quot;headerlink&quot; title=&quot;普通实现&quot;&gt;&lt;/a&gt;普通实现&lt;/h2&gt;&lt;p&gt;下面的加锁操作直接使用一条原子命令即可，而解锁操作需要用到Lua脚本保证原子性，该实现只适用于在单节点上操作。&lt;/p&gt;
&lt;h
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="分布式锁" scheme="http://yoursite.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>String源码分析</title>
    <link href="http://yoursite.com/2019/04/20/String%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/04/20/String源码分析/</id>
    <published>2019-04-20T04:17:00.000Z</published>
    <updated>2019-04-21T11:32:45.089Z</updated>
    
    <content type="html"><![CDATA[<h2 id="String-简介"><a href="#String-简介" class="headerlink" title="String 简介"></a>String 简介</h2><p><code>String</code>实例是常量，一旦创建后就不能再修改其值。以下为它的继承关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><img src="http://blog.default.nanwulife.com/String%20UML.png" alt=""></p><p>可以看出<code>String</code>实现了<code>Serializable</code>、<code>CharSequence</code>、<code>Comparable</code>接口，其中<code>CharSequence</code>主要提供一些对字符序列的只读访问，许多类如<code>StringBuilder</code>、<code>StringBuffer</code>也都实现了此接口，里面就只有几个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>String</code>类通过<code>final</code>修饰，不可被继承，同时<code>String</code>底层的字符数组也是被<code>final</code>修饰的，<code>char</code>属于基本数据类型，一旦被赋值之后也是不能被修改的，所以<code>String</code>是不可变的。这里对<code>final</code>做一个简单的总结：</p><ul><li>修饰类：当用<code>final</code>修饰一个类时，表明这个类不能被继承。也就是说，<code>String</code>类是不能被继承的，</li><li>修饰方法：把方法锁定，以防任何继承类对其覆盖。</li><li>修饰变量：修饰基本数据类型变量，则其数值一旦在初始化之后便不能更改；修饰引用类型变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];<span class="comment">// String的核心，用final修饰，无法再被修改</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// 哈希值，默认为0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">    <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>String</code>有很多重载的构造方法，介绍如下：</p><ol><li><p>空参数构造方法，初始化字符串实例，默认为空字符，理论上不需要用到这个构造方法，实际上定义一个空字符<code>String = &quot;&quot;</code>就会初始化一个空字符串的<code>String</code>对象，而此构造方法，也是把空字符的<code>value[]</code>拷贝一遍而已，源码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过一个字符串参数构造<code>String</code>对象，实际上将形参的<code>value</code>和<code>hash</code>赋值给实例对象作为初始化，相当于深拷贝了一个形参<code>String</code>对象，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过字符数组去构建一个新的<code>String</code>对象，这里使用<code>Arrays.copyOf</code>方法拷贝字符数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在源字符数组基础上，通过偏移量（起始位置）和字符数量，截取构建一个新的<code>String</code>对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果偏移量小于0，则抛出越界异常</span></span><br><span class="line">        <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果字符数量小于0，则抛出越界异常</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在截取的字符数量为0的情况下，偏移量在字符串长度范围内，则返回空字符</span></span><br><span class="line">            <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">                <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note: offset or count might be near -1&gt;&gt;&gt;1.</span></span><br><span class="line">        <span class="comment">//如果偏移量大于字符总长度-截取的字符长度，则抛出越界异常</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(offset + count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用Arrays.copyOfRange静态方法，截取一定范围的字符数组，从offset开始，长度为offset+count，赋值给当前实例的字符数组</span></span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过源字节数组，按照一定范围，从<code>offset</code>开始截取<code>length</code>个长度，初始化<code>String</code>实例，同时可以指定字符编码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> UnsupportedEncodingException </span>&#123;</span><br><span class="line">    <span class="comment">//字符编码参数为空，抛出空指针异常</span></span><br><span class="line">    <span class="keyword">if</span> (charsetName == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charsetName"</span>);</span><br><span class="line">    <span class="comment">//静态方法 检查字节数组的索引是否越界</span></span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="comment">//使用 StringCoding.decode 将字节数组按照一定范围解码为字符串，从offset开始截取length个长度</span></span><br><span class="line">    <span class="keyword">this</span>.value = StringCoding.decode(charsetName, bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>StringBuffer</code>构建成一个新的<code>String</code>，比较特别的就是这个方法有<code>synchronized</code>锁，同一时间只允许一个线程对这个<code>StringBuffer</code>构建成<code>String</code>对象，所以是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对当前 StringBuffer 对象加同步锁</span></span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="comment">//拷贝 StringBuffer 字符数组给当前实例的字符数组</span></span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将<code>StringBuilder</code>构建成一个新的<code>String</code>，与另一个构造器不同的是，此构造器不是线程安全的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><h3 id="value相关"><a href="#value相关" class="headerlink" title="value相关"></a>value相关</h3><ol><li><p>获取字符串长度，实际上是获取字符数组长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断字符串是否为空，实际上是判断字符数组长度是否为0：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据索引参数获取字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//索引小于0或者索引大于字符数组长度，则抛出越界异常</span></span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回字符数组指定位置字符</span></span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo"></a>compareTo</h3><p>实现了<code>Comparable</code>接口的<code>compareTo</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出该方法实现还是比较简单的，直接逐个比较每个字符是否相等，如果其中某个字符不相等就直接返回结果，否则比较它们的长度。</p><h3 id="equals与hashCode"><a href="#equals与hashCode" class="headerlink" title="equals与hashCode"></a>equals与hashCode</h3><p><code>equals</code>方法首先判断两个对象的地址是否相等，如果不等再判断对象是否为<code>String</code>类型，如果是的话再比较它们的长度与值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 先判断地址是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断要比较的对象是否为 String 类型</span></span><br><span class="line">        <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">            String anotherString = (String)anObject;</span><br><span class="line">            <span class="keyword">int</span> n = value.length;</span><br><span class="line">            <span class="comment">// 比较两个字符串的长度</span></span><br><span class="line">            <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">                <span class="keyword">char</span> v1[] = value;</span><br><span class="line">                <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 逐个比较两个字符串中每个字符是否相等</span></span><br><span class="line">                <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hashCode</code>方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为在大多数构造函数中，其实并没有设置成员变量<code>hash</code>的值，默认值是为0的，因此调用此方法会根据<code>value</code>数组重新计算哈希值，并赋给成员变量<code>hash</code>，下次就可以直接拿到该哈希值了。这里还有一行<code>h = 31 * h + val[i];</code>比较特别，它其实可以推导成一个公式：<code>val[0]*31^(n-1) + val[1]*31^(n-2) + ... + val[n-1]</code>，这里之所以要取31这个数字，原因如下：</p><blockquote><p>选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：<code>31 * i == (i &lt;&lt; 5) - i</code>，现代的 Java 虚拟机可以自动的完成这个优化。</p></blockquote><p>具体可以参考这篇文章：<a href="https://www.tianxiaobo.com/2018/01/18/String-hashCode-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/" target="_blank" rel="noopener">String hashCode 方法为什么选择数字31作为乘子</a></p><h3 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h3><p>在Java中有8种基本类型和一种比较特殊的类型<code>String</code>，这些类型为了使他们在运行过程中速度更快，更节省内存，都提供了一种常量池的概念。8种基本类型的常量池都是系统协调的，<code>String</code>类型的常量池比较特殊，它的主要使用方法有两种：</p><ul><li>直接使用双引号声明出来的<code>String</code>对象会直接存储在常量池中。</li><li>如果不是用双引号声明的<code>String</code>对象，可以使用<code>String</code>提供的<code>intern</code>方法。<code>intern</code>方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</li></ul><p>关于这个方法网上的解释有很多，但大多都比较混乱，我暂时还没有整理清楚，日后回来填坑。</p><h2 id="String对-的重载"><a href="#String对-的重载" class="headerlink" title="String对 + 的重载"></a>String对 + 的重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String apple = <span class="string">"Apple,"</span>;</span><br><span class="line">        String fruit = apple + <span class="string">"Pear,"</span> + <span class="string">"Orange"</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器在执行上述代码的时候会自动引入<code>StringBuilder</code>类。虽然在上面的代码中我们并没有使用到<code>StringBuilder</code>类，但是编译器却自动引入了它，因为它更高效。编译器首先会创建一个<code>StringBuilder</code>对象，用来构造最终要生成的<code>String</code>，并为每一个字符串调用一次<code>StringBuilder</code>中的<code>append()</code>方法，因此上述代码一共执行了三次<code>append()</code>方法，最后调用<code>toString</code>生成最终的结果，并保存为<code>fruit</code>。</p><p>但是我们不能认为编译器已经帮我们做了优化，我们就可以随意的使用<code>String</code>对象，下面是两种方法生成一个<code>String</code>，一个方法使用了<code>String</code>对象，另一个使用了<code>StringBuilder</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString1</span><span class="params">(String[] strArray)</span></span>&#123;</span><br><span class="line">       String result = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)</span><br><span class="line">           result += strArray[i];</span><br><span class="line">       <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString2</span><span class="params">(String[] strArray)</span></span>&#123;</span><br><span class="line">       StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strArray.length; i++)</span><br><span class="line">           result.append(strArray[i]);</span><br><span class="line">       <span class="keyword">return</span> result.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上面两个方法都是用来对一个数组中的数据进行连接并返回一个<code>String</code>对象，但是需要我们注意的是<code>getString1</code>方法是在循环内部构造<code>StringBuilder</code>对象的，这意味着每循环一次就会创建一个新的<code>StringBuilder</code>对象。</p><p><code>getString2</code>方法只生成了一个<code>StringBuilder</code>对象，这样更简单更高效的实现了同<code>getString1</code>一样的功能。所以在我们使用<code>String</code>对象时，最好考虑一下是否可以用<code>StringBuilder</code>对象更高效的实现我们想要的功能。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>String</code>类被修饰符<code>final</code>修饰是无法被继承的，而它内部的关键成员变量<code>char value[]</code>同样也是被<code>final</code>修饰不能更改的，因此<code>String</code>是不可变的。</li><li><code>String</code>实现了<code>Serializable</code>接口，可以被序列化；实现了<code>Comparable</code>接口，可用于比较大小；实现了<code>CharSequence</code>，实现了通用的字符序列的只读方法。</li><li><code>String</code>重载了+运算符，会创建一个<code>StringBuilder</code>对象并调用其<code>append()</code>实现字符串拼接。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java 编程思想》Bruce Eckel 著 陈昊鹏 译</li><li><a href="https://juejin.im/post/5c2588d8f265da6110371d2b#heading-3" target="_blank" rel="noopener">String 源码浅析(一)</a></li><li><a href="https://juejin.im/post/59fffddc5188253d6816f9c1#heading-17" target="_blank" rel="noopener">String源码分析</a></li><li><a href="https://www.tianxiaobo.com/2018/01/18/String-hashCode-%E6%96%B9%E6%B3%95%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E6%95%B0%E5%AD%9731%E4%BD%9C%E4%B8%BA%E4%B9%98%E5%AD%90/" target="_blank" rel="noopener">String hashCode 方法为什么选择数字31作为乘子</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;String-简介&quot;&gt;&lt;a href=&quot;#String-简介&quot; class=&quot;headerlink&quot; title=&quot;String 简介&quot;&gt;&lt;/a&gt;String 简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt;实例是常量，一旦创建后就不能再修改其值。以下为
      
    
    </summary>
    
      <category term="JDK源码分析" scheme="http://yoursite.com/categories/JDK%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="JDK" scheme="http://yoursite.com/tags/JDK/"/>
    
      <category term="源码分析" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="String" scheme="http://yoursite.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Redis缓存设计与优化</title>
    <link href="http://yoursite.com/2019/03/31/Redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/03/31/Redis缓存设计与优化/</id>
    <published>2019-03-31T12:28:00.000Z</published>
    <updated>2019-03-31T14:45:22.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>Redis过期策略是：定期删除+惰性删除。</p><p>所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置了过期时间的key（全部都检查的话十分消耗CPU资源），检查其是否过期，如果过期了就删除。但仅依赖此策略会有许多过期的key未被检查到，因此Redis还使用惰性删除策略，即在读/写key的时候再检查其是否过期，如果过期了则删除。</p><h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>如果某些key没有被定期删除，也没及时去读/写以触发惰性删除，那么Redis的内存会越来越高，当已用内存超过<code>maxmemory</code>限定时，就会根据内存淘汰机制删除部分key。Redis内存淘汰机制有以下几个：</p><ul><li>noeviction: 当内存不足以容纳新写入数据时，新写入操作会报错。</li><li>allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。</li><li>allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。</li><li>volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。</li><li>volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。</li><li>volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。</li></ul><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>一般的缓存系统，都是根据key去缓存查询，如果不存在对应的value，就应该去数据库查找。如果key对应的value是一定不存在的，并且对该key并发请求量很大，就会对数据库造成很大的压力，这就叫做缓存穿透。</p><p>第一个解决办法是对查询结果为空的键也进行缓存，由于这种方式需要更多的键，所以可以设置一个短一点的过期时间。</p><p>第二个解决方案则是使用布隆过滤器拦截。布隆过滤器的原理是，当一个元素被加入集合时，通过K个Hash函数将这个元素映射成一个位数组中的K个点，并把它们置为1。检索时，我们只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素有可能在。</p><p><img src="http://blog.default.nanwulife.com/booleanfilter.png" alt=""></p><p>通过布隆过滤器，一个一定不存在的数据会被它拦截掉，从而避免了对数据库的查询压力。</p><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，所有请求都会查询数据库，也会给数据库带来很大压力，这就叫做缓存雪崩。对于缓存雪崩有以下几种解决方案：</p><ul><li>可以给缓存设置过期时间时加上一个随机时间，使得每个key的过期时间分散开来，不会集中在同一时刻失效。</li><li>进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。</li><li>使用分布式缓存。</li><li>提前演练。</li></ul><h2 id="热点key重建"><a href="#热点key重建" class="headerlink" title="热点key重建"></a>热点key重建</h2><p>当前key是一个热点key（比如说某个热门的娱乐新闻），如果在缓存失效时有大量线程并发请求，那么这些线程会同时去访问数据库并重建key，导致后端系统负载过大，甚至因此崩溃。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180629202036949-8223995.png" alt=""></p><p>为此有以下几种解决方案：</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>可以使用互斥锁的方式实现，直接利用redis的<code>set</code>命令即可（如<code>SET mutexKey &quot;1&quot; EX 10086 NX</code>），为了防止该锁未被正确释放，还应给该锁设置一个过期时间。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703003410961-1677269917.png" alt=""></p><p>这种方式的缺点在于重建的过程中别的线程都会处于等待状态，整体性能不高。</p><h3 id="永远不过期"><a href="#永远不过期" class="headerlink" title="永远不过期"></a>永远不过期</h3><p>我们不为每个key设置一个过期时间，但会添加一个逻辑过期时间属性，每次去读的时候都判断一下当前时间是否已经大于逻辑过期时间，如果是的话就使用单独的线程去构建缓存。</p><p><img src="http://blog.default.nanwulife.com/1115933-20180703004145474-1329843618.png" alt=""></p><p>这种方式的缺点在于缓存的构建是异步的，因此别的线程在这个过程中依然会取到老值，不保证数据的一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://www.cnblogs.com/fidelQuan/p/4543387.html" target="_blank" rel="noopener">缓存穿透与缓存雪崩</a></li><li><a href="https://blog.csdn.net/fouy_yun/article/details/81075432" target="_blank" rel="noopener">分布式缓存击穿（布隆过滤器 Bloom Filter）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;过期策略&quot;&gt;&lt;a href=&quot;#过期策略&quot; class=&quot;headerlink&quot; title=&quot;过期策略&quot;&gt;&lt;/a&gt;过期策略&lt;/h2&gt;&lt;p&gt;Redis过期策略是：定期删除+惰性删除。&lt;/p&gt;
&lt;p&gt;所谓定期删除，指的是Redis默认每隔100ms就随机抽取一些设置
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster</title>
    <link href="http://yoursite.com/2019/03/31/Redis-Cluster/"/>
    <id>http://yoursite.com/2019/03/31/Redis-Cluster/</id>
    <published>2019-03-31T05:21:00.000Z</published>
    <updated>2019-03-31T12:22:57.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-Cluster作用"><a href="#Redis-Cluster作用" class="headerlink" title="Redis Cluster作用"></a>Redis Cluster作用</h2><p>Redis Cluster是Redis 3.0开始引入的分布式存储方案，集群由多个节点组成，Redis的数据分布在这些节点中。集群中的节点分为主节点和从节点：只有主节点负责读写请求和集群信息的维护，从节点只进行主节点数据和状态信息的复制。集群的作用，可以归纳为两点：</p><ul><li>数据分片：集群将数据分散到多个节点，突破了Redis单机内存大小的限制，存储容量大大增加。</li><li>高可用：集群支持主从复制和主节点的自动故障转移（与哨兵类似），当任一节点发生故障时，集群仍然可以对外提供服务。</li></ul><h2 id="数据分区方案"><a href="#数据分区方案" class="headerlink" title="数据分区方案"></a>数据分区方案</h2><p>常见的哈希分区方案包括：哈希取余分区、一致性哈希分区、带虚拟节点的一致性哈希分区等。</p><ul><li>哈希取余分区：哈希取余分区思路非常简单，首先计算key的hash值，然后对节点数量进行取余，从而决定数据映射到哪个节点上。该方案最大的问题是，当新增或删减节点时，节点数量发生变化，系统中所有的数据都需要重新计算映射关系，引发大规模数据迁移。</li><li>一致性哈希分区：一致性哈希算法将整个哈希值空间组织成一个虚拟的圆环，范围为<code>0 ~ 2^32-1</code>。对于每个数据，根据key计算hash值，确定数据在环上的位置，然后从此位置沿环顺时针行走，找到的第一台服务器就是其应该映射到的服务器。与哈希取余分区相比，一致性哈希分区将增减节点的影响限制在相邻节点。<br><img src="http://blog.default.nanwulife.com/U%7BKC_N~EU%5DO%5B9_%7B3KK03U58.png" alt=""></li><li>一致性哈希分区（虚拟节点机制）：普通的一致性哈希在服务器节点数量较少时容易产生数据倾斜问题，各个服务器的负载不均匀。为解决这个问题，引入了虚拟节点机制，每台机器可以负责更多节点，数据负担更加均匀。<br><img src="http://blog.default.nanwulife.com/Y90YE9D$%29CU%7B6AA%604QP~VEB.png" alt=""></li><li>虚拟槽分区：Redis Cluser底层使用的虚拟槽分区，有一个长度为16384的虚拟槽，每个Master节点都会负责一部分的槽，Redis对key计算哈希值，使用的算法是CRC16，然后根据哈希值计算数据属于哪个槽，最后根据槽与节点的映射关系，计算数据属于哪个节点。其中哪个节点负责哪个槽，这是可以由用户指定的。<br><img src="http://blog.default.nanwulife.com/1174710-20181025213453407-302249562.png" alt=""></li></ul><h2 id="节点通信机制"><a href="#节点通信机制" class="headerlink" title="节点通信机制"></a>节点通信机制</h2><h3 id="两个端口"><a href="#两个端口" class="headerlink" title="两个端口"></a>两个端口</h3><p>在redis sentinel中，节点分为数据节点和sentinel节点：前者存储数据，后者实现额外的控制功能。在redis cluster中，没有数据节点与非数据节点之分，所有的节点都存储数据，也都参与集群状态的维护。为此，集群中的每个节点都提供了两个TCP端口，普通端口主要用于为客户端提供服务，集群端口用于节点之间的通信，如搭建集群、增减节点、故障转移等操作时节点间的通信。</p><h3 id="Gossip协议"><a href="#Gossip协议" class="headerlink" title="Gossip协议"></a>Gossip协议</h3><p>Gossip过程是由种子节点发起，当一个种子节点有状态需要更新到网络中的其他节点时，它会随机的选择周围几个节点散播消息，收到消息的节点也会重复该过程，直至最终网络中所有的节点都收到了消息。这个过程可能需要一定的时间，由于不能保证某个时刻所有节点都收到消息，但是理论上最终所有节点都会收到消息，因此它是一个最终一致性协议。</p><p><img src="http://blog.default.nanwulife.com/v2-575e785e7d03ad317e5bce4e36debb03_b.gif" alt=""></p><p>Gossip协议的优点：</p><ul><li>负载低：比广播低，广播每条消息都要发送给所有节点，CPU、带宽等消耗较大。</li><li>去中心化：Gossip协议不要求任何中心节点，所有节点都可以是对等的，任何一个节点无需知道整个网络状况，只要网络是连通的，任意一个节点就可以把消息散播到全网。</li><li>容错性高：网络中任何节点的宕机和重启都不会影响Gossip消息的传播，Gossip协议具有天然的分布式系统容错特性。<br>Gossip协议的缺点：</li><li>消息的延迟：由于节点只会随机向少数几个节点发送消息，消息最终是通过多个轮次的散播而到达全网的，因此使用Gossip协议会造成不可避免的消息延迟，不适合用在对实时性要求较高的场景下。</li></ul><h3 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h3><p>集群节点间发送的消息有以下几种类型：</p><ul><li>meet：在节点握手阶段，当节点收到客户端的<code>cluster meet</code>命令时，会向新加入的节点发送meet消息，请求新节点加入到当前集群，新节点收到meet消息后会回复一个pong消息。</li><li>ping：集群里每个节点每秒钟会选择部分节点发送ping消息，接收者收到消息后会回复一个pong消息。ping消息使用Gossip协议发送，内容是自身节点和部分其他节点的状态信息，作用是彼此交换信息，以及检测节点是否在线。</li><li>pong：pong消息封装了自身状态数据，可以分为两种：第一种是在接到meet/ping消息后回复的pong消息，第二种是指节点向集群广播pong消息，这样其他节点可以获知该节点的最新信息，例如故障恢复后新的主节点会广播pong消息。</li><li>fail：当一个主节点判断另一个主节点客观下线后，会向集群广播这一fail消息，通知集群中所有节点标记故障节点为客观下线，并通知故障节点的从节点触发故障转移流程。</li><li>publish：节点收到publish命令后，会先执行该命令，然后向集群广播这一消息，接收节点也会执行该publish命令。</li></ul><h2 id="客户端路由"><a href="#客户端路由" class="headerlink" title="客户端路由"></a>客户端路由</h2><h3 id="moved重定向"><a href="#moved重定向" class="headerlink" title="moved重定向"></a>moved重定向</h3><p>moved异常代表槽已经确认迁移至别的节点。</p><p><img src="http://blog.default.nanwulife.com/1.png" alt=""><br><img src="http://blog.default.nanwulife.com/3.png" alt=""></p><h3 id="ask重定向"><a href="#ask重定向" class="headerlink" title="ask重定向"></a>ask重定向</h3><p>在集群缩容扩容的时候，要对槽进行迁移，在迁移的过程中访问一个key，但是key已经迁移到目标节点，那么就会返回一个ask异常。</p><p><img src="http://blog.default.nanwulife.com/6.png" alt=""></p><h3 id="Smart-Client"><a href="#Smart-Client" class="headerlink" title="Smart Client"></a>Smart Client</h3><p>redis-cli这一类客户端称为Dummy客户端，因为它们在执行命令前不知道数据在哪个节点上，因此需要借助moved异常重定向。为了追求性能，我们不可能每次都随机访问一个节点，再根据moved或ask异常去重定向到目标节点，因此需要实现一个Smart客户端，比如说JedisCluster。JedisCluster的基本原理大致如下：</p><ol><li>从集群中选一个可运行节点，使用<code>cluster slots</code>命令并将结果映射到本地，这样本地就有了slot-&gt;node的映射关系缓存。</li><li>JedisCluster为每个节点创建连接池(即JedisPool)。</li><li>当执行命令时，JedisCluster根据key-&gt;slot-&gt;node选择需要连接的节点，发送命令。如果成功，则命令执行完毕。如果执行失败，则会随机选择其他节点进行重试，并在出现moved错误时，刷新本地的映射关系缓存。</li></ol><p>这里需要注意的是，JedisCluster中已经包含所有节点的连接池，因此JedisCluster要使用单例。</p><h2 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h2><p>集群伸缩的核心是槽迁移，通过修改槽与节点的对应关系，实现槽（即数据）在节点之间的移动。例如，如果槽均匀分布在集群的3个节点中，此时增加一个节点，则需要从3个节点中分别拿出一部分槽给新节点，从而实现槽在4个节点中的均匀分布。</p><h3 id="增加节点"><a href="#增加节点" class="headerlink" title="增加节点"></a>增加节点</h3><ol><li>启动节点</li><li>加入集群：使用<code>cluster meet</code>命令。</li><li>迁移槽和数据</li></ol><h3 id="减少节点"><a href="#减少节点" class="headerlink" title="减少节点"></a>减少节点</h3><ol><li>迁移槽和数据</li><li>忘记节点：使用<code>cluster forget</code>命令</li><li>关闭节点</li></ol><p>这里要注意应先下线从节点再下线主节点，因为若主节点先下线，会触发故障的自动转移。</p><p>在槽迁移未完成时，客户端访问了负责该槽的节点，但key此时已经迁移到了别的节点下，这时候会返回ask异常，通过这个机制使得redis cluster可以无痛的完成扩缩容操作。</p><h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><p>集群对故障发现与故障转移的实现与哨兵思路类似：通过定时任务发送ping消息检测其他节点状态，若某个主节点发现另一个主节点不可用（与参数<code>cluster-node-timeout</code>有关），则标记该节点进行主观下线，而当半数以上持有槽的主节点都标记该节点主观下线，则对该节点进行客观下线，并向集群广播fail消息，让集群中所有节点都将其标记为客观下线，并触发从节点的故障转移。</p><p>在故障转移阶段，主要有以下几个步骤：</p><ul><li>检查资格：每个从节点都会检查与故障主节点的断线时间，如果超过默认值150s（<code>cluster-node-timeout * cluster-slave-validity-factor</code>）则会取消资格。</li><li>准备选举时间：为了保证偏移量比较大的从节点更有可能成为主节点，会将该从节点的延迟时间设置更小一些。</li><li>选举投票：从节点选举胜出需要的票数为N/2+1，其中N为主节点数量（包括故障主节点），但故障主节点实际上不能投票。因此为了能够在故障发生时顺利选出从节点，集群中至少需要3个主节点。</li><li>替换主节点。</li></ul><p>与哨兵一样，集群只实现了主节点的故障转移，从节点故障时只会被下线，不会进行故障转移。因此，使用集群时，应谨慎使用读写分离技术，因为从节点故障会导致读服务不可用，可用性变差。</p><h2 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h2><h3 id="cluster-node-timeout"><a href="#cluster-node-timeout" class="headerlink" title="cluster_node_timeout"></a>cluster_node_timeout</h3><p><code>cluster_node_timeout</code>的默认值是15s，影响包括：</p><ul><li>值越大对延迟容忍度越高，并且由于节点发现与其它节点最后通信时间超过<code>cluster_node_timeout / 2</code>时会直接发送ping消息，因此调大该参数还可以降低带宽消耗，但同时也会降低收敛速度。</li><li>影响故障转移的判定和时间，值越大越不容易误判，但完成转移消耗时间越长。</li></ul><h3 id="cluster-require-full-coverage"><a href="#cluster-require-full-coverage" class="headerlink" title="cluster-require-full-coverage"></a>cluster-require-full-coverage</h3><p><code>cluster-require-full-coverage</code>参数设置为yes时，当主节点发生故障而故障转移尚未完成，原主节点中的槽不在任何节点中，此时集群会处于下线状态，无法响应客户端的请求。但在实际应用中为了保证服务的高可用性，都会将该参数设置为no。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Redis开发与运维》</li><li><a href="http://duqingfeng.net/2018/06/12/%E5%93%88%E5%B8%8C%E5%88%86%E5%8C%BA%E6%8A%80%E6%9C%AF%E4%B9%8B%E9%97%B4%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%88%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E3%80%81Redis%20cluster%E8%99%9A%E6%8B%9F%E6%A7%BD%EF%BC%89/" target="_blank" rel="noopener">哈希分区技术之间的对比（一致性哈希、Redis cluster虚拟槽）</a></li><li><a href="https://www.cnblogs.com/kismetv/p/9853040.html" target="_blank" rel="noopener">深入学习Redis（5）：集群</a></li><li><a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener">P2P 网络核心技术：Gossip 协议</a></li><li><a href="https://enpsl.top/2019/01/24/2019-01-24-redis-cluster-route/" target="_blank" rel="noopener">Redis cluster 客户端路由</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Redis-Cluster作用&quot;&gt;&lt;a href=&quot;#Redis-Cluster作用&quot; class=&quot;headerlink&quot; title=&quot;Redis Cluster作用&quot;&gt;&lt;/a&gt;Redis Cluster作用&lt;/h2&gt;&lt;p&gt;Redis Cluster是Redi
      
    
    </summary>
    
      <category term="Redis" scheme="http://yoursite.com/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
  </entry>
  
</feed>
