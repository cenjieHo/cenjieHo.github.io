<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2018%2F09%2F06%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList简介（jdk1.8）ArrayList就是动态数组，其容量能够自动增长。如下为ArrayList的继承体系结构： 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable接口，且不是线程安全的，因此只能用在单线程环境下。 属性ArrayList主要有elementData和size两个属性：12transient Object[] elementData; private int size; elementData数组是用来存储元素的，而size表示ArrayList中已有的元素数量（不等于elementData.length）。 构造方法ArrayList共有三种构造方法： 指定容量的构造函数 123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125;&#125; 此方法接受一个初始化容量来初始化底层数组elementData，如果初始化容量值为0则将其初始化为一个空的常量数组：private static final Object[] EMPTY_ELEMENTDATA = {}; ，如果值小于零，则抛出异常。 无参构造函数 12345private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 此方法中的DEFAULTCAPACITY_EMPTY_ELEMENTDATA区别于EMPTY_ELEMENTDATA，通过将数组设为前者，在添加元素的时候会将容量设置为默认值10。 Collection作为参数的构造函数 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 此方法接受一个Collection，并且将其转换为数组赋给elementData，如果被赋值后的elementData长度为0，则将空的常量数组赋值给它。相反，则再判断Collection是否转化为了Object数组，如果没有则将其进行转化。 这里用到了Arrays.copyof()方法：123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 可以看出，该方法构造了一个新的长度为newLength的Object类型数组，并且将原数组复制到新的数组中 。而此处的复制用了System.arraycopy()方法，该方法被标记了native，调用了系统的C/C++代码，可以在openJDK中查看到源码。 get123456789public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 此方法可以得到指定下标的元素，先对下标进行越界检查，然后再通过一个间接方法获取到elementData的index下标的元素。 set1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 此方法用于设置指定下标的元素，并将该下标原有的元素返回。 addadd方法比较复杂，也是ArrayList核心所在，有下面两种形式： 将元素加入到列表末尾 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 12345678910private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 此处的calculateCapacity正是与上文DEFAULTCAPACITY_EMPTY_ELEMENTDATA常量相照应的方法。如果ArrayList是默认构造函数构造的话，在添加元素的时候此方法将返回DEFAULT_CAPACITY也就是10。而size已经大于10的情况，该方法便也失去了意义。12345678910111213141516171819202122232425262728private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 从源码可以看出，当需要的容量大于elementData数组的长度时，就需要对其进行扩张。而扩张的大小则根据if条件判断。一般情况下，会将长度扩张为原来的1.5倍，但是当1.5倍仍小于所需的容量时，会将长度直接设为所需容量。而新容量如果大于最大数组长度MAX_ARRAY_SIZE ，则根据所需容量分配Integer.MAX_VALUE或者MAX_ARRAY_SIZE。 ensureExplicitCapacity方法的第一行语句modCount++;的作用是记录修改次数。我们知道，ArrayList不是线程安全的，因此在迭代ArrayList的时候如果有其它线程修改了内容，那么就会导致modCount与迭代器初始化时的modCount不同，从而抛出异常ConcurrentModificationException。说白了，就是防止一个线程正在迭代遍历，另一个线程修改了这个列表的结构。 将元素添加到指定位置上 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 在此方法中，先对index进行越界检查，然后再进行扩容。这里用了System.arraycopy方法，j将包括index在内的之后的所有元素均向右移动一位，再将要添加的元素放置在elementData的index下标下。 addAll 将集合中的元素全部添加到ArrayList末尾 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125; 将Collection对象转化为Object数组后，先根据其长度进行扩容，再同样利用System.arraycopy函数把数组中的所有元素添加到elementData数组末尾。 将集合中的元素全部添加到ArrayList指定位置 12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 原理与add(int index, E element)类似，都是通过将已有元素右移实现，此处将不再阐述。 remove 移除指定下标上的元素 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 在这里，移除操作是将要移除的元素后面的所有元素均向左移动一位，并将size数减小实现的。此方法将返回要移除的元素。 移除指定的元素 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 先找到指定元素的下标，再根据下标进行移除。指定的元素有可能为null，而不为null的情况下将根据元素内容进行比较，因此将分为两种情况遍历数组。fastRemove的实现与remove(int index)基本一致，区别在于fastRemove不需要对下标进行检查，也不返回被移除的元素。 indexOf1234567891011121314151617181920212223242526272829public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 由源码可以看出，indexOf和lastIndexOf与remove(Object o)方法类似，并且找到元素时返回下标，没找到时返回-1，而contains方法正是通过indexOf判断是否找到元素实现的。 ArrayList总结 ArrayList底层是通过数组实现的，随机访问速度快，但插入和移除由于要移动大量的元素，所以性能较差。 ArrayList不是线程安全的，在多线程环境下，通过modCount域检测是否出现问题。 ArrayList每次扩容为原本的1.5倍，若依然不够，则会直接设置为所需容量大小。]]></content>
      <categories>
        <category>JDK源码阅读</category>
        <category>util</category>
      </categories>
      <tags>
        <tag>arraylist</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对尾递归的理解]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%B5%85%E8%B0%88%E5%AF%B9%E5%B0%BE%E9%80%92%E5%BD%92%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天在做《剑指Offer》第十题时，发现了一个用尾递归的解法，由于之前对于尾递归并没有太多了解，于是查阅了一些资料，在此对其进行一个简单的总结。关于其它题目的题解与笔记，感兴趣的朋友可以到我的Github或个人博客上看看：剑指Offer笔记 Cenjie’s Blog ， 以下是正文。 递归本质递归的本质是自己调用自己，因为是嵌套调用，所以栈帧无法回收，在递归调用的层级太多时，往往会引发调用栈溢出，也就是内存溢出。 尾递归概述尾递归本质与递归并无区别，只不过是递归的一种特殊写法。尾递归要求递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分，例如 return 3f(n)或者return f(n)+f(n-1) 都是不允许的。 由于尾递归也是一种递归，因此这种写法本身并不会有任何的优化效果，内存依旧会溢出，只不过一些编译器中会加入对尾递归的优化机制，在编译代码时自动根据尾递归的特性对其进行优化。 如何优化尾递归因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了，这是一方面。 另一方面，正因为调用的是自身，所以需要的存储空间是一模一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间。 因此，为尾递归进行优化主要分两个步骤：1、写成尾递归的形式。2、编译器遇到此形式时自动为其优化。 而在第十题：斐波那契数列中，由于Java没有对尾递归进行优化，因此与使用普通递归并无太大区别，依然会产生内存溢出的问题。 本文参考：https://www.cnblogs.com/bellkosmos/p/5280619.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑期学习记录（2018）]]></title>
    <url>%2F2018%2F07%2F31%2F%E6%9A%91%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%EF%BC%882018%EF%BC%89%2F</url>
    <content type="text"><![CDATA[七月份总结七月十八号从老家回来，正式开始了暑期的学习计划，共十二天的学习时间，掌握了如下内容： SSM框架的使用 查找与图等基础数据结构与算法 八月份要完成二手平台的前台功能，并进行测试与上线，域名要赶紧备案好。其中模态的异步传输已经知道该如何解决，上传商品页面的多图上传功能依然令人头疼。因此，前十天先完成在看的企业级电商项目，后二十天再将二手平台搞定。除此之外，《算法》也要在月底之前看完，最好能抽时间出来总结一下。 八月份总结前十天刷完了SSM电商项目，粗略地看完了《算法》，后二十天完成了二手平台的项目，并且刷了共十七道《剑指Offer》的题目，对解算法题稍微有了一些感觉。 后记计划大致都完成了，但是学校项目花的时间太久，效率不够，导致许多本应完成的附加内容没完成，并且关于框架的使用还不够熟练，后续将多写几篇博客来巩固自己所学的内容。]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms(4th) 读书笔记]]></title>
    <url>%2F2018%2F07%2F04%2FAlgorithms-4th-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《算法》第四版学习过程中的代码记录，更新中Github地址 本书所用到的所有测试数据: algs4-data.zip本书所依赖的jar包: algs4.jar 排序初级排序测试数据: tinyUF.txt mediumUF.txt tiny.txt 选择排序 插入排序 归并排序测试数据: tinyUF.txt mediumUF.txt tiny.txt 自顶向下的归并排序 自底向上的归并排序 快速排序测试数据: tinyUF.txt mediumUF.txt tiny.txt 快速排序 三向切分的快速排序 优先队列测试数据: m1.txt m2.txt m3.txt tinyBatch.txt 基于堆的优先队列 索引优先队列]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术卷Ⅰ 读书笔记]]></title>
    <url>%2F2018%2F06%2F27%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7%E2%85%A0-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文是根据我很久之前读的《Java核心技术卷Ⅰ》第十版而自己总结出的读书笔记+思维导图，包含有三、四、六、七章，主要梳理了章节的知识点，并贴出了书内的样例代码。 《java核心技术卷Ⅰ》第三章：java的基本程序设计结构 《java核心技术卷Ⅰ》第四章：对象与类 《java核心技术卷Ⅰ》第六章：接口、lambda表达式与内部类 《java核心技术卷Ⅰ》第七章：异常、断言和日志]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>Core Java</tag>
        <tag>JavaSE</tag>
        <tag>入门</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README文档的规范写法总结]]></title>
    <url>%2F2018%2F06%2F25%2FREADME%E6%96%87%E6%A1%A3%E7%9A%84%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[俗话说的好：“一个好开源项目一定有一个好的 README”。 要想自己放到github上的项目能吸引更多人的眼球，就必须写一个规范舒适的README.md，这么做不仅可以梳理自己对于项目的思路，也方便他人上手使用或学习。因此，此文根据Github上众多项目以及查阅相关资料对README做了一个小小的总结， 方便以后写README的时候可以直接套用该模板。 XXX系统（如果有Logo可以加上Logo）xxx系统是一个..系统，支持…，…（此处为简要描述） 官方网站 | 文档手册 | 别的东西 目前，此系统包含有以下功能： 功能1 功能2 功能3 准备 依赖1 依赖2 依赖3 搭建环境IntelliJ IDEA + MySQL 或者 eclipse + MySQL，… 快速开始 步骤1 步骤2 步骤3 相关截图截图1截图2 To Do List 功能1 功能2 功能3 CHANGE LOG此处填写版本更新记录 联系方式 水木今山的CSDN 水木今山的Github 水木今山的Gmail 水木今山的Weibo 至此，我们可以看到一个相对规范的README.md模板，在开源项目时可以直接套用该模板，而不必每次都采用不同的零零散散的格式去书写README。Markdown代码在下方给出，当然，大家也可以根据项目具体情况进行修改而使用。 12345678910111213141516171819202122232425262728293031323334353637383940## XXX系统（如果有Logo可以加上Logo）xxx系统是一个..系统，支持...，...（此处为简要描述）[官方网站](http://example.com) | [文档手册](http://example.com) | [别的东西](http://example.com) 目前，此系统包含有以下功能：* 功能1* 功能2* 功能3### 准备* 依赖1* 依赖2* 依赖3### 搭建环境IntelliJ IDEA + MySQL 或者 eclipse + MySQL，...### 快速开始* 步骤1* 步骤2* 步骤3### 相关截图截图1截图2### To Do List* 功能1* 功能2* 功能3### CHANGE LOG此处填写版本更新记录### 联系方式* [水木今山的CSDN](https://blog.csdn.net/qq_38283262)* [水木今山的Github](https://github.com/cenjieHo)* [水木今山的Gmail](mailto:cenjie.ho@gmail.com)* [水木今山的Weibo](https://weibo.com/5777495883/profile?topnav=1&amp;wvr=6)]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>README</tag>
        <tag>markdown</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Web入门项目-图书后台管理系统]]></title>
    <url>%2F2018%2F06%2F25%2FJava-Web%E5%85%A5%E9%97%A8%E9%A1%B9%E7%9B%AE-%E5%9B%BE%E4%B9%A6%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[一个基于JSP、Servlet、Javabeans的十分适合作为入门的Java Web项目。项目地址 项目环境 语言: Java IDE: Intellij IDEA Web服务器: Tomcat8.5 数据库: MySQL 设计模式: JSP+Servlet+JavaBean构成的MVC模型 实现功能登陆注册功能 常规登陆注册操作，用户未登陆无法进入主界面，且注册字段经过正则表达式校验图书分类管理 添加图书分类，未单独设计表图书管理 图书添加 图书查询(使用AJAX局部刷新) 图书展示 使用方式创建数据库libdb，导入sql脚本，将DBHelper中相关数据配置为自己的设置，导入jar包: servlet、jdbc。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>入门</tag>
        <tag>项目</tag>
        <tag>javabean</tag>
        <tag>jsp</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome To My Blog]]></title>
    <url>%2F2018%2F06%2F22%2FWelcome-To-My-Blog%2F</url>
    <content type="text"><![CDATA[写在前面的话大家好！我是就读于南京某高校的一名大二学生，在昨天搭建了这个个人博客网站用于记录自己在学习以及项目过程中的技术积累，希望通过这个平台能与大家分享自己的经验与教训，同时也欢迎大家随时可以联系我，期待与大家共同进步。 关于我我在学校的专业是电子信息科学与技术，曾利用课余时间学习过C、C++、Python等多门语言(仅限于皮毛)，经过两年的不断试错，终于在大二下学期确定了自己以后的发展方向—Java后台研发工程师。于是从基础语法到各大框架，这半年里接触到了许多新技术，看似学了许多东西却仍浮于水面终无所获，逐渐了解到自己要走的路还很长，而自己目前对于基础方面知识也尤为欠缺。因此需记住，沉下心，耐下性子，Coding the World。 近期任务 SSM 阅读jdk的部分源码 阅读《算法》 完成二手平台项目 坚持运动 用心coding RememberWork hard in silence, let success make the noise. 联系If you have some questions after you see this article, you can just find some info by clicking these links. 水木今山的CSDN 水木今山的Github 水木今山的Gmail 水木今山的Weibo]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
