<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux五种IO模型]]></title>
    <url>%2F2019%2F03%2F27%2FLinux-%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[IO模型对于一次IO访问，会分为两个阶段，首先等待数据准备好后被拷贝到操作系统内核的缓冲区中，然后再从操作系统内核的缓冲区拷贝到用户空间。IO模型可以分为以下五种类型： 阻塞式I/O（Blocking I/O） 非阻塞式I/O（Non-blocking I/O） 多路复用I/O（Multiplexing I/O） 信号驱动I/O（Signal-driven I/O） 异步I/O（Asynchronous I/O） 其中信号驱动式IO并不常用，所以重点关注另外四种IO模型。 阻塞式I/O在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的IO。 阻塞IO的特点就是能够及时的返回数据，但是在IO执行的两个阶段都被阻塞了，只有当数据从内核复制到了用户空间中，进程才能继续往下执行，因此对性能有所牺牲。 非阻塞式I/O应用进程执行系统调用之后，内核会立即返回一个错误码，但IO操作还没完成。此时应用进程并没有被阻塞，可以继续执行，但是需要不断的执行系统调用来获知IO操作是否完成，这种方式称为轮询。 这种模型的CPU利用率比较低，并且因为每过一段时间才去轮询一次，所以存在一个响应延迟。还需要注意的是，拷贝数据的整个过程，进程仍然是属于阻塞的状态。 I/O多路复用使用select或者poll对多个IO端口进行监听，只要多个套接字中的任何一个数据准备好了，就能返回可读，之后应用进程再执行recvfrom系统调用把数据从内核复制到进程中。 I/O复用模型让单个进程具有处理多个I/O事件的能力，因此相比多进程和多线程技术，它的系统开销小了许多。但是select，poll，epoll函数依然会阻塞应用进程，并且由于多路复用可以处理多个IO，那么多个IO之间的顺序就变得不确定了。 信号驱动I/O应用进程使用sigaction系统调用，内核立即返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是非阻塞的。内核在数据到达时向应用进程发送SIGIO信号，应用进程收到之后在信号处理程序中调用recvfrom将数据从内核复制到应用进程中。 相比于非阻塞式I/O的轮询方式，信号驱动I/O的CPU利用率更高。 异步非阻塞I/O用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户进程就可以去做别的事情。等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。这个IO模式的两个阶段，进程都是非阻塞的。 五种I/O模型对比 阻塞式I/O：同步阻塞 非阻塞式I/O：同步非阻塞（轮询） I/O多路复用：同步阻塞（可以监听多个IO） 信号驱动I/O：同步非阻塞（收到SIGIO信号后才执行recvfrom并阻塞） 异步I/O：异步非阻塞（两个阶段都不会阻塞） I/O多路复用中的select、poll、epollselect，poll，epoll都是IO多路复用的机制，select出现的最早，之后是poll，再是epoll。I/O多路复用就是通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 select：它仅仅知道有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，测试每个流是否有事件发生，找出能读出数据，或者写入数据的流，对他们进行操作。所以select具有O(n)的时间复杂度，同时处理的流越多，无差别轮询时间就越长。 poll：poll本质上和select没有区别，需要查询每个fd对应的设备状态，但是它没有最大连接数的限制，因为select的描述符类型使用数组实现，而poll的描述符类型使用链表实现。 epoll：epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。所以我们说epoll实际上是事件驱动（每个事件关联上fd）的，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)） 参考资料 Linux IO模式及 select、poll、epoll详解 select、poll、epoll之间的区别(搜狗面试)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>IO</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NIO知识点总结]]></title>
    <url>%2F2019%2F03%2F10%2FNIO%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简介Java NIO是一个可以替代标准Java IO API的IO API，主要有以下三个核心组件： Channels Buffers Selectors NIO与IO的主要区别在于： IO是面向流的，NIO是面向缓冲区的。 IO是阻塞的，NIO是非阻塞的。 NIO有选择器，允许一个单独的线程来管理多个输入通道。 ChannelJava NIO的通道类似流，主要区别在于： 既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。 通道可以异步地读写。 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。 NIO中有以下几个重要的通道实现。 FileChannelFileChannel是一个连接到文件的通道。可以通过文件通道读写文件。 注意：FileChannel无法设置为非阻塞模式，它总是运行在阻塞模式下。 12345678910111213//打开FileChannelRandomAccessFile aFile = new RandomAccessFile("data/nio-data.txt", "rw");FileChannel inChannel = aFile.getChannel();//在FileChannel的某个特定位置进行数据的读/写操作long pos = channel.position();channel.position(pos +123);//可以使用FileChannel.truncate()方法截取一个文件，指定长度后面的部分将被删除channel.truncate(1024);//出于性能方面的考虑，操作系统会将数据缓存在内存中，所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上，而通过FileChannel.force()方法则可以将通道里尚未写入磁盘的数据强制写到磁盘上channel.force(true); SocketChannelSocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel： 打开一个SocketChannel并连接到互联网上的某台服务器。 一个新连接到达ServerSocketChannel时，会创建一个SocketChannel。 SocketChannel是可以设置为非阻塞模式的，设置之后，就可以在异步模式下调用connect(), read()和write()了。 12345678910//打开并连接SocketChannel socketChannel = SocketChannel.open();socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));//非阻塞模式可以调用finishConnect()的方法确定连接是否建立socketChannel.configureBlocking(false);socketChannel.connect(new InetSocketAddress("http://jenkov.com", 80));while(! socketChannel.finishConnect() )&#123; //wait, or do something else...&#125; ServerSocketChannelServerSocketChannel是一个可以监听新进来的TCP连接的通道。在打开了ServerSocketChannel之后，可以通过accept()方法监听新进来的连接，当accept()方法返回的时候，它返回一个包含新进来的连接的SocketChannel。因此，accept()方法会一直阻塞到有新连接到达。 ServerSocketChannel也可以设置成非阻塞模式。在非阻塞模式下，accept()方法会立刻返回，如果还没有新进来的连接,返回的将是null。 1234567//打开通道并监听新进来的连接ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();serverSocketChannel.socket().bind(new InetSocketAddress(9999));while(true)&#123; SocketChannel socketChannel = serverSocketChannel.accept(); //do something with socketChannel...&#125; DatagramChannelDatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议，所以不能像其它通道那样读取和写入。它发送和接收的是数据包。 12345678910111213141516//打开DatagramChannelDatagramChannel channel = DatagramChannel.open();channel.socket().bind(new InetSocketAddress(9999));//通过receive()方法从DatagramChannel接收数据到指定的Buffer，如果Buffer容不下收到的数据，多出的数据将被丢弃ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();channel.receive(buf);//通过send()方法从DatagramChannel发送数据String newData = "New String to write to file..." + System.currentTimeMillis();ByteBuffer buf = ByteBuffer.allocate(48);buf.clear();buf.put(newData.getBytes());buf.flip();int bytesSent = channel.send(buf, new InetSocketAddress("jenkov.com", 80)); BufferBuffer本质是一块可以写入数据，并可以从中读取数据的内存，用于和通道进行交互，过程如下： 写入数据到Buffer 调用flip()方法 从Buffer中读取数据 调用clear()方法或者compact()方法 其中flip()方法是将Buffer从写模式切换到读模式，clear()方法会清空整个缓冲区，compact()方法只会清除已经读过的数据并将所有未读的数据拷贝到Buffer起始处。 Buffer有三个属性： capacity position：当写数据到Buffer中时，position表示当前的位置；当从Buffer读取数据时，也是从当前位置开始读；将Buffer从写模式切换到读模式，position会被重置为0。 limit：在写模式下，limit表示你最多能往Buffer里写多少数据，此时limit等于capacity；在读模式下，limit表示最多能读到多少数据，因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。 Buffer有以下几种类型，它们代表了不同的数据类型： ByteBuffer MappedByteBuffer CharBuffer DoubleBuffer FloatBuffer IntBuffer LongBuffer ShortBuffer Buffer的分配要想获得一个Buffer对象首先要进行分配。每一个Buffer类都有一个allocate方法：1ByteBuffer buf = ByteBuffer.allocate(48); 向Buffer写数据写数据到Buffer有两种方式： 从Channel写到Buffer。 通过Buffer的put()方法写到Buffer里。 123int bytesRead = inChannel.read(buf); //read into buffer.buf.put(127); 从Buffer读数据从Buffer中读取数据有两种方式： 从Buffer读取数据到Channel。 使用get()方法从Buffer中读取数据。 123int bytesWritten = inChannel.write(buf);byte aByte = buf.get(); rewind()方法rewind()将position设回0，所以可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素。 SelectorSelector是NIO中能够检测一到多个通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。 创建并注册与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。 1234567//Selector的创建Selector selector = Selector.open(); //向Selector注册通道 channel.configureBlocking(false);SelectionKey key = channel.register(selector, Selectionkey.OP_READ); 注意register()方法的第二个参数。这是一个interest集合，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件，用SelectionKey的四个常量来表示: SelectionKey.OP_CONNECT：某个channel成功连接到另一个服务器称为“连接就绪” SelectionKey.OP_ACCEPT：一个server socket channel准备好接收新进入的连接称为“接收就绪” SelectionKey.OP_READ：一个有数据可读的通道可以说是“读就绪” SelectionKey.OP_WRITE：等待写数据的通道可以说是“写就绪”。 如果对不止一种事件感兴趣，那么可以用“位或”操作符将常量连接起来，如int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; SelectionKey当向Selector注册Channel时，register()法会返回一个SelectionKey对象，这个对象包含以下几个属性： terest集合 ready集合 Channel Selector 附加的对象（可选） interest集合可以用位与操作interest集合和给定的SelectionKey常量来确定某个事件是否在interest集合中。 123456int interestSet = selectionKey.interestOps();boolean isInterestedInAccept = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；boolean isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;boolean isInterestedInRead = interestSet &amp; SelectionKey.OP_READ;boolean isInterestedInWrite = interestSet &amp; SelectionKey.OP_WRITE; ready集合ready集合是通道已经准备就绪的操作的集合。可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪，也可以通过如下的方法：1234selectionKey.isAcceptable();selectionKey.isConnectable();selectionKey.isReadable();selectionKey.isWritable(); Channel Selector12Channel channel = selectionKey.channel();Selector selector = selectionKey.selector(); 附加的对象可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。使用方法如下： 12selectionKey.attach(theObject);Object attachedObj = selectionKey.attachment(); 选择通道一旦向Selector注册了一或多个通道，就可以调用select()方法选择就绪的通道，方法返回已经就绪的通道数目。select()阻塞到至少有一个通道在你注册的事件上就绪了，而selectNow()不会阻塞。 一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，就可以通过调用selectedKeys()方法返回就绪通道的集合：1Set selectedKeys = selector.selectedKeys(); 之后就可以通过遍历这个集合来访问就绪的通道：123456789101112131415Set selectedKeys = selector.selectedKeys();Iterator keyIterator = selectedKeys.iterator();while(keyIterator.hasNext()) &#123; SelectionKey key = keyIterator.next(); if(key.isAcceptable()) &#123; // a connection was accepted by a ServerSocketChannel. &#125; else if (key.isConnectable()) &#123; // a connection was established with a remote server. &#125; else if (key.isReadable()) &#123; // a channel is ready for reading &#125; else if (key.isWritable()) &#123; // a channel is ready for writing &#125; keyIterator.remove();&#125; 注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从集合中移除SelectionKey实例，必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入集合中。 关闭用完Selector后调用其close()方法会关闭该Selector，且使注册到该Selector上的所有SelectionKey实例无效，但通道本身并不会关闭。 Scatter/GatherJava NIO支持scatter/gather，scatter是指数据从一个channel读取到多个buffer中，而gather则是指数据从多个buffer写入到同一个channel。scatter/gather经常用于需要将传输的数据分开处理的场合，例如传输一个由消息头和消息体组成的消息，你可能会将消息体和消息头分散到不同的buffer中，这样可以方便的处理消息头和消息体。 123456789ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] bufferArray = &#123; header, body &#125;;channel.read(bufferArray);ByteBuffer header = ByteBuffer.allocate(128);ByteBuffer body = ByteBuffer.allocate(1024);ByteBuffer[] bufferArray = &#123; header, body &#125;;channel.write(bufferArray); 注意，Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这意味着它不适用于动态消息，而Gathering Writes只有position和limit之间的数据才会被写入，因此能较好的处理动态消息。 通道之间的数据传输如果两个通道中有一个是FileChannel，那么可以直接将数据从一个通道传输到另外一个通道。 transferFrom()transferFrom()方法可以将数据从源channel传输到FileChannel中：12345678910RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw");FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile("toFile.txt", "rw");FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();toChannel.transferFrom(position, count, fromChannel); transferTo()transferTo()方法将数据从FileChannel传输到其他的channel中。 12345678910RandomAccessFile fromFile = new RandomAccessFile("fromFile.txt", "rw");FileChannel fromChannel = fromFile.getChannel();RandomAccessFile toFile = new RandomAccessFile("toFile.txt", "rw");FileChannel toChannel = toFile.getChannel();long position = 0;long count = fromChannel.size();fromChannel.transferTo(position, count, toChannel); PathPath接口表示的是一个与平台无关的路径，既可以是绝对路径也可以是相对路径，文件和目录都用Path表示。 创建Path可以使用Paths工具类的工厂方法创建一个Path对象： 123456Path path = Paths.get("C:\\DATA\\test.txt");Path projects = Paths.get("d:\\data", "projects");Path currentDir = Paths.get(".");Path parentDir = Paths.get(".."); normalize()normalize()方法可以标准化路径，它会处理路径中的相对路径，去除. ..：123456789Path path = Paths.get("c:/Z_DATA/./test.txt");System.out.println("path = " + path);path = path.normalize();System.out.println("path = " + path);//输出path = c:\Z_DATA\.\test.txtpath = c:\Z_DATA\test.txt FilesFiles工具类封装提供了一些操作文件系统中文件的工具方法，往往和和Path一起使用。 exists()exists()可以判断一个Path在文件系统中是否存在。 createDirctory()在调用创建方法前最好先检查是否存在，如果已经存在会抛出FileAlreadyExistsException异常。 12345678Path newDir = Paths.get("c:/Z_DATA/newDir");try &#123; if(!Files.exists(newDir)) &#123; Files.createDirectory(newDir); &#125;&#125; catch (IOException e) &#123; e.printStackTrace();&#125; copy()copy()只能复制到不存在的路径，如果复制的目标文件已存在则会抛出异常。强制覆盖已存在文件也是可以的，需要增加相应参数： 1234567Path sourcePath = Paths.get(classPath,"nio-data.txt");Path targetPath = Paths.get(classPath,"nio-data-copy.txt");try &#123; Files.copy(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); // 复制并覆盖已有文件&#125; catch (IOException e) &#123; e.printStackTrace();&#125; move()Java NIO Files类同样提供了移动文件的方法。 1234567Path sourcePath = Paths.get(classPath,"nio-data.txt");Path targetPath = Paths.get(classPath,"nio-data-copy.txt");try &#123; Files.move(sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING); // 移动并覆盖已有文件&#125; catch (IOException e) &#123; e.printStackTrace();&#125; delete()删除文件或目录 1Files.delete(targetPath); 如果删除的文件或目录不存在会抛出IOException异常。 AsynchronousFileChannel使用AsynchronousFileChannel可以实现异步地读取和写入文件数据。 创建我们可以使用AsynchronousFileChannel提供的静态方法open()创建它。 123Path path = Paths.get("data/test.xml");AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ); 读取数据AsynchronousFileChannel提供了两种读取数据的方式，都是调用它本身的read()方法。 使用Futrue读取数据第一种方式是调用AsynchronousFileChannel的read()方法，该方法返回一个Future类型的对象。 123456789101112131415AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);ByteBuffer buffer = ByteBuffer.allocate(1024);long position = 0;Future&lt;Integer&gt; operation = fileChannel.read(buffer, position);while(!operation.isDone());buffer.flip();byte[] data = new byte[buffer.limit()];buffer.get(data);System.out.println(new String(data));buffer.clear(); 以上代码read()方法会立即返回，即使整个读的过程还没有完全结束。我们可以通过Future.isDone()来检查读取是否完成。 使用CompletionHandler读取数据第二种读取数据的方式是调用AsynchronousFileChannel的另一个read()方法，该方法需要一个CompletionHandler作为参数。 1234567891011121314151617fileChannel.read(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer attachment) &#123; System.out.println("result = " + result); attachment.flip(); byte[] data = new byte[attachment.limit()]; attachment.get(data); System.out.println(new String(data)); attachment.clear(); &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; &#125;&#125;); 一旦读取操作完成，CompletionHandler的complete()方法将会被调用。它的第一个参数是个Integer类型，表示读取的字节数。第二个参数attachment是ByteBuffer类型的，用来存储读取的数据(ByteBuffer也可以换成其他合适的对象方便数据写入)。它其实就是由read()方法的第三个参数。读取失败的时候，CompletionHandler的failed()方法会被调用。 写入数据就像读取一样，我们同样有两种方式向AsynchronousFileChannel写入数据。 使用Future读取数据12345678910111213141516Path path = Paths.get("data/test-write.txt");AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);ByteBuffer buffer = ByteBuffer.allocate(1024);long position = 0;buffer.put("test data".getBytes());buffer.flip();Future&lt;Integer&gt; operation = fileChannel.write(buffer, position);buffer.clear();while(!operation.isDone());System.out.println("Write done"); 注意，写入目标文件要提前创建好，如果它不存在的话，write()方法会抛出一个 NoSuchFileException。 使用CompletionHandler写入数据1234567891011121314151617181920212223242526Path path = Paths.get("data/test-write.txt");if(!Files.exists(path))&#123; Files.createFile(path);&#125;AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);ByteBuffer buffer = ByteBuffer.allocate(1024);long position = 0;buffer.put("test data".getBytes());buffer.flip();fileChannel.write(buffer, position, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer attachment) &#123; System.out.println("bytes written: " + result); &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; System.out.println("Write failed"); exc.printStackTrace(); &#125;&#125;); 当写入程序完成时，CompletionHandler的completed()方法将会被调用，相反的如果写入失败则会调用failed()方法。 参考资料 Java NIO 系列教程]]></content>
      <categories>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTPS的过程与原理]]></title>
    <url>%2F2019%2F02%2F17%2FHTTPS%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[由于HTTP存在明文通信、无法验证服务器的真实性等弊端，使用HTTPS的人变得越来越多。HTTPS并不是新的协议，而是在HTTP基础之上加一层TLS模块，TLS提供了加密、认证以及消息完整性校验的服务，从而保证通信的安全性。 HTTPS过程HTTPS总的流程就相当于使用非对称加密的方式来传递对称私钥，之后的通信就可以使用这个私钥进行对称加密了。 客户端发起HTTPS请求用户在浏览器里输入一个https网址，然后连接到server的443端口。 服务端的配置采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面。 传送证书这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。 客户端解析证书这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值。然后用证书对该随机值进行加密。 传送加密信息这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。 服务段解密信息服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。 传输加密后的信息这部分信息是服务端用私钥加密后的信息，可以在客户端被还原。 客户端解密信息客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。 证书认证单纯的加密是无法保证通信安全的，TLS还需要通过证书机制来保证访问的服务器是真实的。 证书是由权威机构颁发的，服务端如果能够提供一个合法的证书，说明这个服务端是合法的，可以被信任。整个证书的认证过程如下： 客户端获取到了站点证书，拿到了站点的公钥 要验证站点可信后，才能使用其公钥，因此客户端找到其站点证书颁发者的信息 站点证书的颁发者验证了服务端站点是可信的，但客户端依然不清楚该颁发者是否可信 再往上回溯，找到了认证了中间证书商的根证书颁发者。由于根证书颁发者非常少，我们浏览器之前就认识了，因此可以认为根证书颁发者是可信的 一路倒推，证书颁发者可信，那么它所颁发的所有站点也是可信的，最终确定我们所要访问的服务端是可信的 客户端使用证书中包含的公钥，继续完成TLS的握手过程 如果证书过期了、颁发机构不受信任或者证书绑定的域名和请求的域名不一致等原因，浏览器会抛出异常信息，说明此时的访问是不安全的。 参考资料 图解HTTPS TLS整理（下）：TLS如何保证安全]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
        <tag>TLS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[InnoDB和MyISAM的区别]]></title>
    <url>%2F2019%2F02%2F16%2FInnoDB%E5%92%8CMyISAM%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[InnoDB支持事务，MyISAM不支持。 InnoDB支持外键，而MyISAM不支持。 InnoDB是聚集索引，而MyISAM是非聚集索引。 InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MyISAM</tag>
        <tag>InnoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问一个网页的全过程]]></title>
    <url>%2F2019%2F02%2F13%2F%E8%AE%BF%E9%97%AE%E4%B8%80%E4%B8%AA%E7%BD%91%E9%A1%B5%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[客户端用户从浏览器输入www.google.com网站网址后回车，系统会查询本地hosts文件及DNS缓存信息，查找是否存在网址对应的IP解析记录。如果有就直接获取到IP地址，然后访问网站，一般第一次请求时，DNS缓存是没有解析记录的。 如果hosts与DNS缓存都没有解析记录时，系统会把浏览器的解析请求交给客户端本地设置的DNS服务器地址解析，如果本地DNS服务器的本地缓存有对应的解析记录，就会直接返回IP地址。 如果本地DNS服务器没有对应的解析记录，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(google.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找google.com域服务器，重复上面的动作，进行查询，直至找到www.google.com主机。 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。 通过DNS解析拿到了ip之后，就可以通过ip向服务器发送http请求了，因为http工作在应用层，tcp工作在传输层，所以发生http请求之前，还会进行tcp的三次握手建立连接。 在连接成功建立后，开始向web服务器发送请求，当浏览器向Web服务器发出请求时，它向服务器传递了一个数据块，也就是请求报文，请求报文由请求方法 URI 协议/版本、请求头、请求正文三部分组成。 请求报文由应用层向下，依次经过传输层、网络层、数据链路层与物理层。应用层的任务是通过应用进程间的交互来完成特定网络应用，有HTTP、DNS等众多协议，传输层的主要任务则是负责向两台主机进程之间的通信提供通用的数据传输服务，包括TCP与UDP两种协议，TCP是面向连接的、可靠的的数据传输服务，而UDP提供无连接的、不可靠的数据传输服务，TCP主要提供完整性服务，UDP主要提供及时性服务；传输层是为主机中的进程提供数据传输服务，而网络层则是为不同主机提供数据传输服务，这一层有IP协议，由于主机之间可以有很多链路，数据链路层则是为同一链路的主机提供数据传输服务。最终物理层考虑怎样在传输媒体上传输数据比特流。数据通过以太网电缆传送到服务器，服务器拿到数据包后同样再由数据链路层、网络层、传输层依次向上解析，应用层最终收到请求内容。 服务器收到请求报文之后，就会将响应报文返回给客户端，响应报文由协议/版本 状态码 描述、响应头、响应正文三部分组成。这里的状态码分为1XX（信息类）、2XX（成功类）、3XX（重定向类）、4XX（客户端错误）、5XX（服务器错误）。 当浏览器加载一个完整的页面时，还需要与服务器断开连接，这个过程就是tcp的四次挥手。 在HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。因此，每次的请求都会造成无谓的TCP连接建立与断开，增加通信量的开销。为了解决这个问题，HTTP/1.1使用长连接减少开销，只要任意一端没有明确提出断开连接，就保持TCP连接状态，当客户端再次访问这个服务器上的网页时，会继续使用这一条已经建立的连接。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[多线程断点续传下载器]]></title>
    <url>%2F2019%2F02%2F12%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8B%E8%BD%BD%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近在研究多线程的断点续传下载。断点续传的原理其实很简单，就是在下载时将下载进度保存到一个临时文件中，如果下载过程遇到什么意外中断了，下次下载同一个文件时就可以从临时文件中读取到上次下载发生中断时的进度，然后从这个进度开始继续下载。 要使用断点续传下载首先要判断服务器是否支持范围请求，假如在响应中存在Accept-Ranges首部并且它的值不为 none，那么表示该服务器支持范围请求。通常情况下Web服务器会默认开启对范围请求的支持，我们只需要在请求头中加入Range首部来指示服务器应该返回文件的哪一部分，例如使用Range: bytes=0-1023返回某个资源的前1024个字节，在代码中体现为：httpcon.setRequestProperty(&quot;Range&quot;, &quot;bytes=&quot; + startPos + &quot;-&quot; + endPos);，这时候服务器会返回状态码为206 Partial Content的响应表示成功。 项目中还使用了多线程进行分块下载，要注意的是并非线程数越多下载就越快（受限于带宽），一般开十个线程就差不多了，多线程之所以能提高下载速度的原因也很复杂，具体可以参考为什么多线程下载能加速？以及为什么多 TCP 连接分块下载比单连接下载快？。简单来说就是当链路存在争用的情况下，由于传输网络的带宽有限，每个TCP连接可以得到均等的带宽。在多用户环境下，一个用户拥有越多TCP连接，获得的带宽越大。除此之外，由于TCP的拥塞控制机制被设计的十分友好，只要丢了点包就会极大的减慢速率，而此时可能并没有发生拥塞，导致单个连接没法最大化的利用带宽。 下图为该项目的执行流程： 以下为项目源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262import java.io.File;import java.io.FileNotFoundException;import java.io.IOException;import java.io.InputStream;import java.io.RandomAccessFile;import java.net.HttpURLConnection;import java.net.MalformedURLException;import java.net.URL;import java.util.concurrent.CountDownLatch;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * @Project: breakpoint * @Description: * @Author: Cenjie * @Date: Created in 2019/2/11 */public class Downloader &#123; private String urlStr; private int threadNum; private String filename; private String filename_tmp; private CountDownLatch latch; private long fileLength; private long lenPerThread; //每个线程的下载大小 private long[] start; //保留每个线程下载的起始位置。 private long[] end; //保留每个线程下载的结束位置。 private URL url; public Downloader(String urlStr, int threadNum) &#123; this.urlStr = urlStr; this.threadNum = threadNum; start = new long[this.threadNum]; end = new long[this.threadNum]; latch = new CountDownLatch(this.threadNum); &#125; /** * 文件下载 */ public void download() &#123; File file = null; File file_tmp = null; //从文件链接中获取文件名 filename = urlStr.substring(urlStr.lastIndexOf('/') + 1, urlStr .contains("?") ? urlStr.lastIndexOf('?') : urlStr.length()); //设置临时文件的文件名 filename_tmp = filename + "_tmp"; try &#123; //创建url url = new URL(urlStr); //打开下载链接，并且得到一个HttpURLConnection的一个对象httpcon HttpURLConnection httpcon = (HttpURLConnection) url.openConnection(); httpcon.setRequestMethod("GET"); //获取请求资源的总长度，为Long型 fileLength = httpcon.getContentLengthLong(); //下载文件和临时文件 file = new File(filename); file_tmp = new File(filename_tmp); //每个线程需下载的资源大小；由于文件大小不确定，为避免数据丢失 lenPerThread = fileLength % threadNum == 0 ? fileLength / threadNum : fileLength / threadNum + 1; //打印下载信息 System.out.println("文件名: " + filename + "，" + "文件大小：" + fileLength + "字节，每个线程下载大小：" + lenPerThread + "字节"); if (file.exists() &amp;&amp; file.length() == fileLength) &#123; System.out.println("文件已存在"); return; &#125; else &#123; setBreakPoint(file_tmp); ExecutorService exec = Executors.newCachedThreadPool(); for (int i = 0; i &lt; threadNum; i++) &#123; exec.execute(new DownLoadThread(start[i], end[i], this, i)); &#125; latch.await(); //当所有线程下载完毕后，才会从此阻塞中返回 System.out.println("文件下载完成"); exec.shutdown(); &#125; &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //下载完成后，判断文件是否完整，并删除临时文件 if (file.length() == fileLength) &#123; if (file_tmp.exists()) &#123; file_tmp.delete(); System.out.println("删除临时文件完成，下载结束"); &#125; &#125; else&#123; System.out.println("该文件不完整"); &#125; &#125; /** * 读取临时文件中记录的断点，加载每个线程的任务区间，若临时文件不存在，则重新分配每个线程的任务区间 * @param file_tmp */ private void setBreakPoint(File file_tmp) &#123; RandomAccessFile random_file_tmp = null; System.out.println("开始分配任务区间："); try &#123; //如果存在临时文件，则从临时文件记录的位置继续下载 if (file_tmp.exists()) &#123; System.out.println("找到临时文件，将从断点处恢复下载..."); random_file_tmp = new RandomAccessFile(file_tmp, "rw"); for (int i = 0; i &lt; threadNum; i++) &#123; random_file_tmp.seek(i * 8); start[i] = random_file_tmp.readLong(); random_file_tmp.seek(1000 + i * 8); end[i] = random_file_tmp.readLong(); System.out.println("线程" + i + " 起始位置：" + start[i] + "，结束位置：" + end[i]); &#125; &#125; else &#123; System.out.println("未找到临时文件，开始一个新的下载..."); random_file_tmp = new RandomAccessFile(file_tmp, "rw"); for (int i = 0; i &lt; threadNum; i++) &#123; //设置线程i的下载起始位置 start[i] = lenPerThread * i; if (i == threadNum - 1) &#123; //当线程i为最后一个线程时，设置线程i的下载结束位置为文件长度 end[i] = fileLength - 1; &#125; else &#123; end[i] = lenPerThread * (i + 1) - 1; &#125; random_file_tmp.seek(i * 8); random_file_tmp.writeLong(start[i]); random_file_tmp.seek(1000 + i * 8); random_file_tmp.writeLong(end[i]); System.out.println("线程" + i + " 起始位置：" + start[i] + "，结束位置：" + end[i]); &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (random_file_tmp != null) &#123; random_file_tmp.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; class DownLoadThread implements Runnable &#123; private int id; //线程id private long startPos; //线程下载起始位置 private long endPos; //线程下载结束位置 private Downloader task; private RandomAccessFile rand_file; private RandomAccessFile rand_file_tmp; public DownLoadThread(long startPos, long endPos, Downloader task, int id) &#123; this.startPos = startPos; this.endPos = endPos; this.task = task; this.id = id; try &#123; this.rand_file = new RandomAccessFile(this.task.filename, "rw"); this.rand_file_tmp = new RandomAccessFile(this.task.filename_tmp, "rw"); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public void run() &#123; HttpURLConnection httpcon; InputStream is = null; int length; System.out.println("线程" + id + " 开始下载..."); while (true) &#123; try &#123; httpcon = (HttpURLConnection) task.url.openConnection(); httpcon.setRequestMethod("GET"); //防止网络阻塞，设置指定的超时时间；单位都是ms。超过指定时间，就会抛出异常 httpcon.setReadTimeout(20000);//读取数据的超时设置 httpcon.setConnectTimeout(20000);//连接的超时设置 if (startPos &lt; endPos) &#123; //向服务器请求指定区间段的数据，这是实现断点续传的根本。 httpcon.setRequestProperty("Range", "bytes=" + startPos + "-" + endPos); System.out.println("线程" + id + " 长度：" + (endPos - startPos + 1)); rand_file.seek(startPos); is = httpcon.getInputStream();//获取服务器返回的资源流 long count = 0L; byte[] buf = new byte[1024]; while ((length = is.read(buf)) != -1) &#123; count += length; rand_file.write(buf, 0, length); //不断更新每个线程下载资源的起始位置，并写入临时文件 startPos += length; rand_file_tmp.seek(id * 8); rand_file_tmp.writeLong(startPos); &#125; System.out.println("线程" + id + " 总下载大小: " + count); //关闭流 is.close(); httpcon.disconnect(); rand_file.close(); rand_file_tmp.close(); &#125; latch.countDown(); System.out.println("线程" + id + " 下载完成"); break; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (is != null) &#123; is.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int threadNum = 10; String url = "http://blog.default.nanwulife.com/pexels-photo-640947.jpeg"; Downloader load = new Downloader(url, threadNum); load.download(); &#125;&#125;]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>多线程</tag>
        <tag>断点续传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池与Executor框架]]></title>
    <url>%2F2019%2F02%2F10%2FExecutor%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[为什么要使用线程池 降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁造成的消耗。 提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。 提高线程的可管理性：线程是稀缺资源，使用线程池可以进行统一分配、调优和监控。 线程池的实现原理 如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（这一步需获取全局锁）。 如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。 如果队列已满，则创建新的线程来处理任务（这一步需获取全局锁）。 如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并使用相关饱和策略进行处理，默认是直接抛出异常。 之所以采用这个步骤，是因为在执行execute()方法时，尽可能地避免获取全局锁。在线程池完成预热之后（当前运行的线程数大于等于corePoolSize），几乎所有的execute()方法调用都是执行步骤2，而步骤2不需要获取全局锁。 Executor框架Executor框架内部使用了线程池机制，它在java.util.cocurrent包下，通过该框架来控制线程的启动、执行和关闭，可以简化并发编程的操作。因此，通过Executor来启动线程比使用Thread的start()方法更易管理且效率更好。 Executor框架的结构与成员 ThreadPoolExecutorThreadPoolExecutor是Executor框架的最核心的类，是线程池的实现类，用来执行被提交的任务，通常使用工厂类Executors来创建，有以下三种类型： FixedThreadPool：线程数固定。适用于为了满足资源管理而需要限制线程数的场景，适用于负载比较重的服务器。 SingleThreadExecutor：只有一个线程。适用于需要保证顺序地执行各个任务，并且在任意时间点不会有多个线程是活动的场景。 CachedThreadPool：根据需要创建新线程。空闲线程等待新任务超过60秒就会被终止。适用于执行很多短期异步任务的小程序，或者是负载较轻的服务器。 FixedThreadPool和SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列。CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列。 ScheduledThreadPoolExecutorScheduledThreadPoolExecutor继承自ThreadPoolExecutor，主要用来在给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活，Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。 FutureTaskFuture接口和实现Future接口的FutureTask类，代表异步计算的结果。FutureTask除了实现Future接口外，还实现了Runnable接口。可以把FutureTask交给Executor执行，也可以通过submit()方法返回一个FutureTask，然后执行FutureTask.get()方法。 线程池的使用线程池的创建我们可以通过ThreadPoolExecutor来创建一个线程池： 1new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, threadFactory,handler); 当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其它空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。 向线程池提交任务可以使用execute()方法提交任务，但是execute()方法没有返回值，所以无法判断任务是否被线程池执行成功。也可以使用submit()方法来提交任务，它会返回一个future，可以通过这个future的get()方法来获取返回值，get()方法会阻塞直到任务完成。 关闭线程池可以通过调用线程池的shutdown()或shutdownNow()方法来关闭线程池。 shutdown()先将线程池状态置为SHUTDOWN，停止接受外部提交的新任务，而等到正在执行的任务以及队列中等待的任务执行完才真正停止。 shutdownNow()先将线程池状态置为STOP，停止接受外部提交的新任务，忽略队列里等待的任务，使用interrupt()方法尝试将正在跑的任务中断，然后返回未执行的任务列表。 注意，如果线程中没有sleep、wait、Condition等应用，interrupt()方法是无法中断当前的线程的。所以，shutdownNow()并不代表线程池一定立即就能退出，它也可能必须要等待所有正在执行的任务都执行完成了才能退出。 参考资料 聊聊并发（三）Java线程池的分析和使用]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Executor</tag>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的并发工具类]]></title>
    <url>%2F2019%2F02%2F10%2FJava%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[CountdownLatchCountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。 CountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。例如： 123456789101112131415161718192021public class CountDownLatchTest&#123; static CountDownLatch c = new CountDownLatch(2); public static void main(String[] args)&#123; new Thread(new Runnable()&#123; @Override public void run()&#123; System.out.println(1); c.countDown(); System.out.println(2); c.countDown(); &#125; &#125;).start(); try &#123; c.await(); &#125; catch (InterruptedException e) &#123; &#125; System.out.println(3); &#125;&#125; 还可以通过创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，随后调用countDown()方法来同时启动多个线程。 CyclicBarrier同步屏障CyclicBarrier可以让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。例如： 12345678910111213141516171819202122public class CyclicBarrierTest &#123; static CyclicBarrier c = new CyclicBarrier(2); public static void main(String[] args) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; try&#123; c.await(); &#125; catch (Exception e)&#123; &#125; System.out.println(1); &#125; &#125;).start(); try&#123; c.await(); &#125;catch (Exception e)&#123; &#125; System.out.println(2); &#125;&#125; CyclicBarrier和CountDownLatch的区别CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。 SemaphoreSemaphore是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。Semaphore的构造方法接受一个整型的数字，表示可用的许可证数量，线程使用acquire()方法获取一个许可证，如果没有许可证能够获得则被阻塞，使用完后调用release()方法归还许可证。还可以使用tryAcquire()方法尝试获取许可证，若获取成功，则立即返回true，若获取失败，则立即返回false。 Semaphore可以用于流量控制，特别是公用资源有限的应用场景，比如数据库连接。如果线程数有几十个，而数据库的连接只有十个，那么就可以使用Semaphore控制同时获取数据库连接的个数。 参考资料 《Java并发编程的艺术》 什么时候使用CountDownLatch]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java并发编程基础]]></title>
    <url>%2F2019%2F02%2F09%2FJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[线程状态Java线程在运行的生命周期中可能处于以下6种不同的状态： 状态名称 说明 NEW 初始状态，线程被构建，但是还没调用start()方法 RUNNABLE 运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作“运行中” BLOCKED 阻塞状态，表示线程阻塞于锁 WAITING 无限期等待状态，进入该状态表示当前线程需要等待其它线程做出一些特定动作（通知或中断） TIME_WAITING 限期等待状态，可以在指定的时间自行返回 TERMINATED 终止状态，表示当前线程已经执行完毕 Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在Lock接口的线程状态是等待状态。 Daemon线程用户线程是我们平常创建的普通线程，而守护线程则是用来服务于用户线程的一种支持型线程。当一个Java虚拟机中只存在守护线程的时候，Java虚拟机将会退出。可以在启动线程之前通过调用Thread.setDaemon(true)将该线程设置为守护线程。 守护线程可用于实时监控和管理系统中的可回收资源。例如，Java垃圾回收线程就是一个典型的守护线程，当我们的程序中不再有任何运行中的Thread，程序就不会再产生垃圾，垃圾回收器也就无事可做，所以当垃圾回收线程是Java虚拟机上仅剩的线程时，Java虚拟机会自动退出。 使用线程有三种使用线程的方法： 实现Runnable接口； 实现Callable接口； 继承Thread类。 实现Runnable和Callable接口的类只能当做一个可以在线程中运行的任务，不是真正意义上的线程，因此最后还需要通过Thread来调用。可以说任务是通过线程驱动从而执行的。 实现Runnable接口需要实现run()方法。通过Thread调用start()方法来启动线程。 1234567891011public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现Callable接口与Runnable相比，Callable可以有返回值，返回值通过FutureTask进行封装。 12345678910111213public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 继承Thread类同样也是需要实现run()方法，因为Thread类也实现了Runable接口。 当调用start()方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的run()方法。 12345678910public class MyThread extends Thread &#123; public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 对比实现接口会更好一些，因为： Java不支持多重继承，因此继承了Thread类就无法继承其它类，但是可以实现多个接口。 类可能只要求可执行就行，继承整个Thread类开销过大。 等待/通知机制等待/通知机制是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。以下为等待/通知的经典范式： 12345678910111213//等待方synchronized(对象)&#123; while(条件不满足)&#123; 对象.wait(); &#125; 对应的处理逻辑;&#125;//通知方synchronized(对象)&#123; 改变条件 对象.notifyAll();&#125; wait()，notify()，notifyAll()方法只能用在同步方法或者同步控制块中使用，否则会在运行时抛出IllegalMonitorStateException。使用wait()挂起期间，线程会释放锁，这是因为如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行notify()或者notifyAll()来唤醒挂起的线程，造成死锁。 注意，wait()是Object的方法，而sleep()是Thread的静态方法；wait()会释放锁，sleep()不会。 线程之间的协作Thread.join()在线程中调用另一个线程的join()方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。 await() signal() signalAll()java.util.concurrent类库中提供了Condition类来实现线程之间的协调，可以在Condition上调用await()方法使线程等待，其它线程调用signal()或signalAll()方法唤醒等待的线程。 相比于wait()这种等待方式，await()可以指定等待的条件，因此更加灵活。 1234567891011121314151617181920212223242526272829303132333435public class AwaitSignalExample &#123; private Lock lock = new ReentrantLock(); private Condition condition = lock.newCondition(); public void before() &#123; lock.lock(); try &#123; System.out.println("before"); condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125; &#125; public void after() &#123; lock.lock(); try &#123; condition.await(); System.out.println("after"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); AwaitSignalExample example = new AwaitSignalExample(); executorService.execute(() -&gt; example.after()); executorService.execute(() -&gt; example.before()); &#125;&#125; ThreadLocalThreadLocal即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。 参考资料 《Java并发编程的艺术》 CS-Notes]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[final域的内存语义]]></title>
    <url>%2F2019%2F02%2F09%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90final%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[对于final域，编译器和处理器要遵守两个重排序规则。 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。 以上规则保证只要对象是正确构造的，那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。要实现这个效果，还需要保证在构造函数内部，不能让这个被构造对象的引用为其它线程所见，也就是对象引用不能在构造函数中“逸出”，因为此时的final域由于重排序等原因可能还没被初始化。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>final</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顺序一致性模型与happens-before原则]]></title>
    <url>%2F2019%2F02%2F09%2F%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B%E4%B8%8Ehappens-before%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[顺序一致性模型顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参考。顺序一致性内存模型有两大特性： 一个线程中的所有操作必须按照程序的顺序来执行。 不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行并且立刻对所有线程可见。 JMM保证如果程序是正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。 而对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值要么是之前某个线程写入的值，要么是默认值（0，null，false），JMM保证线程读操作读取到的值不会无中生有的冒出来。为了实现最小安全性，JVM在堆上分配内存时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。 注意：对于未同步程序，JMM不保证对64位的long型和double型变量的写操作具有原子性。 happens-beforehappens-before原则定义如下： 如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。 两个操作之间存在happens-before关系，并不意味着Java平台的具体实现一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。 参考资料 《Java并发编程的艺术》]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>happens-before</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入分析synchronized关键字]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90synchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[简介synchronized是Java中的关键字，是一种同步锁，可作用于一段代码或方法，既可以保证可见性，又能够保证原子性。Java中的每一个对象都可以作为锁： 对于同步方法，锁是当前实例对象。 对于静态同步方法，锁是当前对象的Class对象。 对于同步方法块，锁是Synchonized括号里配置的对象。 当一个线程试图访问同步代码时，它首先必须得到锁，退出或抛出异常时必须释放锁，而没获取到锁的线程将被阻塞。 synchronized实现原理每个对象有一个监视器锁（monitor），当monitor被占用时就会处于锁定状态。 代码块同步是使用monitorenter和monitorexit指令实现的，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下： 如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。 如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1. 如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。 而对于monitorexit指令，指令执行时monitor的进入数减1，如果减1后进入数为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。 方法同步不是使用monitorenter和monitorexit指令来完成，但同样是基于进入和退出monitor对象来实现，在方法执行期间，其他任何线程都无法再获得同一个monitor对象。 锁的升级JDK1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在JDK1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。 偏向锁引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的加锁解锁开销，因为轻量级锁的获取及释放依赖多次CAS操作，而偏向锁只需要在置换线程ID的时候依赖一次CAS操作。 偏向锁获取过程： 访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，以此确认为可偏向状态。 如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤（5），否则进入步骤（3）。 如果线程ID并未指向当前线程，则通过CAS操作获取锁。如果获取成功，则将Mark Word中线程ID设置为当前线程ID，然后执行（5）；如果获取失败，执行（4）。 如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。 执行同步代码。 线程不会主动去释放偏向锁，只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。 轻量级锁轻量级锁的加锁过程： 在代码进入同步块的时候，如果同步对象锁状态为无锁状态，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录的空间，拷贝对象头中的Mark Word到锁记录中，官方称之为Displaced Mark Word。 拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向锁记录的指针，并将锁记录里的owner指针指向object mark word。如果更新成功，则执行步骤（3），否则执行步骤（4）。 如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。 如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态，而当前线程便尝试使用自旋来获取锁。 在最后一步线程获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的，由于自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。JDK采用适应性自旋的方式解决这个问题，指定自旋的次数，如果超过次数如果还没获取到锁就进入阻塞状态。线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。 轻量级锁的解锁过程： 通过CAS操作尝试把线程中复制的Displaced Mark Word对象替换当前的Mark Word。 如果替换成功，整个同步过程就完成了。 如果替换失败，说明有其他线程尝试过获取该锁（此时锁已膨胀），那就要在释放锁的同时，唤醒被挂起的线程。 锁的对比 锁 优点 缺点 适用场景 偏向锁 加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。 如果线程间存在锁竞争，会带来额外的锁撤销的消耗。 只有一个线程执行同步块。 轻量级锁 竞争的线程不会阻塞，提高了程序的响应速度。 如果始终得不到锁竞争的线程使用自旋会消耗CPU。 多个线程交替执行同步块。 重量级锁 线程竞争不使用自旋，不会消耗CPU。 线程阻塞，响应时间缓慢。 多个线程同时执行同步块。 参考资料 聊聊并发（二）Java SE1.6中的Synchronized Java并发编程：Synchronized及其实现原理 Java并发编程：Synchronized底层优化（偏向锁、轻量级锁）]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>synchronized</tag>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入分析volatile关键字]]></title>
    <url>%2F2019%2F02%2F08%2F%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90volatile%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[简介volatile是轻量级的synchronized，如果使用恰当的话，它会比synchronized的使用成本更低，因为它不会引起线程上下文的切换和调度。如果一个字段被声明成volatile，它将具有以下两个特性： 可见性：对一个volatile变量的读，总是能看到任意线程对这个volatile变量最后的写入。 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 volatile的实现原理如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 简单来说就是Lock前缀指令会引起处理器缓存回写到内存，而一个处理器的缓存回写到内存会导致其它处理器的缓存无效。 volatile的内存语义 volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。 volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存设置为无效。线程接下来将从主内存中读取共享变量。 为了实现volatile内存语义，JMM会分别限制编译器重排序和处理器重排序。 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序。以下是针对编译器制定的重排序规则： 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。 当第一个操作是volatile写，第二个操作是volatile读时，都不能重排序。 对于处理器，JMM的处理器重排序规则会要求编译器在生成字节码时，在指令序列中插入内存屏障来禁止特定类型的处理器重排序。以下是基于保守策略的JVM内存屏障插入策略： 在每个volatile写操作的前面插入一个StoreStore屏障。 在每个volatile写操作的后面插入一个StoreLoad屏障。 在每个volatile读操作的后面插入一个LoadLoad屏障。 在每个volatile读操作的后面插入一个LoadStore屏障。 此策略可以保证在任意处理器平台，任意程序中都能得到正确的volatile内存语义。 参考资料 聊聊并发（一）深入分析Volatile的实现原理]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[支付宝的支付流程（当面付）]]></title>
    <url>%2F2019%2F02%2F07%2F%E6%94%AF%E4%BB%98%E5%AE%9D%E5%AF%B9%E6%8E%A5%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[由于在之前的项目中使用到了用支付宝完成订单支付这一功能，因此在此篇文章中对支付宝的整个支付流程以及背后的细节做一个简单的总结。具体接入指南以及开发文档参考蚂蚁金服 扫码支付接入指引 。 前期准备整体来说前期准备工作有下面两步： 创建应用并获取APPID 配置密钥 其中配置密钥需要交换双方的公钥，在交易过程中会对交易数据进行双方校验。我们知道公钥加密过的内容只有私钥才可以解密，同样，私钥加签过的内容也只有公钥才能验签。商户系统在发起支付时会使用自己的私钥进行加签，由于私钥只有自己持有（因此要妥善保管），支付宝就可以确认支付是由商户系统发起的而非他人；同样支付宝也会使用自己的私钥对支付结果进行加签，这样商户系统使用支付宝的公钥验签后也就能确定该结果是支付宝返回的了。 支付流程 用户选中购物车的商品，创建一个待支付订单，商户系统生成唯一订单号。 用户点击支付，商户系统调用支付宝的预下单接口发送订单信息，接口返回一个二维码串。 商户系统通过二维码串自行生成订单二维码并显示给用户。 用户扫描二维码并付款。 支付成功后，支付宝根据预先配置的回调接口将支付结果异步通知给商户系统。 商户系统收到支付结果，验签确保是支付宝发出后，告知用户支付完成并更新相关数据库表。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>支付宝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架知识点总结]]></title>
    <url>%2F2019%2F02%2F06%2FSpring%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Spring概述Spring框架是一个为Java应用程序的开发提供了综合、广泛的基础性支持的Java平台。Spring帮助开发者解决了开发中基础性的问题，使得开发人员可以专注于应用程序的开发。Spring框架本身亦是按照设计模式精心打造，这使得我们可以在开发环境中安心的集成Spring框架，不必担心Spring是如何在后台进行工作的。 Spring框架至今已集成了20多个模块。这些模块主要被分如下图所示的核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。 使用Spring的好处有以下几点： Spring是轻量的，基本的版本大约2MB。 Spring通过控制反转实现了松散耦合。 Spring支持面向切面编程，把应用业务逻辑和系统服务分开。 Spring包含并管理应用中对象的生命周期和配置。 Spring的Web框架是一个精心设计的Web MVC框架，是其它WEB框架的很好的替代品。 Spring提供了一个便捷的事务管理接口，适用于小型的本地事物处理（比如在单DB的环境下）和复杂的共同事物处理（比如利用JTA的复杂DB环境）。 IOCSpring框架的核心就是IoC容器，要掌握Spring框架，就必须要理解控制反转的思想以及依赖注入的实现方式。 DI与IOC控制反转（Inversion of Control）就是将原本在程序中手动创建对象的控制权，交由Spring框架管理，根据配置文件在运行时动态的去创建对象，并调用对象的方法。作用是实现了程序的解耦合。 依赖注入（Dependency Injection）就是将实例变量传入到一个对象中去，非自己主动初始化依赖，而是通过外部来传入依赖。比如以前可能会在构造函数中自己new一个对象赋给成员变量，依赖注入则是将已经初始化好的对象作为构造函数的一个参数传入。Spring的依赖注入有3种方式： setter方法注入。 构造函数注入。 注解方式注入。 控制反转与依赖注入有着本质的不同： 控制反转是一种思想。 依赖注入是一种实现方式。 IoC容器使用依赖注入作为实现控制反转的方式，但是控制反转还有其他的实现方式，例如说ServiceLocator，所以不能将控制反转和依赖注入等同。 BeanFactory和ApplicationContextBeanFactory是Spring框架最核心、最底层的接口，是Spring IoC容器的具体实现。BeanFactory负责读取bean配置文件实例化Bean并建立Bean之间的依赖关系，提供Bean实例缓存、生命周期管理等服务。 ApplicationContext建立在BeanFactory基础之上，称为应用上下文，提供了更多面向应用的功能。例如提供了支持国际化的文本消息、统一的资源文件读取方式和框架事件体系等，更易于创建实际应用。以下是三种较常见的ApplicationContext实现方式： FileSystemXmlApplicationContext：由文件系统中的XML配置文件中读取上下文。 ClassPathXmlApplicationContext：由类路径的XML配置文件中读取上下文。 WebXmlApplicationContext：由Web应用的XML文件读取上下文。 除了以上的区别外，BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时（调用getBean()），才对该Bean进行加载实例化，这样我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时一次性创建了所有的Bean，这样在容器启动时我们就可以发现Spring中存在的配置错误。 Spring BeansSpring beans是那些形成Spring应用的主干java对象。它们被Spring IOC容器初始化，装配和管理。这些beans通过容器中配置的元数据创建，比如以XML文件中&lt;bean/&gt;的形式定义。装配Bean总共有三种方式： XML配置文件。 基于java的配置。 基于注解的配置。 Bean的作用域当定义一个&lt;bean&gt;时，我们能通过定义中的scope属性来给这个bean声明一个作用域。Spring框架支持以下五种bean的作用域： singleton : bean在每个Spring Ioc 容器中只有一个实例。 prototype：一个bean的定义可以有多个实例。 request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。 session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。 其中，单例bean不是线程安全的，Spring框架并没有对单例bean进行任何多线程的封装处理，关于单例bean的线程安全和并发问题需要开发者自行去搞定。 Bean的生命周期在一个bean实例被初始化时，需要执行一系列的初始化操作以达到可用的状态。同样的，当一个bean不再被调用时需要进行相关的析构操作，并从bean容器中移除。 Spring容器从XML文件中读取bean的定义并实例化bean。 Spring根据bean的定义填充所有的属性。 调用BeanNameAware的setBeanName方法。 调用BeanFactoryAware的setBeanFactory方法。 调用BeanPostProcessor的postProcesserBeforeInitialization方法。 调用InitializingBean的afterPropertiesSet方法。 调用&lt;bean&gt;的init-method属性指定的初始化方法。 调用BeanPostProcessor的postProcesserAfterInitialization方法。 容器初始化成功，程序执行，业务逻辑调用后，下面销毁容器。 调用DisposableBean的destroy方法。 调用&lt;bean&gt;的destroy-method属性指定的销毁方法。 &lt;bean&gt;有两个重要的属性init-method和destroy-method用来定制初始化和注销方法，它们也有相应的注解@PostConstruct和@PreDestroy。 Inner Bean当一个bean仅被用作另一个bean的属性时，它能被声明为一个内部bean，内部bean通常是匿名的，它们的作用域一般是prototype。 Bean的自动装配Spring引入自动装配机制就是为了解决&lt;bean&gt;标签下&lt;property&gt;标签过多导致可维护性差的问题，Spring容器能够自动装配相互合作的bean，这意味着容器不需要&lt;constructor-arg&gt;和&lt;property&gt;配置，能通过BeanFactory自动处理bean之间的依赖关系。在Spring框架中共有以下5种自动装配： no：这是Spring框架的默认设置，在该设置下自动装配是关闭的，开发者需要自行在bean定义中用标签明确的设置依赖关系。 byName：该选项可以根据bean名称设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的名称自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到的话就报错。 byType：该选项可以根据bean类型设置依赖关系。当向一个bean中自动装配一个属性时，容器将根据bean的类型自动在在配置文件中查询一个匹配的bean。如果找到的话，就装配这个属性，如果没找到或找到多个相同类型的话就报错。 constructor：构造器的自动装配和byType模式类似，但是仅仅适用于与有构造器相同参数的bean，如果在容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。 autodetect：该模式自动探测使用构造器自动装配或者byType自动装配。首先会尝试找合适的带参数的构造器，如果找到的话就是用构造器自动装配，如果在bean内部没有找到相应的构造器或者是无参构造器，容器就会自动选择byTpe的自动装配方式。 AOP面向切面编程（AOP）就是在运行时，动态地将代码切入到类的指定方法、指定位置上的一种编程思想。 通知（Advice）就是想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下。Spring可以应用五种类型的通知： before：前置通知，在一个方法执行前被调用。 after：在方法执行之后调用的通知，无论方法执行是否成功。 after-returning：仅当方法成功完成后执行的通知。 after-throwing：在方法抛出异常退出时执行的通知。 around：在方法执行之前和之后调用的通知。 连接点（JoinPoint）就是Spring允许是通知（Advice）的地方，基本每个方法的前、后（两者都有也行），或抛出异常时都可以是连接点，Spring只支持方法连接点。 切入点（Pointcut）上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有十几个连接点了对吧，但是你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切入点来筛选连接点，选中那几个你想要的方法。 切面（Aspect）切面是通知和切入点的结合。通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。 织入（weaving）把切面应用到目标对象来创建新的代理对象的过程。 引入（introduction）允许我们在已存在的类中增加新的方法和属性。 代理（proxy）通知目标对象后创建的对象。从客户端的角度看，代理对象和目标对象是一样的。 Spring MVCSpring MVC是一个基于MVC架构的用来简化web应用程序开发的应用开发框架，它是Spring的一个模块。在web模型中，MVC是一种很流行的架构，通过把Model，View，Controller分离，把较为复杂的web应用分成逻辑清晰的几部分，简化开发，减少出错，方便组内开发人员之间的配合。 执行流程 用户发送请求至前端控制器DispatcherServlet； DispatcherServlet收到请求后，调用HandlerMapping处理器映射器，请求获取Handle； 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet； DispatcherServlet通过HandlerAdapter处理器适配器调用处理器； 执行处理器(Handler，也叫后端控制器)； Handler执行完成返回ModelAndView； HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet； DispatcherServlet将ModelAndView传给ViewResolver视图解析器进行解析； ViewResolver解析后返回具体View； DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中） DispatcherServlet响应用户。 SpringMVC如何和AJAX相互调用通过Jackson框架就可以把Java里面的对象直接转化成js可以识别的Json对象。具体步骤如下 ： 加入Jackson.jar 在配置文件中配置json的映射 在方法前面要加上@ResponseBody注解。 Spring注解 @Required：该注解表明bean的属性必须在配置的时候设置，若@Required注解的bean属性未被设置，容器将抛出BeanInitializationException。注意@Required只能设置在setter方法上。 @Autowired：该注解可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作，默认是按类型进行装配。在类成员变量上加上该注解时，就可以去掉相应的getter和setter方法了，Spring将直接采用Java反射机制对成员变量进行自动注入。 @Qualifier：当有多个相同类型的bean却只有一个需要自动装配时，将@Qualifier注解和@Autowired注解结合使用以消除这种混淆，指定需要装配的确切的bean。 @Resource：与@Autowired不同的是该注解默认按照名称装配，当找不到与名称匹配的bean时才会按照类型装配。注意如果没有指定name属性，并且按照默认的名称仍然找不到依赖的对象时候，会回退到按照类型装配，但一旦指定了name属性，就只能按照名称 装配了。 其它Spring框架中都用到了哪些设计模式？待更。。。]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电商项目优化实践]]></title>
    <url>%2F2019%2F02%2F05%2Fmmall%E7%94%B5%E5%95%86%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[本篇日志将记录之前做过的mmall项目的一些优化过程，主要包括JVM调优和数据库优化两个方面，通过不断动手实践并总结心得，希望能在此积累起许多经验，为以后能更得心应手的写出高效而又稳健的代码打好基础。 商品表的优化在实际应用中我们往往都会遇到根据名称来查询某个商品或者根据昵称查询某个用户，如果返回的行数较多则要使用分页，而之前项目一直都是使用的PageHelper这个框架来完成分页功能的，这么做自然简单方便，但是当数据量达到几十万甚至百万时就会遇到性能瓶颈，尽管能够使用一些索引进行优化，但一个查询仍然需要十几二十秒才能完成，显然还远不能达标。在阅读PageHelper源码后可以发现，之所以会发生这种情况是因为PageHelper主要是通过拼接LIMIT语句来实现分页功能的，我们知道LIMIT在偏移量很大的时候会扫描很多不必要的行，因此需要对查询进行改进才能更好的应用在数据量比较大的场景下。 我们先建立一张商品表，还未在上面建立任何索引（除主键外）： 12345678910111213141516DROP TABLE IF EXISTS `mmall_product`;CREATE TABLE `mmall_product` ( `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '商品id', `category_id` int(11) NOT NULL COMMENT '分类id,对应mmall_category表的主键', `name` varchar(100) NOT NULL COMMENT '商品名称', `subtitle` varchar(200) DEFAULT NULL COMMENT '商品副标题', `main_image` varchar(500) DEFAULT NULL COMMENT '产品主图,url相对地址', `sub_images` text COMMENT '图片地址,json格式,扩展用', `detail` text COMMENT '商品详情', `price` decimal(20,2) NOT NULL COMMENT '价格,单位-元保留两位小数', `stock` int(11) NOT NULL COMMENT '库存数量', `status` int(6) DEFAULT '1' COMMENT '商品状态.1-在售 2-下架 3-删除', `create_time` datetime DEFAULT NULL COMMENT '创建时间', `update_time` datetime DEFAULT NULL COMMENT '更新时间', PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=30 DEFAULT CHARSET=utf8; 接着使用存储过程往里面插入100万条数据，为了提高插入时的速度，需要先修改my.ini配置文件的以下两处： 12innodb_flush_log_at_trx_commit=0max_allowed_packet=100M 重启MySQL后再执行以下代码： 1234567891011121314151617181920drop procedure if exists product_insert;DELIMITER ;; CREATE PROCEDURE product_insert() BEGIN DECLARE y INT DEFAULT 1;WHILE y &lt; 100000DOinsert into mmall_product(category_id, name, subtitle, main_image, sub_images, detail, price, stock, status, create_time, update_time) values(y%30+100001, 'ab', substring(MD5(RAND()),15,20), '241997c4-9e62-4824-b7f0-7425c3c28917.jpeg', '241997c4-9e62-4824-b7f0-7425c3c28917.jpeg,b6c56eb0-1748-49a9-98dc-bcc4b9788a54.jpeg,92f17532-1527-4563-aa1d-ed01baa0f7b2.jpeg,3adbe4f7-e374-4533-aa79-cc4a98c529bf.jpeg', '&lt;p&gt;&lt;img alt="miaoshu.jpg" src="http://img.happymmall.com/9c5c74e6-6615-4aa0-b1fc-c17a1eff6027.jpg" width="790" height="444"&gt;&lt;br&gt;&lt;/p&gt;&lt;p&gt;&lt;img alt="miaoshu2.jpg" src="http://img.happymmall.com/31dc1a94-f354-48b8-a170-1a1a6de8751b.jpg" width="790" height="1441"&gt;&lt;img alt="miaoshu3.jpg" src="http://img.happymmall.com/7862594b-3063-4b52-b7d4-cea980c604e0.jpg" width="790" height="1442"&gt;&lt;img alt="miaoshu4.jpg" src="http://img.happymmall.com/9a650563-dc85-44d6-b174-d6960cfb1d6a.jpg" width="790" height="1441"&gt;&lt;br&gt;&lt;/p&gt;',RAND() * 10000,RAND() * 100,1, now(), now()); SET y=y+1; END WHILE ; commit; END;; CALL product_insert(); 这里的商品名、子标题等都使用的随机字符串，没有太多考究。此时就可以根据商品名name按价格price排序后进行查询了： 12345SELECT * FROM mmall_product WHERE name = 'ab' ORDER BY price LIMIT 100, 10;SELECT * FROM mmall_product WHERE name = 'ab' ORDER BY price LIMIT 1000, 10;SELECT * FROM mmall_product WHERE name = 'ab' ORDER BY price LIMIT 10000, 10; 执行时间如下： 可以看出，在不断增大LIMIT的偏移量后，查询时间着实吓人，通过EXPLAIN分析执行计划发现type那列显示ALL，说明要全表扫描一百多万行，并且还有Using filesort。我们先根据WHERE语句和ORDER BY语句建立如下组合索引： 1ALTER TABLE mmall_product ADD INDEX index_name_price (name, price); 执行SHOW INDEX FROM mmall_product;查看索引是否添加如下： 这时在初步优化后分析执行计划可以看到查询不再是全表扫描，而是使用到了上面的索引，效率有所提升，但此时增大偏移量后查询依然会变得十分缓慢，还需要进一步优化。这里就可以用到“延迟关联”的技巧，由于LIMIT每扫描一行时都要去主索引拿到许多不必要的数据再丢弃，那么可以让其先在二级索引覆盖扫描得到满足条件的id，然后再与原表关联得到最终结果，代码如下： 12SELECT * FROM mmall_product INNER JOIN (SELECT id FROM mmall_product WHERE name = 'ab' ORDER BY price LIMIT 100000, 10) AS mmall_product_id USING(id); 此时，就算偏移量为一百万时，查询也可以很轻松的在0.5S内完成，效果还是令人满意的。 PageHelper原理：PageHelper实现了MyBatis提供的Interceptor接口得到分页拦截器PageInterceptor，使用分页查询的时候，先调用PageHelper.startPage在当前线程上下文中设置一个ThreadLocal变量，分页拦截器拦截到SQL后会从ThreadLocal中拿到分页的信息，拼接分页语句并进行分页查询，最后再把ThreadLocal中的东西清除掉。 GC调优看了《深入理解Java虚拟机》也有一段时间了，书本的知识虽然都能理解，但实际的优化却从来没试过，这方面可以说是毫无经验。都说读万卷书不如行万里路，在网上看了一些GC优化的实际案例后，决定亲自动手在这个项目中尝试一下。 这次实践使用的垃圾收集器为ParNew+CMS（CMS失败时Serial Old替补）。首先通过以下参数设置垃圾收集器并打开GC日志：123456-XX:+UseConcMarkSweepGC-XX:+UseParNewGC-XX:+PrintGC-Xloggc:C:\Users\canjie\Desktop\gc.log-XX:+PrintHeapAtGC-XX:+PrintGCDateStamps 然后使用jmeter工具模拟多用户持续请求接口的场景，这里设置的一分钟的用户数5000人。jemeter的聚合报告显示如下，主要关注TP99这一指标： 请求结束后分析GC日志发现Minor GC执行的十分频繁，而Major GC仅仅五分钟内就执行了好几次，每次耗时约0.2s，频繁且耗时的STW对接口响应时间造成了很大的影响，对于追求低延时的服务来说肯定是不可取的。要想优化就必须得先知其原因，首先JVM的默认内存为64M，这肯定是不够的，其次频繁的Major GC主要是因为老年代的空间不够，那接下来就是通过调整总堆大小以及年轻代和老年代的比例来减少GC的频率和STW的时间。当然，这里的内存不是调的越大越好，调的过小会导致GC频率过高，而调的过大虽然GC频率降低了，但每次GC的耗时也会变长。 先通过GC日志得到活跃数据的大小（活跃数据的大小是指Full GC后堆中老年代占用空间的大小），然后通过以下策略设置基本参数： 空间 倍数 总堆 3-4 倍活跃数据的大小 新生代 1-1.5 活跃数据的大小 老年代 2-3 倍活跃数据的大小 永久代 1.2-1.5 倍Full GC后的永久代空间占用 我在这个例子中经过计算后设置的参数如下： 1234-Xmx640m-Xms640m-XX:NewSize=240m-XX:MaxNewSize=240m 此时再启动项目并用jmeter模拟真实环境进行测试，可以发现调大总堆大小并设置合适的年轻代与老年代的比例后，Minor GC每分钟的频率已经降到了70-80次，而Major GC十分钟才会出现一次，每次的耗时在100ms以下，TP95下降了约10ms，TP99下降了约100ms。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java阻塞队列实现生产者-消费者模型]]></title>
    <url>%2F2019%2F02%2F03%2FJava%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[简介阻塞队列（BlockingQueue）是一个支持阻塞的插入和移除的队列。阻塞插入即当队列满时，队列会阻塞插入元素的线程，直到队列不满；阻塞移除即当队列为空时，获取元素的线程会等待队列变为非空。 阻塞队列提供了四种处理方法： 方法\处理方式 抛出异常 返回特殊值 一直阻塞 超时退出 插入方法 add(e) offer(e) put(e) offer(e,time,unit) 移除方法 remove() poll() take() poll(time,unit) 检查方法 element() peek() 不可用 不可用 分类 ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。 LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。 PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。 DelayQueue：一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现，队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素。可以用于设计缓存系统和定时任务调度。 SynchronousQueue：一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素。 LinkedBlockingDeque：LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列。 实现JDK是使用通知模式（await()/signal()）实现的阻塞队列：当生产者往满的队列里添加元素时会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。下面是ArrayBlockingQueue的部分源码： 12345678910111213141516171819202122232425262728293031323334353637383940private final Condition notFull;private final Condition notEmpty;public ArrayBlockingQueue(int capacity, boolean fair) &#123; //省略其他代码 notEmpty = lock.newCondition(); notFull = lock.newCondition(); &#125;public void put(E e) throws InterruptedException &#123; checkNotNull(e); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == items.length) notFull.await(); insert(e); &#125; finally &#123; lock.unlock(); &#125;&#125;public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; while (count == 0) notEmpty.await(); return extract(); &#125; finally &#123; lock.unlock(); &#125;&#125;private void insert(E x) &#123; items[putIndex] = x; putIndex = inc(putIndex); ++count; notEmpty.signal();&#125; 生产者-消费者模式下面通过阻塞队列来实现一个经典的生产者-消费者模式，由于已经将底层封装的很好了，所以代码十分简洁： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class ProducerConsumer &#123; private static BlockingQueue&lt;Task&gt; queue = new ArrayBlockingQueue&lt;&gt;(5); private static AtomicInteger increTaskNo = new AtomicInteger(0); private static class Producer implements Runnable&#123; @Override public void run() &#123; Task task = new Task(increTaskNo.getAndIncrement()); try &#123; queue.put(task); System.out.println("produce: " + task.no); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class Consumer implements Runnable&#123; @Override public void run()&#123; try &#123; Task task = queue.take(); System.out.println("consume: " + task.no); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private static class Task&#123; public int no; public Task(int no) &#123; this.no = no; &#125; &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Producer()).start(); &#125; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new Consumer()).start(); &#125; &#125;&#125; 这里要注意，put()与take()方法与输出语句不是原子的，这会导致日志的输出顺序与实际任务的入队/出队顺序不一定匹配。 参考资料 聊聊并发（七）——Java中的阻塞队列]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fork/join框架分析与实战]]></title>
    <url>%2F2019%2F02%2F02%2FFork-join%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90%E4%B8%8E%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[简介Fork/Join框架是Java7提供了的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。 工作窃取算法工作窃取算法（work-stealing）是指当一个队列所对应的线程先执行完队列中的所有任务后，从其他线程的队列里窃取一个任务来执行。为了减少竞争，通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。 Fork/join的使用 ForkJoinTask：我们要使用Fork/Join框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join()操作的机制，通常情况下我们不需要直接继承ForkJoinTask类，而只需要继承它的子类，Fork/Join框架提供了以下两个子类： RecursiveAction：用于没有返回结果的任务。 RecursiveTask ：用于有返回结果的任务。 ForkJoinPool ：ForkJoinTask需要通过ForkJoinPool来执行，任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务。 接下来我们看一个问题：如何充分利用多核 CPU 计算很大 List 中所有整数的和？ 这里就可以用到Fork/join框架将求和任务分成许多子任务来完成，再将子任务的计算结果相加即可，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class ForkJoinLargeListSum &#123; public static void main(String[] args) &#123; int[] array = new int[100000000]; // 初始化 for(int i = 0; i &lt; array.length; i++)&#123; array[i] = i + 1; &#125; ForkJoinPool forkJoinPool = new ForkJoinPool(); long begintime = System.currentTimeMillis(); CountSumTask task = new CountSumTask(100000, 0, array.length-1, array); Future&lt;Long&gt; future = forkJoinPool.submit(task); try &#123; System.out.println("计算结果为：" + future.get()); long endtime=System.currentTimeMillis(); System.out.println("耗时：" + (endtime - begintime) + "ms"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; static class CountSumTask extends RecursiveTask&lt;Long&gt; &#123; private int threshold; private int hi, lo; private int[] array; public CountSumTask(int threshold, int lo, int hi, int[] array) &#123; this.threshold = threshold; this.hi = hi; this.lo = lo; this.array = array; &#125; @Override protected Long compute() &#123; long sum = 0L; //如果任务足够小就计算任务 boolean canCompute = (hi - lo) &lt;= threshold; if(canCompute)&#123; for(int i = lo; i &lt;= hi; i++)&#123; sum += array[i]; &#125; &#125; else&#123; //如果任务大于阈值，就分裂成两个子任务计算 int middle = lo + (hi - lo) / 2; CountSumTask leftTask = new CountSumTask(threshold, lo, middle, array); CountSumTask rightTask = new CountSumTask(threshold, middle+1, hi, array); //执行子任务 leftTask.fork(); rightTask.fork(); //等待子任务执行完，并得到结果 long leftResult = leftTask.join(); long rightResult = rightTask.join(); //合并子任务 sum = leftResult + rightResult; &#125; return sum; &#125; &#125;&#125; 此时输出： 12计算结果为：5000000050000000耗时：69ms 当我们调大阈值threshold时，意味着分割任务的次数减少，直接计算的次数增多，此时计算的效率也有可能降低。例如，当把阈值增大为100000000时，输出结果为： 12计算结果为：5000000050000000耗时：110ms 参考资料 聊聊并发（八）——Fork/Join框架介绍 重做一道Java面试题（Fork/Join）]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>Fork/join</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap源码分析]]></title>
    <url>%2F2019%2F02%2F01%2FConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[为什么要使用ConcurrentHashMap HashMap线程不安全。在JDK1.8之前的版本中，HashMap的实现在并发执行put操作时会导致HashMap的Entry链表形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。在之后的版本中这个死循环的问题不再发生，但仍然无法保证并发环境下的线程安全。 HashTable使用synchronized来保证线程安全，因此当一个线程访问HashTable的同步方法时，其它线程也访问同步方法就会被阻塞，在线程竞争激烈时效率很低。 基于以上两点，我们在并发环境中应该选择线程安全且高效的ConcurrentHashMap。 版本演进 jdk1.7采用分段锁技术，整个哈希表被分成多个段，每个段中会对应一个Segment段锁，段与段之间可以并发访问，但是多线程想要操作同一个段是需要获取锁的。所有的put，get，remove等方法都是根据键的哈希值对应到相应的段中，然后尝试获取锁进行访问。 jdk1.8取消了基于Segment的分段锁思想，改用CAS + synchronized控制并发操作，在某些方面提升了性能。并且追随1.8版本的 HashMap 底层实现，使用数组+链表+红黑树进行数据存储。 JDK1.8分析属性12345678910111213transient volatile Node&lt;K,V&gt;[] table; //哈希表，第一次put时才进行初始化private transient volatile Node&lt;K,V&gt;[] nextTable; //扩容时新生成的数组，其大小为原数组的两倍。private transient volatile long baseCount; //哈希表中存储的所有的结点的个数总和/** * 用来控制table的初始化和扩容操作，默认为0。 * 当为-1时代表table正在初始化，-N代表N-1个线程正在进行扩容操作，其余情况： * 如果table未初始化，表示table需要初始化的大小。 * 如果table初始化完成，表示table的容量。 */private transient volatile int sizeCtl; ForwardingNode这是一个特殊的Node节点，用来占位表示扩容时该桶的所有节点已完成迁移，hash值为-1，key和value都为null，并且内部存储着扩容后的表nextTable的引用。 1234567final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; &#123; final Node&lt;K,V&gt;[] nextTable; ForwardingNode(Node&lt;K,V&gt;[] tab) &#123; super(MOVED, null, null, null); this.nextTable = tab; &#125;&#125; put() 在计算键所对应的哈希值后，如果哈希表还未初始化，那么初始化它。此时只允许一个线程对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出CPU等待下次系统调度。 初始化完后，获取table中对应索引的元素f，如果f为null，说明table中这个位置第一次插入元素，利用Unsafe.compareAndSwapObject方法插入Node节点。如果CAS成功，说明Node节点已经插入，随后addCount()方法会检查当前容量是否需要进行扩容。如果CAS失败，说明有其它线程提前插入了节点，自旋重新尝试在这个位置插入节点。 如果f的hash值等于MOVED也就是-1时，说明当前f是ForwardingNode节点，意味着有其它线程正在扩容，于是调用helpTransfer()方法让当前线程去协助扩容。 其余情况把新的Node节点按链表或红黑树的方式插入到合适的位置，这个过程采用同步内置锁实现并发。 transfer()ConcurrentHashMap的扩容是高度并发的，执行逻辑如下： 通过计算CPU核心数和Map数组的长度得到每个线程要帮助处理多少个桶，并且这里每个线程处理都是平均的。默认每个线程处理16个桶，因此，当长度是16的时候，扩容的时候只会有一个线程扩容。 初始化nextTable，将其在原有基础上扩容两倍。 进入一个while循环，每个线程会先领取自己的任务区间，然后开始--i来遍历自己的任务区间，对每个桶进行处理。 如果遇到桶的头结点是空的，那么使用ForwardingNode标识该桶已经被处理完成了。如果遇到已经处理完成的桶，直接跳过进行下一个桶的处理。如果是正常的桶，对桶首节点加锁，正常的迁移即可，迁移结束后依然会将原表的该位置标识位已经处理。 finnish如果为true 则说明整张表的迁移操作已经全部完成了，我们只需要重置table的引用并将nextTable赋为空即可。否则，CAS式的将sizeCtl减一，表示当前线程已经完成了任务，退出扩容操作。 addCount()当我们成功的添加完成一个结点，最后是需要判断添加操作后是否会导致哈希表达到它的阈值，并针对不同情况决定是否需要进行扩容，还有CAS式更新哈希表实际存储的键值对数量，这些操作都封装在addCount这个方法中，当然putVal方法的最后必然会调用该方法进行处理。该方法主要做两个事情：一是更新 baseCount，二是判断是否需要扩容。 remove()ConcurrentHashMap的并发删除过程：首先遍历整张表的桶结点，如果表还未初始化或者无法根据参数的哈希值定位到桶结点，那么将返回null。如果定位到的桶结点类型是ForwardingNode结点，调用helpTransfer协助扩容。否则给桶加锁，删除一个节点，最后调用addCount()方法CAS式更新baseCount的值。 参考资料 为并发而生的 ConcurrentHashMap（Java 8） 深入浅出ConcurrentHashMap1.8 并发编程——ConcurrentHashMap#transfer() 扩容逐行分析]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>ConcurrentHashMap</tag>
        <tag>JDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式]]></title>
    <url>%2F2019%2F01%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[七大设计原则开闭原则定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。 用抽象构建框架，用实现扩展细节。 依赖倒置原则定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象。 做到针对接口编程，不要针对实现编程。 单一职责原则定义：不要存在多于一个导致类变更的原因。一个类/接口/方法只负责一项职责。 接口隔离原则定义：用多个专门的接口，而不使用单一的总接口，客户端不应该依赖它不需要的接口。 建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量少；接口中不要存在子类用不到却必须实现的方法。 迪米特法则定义：一个对象应该对其它对象保持最少的了解。又叫最少知道原则。 只与朋友说话，而不和陌生人说话。这里的朋友指的是出现在成员变量，方法输入、输出参数中的类，而出现在方法体内部的不属于朋友。 里氏替换原则定义：如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都替换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 子类中可以增加自己特有的方法 当子类的方法重载（注意不是覆盖）父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松 当子类的方法实现父类的方法时（重写/重载或实现抽象方法），方法的后置条件（即方法的输出/返回值）要比父类更严格或相等 合成复用原则定义：尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。 创建型简单工厂（Simple Factory）简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例，而不向客户暴露内部细节。 简单工厂不属于23种设计模式，但是之后的工厂方法模式、抽象工厂模式都是由其演化而来，并且在实际场景中也有应用，因此有必要了解。 适用场景：工厂类负责创建的对象比较少。 优缺点优点：只需要传入一个正确的参数，就可以获取所需要的对象而无须知道其创建细节。 缺点：工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，违背开闭原则。 应用场景创建五个类：Video、JavaVideo、PythonVideo、VideoFactory、Test： 抽象产品类Video：123public abstract class Video &#123; public abstract void produce();&#125; 具体产品类JavaVideo、PythonVideo：12345678910111213public class JavaVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制Java课程视频"); &#125;&#125;public class PythonVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制Python课程视频"); &#125;&#125; 客户端类Test，这里可以传入字符串参数或者Class类参数：1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; VideoFactory videoFactory = new VideoFactory(); Video video = videoFactory.getVideo("java"); if(video == null)&#123; return; &#125; video.produce(); VideoFactory videoFactory2 = new VideoFactory(); Video video2 = videoFactory2.getVideo(JavaVideo.class); if(video2 == null)&#123; return; &#125; video2.produce(); &#125;&#125; 在简单工厂中，客户端不应该直接创建出具体的产品类，而应交给工厂类去创建，下面看看工厂类VideoFactory，使用了if-else判断参数或者使用使用反射技术从而决定创建哪个具体子类：123456789101112131415161718192021222324public class VideoFactory &#123; public Video getVideo(Class c)&#123; Video video = null; try &#123; video = (Video) Class.forName(c.getName()).newInstance(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; return video; &#125; public Video getVideo(String type)&#123; if("java".equalsIgnoreCase(type))&#123; return new JavaVideo(); &#125; else if("python".equalsIgnoreCase(type))&#123; return new PythonVideo(); &#125; return null; &#125;&#125; 通过简单工厂，客户端类就不需要自己去实例化具体的产品类，做到了客户端类和产品类的解耦。 Calendar类的应用java.util下的Calendar类是一个抽象类，我们看看其中的getInstance方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public static Calendar getInstance(TimeZone zone, Locale aLocale)&#123; return createCalendar(zone, aLocale);&#125;private static Calendar createCalendar(TimeZone zone, Locale aLocale)&#123; CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale) .getCalendarProvider(); if (provider != null) &#123; try &#123; return provider.getInstance(zone, aLocale); &#125; catch (IllegalArgumentException iae) &#123; // fall back to the default instantiation &#125; &#125; Calendar cal = null; if (aLocale.hasExtensions()) &#123; String caltype = aLocale.getUnicodeLocaleType("ca"); if (caltype != null) &#123; switch (caltype) &#123; case "buddhist": cal = new BuddhistCalendar(zone, aLocale); break; case "japanese": cal = new JapaneseImperialCalendar(zone, aLocale); break; case "gregory": cal = new GregorianCalendar(zone, aLocale); break; &#125; &#125; &#125; if (cal == null) &#123; if (aLocale.getLanguage() == "th" &amp;&amp; aLocale.getCountry() == "TH") &#123; cal = new BuddhistCalendar(zone, aLocale); &#125; else if (aLocale.getVariant() == "JP" &amp;&amp; aLocale.getLanguage() == "ja" &amp;&amp; aLocale.getCountry() == "JP") &#123; cal = new JapaneseImperialCalendar(zone, aLocale); &#125; else &#123; cal = new GregorianCalendar(zone, aLocale); &#125; &#125; return cal;&#125; 在后半段中可以看出其根据参数通过switch和if-else创建了相应的具体子类对象，与之前的应用场景十分类似。在这里，Calendar既作为抽象产品类，也作为一个工厂类。 工厂方法（Factory Method）定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行。 适用场景： 创建对象需要大量重复的代码 客户端不依赖于产品类示例如何被创建、实现等细节 一个类通过其子类来指定创建哪个对象 优缺点优点：用户只需要关心所需产品对应的工厂，无需关心创建细节；加入新产品符合开闭原则，提高可扩展性。 缺点：类的个数容易过多，增加复杂度。 应用场景 抽象产品类Video： 1234public abstract class Video &#123; public abstract void produce();&#125; 具体产品类JavaVideo、PythonVideo： 12345678910111213public class JavaVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制Java课程视频"); &#125;&#125;public class PythonVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制Python课程视频"); &#125;&#125; 抽象工厂类VideoFactory： 123public abstract class VideoFactory &#123; public abstract Video getVideo();&#125; 具体工厂类JavaVideoFactory、PythonVideo： 12345678910111213public class JavaVideoFactory extends VideoFactory &#123; @Override public Video getVideo() &#123; return new JavaVideo(); &#125;&#125;public class PythonVideoFactory extends VideoFactory &#123; @Override public Video getVideo() &#123; return new PythonVideo(); &#125;&#125; 客户端类Test： 12345678public class Test &#123; public static void main(String[] args) &#123; VideoFactory videoFactory = new PythonVideoFactory(); VideoFactory videoFactory2 = new JavaVideoFactory(); Video video = videoFactory.getVideo(); video.produce(); &#125;&#125; 这时如果需要增加一个新的产品时，只需要添加一个新的具体产品类和具体工厂类，而无需像简单工厂一样修改工厂类里面的判断逻辑，即满足了开闭原则。 例如，如果要增加新产品FEVideo，我们需要先加入一个具体产品类： 123456public class FEVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制FE课程视频"); &#125;&#125; 再增加这个具体产品所对应的具体工厂类： 123456public class FEVideoFactory extends VideoFactory&#123; @Override public Video getVideo() &#123; return new FEVideo(); &#125;&#125; 之后在应用层就可以直接使用了： 12345678910public class Test &#123; public static void main(String[] args) &#123; VideoFactory videoFactory = new PythonVideoFactory(); VideoFactory videoFactory2 = new JavaVideoFactory(); VideoFactory videoFactory3 = new FEVideoFactory(); Video video = videoFactory.getVideo(); video.produce(); &#125;&#125; 此时的UML类图： Java集合接口Collection中的应用java.util.Collection接口下的iterator()方法：1234public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123; //... Iterator&lt;E&gt; iterator(); //... 查看该接口的其中一个实现类ArrayList： 1234567891011121314151617181920212223 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; private class Itr implements Iterator&lt;E&gt; &#123;//... public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; //... &#125; public void remove() &#123; //... &#125; @Override @SuppressWarnings("unchecked") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; //... &#125; //... &#125; 在这里，Collection相当于一个抽象工厂，而ArrayList相当于一个具体工厂，这个具体工厂实现了工厂方法iterator()实例化具体产品Itr，而这个具体产品实现了抽象产品Iterator。 logback中的应用 由UML可以看出ILoggerFactory作为抽象的工厂类，实现有三个具体的工厂类，以其中的NOPLoggerFactory为例，实现了抽象方法getLogger来实例化具体产品类： 12345678public class NOPLoggerFactory implements ILoggerFactory &#123; public NOPLoggerFactory() &#123; &#125; public Logger getLogger(String name) &#123; return NOPLogger.NOP_LOGGER; &#125;&#125; 抽象工厂（Abstract Factory）抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口。 抽象工厂是面向产品族的，而工厂方法是面向产品等级结构的，这是两者的主要区别。 适用场景： 客户端不依赖于产品类实例如何被创建、实现等细节 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象时需要大量重复的代码 提供一个产品类的库，所有的产品以同样的接口出现 优缺点优点：具体产品在应用层代码隔离，无须关心创建细节；将一个系列的产品族统一到一起创建。 缺点：规定了所有可能被创建的产品集合，产品族中扩展新的产品困难，需要修改抽象工厂的接口。 应用场景对于一个课程，既包含课程视频，也包含课程笔记： 抽象视频产品Video: 123public abstract class Video &#123; public abstract void produce();&#125; 具体视频产品JavaVideo、PythonVideo： 12345678910111213public class JavaVideo extends Video &#123; @Override public void produce() &#123; System.out.println("录制Java课程视频"); &#125;&#125;public class PythonVideo extends Video&#123; @Override public void produce() &#123; System.out.println("录制Python课程视频"); &#125;&#125; 同样，也有抽象笔记产品Article和具体笔记产品JavaArticle、PythonArticle： 1234567891011121314151617public abstract class Artical &#123; public abstract void produce();&#125;public class JavaArticle extends Artical &#123; @Override public void produce() &#123; System.out.println("编写Java课程手记"); &#125;&#125;public class PythonArticle extends Artical&#123; @Override public void produce() &#123; System.out.println("编写Python课程手记"); &#125;&#125; 课程的抽象工厂CourseFactory，生产视频和笔记两类产品： 1234public interface CourseFactory &#123; Video getVideo(); Artical getArtical();&#125; Java课程的具体工厂JavaCourseFactory： 123456789public class JavaCourseFactory implements CourseFactory &#123; public Video getVideo() &#123; return new JavaVideo(); &#125; public Artical getArtical() &#123; return new JavaArticle(); &#125;&#125; Python课程的具体工厂PythonCourseFactory： 123456789public class PythonCourseFactory implements CourseFactory &#123; public Video getVideo() &#123; return new PythonVideo(); &#125; public Artical getArtical() &#123; return new PythonArticle(); &#125;&#125; 客户端Test： 123456789public class Test &#123; public static void main(String[] args) &#123; CourseFactory courseFactory = new JavaCourseFactory(); Video video = courseFactory.getVideo(); Artical artical = courseFactory.getArtical(); video.produce(); artical.produce(); &#125;&#125; 可以看出，每一个具体工厂中都只会生产同一产品族下的产品。如果要扩展新的产品族，例如要添加一个算法课程，则添加一个AlgorithmCourseFactory工厂类即可，十分简单；但是如果要增加新的产品等级，比如在课程中除了视频和笔记外还要添加源码，那么就要修改抽象工厂中的实现，并且每一个具体工厂的实现也都要修改，抽象工厂模式在这种场景下就不适用了。 Connection中的应用java.sql.Connection接口定义了与指定数据库的连接： 123456public interface Connection extends Wrapper, AutoCloseable &#123; //... Statement createStatement() throws SQLException; PreparedStatement prepareStatement(String sql) throws SQLException; //...&#125; 其中，Statement、PreparedStatement等也都为接口。我们查看Connection的其中一个实现类ConnectionImpl： 1234567891011121314151617public class ConnectionImpl extends ConnectionPropertiesImpl implements Connection &#123; //... public Statement createStatement() throws SQLException &#123; return this.createStatement(1003, 1007); &#125; public Statement createStatement(int resultSetType, int resultSetConcurrency) throws SQLException &#123; this.checkClosed(); StatementImpl stmt = new StatementImpl(this, this.database); stmt.setResultSetType(resultSetType); stmt.setResultSetConcurrency(resultSetConcurrency); return stmt; &#125; //...&#125; 在createStatement方法中实例化了Statement接口的一个具体实现类，也就是com.mysql.jdbc.StatementImpl。 由此可见，在这个场景中Connection相当于一个抽象工厂，而ConnectionImpl是一个具体工厂，抽象产品为Statement，具体产品为StatementImpl。在这个例子中，mysql产品族的工厂只会生产mysql的Statement、PreparedStatement等产品。 建造者（Builder）将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 工厂方法模式注重的是整体对象的创建方法，而建造者模式注重的是部件构建的过程，旨在通过一步一步地精确构造创建出一个复杂的对象。 适用场景： 如果一个对象有非常复杂的内部结构（很多属性） 想把复杂对象的创建和使用分离 优缺点优点：封装性好，创建和使用分离；扩展性好、建造类之间独立、一定程度上解耦。 缺点：产生多余的Builder对象；产品内部发生变化，建造者都要修改，成本较大。 应用场景CourseBuilder作为抽象建造者类，CourseActualBuilder作为具体建造者类，Coach作为教练类根据传入的建造者类安排复杂对象的建造次序（非必需），而Course作为产品类。 抽象建造者CourseBuilder： 123456789public abstract class CourseBuilder &#123; public abstract void buildCourseName(String courseName); public abstract void buildCoursePPT(String coursePPT); public abstract void buildCourseVideo(String courseVideo); public abstract void buildCourseArticle(String courseArticle); public abstract void buildCourseQA(String courseQA); public abstract Course makeCourse();&#125; 具体建造者CourseActualBuilder： 12345678910111213141516171819202122232425262728293031323334public class CourseActualBuilder extends CourseBuilder &#123; private Course course = new Course(); @Override public void buildCourseName(String courseName) &#123; course.setCourseName(courseName); &#125; @Override public void buildCoursePPT(String coursePPT) &#123; course.setCoursePPT(coursePPT); &#125; @Override public void buildCourseVideo(String courseVideo) &#123; course.setCourseVideo(courseVideo); &#125; @Override public void buildCourseArticle(String courseArticle) &#123; course.setCourseArticle(courseArticle); &#125; @Override public void buildCourseQA(String courseQA) &#123; course.setCourseQA(courseQA); &#125; @Override public Course makeCourse() &#123; return course; &#125;&#125; 教练Coach： 123456789public abstract class CourseBuilder &#123; public abstract void buildCourseName(String courseName); public abstract void buildCoursePPT(String coursePPT); public abstract void buildCourseVideo(String courseVideo); public abstract void buildCourseArticle(String courseArticle); public abstract void buildCourseQA(String courseQA); public abstract Course makeCourse();&#125; 产品Course： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Course &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String courseQA; //question &amp; answer public String getCourseName() &#123; return courseName; &#125; public void setCourseName(String courseName) &#123; this.courseName = courseName; &#125; public String getCoursePPT() &#123; return coursePPT; &#125; public void setCoursePPT(String coursePPT) &#123; this.coursePPT = coursePPT; &#125; public String getCourseVideo() &#123; return courseVideo; &#125; public void setCourseVideo(String courseVideo) &#123; this.courseVideo = courseVideo; &#125; public String getCourseArticle() &#123; return courseArticle; &#125; public void setCourseArticle(String courseArticle) &#123; this.courseArticle = courseArticle; &#125; public String getCourseQA() &#123; return courseQA; &#125; public void setCourseQA(String courseQA) &#123; this.courseQA = courseQA; &#125; @Override public String toString() &#123; return "Course&#123;" + "courseName='" + courseName + '\'' + ", coursePPT='" + coursePPT + '\'' + ", courseVideo='" + courseVideo + '\'' + ", courseArticle='" + courseArticle + '\'' + ", courseQA='" + courseQA + '\'' + '&#125;'; &#125;&#125; 客户端Test: 12345678910public class Test &#123; public static void main(String[] args) &#123; CourseBuilder courseBuilder = new CourseActualBuilder(); Coach coach = new Coach(); coach.setCourseBuilder(courseBuilder); Course course = coach.makeCourse("Java设计模式", "Java设计模式PPT", "Java设计模式视频", "Java设计模式笔记", "Java设计模式问答"); System.out.println(course); &#125;&#125; 客户端创建了一个建造者和一个教练，并将这个建造者作为参数传给教练，之后直接通过教练进行产品的创建，而对客户端隐藏了具体的创建细节。在教练内部，实际上是通过建造者一步步构造出复杂的产品的。 我们对以上的场景做进一步演化，省略了教练类，并且将建造者放在产品类的内部。这种做法在实际场景中更为常见，利于维护与扩展，并且支持链式调用。 产品类Course以及作为建造者的内部类CourseBuilder： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Course &#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String courseQA; //question &amp; answer public Course(CourseBuilder courseBuilder) &#123; this.courseName = courseBuilder.courseName; this.coursePPT = courseBuilder.coursePPT; this.courseVideo = courseBuilder.courseVideo; this.courseArticle = courseBuilder.courseArticle; this.courseQA = courseBuilder.courseQA; &#125; @Override public String toString() &#123; return "Course&#123;" + "courseName='" + courseName + '\'' + ", coursePPT='" + coursePPT + '\'' + ", courseVideo='" + courseVideo + '\'' + ", courseArticle='" + courseArticle + '\'' + ", courseQA='" + courseQA + '\'' + '&#125;'; &#125; public static class CourseBuilder&#123; private String courseName; private String coursePPT; private String courseVideo; private String courseArticle; private String courseQA; //question &amp; answer public CourseBuilder buildCourseName(String courseName)&#123; this.courseName = courseName; return this; &#125; public CourseBuilder buildCoursePPT(String coursePPT) &#123; this.coursePPT = coursePPT; return this; &#125; public CourseBuilder buildCourseVideo(String courseVideo) &#123; this.courseVideo = courseVideo; return this; &#125; public CourseBuilder buildCourseArticle(String courseArticle) &#123; this.courseArticle = courseArticle; return this; &#125; public CourseBuilder buildCourseQA(String courseQA) &#123; this.courseQA = courseQA; return this; &#125; public Course build()&#123; return new Course(this); &#125; &#125;&#125; CourseBuilder中的每一个构建方法都返回对象自身，使得其支持链式调用，而build()方法将建造者作为参数传给产品类的构造函数，其根据建造者初始化产品各属性值，并将构建完毕的产品返回。 客户端Test： 1234567public class Test &#123; public static void main(String[] args) &#123; Course course = new Course.CourseBuilder().buildCourseName("Java设计模式").buildCoursePPT("Java设计模式PPT"). buildCourseVideo("Java设计模式视频").build(); System.out.println(course); &#125;&#125; 可以看出，演进之后的建造过程更为简洁明了。 StringBuilder中的应用Java.util.StringBuilder类下的append方法： 123456789101112131415161718192021222324252627public final class StringBuilder extends AbstractStringBuilder implements java.io.Serializable, CharSequence&#123; //... public StringBuilder append(String str) &#123; super.append(str); return this; &#125; public StringBuilder append(StringBuffer sb) &#123; super.append(sb); return this; &#125; public StringBuilder append(CharSequence s) &#123; super.append(s); return this; &#125; public StringBuilder append(CharSequence s, int start, int end) &#123; super.append(s, start, end); return this; &#125; //... 可以看出，这里使用了建造者模式，append方法总是返回建造者自身。StringBuilder既担任建造者，又担任产品，而建造方法的实现由父类AbstractStringBuilder完成。 StringBuffer的实现与上面类似，区别在于StringBuffer中的append方法加了synchronized关键字，因而是线程安全的。 mybatis中的应用查看org.apache.ibatis.session包下的SqlSessionFactoryBuilder： 1234567891011121314151617181920212223242526272829303132333435363738394041public class SqlSessionFactoryBuilder &#123; //... public SqlSessionFactory build(Reader reader) &#123; return this.build((Reader)reader, (String)null, (Properties)null); &#125; public SqlSessionFactory build(Reader reader, String environment) &#123; return this.build((Reader)reader, environment, (Properties)null); &#125; public SqlSessionFactory build(Reader reader, Properties properties) &#123; return this.build((Reader)reader, (String)null, properties); &#125; public SqlSessionFactory build(Reader reader, String environment, Properties properties) &#123; SqlSessionFactory var5; try &#123; XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties); var5 = this.build(parser.parse()); &#125; catch (Exception var14) &#123; throw ExceptionFactory.wrapException("Error building SqlSession.", var14); &#125; finally &#123; ErrorContext.instance().reset(); try &#123; reader.close(); &#125; catch (IOException var13) &#123; ; &#125; &#125; return var5; &#125; //... public SqlSessionFactory build(Configuration config) &#123; return new DefaultSqlSessionFactory(config); &#125; 这里面两个参数的build方法大多直接调用后面三个参数的build方法，返回值都为SqlSessionFactory，而这个方法中又有另一个建造者XMLConfigBuilder构建出一个Configuration对象，我们查看XMLConfigBuilder中的相关方法： 1234567891011121314151617181920212223242526272829public Configuration parse() &#123; if (this.parsed) &#123; throw new BuilderException("Each XMLConfigBuilder can only be used once."); &#125; else &#123; this.parsed = true; this.parseConfiguration(this.parser.evalNode("/configuration")); return this.configuration; &#125;&#125;private void parseConfiguration(XNode root) &#123; try &#123; Properties settings = this.settingsAsPropertiess(root.evalNode("settings")); this.propertiesElement(root.evalNode("properties")); this.loadCustomVfs(settings); this.typeAliasesElement(root.evalNode("typeAliases")); this.pluginElement(root.evalNode("plugins")); this.objectFactoryElement(root.evalNode("objectFactory")); this.objectWrapperFactoryElement(root.evalNode("objectWrapperFactory")); this.reflectorFactoryElement(root.evalNode("reflectorFactory")); this.settingsElement(settings); this.environmentsElement(root.evalNode("environments")); this.databaseIdProviderElement(root.evalNode("databaseIdProvider")); this.typeHandlerElement(root.evalNode("typeHandlers")); this.mapperElement(root.evalNode("mappers")); &#125; catch (Exception var3) &#123; throw new BuilderException("Error parsing SQL Mapper Configuration. Cause: " + var3, var3); &#125;&#125; 构建出一个Configuration对象的过程都在parseConfiguration方法中，而parse方法主要用来标记是否已经parse过并且返回构建好的Configuration对象。 单例模式（Singleton）保证一个类仅有一个实例，并提供一个全局访问点 适用场景：想确保任何情况下都绝对只有一个实例。 优缺点优点：在内存里只有一个实例，减少了内存开销；可以避免对资源的多重占用；设置全局访问点，严格控制访问。 缺点：可扩展性较差。 重点 私有构造器 线程安全 延迟加载 序列化和反序列化 反射 懒汉式实现线程不安全以下实现中延迟了lazySingleton的实例化，因此如果没有使用该类，那么就不会实例化lazySingleton，从而节约了资源。 但这种实现是线程不安全的，在多线程的环境下多个线程有可能同时判断if(lazySingleton == null)为true而进行实例化，导致多次实例化lazySingleton。 12345678910111213public class LazySingleton &#123; private static LazySingleton lazySingleton = null; private LazySingleton()&#123; &#125; public static LazySingleton getInstance()&#123; if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton; &#125;&#125; synchronized关键字要想其变为线程安全的，第一种方式是在getInstance()方法加上synchronized关键字，使这个方法变为同步方法： 123456public synchronized static LazySingleton getInstance()&#123; if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; return lazySingleton;&#125; 由于这个方法是静态方法，因此这个锁将锁住这个类，等效于以下代码： 12345678public static LazySingleton getInstance()&#123; synchronized (LazySingleton.class)&#123; if(lazySingleton == null)&#123; lazySingleton = new LazySingleton(); &#125; &#125; return lazySingleton;&#125; 通过这种方式，虽然解决了懒汉式在多线程环境下的同步问题，但由于同步锁消耗的资源较多，且锁的范围较大，对性能有一定影响，因此还需要进行演进。 双重校验锁当lazyDoubleCheckSingleton就算没有被实例化时，synchronized关键字也保证了不会出现同步问题，例如，如果两个线程同时判断第一个if(lazyDoubleCheckSingleton == null)为true，其中一个线程会进入到第二个if(lazyDoubleCheckSingleton == null)并开始实例化lazyDoubleCheckSingleton，而另一个线程则被阻塞直到前一个进程释放锁。一旦前一个线程实例化完并释放锁，被阻塞的线程将进入第二个if(lazyDoubleCheckSingleton == null)且判断为false。之后，由于lazyDoubleCheckSingleton已经被实例化过，再有线程调用此方法都会在第一个if(lazyDoubleCheckSingleton == null)就判断为false，不会再进行加锁操作。 1234567891011121314151617public class LazyDoubleCheckSingleton &#123; private static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton()&#123; &#125; public static LazyDoubleCheckSingleton getInstance()&#123; if(lazyDoubleCheckSingleton == null)&#123; synchronized (LazyDoubleCheckSingleton.class) &#123; if (lazyDoubleCheckSingleton == null) &#123; lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton(); &#125; &#125; &#125; return lazyDoubleCheckSingleton; &#125;&#125; 这种实现依然存在问题，对于lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();这一行代码其实是分为以下三步执行的： 分配内存给这个对象 初始化对象 设置lazyDoubleCheckSingleton指向刚分配的内存地址 但是JVM为了优化指令，提高程序运行效率，会进行指令重排序，指令顺序有可能由1-&gt;2-&gt;3变为1-&gt;3-&gt;2，这在单线程下不会出现问题，但是在多线程下会导致一个线程获得还没有被初始化的实例。例如，一个线程已经执行到了lazyDoubleCheckSingleton = new LazyDoubleCheckSingleton();这一行，且完成了1-&gt;3这两步，即lazyDoubleCheckSingleton已经不为null，但还没有进行初始化，此时另一个线程在第一个if(lazyDoubleCheckSingleton == null)判断为false后便将还未被初始化的lazyDoubleCheckSingleton返回，从而产生问题。 要解决指令重排序导致的问题，第一种方式是使用volatile关键字禁止JVM进行指令重排序： 12345678910public class LazyDoubleCheckSingleton &#123; private volatile static LazyDoubleCheckSingleton lazyDoubleCheckSingleton = null; private LazyDoubleCheckSingleton()&#123; &#125; public static LazyDoubleCheckSingleton getInstance()&#123; //... &#125;&#125; 静态内部类另一种解决指令重排序所导致的问题的方式是使用静态内部类让其它线程看不到这个线程的指令重排序： 12345678910111213public class StaticInnerClassSingleton &#123; private static class InnerClass&#123; private static StaticInnerClassSingleton staticInnerClassSingleton = new StaticInnerClassSingleton(); &#125; public static StaticInnerClassSingleton getInstance()&#123; return InnerClass.staticInnerClassSingleton; &#125; private StaticInnerClassSingleton()&#123; &#125;&#125; 当StaticInnerClassSingleton类加载时，静态内部类InnerClass还不会加载进内存，只有调用getInstance()方法使用到了InnerClass.staticInnerClassSingleton时才会加载。在多线程环境下，只有一个线程能获得Class对象的初始化锁，从而加载StaticInnerClassSingleton类，也就是这时候完成staticInnerClassSingleton的实例化，另一个线程此时只能在这个Class对象的初始化锁上等待。因此，由于等待的线程是看不见指令重排序的过程的，所以指令重排的顺序不会有任何影响。 饿汉式实现饿汉式即当类加载的时候就完成实例化，避免了同步问题，但同时也因为没有延迟实例化的特性而导致资源的浪费。 12345678910public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton = new HungrySingleton(); private HungrySingleton()&#123; &#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125;&#125; 以上代码与以下代码等效： 1234567891011121314public class HungrySingleton implements Serializable &#123; private final static HungrySingleton hungrySingleton; static&#123; hungrySingleton = new HungrySingleton(); &#125; private HungrySingleton()&#123; &#125; public static HungrySingleton getInstance()&#123; return hungrySingleton; &#125;&#125; 单例模式存在的问题序列化破坏单例模式通过对Singleton的序列化与反序列化得到的对象是一个新的对象，这就破坏了Singleton的单例性。 123456789101112131415public class Test &#123; public static void main(String[] args)&#123; HungrySingleton instance = HungrySingleton.getInstance(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("singleton_file")); oos.writeObject(instance); File file = new File("singleton_file"); ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file)); HungrySingleton newInstance = (EnumInstance) ois.readObject(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance == newInstance); &#125;&#125; 之所以会如此，是因为序列化会通过反射调用无参数的构造方法创建一个新的对象。要解决这个问题很简单：只要在Singleton类中定义readResolve即可： 123456789public class HungrySingleton implements Serializable &#123; //... private Object readResolve()&#123; return hungrySingleton; &#125; //...&#125; 反射攻击通过反射可以打开Singleton的构造器权限，由此实例化一个新的对象。 123456789101112131415public class Test &#123; public static void main(String[] args)&#123; Class objectClass = HungrySingleton.class; Class objectClass = LazySingleton.class; Constructor constructor = objectClass.getDeclaredConstructor(); constructor.setAccessible(true); HungrySingleton instance = HungrySingleton.getInstance(); HungrySingleton newInstance = (HungrySingleton) constructor.newInstance(); System.out.println(instance); System.out.println(newInstance); System.out.println(instance == newInstance); &#125;&#125; 对于饿汉式，由于是在类加载的时候就实例化对象了，因此要解决反射攻击问题，可以在构造器内部加一个判断用来防御，这样当反射调用构造器的时候hungrySingleton已经存在，不会再进行实例化并抛出异常： 1234567891011public class HungrySingleton implements Serializable &#123; //... private HungrySingleton()&#123; if(hungrySingleton != null)&#123; throw new RuntimeException("单例构造器禁止反射调用"); &#125; &#125; //...&#125; 而对于懒汉式，即使加上了上面的防御代码，依然可以通过调整顺序即先使用反射创建实例，再调用getInstance()创建实例来得到不止一个该类的对象。 枚举实现枚举类是实现单例的最佳方式，其在多次序列化再进行反序列化之后不会得到多个实例，也可以防御反射攻击。这部分的处理是由ObjectInputStream和Constructor这两个类实现的。 12345678910111213141516public enum EnumInstance &#123; INSTANCE; private Object data; public Object getData() &#123; return data; &#125; public void setData(Object data) &#123; this.data = data; &#125; public static EnumInstance getInstance()&#123; return INSTANCE; &#125;&#125; 容器实现如果系统中单例对象特别多，则可以考虑使用一个容器把所有单例对象统一管理，但是是线程不安全的。 123456789101112131415161718public class ContainerSingleton &#123; private static Map&lt;String, Object&gt; singletonMap = new HashMap&lt;String, Object&gt;(); private ContainerSingleton()&#123; &#125; public static void putInstance(String key, Object instance)&#123; if(StringUtils.isNotBlank(key) &amp;&amp; instance != null)&#123; if(!singletonMap.containsKey(key))&#123; singletonMap.put(key, instance); &#125; &#125; &#125; public static Object getInstance(String key)&#123; return singletonMap.get(key); &#125;&#125; Runtime中的应用查看java.lang包下的Runtime类： 123456789public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; //...&#125; 这里的currentRuntime在类加载的时候就实例化好了，属于饿汉式单例模式。 Spring中的应用查看org.springframework.beans.factory.config包下的AbstractFactoryBean： 1234567891011121314151617181920212223242526public abstract class AbstractFactoryBean&lt;T&gt; implements FactoryBean&lt;T&gt;, BeanClassLoaderAware, BeanFactoryAware, InitializingBean, DisposableBean &#123; //... public final T getObject() throws Exception &#123; if (this.isSingleton()) &#123; return this.initialized ? this.singletonInstance : this.getEarlySingletonInstance(); &#125; else &#123; return this.createInstance(); &#125; &#125; private T getEarlySingletonInstance() throws Exception &#123; Class&lt;?&gt;[] ifcs = this.getEarlySingletonInterfaces(); if (ifcs == null) &#123; throw new FactoryBeanNotInitializedException(this.getClass().getName() + " does not support circular references"); &#125; else &#123; if (this.earlySingletonInstance == null) &#123; this.earlySingletonInstance = Proxy.newProxyInstance(this.beanClassLoader, ifcs, new AbstractFactoryBean.EarlySingletonInvocationHandler()); &#125; return this.earlySingletonInstance; &#125; &#125; //...&#125; 在getObject()方法中，先判断这个对象是否为单例的，如果不是则直接创建；如果是单例的，那么判断是否被初始化过，如果被初始化了则直接返回，没有的话则调用getEarlySingletonInstance()方法获取早期的单例对象，如果早期的单例对象不存在，则通过代理来获取。 结构型外观（Facade）外观模式又叫门面模式，提供了一个统一的接口，用来访问子系统中的一群接口。 外观模式定义了一个高层接口，让子系统更容易使用。 适用场景： 子系统越来越复杂，增加外观模式提供简单调用接口 构建多层系统接口，利用外观对象作为每层的入口，简化层间调用 优缺点优点：简化了调用过程，无需了解子系统，防止带来风险；减少系统依赖、松散耦合；更好的划分访问层次；符合迪米特法则，即最少知道原则。 缺点：增加子系统、扩展子系统行为容易引入风险，不符合开闭原则。 应用场景我们考虑一个用积分兑换礼物的场景，积分兑换礼物需要校验积分是否符合资格、扣减积分以及对接物流系统三个模块，这三个模块也可以理解为三个子系统。 校验资格子系统： 123456public class QualifyService &#123; public boolean isAvailable(PointsGift pointsGift)&#123; System.out.println("校验" + pointsGift.getName() + " 积分资格通过，库存通过"); return true; &#125;&#125; 扣减积分子系统： 1234567public class PointsPaymentService &#123; public boolean pay(PointsGift pointsGift)&#123; //扣减积分 System.out.println("支付" + pointsGift.getName() + " 积分成功"); return true; &#125;&#125; 对接物流系统的子系统： 12345678public class ShippingService &#123; public String shipGift(PointsGift pointsGift)&#123; //物流系统的对接逻辑 System.out.println(pointsGift.getName() + "进入物流系统"); String shippingOrderNo = "666"; return shippingOrderNo; &#125;&#125; 积分礼物类： 123456789101112131415public class PointsGift &#123; private String name; public PointsGift(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125; 外观类： 12345678910111213141516171819202122232425262728293031323334353637383940public class GiftExchangeService &#123; private QualifyService qualifyService = new QualifyService(); private PointsPaymentService pointsPaymentService = new PointsPaymentService(); private ShippingService shippingService = new ShippingService(); public QualifyService getQualifyService() &#123; return qualifyService; &#125; public void setQualifyService(QualifyService qualifyService) &#123; this.qualifyService = qualifyService; &#125; public PointsPaymentService getPointsPaymentService() &#123; return pointsPaymentService; &#125; public void setPointsPaymentService(PointsPaymentService pointsPaymentService) &#123; this.pointsPaymentService = pointsPaymentService; &#125; public ShippingService getShippingService() &#123; return shippingService; &#125; public void setShippingService(ShippingService shippingService) &#123; this.shippingService = shippingService; &#125; public void giftExchange(PointsGift pointsGift)&#123; if(qualifyService.isAvailable(pointsGift))&#123; //资格校验通过 if(pointsPaymentService.pay(pointsGift))&#123; //如果支付积分成功 String shippingOrderNo = shippingService.shipGift(pointsGift); System.out.println("物流系统下单成功，订单号是："+shippingOrderNo); &#125; &#125; &#125;&#125; 客户端类： 1234567public class Test &#123; public static void main(String[] args) &#123; PointsGift pointsGift = new PointsGift("衣服"); GiftExchangeService giftExchangeService = new GiftExchangeService(); giftExchangeService.giftExchange(pointsGift); &#125;&#125; 输出： 1234校验衣服 积分资格通过，库存通过支付衣服 积分成功衣服进入物流系统物流系统下单成功，订单号是：666 客户端创建一个衣服作为积分商品，然后使用积分兑换系统来完成积分兑换，这个积分兑换系统作为一个外观类整合了各个子系统，而客户端无需知道具体的子系统。 Spring中的应用查看org.springframework.jdbc.support下的JdbcUtils： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public abstract class JdbcUtils &#123; public static void closeConnection(Connection con) &#123; if (con != null) &#123; try &#123; con.close(); &#125; catch (SQLException ex) &#123; logger.debug("Could not close JDBC Connection", ex); &#125; catch (Throwable ex) &#123; // We don't trust the JDBC driver: It might throw RuntimeException or Error. logger.debug("Unexpected exception on closing JDBC Connection", ex); &#125; &#125; &#125; public static Object getResultSetValue(ResultSet rs, int index, Class&lt;?&gt; requiredType) throws SQLException &#123; if (requiredType == null) &#123; return getResultSetValue(rs, index); &#125; Object value = null; boolean wasNullCheck = false; // Explicitly extract typed value, as far as possible. if (String.class.equals(requiredType)) &#123; value = rs.getString(index); &#125; else if (boolean.class.equals(requiredType) || Boolean.class.equals(requiredType)) &#123; value = rs.getBoolean(index); wasNullCheck = true; &#125; else if (byte.class.equals(requiredType) || Byte.class.equals(requiredType)) &#123; value = rs.getByte(index); wasNullCheck = true; &#125; else if (short.class.equals(requiredType) || Short.class.equals(requiredType)) &#123; value = rs.getShort(index); wasNullCheck = true; &#125; else if (int.class.equals(requiredType) || Integer.class.equals(requiredType)) &#123; value = rs.getInt(index); wasNullCheck = true; &#125; else if (long.class.equals(requiredType) || Long.class.equals(requiredType)) &#123; value = rs.getLong(index); wasNullCheck = true; &#125; else if (float.class.equals(requiredType) || Float.class.equals(requiredType)) &#123; value = rs.getFloat(index); wasNullCheck = true; &#125; else if (double.class.equals(requiredType) || Double.class.equals(requiredType) || Number.class.equals(requiredType)) &#123; value = rs.getDouble(index); wasNullCheck = true; &#125; else if (byte[].class.equals(requiredType)) &#123; value = rs.getBytes(index); &#125; else if (java.sql.Date.class.equals(requiredType)) &#123; value = rs.getDate(index); &#125; else if (java.sql.Time.class.equals(requiredType)) &#123; value = rs.getTime(index); &#125; else if (java.sql.Timestamp.class.equals(requiredType) || java.util.Date.class.equals(requiredType)) &#123; value = rs.getTimestamp(index); &#125; else if (BigDecimal.class.equals(requiredType)) &#123; value = rs.getBigDecimal(index); &#125; else if (Blob.class.equals(requiredType)) &#123; value = rs.getBlob(index); &#125; else if (Clob.class.equals(requiredType)) &#123; value = rs.getClob(index); &#125; else &#123; // Some unknown type desired -&gt; rely on getObject. value = getResultSetValue(rs, index); &#125; // Perform was-null check if demanded (for results that the // JDBC driver returns as primitives). if (wasNullCheck &amp;&amp; value != null &amp;&amp; rs.wasNull()) &#123; value = null; &#125; return value; &#125; 可以看出，该工具类主要是对jdbc的封装，向外提供一个隐藏了具体实现细节的接口，对访问屏蔽复杂的子系统调用。 SLF4J中的应用SLF4J是简单的日志外观模式框架，抽象了各种日志框架例如Logback、Log4j、Commons-logging和JDK自带的logging实现接口。它使得用户可以在部署时使用自己想要的日志框架。 SLF4J没有替代任何日志框架，它仅仅是标准日志框架的外观模式。如果在类路径下除了SLF4J再没有任何日志框架，那么默认状态是在控制台输出日志。 适配器（Adapter）将一个类的接口转换成客户期望的另一个接口。 适配器模式使原本接口不兼容的类可以一起工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是组合关系，使用的是委托机制；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。 适用场景： 已经存在的类，它的方法和需求不匹配时（方法结果相同或相似）。 不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造功能类似而接口不相同情况下的解决方案。 优缺点优点：能提高类的透明性和复用；目标类和适配器类解耦，提高程序扩展性；符合开闭原则。 缺点：增加了系统的复杂性；增加系统代码可读的难度。 应用场景类适配器模式被适配者类： 12345public class Adaptee &#123; public void adapteeRequest()&#123; System.out.println("被适配者的方法"); &#125;&#125; 目标接口： 123public interface Target &#123; void request();&#125; 目标接口实现（非必需的，只是待会用来做对比）： 12345public class ConcreteTarget implements Target &#123; public void request() &#123; System.out.println("concreteTarget目标方法"); &#125;&#125; 适配器类，既实现了目标接口又继承了被适配者类，因此直接在实现的request()中调用父类的adapteeRequest()方法即可： 12345public class Adapter extends Adaptee implements Target&#123; public void request() &#123; super.adapteeRequest(); &#125;&#125; 客户端类： 123456789public class Test &#123; public static void main(String[] args) &#123; Target target = new ConcreteTarget(); target.request(); Target adapterTarget = new Adapter(); adapterTarget.request(); &#125;&#125; 通过适配器，我们就将被适配者类Adaptee的adapteeRequest()方法适配成了目标接口Target的request()方法。 对象适配器模式在对象适配器模式中，被适配者类Adaptee、目标接口与实现类Target ConcreteTarget、客户端类Test 都不需要改变，唯一需要改变的就是适配器类Adapter。 1234567public class Adapter implements Target &#123; private Adaptee adaptee = new Adaptee(); public void request() &#123; adaptee.adapteeRequest(); &#125;&#125; 可以看出，对象适配器与类适配器不同之处在于类适配器是通过继承来完成适配，而对象适配器则组合被适配者并将请求委托给被适配者来完成。 变压器的例子这里考虑一个生活中常见的变压器的场景，我们把220V交流电压适配成5V直流电压，其中220V交流电压就是被适配者类，而5V直流电压则是目标接口，我们需要一个适配器来完成这个变压操作。 被适配者类（220V交流电压）： 1234567public class AC220 &#123; public int outputAC220V()&#123; int output = 220; System.out.println("输出交流电" + output + "V"); return output; &#125;&#125; 目标接口（5V直流电压）： 123public interface DC5 &#123; int outputDC5V();&#125; 适配器类，这里使用的是对象适配器模式： 1234567891011121314public class PowerAdapter implements DC5 &#123; private AC220 ac220 = new AC220(); public int outputDC5V() &#123; //将220V交流电压作为输入电压 int adapterInput = ac220.outputAC220V(); //模拟变压器，得到5V直流电压 int adapterOutput = adapterInput / 44; System.out.println("使用PowerAdapter输入AC：" + adapterInput +"V " + "输出DC：" + adapterOutput + "V"); return adapterOutput; &#125;&#125; 客户端类： 123456public class Test &#123; public static void main(String[] args) &#123; DC5 dc5 = new PowerAdapter(); dc5.outputDC5V(); &#125;&#125; 通过适配器将220V交流电压转换成了5V直流电压，此时输出：12输出交流电220V使用PowerAdapter输入AC：220V 输出DC：5V Spring AOP中的应用在Spring的AOP中，使用的Advice (通知)来增强被代理类的功能。Advice的类型有：MethodBeforeAdvice、AfterReturningAdvice、ThrowsAdvice，而每个类型的Advice都有对应的拦截器MethodBeforeAdviceInterceptor、AfterReturningAdviceInterceptor、ThrowsAdviceInterceptor。 Spring需要将每个Advice都封装成对应的拦截器类型，返回给容器，所以需要使用适配器模式对 Advice进行转换。 三个适配者类： 12345678910public interface MethodBeforeAdvice extends BeforeAdvice &#123; void before(Method var1, Object[] var2, @Nullable Object var3) throws Throwable;&#125;public interface AfterReturningAdvice extends AfterAdvice &#123; void afterReturning(@Nullable Object var1, Method var2, Object[] var3, @Nullable Object var4) throws Throwable;&#125;public interface ThrowsAdvice extends AfterAdvice &#123;&#125; 适配器接口，其中supportsAdvice方法判断Advice类型是否匹配，另一个是创建对应的拦截器的工厂方法： 12345public interface AdvisorAdapter &#123; boolean supportsAdvice(Advice var1); MethodInterceptor getInterceptor(Advisor var1);&#125; 三个适配器类： 1234567891011121314151617181920212223242526272829303132333435class MethodBeforeAdviceAdapter implements AdvisorAdapter, Serializable &#123; @Override public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof MethodBeforeAdvice); &#125; @Override public MethodInterceptor getInterceptor(Advisor advisor) &#123; MethodBeforeAdvice advice = (MethodBeforeAdvice) advisor.getAdvice(); return new MethodBeforeAdviceInterceptor(advice); &#125;&#125;class AfterReturningAdviceAdapter implements AdvisorAdapter, Serializable &#123; @Override public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof AfterReturningAdvice); &#125; @Override public MethodInterceptor getInterceptor(Advisor advisor) &#123; AfterReturningAdvice advice = (AfterReturningAdvice) advisor.getAdvice(); return new AfterReturningAdviceInterceptor(advice); &#125;&#125;class ThrowsAdviceAdapter implements AdvisorAdapter, Serializable &#123; @Override public boolean supportsAdvice(Advice advice) &#123; return (advice instanceof ThrowsAdvice); &#125; @Override public MethodInterceptor getInterceptor(Advisor advisor) &#123; return new ThrowsAdviceInterceptor(advisor.getAdvice()); &#125;&#125; 客户端类： 12345678910111213141516171819202122232425262728293031323334public class DefaultAdvisorAdapterRegistry implements AdvisorAdapterRegistry, Serializable &#123; private final List&lt;AdvisorAdapter&gt; adapters = new ArrayList(3); public DefaultAdvisorAdapterRegistry() &#123; // 这里注册了适配器 this.registerAdvisorAdapter(new MethodBeforeAdviceAdapter()); this.registerAdvisorAdapter(new AfterReturningAdviceAdapter()); this.registerAdvisorAdapter(new ThrowsAdviceAdapter()); &#125; public MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123; List&lt;MethodInterceptor&gt; interceptors = new ArrayList(3); Advice advice = advisor.getAdvice(); if (advice instanceof MethodInterceptor) &#123; interceptors.add((MethodInterceptor)advice); &#125; Iterator var4 = this.adapters.iterator(); while(var4.hasNext()) &#123; AdvisorAdapter adapter = (AdvisorAdapter)var4.next(); if (adapter.supportsAdvice(advice)) &#123; // 这里调用适配器方法 interceptors.add(adapter.getInterceptor(advisor)); // 这里调用适配器方法 &#125; &#125; if (interceptors.isEmpty()) &#123; throw new UnknownAdviceTypeException(advisor.getAdvice()); &#125; else &#123; return (MethodInterceptor[])interceptors.toArray(new MethodInterceptor[0]); &#125; &#125; // ...&#125; 上面的代码在while循环里逐个取出注册的适配器，调用supportsAdvice()方法来判断Advice对应的类型，然后调用 getInterceptor() 创建对应类型的拦截器。 这里应该属于对象适配器模式，不过这里的Advice对象是从外部传进来，而不是成员属性。 组合（Composite）将对象组合成树形结构来表示“整体-部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。 适用场景： 希望客户端可以忽略组合对象与单个对象的差异时。 处理一个树形结构时。 优缺点优点：客户端不必关心处理的是单个对象还是整个组合结构，简化了客户端代码；增加新的构件无须对现有类库进行任何修改，符合开闭原则。 缺点：限制类型时会较为复杂；使设计变得更加抽象。 应用场景一个在线学习网站下有许多目录以及学习视频，而目录下可能还会存在子目录，这里就可以使用组合模式。 抽象构件： 123456789101112131415161718192021public abstract class CatalogComponent &#123; public void add(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException("不支持添加操作"); &#125; public void remove(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException("不支持删除操作"); &#125; public String getName(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException("不支持获取名称操作"); &#125; public double getPrice(CatalogComponent catalogComponent)&#123; throw new UnsupportedOperationException("不支持获取价格操作"); &#125; public void print()&#123; throw new UnsupportedOperationException("不支持打印操作"); &#125;&#125; 叶子构件（课程视频）： 123456789101112131415161718192021222324public class Course extends CatalogComponent&#123; private String name; private double price; public Course(String name, double price) &#123; this.name = name; this.price = price; &#125; @Override public String getName(CatalogComponent catalogComponent) &#123; return this.name; &#125; @Override public double getPrice(CatalogComponent catalogComponent) &#123; return this.price; &#125; @Override public void print() &#123; System.out.println("Course Name: " + name + " Price: " + price); &#125;&#125; 容器构件（课程目录）： 12345678910111213141516171819202122232425262728293031323334353637public class CourseCatalog extends CatalogComponent &#123; private List&lt;CatalogComponent&gt; items = new ArrayList&lt;CatalogComponent&gt;(); private String name; private Integer level; public CourseCatalog(String name, Integer level) &#123; this.name = name; this.level = level; &#125; @Override public String getName(CatalogComponent catalogComponent) &#123; return this.name; &#125; @Override public void add(CatalogComponent catalogComponent) &#123; items.add(catalogComponent); &#125; @Override public void remove(CatalogComponent catalogComponent) &#123; items.remove(catalogComponent); &#125; @Override public void print() &#123; System.out.println(this.name); for(CatalogComponent catalogComponent : items)&#123; if(this.level != null)&#123; for(int i = 0; i &lt; this.level; i++) System.out.print(" "); &#125; catalogComponent.print(); &#125; &#125;&#125; 客户端类： 12345678910111213141516171819202122public class Test &#123; public static void main(String[] args) &#123; CatalogComponent linuxCourse = new Course("linux课程", 11); CatalogComponent windowsCourse = new Course("Windows课程", 11); CatalogComponent javaCourseCatalog = new CourseCatalog("Java课程目录", 2); CatalogComponent mallCourse1 = new Course("Java电商一期", 55); CatalogComponent mallCourse2 = new Course("Java电商二期", 66); CatalogComponent designPattern = new Course("Java设计模式", 77); javaCourseCatalog.add(mallCourse1); javaCourseCatalog.add(mallCourse2); javaCourseCatalog.add(designPattern); CatalogComponent mainCourseCatalog = new CourseCatalog("课程主目录", 1); mainCourseCatalog.add(linuxCourse); mainCourseCatalog.add(windowsCourse); mainCourseCatalog.add(javaCourseCatalog); mainCourseCatalog.print(); &#125;&#125; 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。 装饰者（Decorator）在不改变原有对象的基础之上，将功能附加到对象上。 提供了比继承更有弹性的替代方案（扩展原有对象功能）。 适用场景： 扩展一个类的功能或给一个类添加附加职责。 动态的给一个对象添加功能，这些功能可以再动态的撤销。 优缺点优点：继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能；通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果；符合开闭原则。 缺点：会出现更多的代码，更多的类，增加程序复杂性；动态装饰时、多层装饰时会更复杂。 应用场景我们考虑一个买煎饼的例子，人们可以自由地选择是否要在煎饼上加鸡蛋或者火腿，每次要加多少个，而总共价格是多少。 煎饼抽象类： 1234public abstract class ABattercake &#123; protected abstract String getDesc(); protected abstract int cost();&#125; 煎饼类： 1234567891011public class Battercake extends ABattercake &#123; @Override protected String getDesc() &#123; return "煎饼"; &#125; @Override protected int cost() &#123; return 8; &#125;&#125; 抽象装饰类（并不是真正的抽象类，因为这个场景中不需要抽象方法），这个类将抽象煎饼类作为成员属性，并且也继承了抽象煎饼类： 1234567891011121314151617public class AbstractDecorator extends ABattercake &#123; private ABattercake aBattercake; public AbstractDecorator(ABattercake aBattercake) &#123; this.aBattercake = aBattercake; &#125; @Override protected String getDesc() &#123; return this.aBattercake.getDesc(); &#125; @Override protected int cost() &#123; return this.aBattercake.cost(); &#125;&#125; 加鸡蛋的装饰类，继承了抽象装饰类： 123456789101112131415public class EggDecorator extends AbstractDecorator &#123; public EggDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected String getDesc() &#123; return super.getDesc() + " 加一个鸡蛋"; &#125; @Override protected int cost() &#123; return super.cost()+1; &#125;&#125; 加火腿的装饰类，继承了抽象装饰类： 123456789101112131415public class SausageDecorator extends AbstractDecorator &#123; public SausageDecorator(ABattercake aBattercake) &#123; super(aBattercake); &#125; @Override protected String getDesc() &#123; return super.getDesc() + " 加一根香肠"; &#125; @Override protected int cost() &#123; return super.cost()+2; &#125;&#125; 客户端类： 1234567891011public class Test &#123; public static void main(String[] args) &#123; ABattercake aBattercake; aBattercake = new Battercake(); aBattercake = new EggDecorator(aBattercake); aBattercake = new EggDecorator(aBattercake); aBattercake = new SausageDecorator(aBattercake); System.out.println(aBattercake.getDesc() + " 销售价格：" + aBattercake.cost()); &#125;&#125; 输出： 1煎饼 加一个鸡蛋 加一个鸡蛋 加一根香肠 销售价格：12 装饰类和具体组件类都继承了抽象组件类。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能，装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。 Java I/O中的应用在Java中应用程序通过输入流（InputStream）的Read方法从源地址处读取字节，然后通过输出流（OutputStream）的Write方法将流写入到目的地址。 流的来源主要有三种：本地的文件（File）、控制台、通过socket实现的网络通信。 下面查看其中InputStream的类图，而关于OutputStream、Reader、Writer等都与此类似： 由上图可以看出只要继承了FilterInputStream的类就是装饰者类，可以用于包装其他的流，装饰者类还可以对装饰者和类进行再包装。以下是对其中部分类的简要介绍： 流名称 简介 ByteArrayInputStream 字节数组输入流在内存中创建一个字节数组缓冲区，从输入流读取的数据保存在该字节数组缓冲区中 PipedInputStream 访问管道，主要在线程中使用，一个线程通过管道输出流发送数据，而另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯 FileInputStream 访问文件，把一个文件作为 InputStream ，实现对文件的读取操作 PushBackInputStream 推回输入流，可以把读取进来的某些数据重新回退到输入流的缓冲区之中 BufferedInputStream 带缓冲的输入流一次读很多字节先放到内存中，等缓冲区满的时候一次性写入磁盘，这种方式可以减少磁盘操作次数，因此效率很高 DataInputStream 允许应用程序以与机器无关方式从底层输入流中读取基本Java数据类型 Spring中的应用查看org.springframework.cache.transaction下的TransactionAwareCacheDecorator： 该类实现了Cache接口，同时将Cache组合到类中成为了成员属性，所以可以大胆猜测TransactionAwareCacheDecorator是一个装饰类，不过这里并没有抽象装饰类，且TransactionAwareCacheDecorator没有子类，这里的装饰类关系并没有Java I/O中的装饰关系那么复杂。 实际上，Spring cache是对缓存使用的抽象，通过它我们可以在不侵入业务代码的基础上让现有代码即刻支持缓存。通过Spring的TransactionSynchronizationManager将其缓存操作与Spring管理的事务同步，仅在成功事务的提交之后执行实际的缓存操作。 MyBatis中的应用查看包org.apache.ibatis.cache： 代理（Proxy）代理模式为其它对象提供一种代理，以控制对这个对象的访问，代理对象在客户端和目标对象之间起到中介的作用。 我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话， 可以分为两种：静态代理、动态代理。静态代理是由程序员创建或特定工具自动生成源代码，再对其编译，在运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。 适用场景： 保护目标对象 增强目标对象 优缺点优点：能将代理对象与真实被调用的目标对象分离；保护目标对象；增强目标对象。 缺点：会造成系统设计中类的数目增加；在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢；增加系统的复杂度。 应用场景静态代理使用静态代理可以做到在符合开闭原则的情况下对目标对象进行功能扩展，但我们得为每一个服务都创建代理类，工作量太大，不易管理。 服务接口： 123public interface BuyHouse &#123; void buyHosue();&#125; 实现服务接口： 1234567public class BuyHouseImpl implements BuyHouse &#123; @Override public void buyHosue() &#123; System.out.println("我要买房"); &#125;&#125; 代理类： 123456789101112131415161718192021222324public class BuyHouseProxy implements BuyHouse &#123; private BuyHouse buyHouse; public BuyHouseProxy(BuyHouse buyHouse) &#123; this.buyHouse = buyHouse; &#125; @Override public void buyHosue() &#123; beforeMethod(); buyHouse.buyHosue(); afterMethod(); &#125; private void beforeMethod()&#123; System.out.println("买房前准备"); &#125; private void afterMethod()&#123; System.out.println("买房后装修"); &#125;&#125; 客户端类： 12345678public class Test&#123; public static void main(String[] args) &#123; BuyHouse buyHouse = new BuyHouseImpl(); buyHouse.buyHosue(); BuyHouseProxy buyHouseProxy = new BuyHouseProxy(buyHouse); buyHouseProxy.buyHosue(); &#125;&#125; 动态代理在动态代理中我们不再需要手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。 动态处理器，实现了InvocationHandler接口： 123456789101112131415161718192021222324public class DynamicProxyHandler implements InvocationHandler &#123; private Object object; public DynamicProxyHandler(final Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; beforeMethod(); Object result = method.invoke(object, args); afterMethod(); return result; &#125; private void beforeMethod()&#123; System.out.println("买房前准备"); &#125; private void afterMethod()&#123; System.out.println("买房后装修"); &#125;&#125; 客户端类： 1234567public class Test &#123; public static void main(String[] args) &#123; BuyHouse buyHouse = new BuyHouseImpl(); BuyHouse proxyBuyHouse = (BuyHouse) Proxy.newProxyInstance(buyHouse .getClass().getClassLoader(), buyHouse.getClass().getInterfaces(), new DynamicProxyHandler(buyHouse)); proxyBuyHouse.buyHosue(); &#125;&#125; 其中Proxy.newProxyInstance()方法接受三个参数： ClassLoader loader：指定当前目标对象使用的类加载器，获取加载器的方法是固定的 Class&lt;?&gt;[] interfaces：指定目标对象实现的接口的类型，使用泛型方式确认类型 InvocationHandler：指定动态处理器，执行目标对象的方法时，会触发事件处理器的方法 动态代理虽然不需要自己手动实现代理类和目标方法，但动态代理目标对象必须有接口，没有接口不能实现JDK版动态代理。 CGLIB代理JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。 CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。 Spring的代理选择 当Bean有实现接口时，Spring就会用JDK的动态代理。 当Bean没有实现接口时，Spring使用CGlib。 可以强制使用CGLib。 桥接（Bridge）将抽象部分与它的具体实现部分分离，使它们都可以独立地变化。 通过组合的方式建立两个类之间联系，而不是继承。 适用场景： 抽象和具体实现之间增加更多的灵活性。 一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。 不希望使用继承，或因为多层继承导致系统类的个数剧增。 优缺点优点：分离抽象部分及其具体实现部分；提高了系统的可扩展性；符合开闭原则与合成复用原则。 缺点：增加了系统的设计难度；需要正确地识别出系统中两个独立变化的维度。 应用场景画图时可以画正方形、长方形、圆形三种形状，而每种形状又可以画白色、灰色、黑色三种颜色，因此我们可以很自然地想出以下的继承关系： 对于这种方案，假如我们要添加一个椭圆形状，我们又要增加三种颜色，也就是白椭圆、灰椭圆和黑椭圆。假如我们要添加一个绿色，我们就要增加绿正方形、绿椭圆和绿长方形。每次增加都会增加若干个类（如果增加颜色则会增加形状个数个类，若增加形状则会增加颜色个数个类），这会导致系统类的个数剧增，且不利于系统的扩展。 对于这种有几个变化维度的场景，我们就可以使用桥接模式来减少系统中的类个数。这里提供两个父类一个是颜色、一个形状，颜色父类和形状父类两个类都包含了相应的子类，然后根据需要对颜色和形状进行组合： 形状抽象类，将颜色接口设为其成员变量： 12345678910public abstract class Shape &#123; Color color; public void setColor(Color color) &#123; this.color = color; &#125; public abstract void draw();&#125; 具体形状类： 1234567891011121314151617public class Circle extends Shape&#123; public void draw() &#123; color.bepaint("圆形"); &#125;&#125;public class Rectangle extends Shape&#123; public void draw() &#123; color.bepaint("长方形"); &#125;&#125;public class Square extends Shape&#123; public void draw() &#123; color.bepaint("正方形"); &#125;&#125; 颜色接口： 123public interface Color &#123; public void bepaint(String shape);&#125; 具体颜色类： 1234567891011121314151617public class White implements Color&#123; public void bepaint(String shape) &#123; System.out.println("白色的" + shape); &#125;&#125;public class Gray implements Color&#123; public void bepaint(String shape) &#123; System.out.println("灰色的" + shape); &#125;&#125;public class Black implements Color&#123; public void bepaint(String shape) &#123; System.out.println("黑色的" + shape); &#125;&#125; 客户端类： 12345678910111213141516public class Test&#123; public static void main(String[] args) &#123; //白色 Color white = new White(); //正方形 Shape square = new Square(); //白色的正方形 square.setColor(white); square.draw(); //长方形 Shape rectange = new Rectangle(); rectange.setColor(white); rectange.draw(); &#125;&#125; 这里在实现时要注意，抽象类的方法要调用组合的实现类的方法（如类Square中的color.bepaint(&quot;正方形&quot;)这行代码），这样才能体现出桥接的意义。 JDBC的应用jdbc的类族设计是由sun公司设计了一套接口，再由各个数据库公司实现接口，我们在调用的过程中只需要使用接口去定义，然后在加载Driver的过程中底层代码会给我们选择好接口真正的实现类，以此来实现真正的数据库连接，此后所有的方法，包括获取statement等等，都是由接口声明调用，但是底层返回的是接口实现类。用这种桥接的模式，我们可以很轻松地在不同的数据库连接中进行转化，只需要修改Driver加载的类，如果把加载类的声明放入配置文件中，更是不需要重新去编译，可以很方便地在不同数据库间进行转化。 享元（Flyweight）享元模式提供了减少对象数量从而改善应用所需的对象结构的方式。 适用场景： 常常应用于系统底层的开发，以便解决系统的性能问题。 系统有大量相似对象、需要缓冲池的场景。 优缺点优点：减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率；减少内存之外的其它资源占用（比如创建对象所需的时间）。 缺点：关注内外部状态以及线程安全问题；使系统的逻辑复杂化。 应用场景在年底的时候公司的老总、副总等许多高层经常需要将部门经理叫去办公室汇报工作，而汇报的往往都是同样的内容，部门经理没有必要每次汇报前都准备一份全新的相同报告，而可以直接使用之前的报告，在这里可以应用享元模式。 雇员接口： 123public interface Employee &#123; void report();&#125; 部门经理类，在创建部门经理的时候需要指定部门department，这个部门就是外部状态，而职位title是固定设为部门经理的，因此就是内部状态： 1234567891011121314151617public class Manager implements Employee &#123; public void report() &#123; System.out.println(reportContent); &#125; private String title = "部门经理"; private String department; private String reportContent; public void setReportContent(String reportContent) &#123; this.reportContent = reportContent; &#125; public Manager(String department) &#123; this.department = department; &#125;&#125; 雇员工厂类，用于创建并管理享元对象。这里使用了一个HashMap作为缓存池，如果某个部门经理没有做过汇报，那么就创建这个部门经理，并且设置汇报内容，然后将其加入到缓存池中。如果以后再叫到了这个部门经理，就直接从缓存池中取出而不必再创建一遍了： 12345678910111213141516public class EmployeeFactory &#123; private static final Map&lt;String, Employee&gt; EMPLOYEE_MAP = new HashMap&lt;String, Employee&gt;(); public static Employee getManager(String department)&#123; Manager manager = (Manager) EMPLOYEE_MAP.get(department); if(manager == null)&#123; manager = new Manager(department); System.out.print("创建部门经理: " + department); String repportContent = department + "部门汇报: 此次报告的主要内容是..."; manager.setReportContent(repportContent); System.out.println(" 创建报告: " + repportContent); EMPLOYEE_MAP.put(department, manager); &#125; return manager; &#125;&#125; 客户端类，随机取出一个部门的部门经理做汇报： 1234567891011public class Test &#123; private static final String departments[] = &#123;"RD", "QA", "PM", "BD"&#125;; public static void main(String[] args) &#123; for(int i = 0; i &lt; 10; i++)&#123; String department = departments[(int) (Math.random() * departments.length)]; Manager manager = (Manager) EmployeeFactory.getManager(department); manager.report(); &#125; &#125;&#125; 输出： 1234567891011121314创建部门经理: BD 创建报告: BD部门汇报: 此次报告的主要内容是...BD部门汇报: 此次报告的主要内容是...BD部门汇报: 此次报告的主要内容是...创建部门经理: QA 创建报告: QA部门汇报: 此次报告的主要内容是...QA部门汇报: 此次报告的主要内容是...QA部门汇报: 此次报告的主要内容是...创建部门经理: RD 创建报告: RD部门汇报: 此次报告的主要内容是...RD部门汇报: 此次报告的主要内容是...BD部门汇报: 此次报告的主要内容是...RD部门汇报: 此次报告的主要内容是...RD部门汇报: 此次报告的主要内容是...创建部门经理: PM 创建报告: PM部门汇报: 此次报告的主要内容是...PM部门汇报: 此次报告的主要内容是...QA部门汇报: 此次报告的主要内容是... 可以发现每个部门经理只创建过一次报告，之后都使用的同一份报告做汇报。 Integer中的应用我们查看jdk中Integer类下的valueOf方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243//... public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125;//... 可以看出，在使用valueOf方法时，如果传入的参数在缓存范围内（这个范围在IntegerCache中设置为-128~127），那么直接从缓存中读取并返回，否则就创建一个新的对象返回。 我们可以通过一个实验来加以验证：12345678910111213public static void main(String[] args) &#123; Integer t1 = new Integer(100); Integer t2 = new Integer(100); System.out.println(t1 == t2); Integer t3 = 100; Integer t4 = 100; System.out.println(t3 == t4); Integer t5 = 128; Integer t6 = 128; System.out.println(t5 == t6);&#125; 输出： 123falsetruefalse 使用new创建的Integer对象用==比较的是对象地址，因为对象不同所以地址也不相同，故输出false；而像Integer t = xxx 这种形式的定义实际会变成Integer t = Integer.valueOf(xxx)，先判断是否能直接从缓存中取出，100是在缓存范围内的也加入过缓存，因此可以直接取出；而128超出了缓存范围，所以在valueOf方法中会创建一个新的对象返回。 行为型模板方法（Template Method）定义了一个算法的骨架，并允许子类为一个或多个步骤提供实现。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。 适用场景： 一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。 各子类中公共的行为被提取出来并集中到一个公共父类中，从而避免代码重复。 优缺点优点：提高复用性；提高扩展性；符合开闭原则。 缺点：类数目增加，增加了系统实现的复杂度；继承关系自身缺点，即如果父类添加新的抽象方法，所有子类都要改一遍。 应用场景制作一节网课的步骤可以简化为4个步骤：制作PPT；录制视频；编写笔记；提供课程资料。 所有课程都需要制作PPT、录制视频，但不是每个课程都需要编写笔记，而提供的课程资料在每个课程都不尽不同（有些课程需要提供源代码，有些需要提供图片文件等）。 我们可以在抽象父类中确定整个流程的模板，并实现固定不变的步骤，而把不固定的步骤留给子类实现。除此之外，对于类似编写笔记这个不一定有的步骤，我们可以通过一个钩子方法，让子类来决定流程中其执行与否。 抽象父类，由于制作PPT、录制视频对于每节课都是必须且相同的，因此声明为final使得子类无法对其修改，而编写笔记虽然可有可无，但是具体的操作对于所有课程也是相同的因此不需要修改，所以也声明为final，而提供课程资料(packageCourse方法)这一步骤则交由具体子类实现： 12345678910111213141516171819202122232425public abstract class ACourse &#123; protected final void makeCourse()&#123; this.makePPT(); this.makeVideo(); if(needWriteArticle())&#123; this.writeArticle(); &#125; this.packageCourse(); &#125; final void makePPT()&#123; System.out.println("制作PPT"); &#125; final void makeVideo()&#123; System.out.println("制作视频"); &#125; final void writeArticle()&#123; System.out.println("编写笔记"); &#125; //钩子方法 protected boolean needWriteArticle()&#123; return false; &#125; abstract void packageCourse();&#125; 前端课程： 1234567public class FECourse extends ACourse &#123; @Override void packageCourse() &#123; System.out.println("提供课程的前端代码"); System.out.println("提供课程的图片等多媒体素材"); &#125;&#125; 设计模式课程，覆盖了钩子方法，让其可以编写笔记： 1234567891011public class DesignPatternCourse extends ACourse &#123; @Override void packageCourse() &#123; System.out.println("提供课程Java源码"); &#125; @Override protected boolean needWriteArticle() &#123; return true; &#125;&#125; 客户端类： 12345678910111213public class Test &#123; public static void main(String[] args) &#123; System.out.println("后端设计模式课程start---"); ACourse designPatternCourse = new DesignPatternCourse(); designPatternCourse.makeCourse(); System.out.println("后端设计模式课程end---"); System.out.println("前端设计模式课程start---"); ACourse feCourse = new FECourse(); feCourse.makeCourse(); System.out.println("前端设计模式课程end---"); &#125;&#125; JDK中的应用我们查看java.util下的AbstractList抽象类： 1234567891011121314public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; //... public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); boolean modified = false; for (E e : c) &#123; add(index++, e); modified = true; &#125; return modified; &#125; //... 这里面的addAll方法就相当于一个模板方法，它定义了这个算法的整体流程，而其具体的步骤如rangeCheckForAdd、add则交由子类如ArrayList等来完成。 Servlet中的应用Servlet是用Java编写的服务器端程序，主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。 每一个Servlet都必须要实现Servlet接口，GenericServlet是个通用的、不特定于任何协议的Servlet，它实现了Servlet接口，而HttpServlet继承于GenericServlet，实现了Servlet接口，为Servlet接口提供了处理HTTP协议的实现，所以我们定义的Servlet只需要继承HttpServlet即可。 在HttpServlet的service方法中，首先获得到请求的方法名，然后根据方法名调用对应的doXXX方法，比如说请求方法为GET，那么就去调用doGet方法；请求方法为POST，那么就去调用doPost方法。 HttpServlet相当于定义了一套处理HTTP请求的模板。service方法为模板方法，定义了处理HTTP请求的基本流程，doXXX等方法为基本步骤，根据请求方法做相应的处理，编写自定义的Servlet时可以重写这些方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public abstract class HttpServlet extends GenericServlet &#123; //,,, protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String method = req.getMethod(); if (method.equals(METHOD_GET)) &#123; long lastModified = getLastModified(req); if (lastModified == -1) &#123; // servlet doesn't support if-modified-since, no reason // to go through further expensive logic doGet(req, resp); &#125; else &#123; long ifModifiedSince; try &#123; ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE); &#125; catch (IllegalArgumentException iae) &#123; // Invalid date header - proceed as if none was set ifModifiedSince = -1; &#125; if (ifModifiedSince &lt; (lastModified / 1000 * 1000)) &#123; // If the servlet mod time is later, call doGet() // Round down to the nearest second for a proper compare // A ifModifiedSince of -1 will always be less maybeSetLastModified(resp, lastModified); doGet(req, resp); &#125; else &#123; resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED); &#125; &#125; &#125; else if (method.equals(METHOD_HEAD)) &#123; long lastModified = getLastModified(req); maybeSetLastModified(resp, lastModified); doHead(req, resp); &#125; else if (method.equals(METHOD_POST)) &#123; doPost(req, resp); &#125; else if (method.equals(METHOD_PUT)) &#123; doPut(req, resp); &#125; else if (method.equals(METHOD_DELETE)) &#123; doDelete(req, resp); &#125; else if (method.equals(METHOD_OPTIONS)) &#123; doOptions(req,resp); &#125; else if (method.equals(METHOD_TRACE)) &#123; doTrace(req,resp); &#125; else &#123; // // Note that this means NO servlet supports whatever // method was requested, anywhere on this server. // String errMsg = lStrings.getString("http.method_not_implemented"); Object[] errArgs = new Object[1]; errArgs[0] = method; errMsg = MessageFormat.format(errMsg, errArgs); resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg); &#125; &#125; //...&#125; 策略模式（Strategy）定义了算法家族，分别封装起来，让它们之间可以互相替代，此模式让算法的辩护权啊不会影响到使用算法的用户。 适用场景： 系统有很多类，而他们的区别仅仅在于他们的行为不同。 一个系统需要动态地在几种算法中选择一种。 优缺点 优点：符合开闭原则；避免使用多重条件转移语句；提高算法的保密性和安全性。 缺点：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 应用场景在促销期间商家有不同的促销策略：返现、立减和满减。 策略抽象类： 123public interface PromotionStrategy &#123; void doPromotion();&#125; 返现策略： 12345public class FanXianPromotionStrategy implements PromotionStrategy &#123; public void doPromotion() &#123; System.out.println("返现促销，返回的金额存放到用户余额中"); &#125;&#125; 立减策略： 12345public class LiJianPromotionStrategy implements PromotionStrategy&#123; public void doPromotion() &#123; System.out.println("立减促销，课程的价格直接减去配置的价格"); &#125;&#125; 满减策略： 12345public class ManJianPromotionStratehy implements PromotionStrategy &#123; public void doPromotion() &#123; System.out.println("满减促销，满200-20元"); &#125;&#125; 促销活动，将促销策略作为成员变量： 1234567891011public class PromotionActivity &#123; private PromotionStrategy promotionStrategy; public PromotionActivity(PromotionStrategy promotionStrategy) &#123; this.promotionStrategy = promotionStrategy; &#125; public void executePromotionStrategy()&#123; promotionStrategy.doPromotion(); &#125;&#125; 客户端类： 12345678public class Test &#123; public static void main(String[] args) &#123; PromotionActivity promotionActivity618 = new PromotionActivity(new LiJianPromotionStrategy()); PromotionActivity promotionActivity1111 = new PromotionActivity(new FanXianPromotionStrategy()); promotionActivity618.executePromotionStrategy(); promotionActivity1111.executePromotionStrategy(); &#125;&#125; 每当要新增一个促销策略的时候，直接增加一个策略实现即可，十分方便。 观察者模式（Observer）定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者（观察者）都会收到通知并更新。 优缺点 优点：观察者和被观察者之间建立一个抽象的耦合；支持广播通信。 缺点：观察者之间有过多的细节依赖、提高时间消耗及程序复杂度。 应用场景每个课程有一名老师，而课程的学生可能提出许多问题，因此创建三个类Course、Question、Teacher。其中课程应该作为被观察者，而老师由于要回答学生们的问题，因此作为观察者时刻观察着。 课程类Course：123456789101112131415161718192021public class Course extends Observable &#123; private String courseName; public Course(String courseName) &#123; this.courseName = courseName; &#125; public String getCourseName() &#123; return courseName; &#125; public void setCourseName(String courseName) &#123; this.courseName = courseName; &#125; public void produceQuestion(Course course, Question question)&#123; System.out.println(question.getUserName() + "在" + course.getCourseName() + "提交了一个问题"); setChanged(); notifyObservers(question); &#125;&#125; 问题类Question：1234567891011121314151617181920public class Question &#123; private String userName; private String questionContent; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getQuestionContent() &#123; return questionContent; &#125; public void setQuestionContent(String questionContent) &#123; this.questionContent = questionContent; &#125;&#125; 教师类Teacher：12345678910111213public class Teacher implements Observer &#123; private String teacherName; public Teacher(String teacherName) &#123; this.teacherName = teacherName; &#125; public void update(Observable o, Object arg) &#123; Course course = (Course)o; Question question = (Question) arg; System.out.println(teacherName + "老师的" + course.getCourseName() + "课程接收到一个" + question.getUserName() + "提交的问答：" + question.getQuestionContent()); &#125;&#125; 可以看出，以上代码通过继承Observable类和实现Observer接口实现了观察者模式。 Observable中有两个方法对Observer特别重要，一个是setChanged()方法用来设置一个内部标志位表示数据发生了变化，一个是notifyObservers()方法会去调用一个列表中所有的Observer的update()方法，通知它们数据发生了变化。 客户端类Test： 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Course course = new Course("Java设计模式课程"); Teacher teacher1 = new Teacher("Alpha"); Teacher teacher2 = new Teacher("Belta"); course.addObserver(teacher1); course.addObserver(teacher2); Question question = new Question(); question.setUserName("cenjie"); question.setQuestionContent("Java的主函数如何编写"); course.produceQuestion(course, question); &#125;&#125; Observable通过addObserver()方法把任意多个Observer添加到这个列表中。 运行结果： 123cenjie在Java设计模式课程提交了一个问题Belta老师的Java设计模式课程课程接收到一个cenjie提交的问答：Java的主函数如何编写Alpha老师的Java设计模式课程课程接收到一个cenjie提交的问答：Java的主函数如何编写 可以看出，当被观察者course对象发生变化时，teacher1和teacher2这两个观察者都得到了通知。 责任链模式（Chain Of Responsibility）使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。 应用场景抽象处理器，组合有一个同类型的成员变量： 12345678910public abstract class Handler &#123; protected Handler successor; public Handler(Handler successor) &#123; this.successor = successor; &#125; protected abstract void handleRequest(Request request);&#125; 具体处理器一：1234567891011121314151617public class ConcreteHandler1 extends Handler &#123; public ConcreteHandler1(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.TYPE1) &#123; System.out.println(request.getName() + " is handle by ConcreteHandler1"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; 具体处理器二：1234567891011121314151617public class ConcreteHandler2 extends Handler &#123; public ConcreteHandler2(Handler successor) &#123; super(successor); &#125; @Override protected void handleRequest(Request request) &#123; if (request.getType() == RequestType.TYPE2) &#123; System.out.println(request.getName() + " is handle by ConcreteHandler2"); return; &#125; if (successor != null) &#123; successor.handleRequest(request); &#125; &#125;&#125; 要处理的请求： 12345678910111213141516171819202122public class Request &#123; private RequestType type; private String name; public Request(RequestType type, String name) &#123; this.type = type; this.name = name; &#125; public RequestType getType() &#123; return type; &#125; public String getName() &#123; return name; &#125;&#125;public enum RequestType &#123; TYPE1, TYPE2&#125; 客户端：1234567891011121314public class Client &#123; public static void main(String[] args) &#123; Handler handler1 = new ConcreteHandler1(null); Handler handler2 = new ConcreteHandler2(handler1); Request request1 = new Request(RequestType.TYPE1, "request1"); handler2.handleRequest(request1); Request request2 = new Request(RequestType.TYPE2, "request2"); handler2.handleRequest(request2); &#125;&#125; 可以看出，handler2中包含了一个handler1，当发送一个request给handler2时，handler2可以将request继续传递给handler1，由handler1完成处理并结束。 备忘录模式（Memento）保存一个对象的某个状态，以便在适当的时候恢复对象。 为用户提供一种可恢复机制，并对存档信息进行封装，但如果使用不当的话会造成资源的浪费。 应用场景可以通过备忘录模式对用户的文章进行修改保存与回滚。 文章类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class Article &#123; private String title; private String content; private String imgs; public Article(String title, String content, String imgs) &#123; this.title = title; this.content = content; this.imgs = imgs; &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public String getContent() &#123; return content; &#125; public void setContent(String content) &#123; this.content = content; &#125; public String getImgs() &#123; return imgs; &#125; public void setImgs(String imgs) &#123; this.imgs = imgs; &#125; public ArticleMemento saveToMemento() &#123; ArticleMemento articleMemento = new ArticleMemento(this.title,this.content,this.imgs); return articleMemento; &#125; public void undoFromMemento(ArticleMemento articleMemento) &#123; this.title = articleMemento.getTitle(); this.content = articleMemento.getContent(); this.imgs = articleMemento.getImgs(); &#125; @Override public String toString() &#123; return "Article&#123;" + "title='" + title + '\'' + ", content='" + content + '\'' + ", imgs='" + imgs + '\'' + '&#125;'; &#125;&#125; 文章备忘录，属性与文章类一致，当没有setter方法，防止他人的修改：1234567891011121314151617181920212223242526272829303132public class ArticleMemento &#123; private String title; private String content; private String imgs; public ArticleMemento(String title, String content, String imgs) &#123; this.title = title; this.content = content; this.imgs = imgs; &#125; public String getTitle() &#123; return title; &#125; public String getContent() &#123; return content; &#125; public String getImgs() &#123; return imgs; &#125; @Override public String toString() &#123; return "ArticleMemento&#123;" + "title='" + title + '\'' + ", content='" + content + '\'' + ", imgs='" + imgs + '\'' + '&#125;'; &#125;&#125; 文章备忘录管理器，聚合了之前保存的管理器，可以随时调取上一个备忘录，也可以加入一个新的备忘录：1234567891011121314public class ArticleMementoManager &#123; private final Stack&lt;ArticleMemento&gt; ARTICLE_MEMENTO_STACK = new Stack&lt;ArticleMemento&gt;(); public ArticleMemento getMemento() &#123; ArticleMemento articleMemento= ARTICLE_MEMENTO_STACK.pop(); return articleMemento; &#125; public void addMemento(ArticleMemento articleMemento) &#123; ARTICLE_MEMENTO_STACK.push(articleMemento); &#125;&#125; 客户端：123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Test &#123; public static void main(String[] args) &#123; ArticleMementoManager articleMementoManager = new ArticleMementoManager(); Article article= new Article("如影随行的设计模式A","手记内容A","手记图片A"); ArticleMemento articleMemento = article.saveToMemento(); articleMementoManager.addMemento(articleMemento); System.out.println("标题:"+article.getTitle()+" 内容:"+article.getContent()+" 图片:"+article.getImgs()+" 暂存成功"); System.out.println("手记完整信息:"+article); System.out.println("修改手记start"); article.setTitle("如影随行的设计模式B"); article.setContent("手记内容B"); article.setImgs("手记图片B"); System.out.println("修改手记end"); System.out.println("手记完整信息:"+article); articleMemento = article.saveToMemento(); articleMementoManager.addMemento(articleMemento); article.setTitle("如影随行的设计模式C"); article.setContent("手记内容C"); article.setImgs("手记图片C"); System.out.println("暂存回退start"); System.out.println("回退出栈1次"); articleMemento = articleMementoManager.getMemento(); article.undoFromMemento(articleMemento); System.out.println("回退出栈2次"); articleMemento = articleMementoManager.getMemento(); article.undoFromMemento(articleMemento); System.out.println("暂存回退end"); System.out.println("手记完整信息:"+article); &#125;&#125; 中介者模式（Mediator）用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显示的相互引用，从而降低耦合。 应用场景用户（同事类）：12345678910111213141516171819public class User &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public User(String name) &#123; this.name = name; &#125; public void sendMessage(String message) &#123; StudyGroup.showMessage(this, message); &#125;&#125; 学习小组：123456public class StudyGroup &#123; public static void showMessage(User user, String message)&#123; System.out.println(new Date().toString() + " [" + user.getName() + "] : " + message); &#125;&#125; 客户端：123456789public class Test &#123; public static void main(String[] args) &#123; User geely = new User("Geely"); User tom= new User("Tom"); geely.sendMessage(" Hey! Tom! Let's learn Design Pattern"); tom.sendMessage("OK! Geely"); &#125;&#125; 参考资料 弗里曼. Head First 设计模式 [M]. 中国电力出版社, 2007. 慕课网java设计模式精讲 Debug 方式+内存分析 SLF4J和Logback日志框架详解 设计模式—代理模式 设计模式读书笔记–桥接模式 JDBC源码分析&amp;桥接模式 模板方法模式及典型应用]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《剑指Offer》题解与笔记]]></title>
    <url>%2F2019%2F01%2F29%2F%E3%80%8A%E5%89%91%E6%8C%87Offer%E3%80%8B%E9%A2%98%E8%A7%A3%E4%B8%8E%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[3.1 找出数组中重复的数字题目描述在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 题解对数组进行移位，判断i下标的数字等于i，如果不等则对其进行交换，eg: {1，3，4，6，5，2，5} –&gt; {3，1，4，6，5，2，5} //下标为0的数字为1，因此将下标为1的数字即3与1换位，使得1到了其应在的地方 {3，1，4，6，5，2，5} –&gt; {6，1，4，3，5，2，5} //此时下标为0的数字为3，依然不等于其下标，因此找到下标为3的数字6与其交换，使3到了其应在的地方 {6，1，4，3，5，2，5} –&gt; {5，1，4，3，5，2，6} //同理 {5，1，4，3，5，2，6} –&gt; {2，1，4，3，5，5，6} {2，1，4，3，5，5，6} –&gt; {4，1，2，3，5，5，6} {4，1，2，3，5，5，6} –&gt; {5，1，2，3，4，5，6} {5，1，2，3，4，5，6} //此时，要交换的两个数字相等，则证明该数字重复 可以看出，其时间复杂度为O(n)，且不需要额外分配空间，空间复杂度为O(1) 12345678910111213141516171819202122232425262728293031public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers == null)&#123; return false; &#125; for(int i = 0; i &lt; length; i++)&#123; while(numbers[i] != i)&#123; if(numbers[i] == numbers[numbers[i]])&#123; duplication[0] = numbers[i]; return true; &#125; swap(numbers, numbers[i], i); &#125; &#125; return false; &#125; private void swap(int[] numbers, int a, int b)&#123; int temp = numbers[a]; numbers[a] = numbers[b]; numbers[b] = temp; &#125;&#125; 3.2 不修改数组找出重复的数字题目描述在一个长度为n+1的数组里的所有数字都在1~n的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 题解此道题与上题类似，但有不同的几点： 1、题目要求不能修改输入的数组，因此可能要考虑创建辅助数组，这里的一个思路是将原数组的数字m移动到辅助数组中下标为m的位置，因此当移动时检测到辅助数组该下标已经有数字时，表示此数字重复了。这里的的空间复杂度为O(n)，时间复杂度为O(n)。 2、题目中提到“在一个长度为n+1的数组里的所有数字都在1-n的范围内”，例如，若有个包含5个数的数组，但里面的数字只有1、2、3、4，那么必然有一个是重复的。这时候另一个思路则是在1、2、3、4、5中找出中间数3，以此将数组分割成两块，左半块是1-3（注意不是1-2），右半块是4-5，之后遍历整个数组，若数字在左半边的范围内，则将计数器加一。结束遍历时，若计数器的值大于这边块包含的个数，就说明重复的数字在这边块里，否则其就在右半块。紧接着把范围缩小到其中一边，继续重复以上操作。此操作类似二分查找法，需要的时间为O(nlogn)，空间复杂度为o(1)，相当于以时间换空间。下面给出的代码将根据此种思路。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Solution &#123; // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number,length of duplication array is 1,so using duplication[0] = ? in implementation; // Here duplication like pointor in C/C++, duplication[0] equal *duplication in C/C++ // 这里要特别注意~返回任意重复的一个，赋值duplication[0] // Return value: true if the input is valid, and there are some duplications in the array number // otherwise false public boolean duplicate(int numbers[],int length,int [] duplication) &#123; if(numbers == null)&#123; return false; &#125; int start = 1; int end = length - 1; while(end &gt;= start)&#123; int middle = (end - start) / 2 + start; int count = countRange(numbers, length, start, middle); if(end == start)&#123; if(count &gt; 1)&#123; duplication[0] = start; return true; &#125; break; &#125; if(count &gt; middle - start + 1) end = middle; else start = middle + 1; &#125; return false; &#125; public int countRange(int numbers[],int length, int start, int end)&#123; if(numbers == null)&#123; return 0; &#125; int count = 0; for(int i = 0; i &lt; length; i++)&#123; if(numbers[i] &gt;= start &amp;&amp; numbers[i] &lt;= end)&#123; count++; &#125; &#125; return count; &#125;&#125; 4.二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 题解12345678910111213141516public class Solution &#123; public boolean Find(int target, int [][] array) &#123; int len = array.length - 1; int i = 0; while(i &lt; array[0].length &amp;&amp; len &gt;= 0)&#123; if(array[len][i] &gt; target)&#123; len--; &#125; else if(array[len][i] &lt; target)&#123; i++; &#125; else&#123; return true; &#125; &#125; return false; &#125;&#125; 5.替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 题解先遍历一次字符串，得到空格的总数，然后将字符串的长度设置为字符串的原长度加上空格数的两倍。将原始字符串末尾的值不断复制给新新字符串的末尾，每次遇到空格的时候在新字符串前插入%20。此算法中所有字符都只复制了一次，因此时间复杂度为O(n)。 在合并两个数组时，如果从前往后复制每个数字（或字符）则需要重复移动数字（或字符）多次，那么我们可以考虑从后往前复制，这样就能减少移动的次数，从而提高效率。 12345678910111213141516171819202122232425262728public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; if(str == null)&#123; return null; &#125; int spaceNum = 0; for(int i = 0; i &lt; str.length(); i++)&#123; if(str.charAt(i) == ' ')&#123; spaceNum++; &#125; &#125; int oldIndex = str.length() - 1; int newLength = str.length() + spaceNum * 2; str.setLength(newLength); int newIndex = newLength - 1; for(; oldIndex &gt;= 0 &amp;&amp; oldIndex &lt;= newIndex; oldIndex--)&#123; if(str.charAt(oldIndex) == ' ') &#123; str.setCharAt(newIndex--, '0'); str.setCharAt(newIndex--, '2'); str.setCharAt(newIndex--, '%'); &#125;else&#123; str.setCharAt(newIndex--, str.charAt(oldIndex)); &#125; &#125; return str.toString(); &#125;&#125; 6.从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 1234567891011/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/ 题解使用递归每访问到一个节点的时候，先递归输出它后面的节点，再输出该节点自身。 12345678910public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); if(listNode != null)&#123; arrayList.addAll(printListFromTailToHead(listNode.nextNode)); arrayList.add(listNode.val); &#125; return arrayList; &#125;&#125; 使用栈利用栈“先进后出”的特性，实现最先入栈的节点值最后输出。 123456789101112public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; Stack stack = new Stack(); while(listNode != null)&#123; stack.push(listNode.val); listNode = listNode.nextNode; &#125; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;&gt;(); while(!stack.isEmpty())&#123; arrayList.add((Integer) stack.pop()); &#125; return arrayList;&#125; 7.重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 123456789/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 题解对于前序遍历，第一个数字即为根节点的值；对于中序遍历，根据根节点值将序列划分为左右子树。接下来使用递归分别继续进行如上操作，便可不断构建出左右子树。 12345678910111213141516171819202122232425public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; if(pre == null || in == null)&#123; return null; &#125; return reConstructBinaryTree(pre, 0, pre.length-1, in, 0, in.length-1); &#125; private TreeNode reConstructBinaryTree(int[] pre, int startPre, int endPre, int[] in, int startIn, int endIn)&#123; if(startPre &gt; endPre || startIn &gt; endIn) return null; TreeNode root = new TreeNode(pre[startPre]); for(int i = startIn; i &lt;= endIn; i++)&#123; if(in[i] == pre[startPre])&#123; root.left = reConstructBinaryTree(pre, startPre+1, i-startIn+startPre, in, startIn, i-1); root.right = reConstructBinaryTree(pre, startPre+i-startIn+1, endPre, in, i+1, endIn); break; &#125; &#125; return root; &#125;&#125; 8.二叉树的下一个节点题目描述给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 123456789101112/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解此题可分为两种情况：一种是一个节点有右子树，那么它的下一个节点就是它的右子树中的最左子节点；另一种是没有右子树，那么就判断它是否为父节点的左节点，如果是，则父结点为其下一个节点，如果不是，则向上遍历其父结点，找到为其祖先节点左节点的父结点，这个祖先节点就是它的下一个节点。 1234567891011121314151617181920public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; //1、一个节点有右子树，那么找到右子树的最左子节点 if (pNode.right != null) &#123; TreeLinkNode node = pNode.right; while (node.left != null) &#123; node = node.left; &#125; return node; &#125; //2、一个节点没有右子树 while (pNode.next != null) &#123; if(pNode.next.left == pNode) return pNode.next; pNode = pNode.next; &#125; return null; &#125;&#125; 9.用两个栈实现队列题目描述用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 题解此题思路较为简单，主要就是利用栈“先入后出”和队列“先入先出”的特性，每次push的时候将值存到栈1中，pop的时候先将栈1的值放入栈2从而实现逆序，然后再对栈2进行pop操作，就实现了队列的“先进先出”。 1234567891011121314151617public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if (stack2.size() &lt;= 0) &#123; while (stack1.size() &gt; 0) &#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 10.1 斐波那契数列题目描述大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。 题解传统的做法是使用递归：return Fibonacci(n-1)+Fibonacci(n-2)。但是这种做法画出树形图就能看出有许多重复的节点，而且容易导致内存溢出，因而不建议使用。 使用循环使用循环是一个较好的做法，不仅提高了时间效率，也解决了内存溢出的问题。实际上，任何递归都可以用循环来实现。 1234567891011121314151617public class Solution &#123; public int Fibonacci(int n) &#123; if(n == 0) return 0; if(n == 1) return 1; int num = 0; int num1 = 0; int num2 = 1; for(int i = 2; i &lt;= n; i++)&#123; num = num1 + num2; num1 = num2; num2 = num; &#125; return num; &#125;&#125; 使用尾递归尾递归是递归的一种特殊形式，本质上和递归没有什么区别，但优化后可以重复利用同一个栈帧，大幅提高效率，具体介绍在我的博客中有介绍：。由于java没有对尾递归进行优化，所以在此题中用java解题时依旧无法解决内存溢出的问题，主要提供一种答题思路。 1234567891011121314public class Solution &#123; public int Fibonacci(int n) &#123; return Fibonacci(n, 0, 1); &#125; private static int Fibonacci(int n, int num1, int num2)&#123; if(n == 0) return 0; if(n == 1) return num2; else return Fibonacci(n - 1, num2, num1 + num2); &#125;&#125; 10.2 跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 题解如果只有1级台阶，则只有一种跳法；如果有2级台阶，则可以一次跳两阶，或者一次跳一阶；如果有n级台阶，第一次跳就有两种不同的选择：当第一次只跳一阶时，总的跳法数等于后面n-1级台阶的跳法数，而如果第一次跳两阶的话，总的跳法数就等于后面n-2级台阶的跳法数。根据此规律可以得到以下公式：1234f(n) = 0, 当n=0时f(n) = 1, 当n=1时f(n) = 2, 当n=2时f(n) = f(n-1) + f(n-2), 当n&gt;2时 12345678910111213141516171819public class Solution &#123; public int JumpFloor(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; if(n == 2) return 2; int num = 0; int num1 = 1; int num2 = 2; for(int i = 3; i &lt;= n; i++)&#123; num = num1 + num2; num1 = num2; num2 = num; &#125; return num; &#125;&#125; 10.3 变态跳台阶题目描述一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 题解思路一此题和上题类似，但是一次可以跳多级台阶，依旧可以根据“第一次跳多少台阶，则跳法数等于剩下多少台阶的跳法数目”的思路进行分析，因此我们可以如下分析： 12345678910111213如果有1级台阶，则有f(1) = 1 种跳法如果有2级台阶，则有f(2) = f(2-1) + f(2-2) = 2 种跳法如果有3级台阶，则有f(3) = f(3-1) + f(3-2) + f(3-3) = 4 种跳法···如果有n级台阶，则有f(n) = f(n-1) + f(n-2) + f(n-3) + ··· + f(0) 种跳法 又 f(n-1) = f(n-2) + f(n-3) + f(n-4) + ··· + f(0) 进行相减可得，f(n) - f(n-1) = f(n-1) 即，f(n) = 2f(n-1) 由此得出，f(n) = 1, 当n=0时f(n) = 1, 当n=1时f(n) = f(n-1) + f(n-2), 当n&gt;=2时 此题一个比较难理解的部分是，在公式中当n=0时，f(n)应当等于1而不是0。因为如果第一次就跳完了所有台阶，这也算一种跳法，此时f(n-n)=f(0)应当等于1而非0。 1234567891011121314151617public class Solution &#123; public int JumpFloorII(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; int num = 0; int num1 = 1; //初始值应为1而非0 int num2 = 1; for(int i = 2; i &lt;= n; i++)&#123; num = num1 + num2; num2 = num1; num1 = num; &#125; return num; &#125;&#125; 思路二在跳台阶的整个过程中，除了最后一阶是必须要跳的，其它每个台阶都有跳或者不跳两种可能性，因此f(n) = 2^(n-1)。 12345678public class Solution &#123; public int JumpFloorII(int n) &#123; if(n &lt;= 0) return 0; else return (int)Math.pow(2, n-1); &#125;&#125; 10.4 矩形覆盖题目描述我们可以用2 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 1的小矩形无重叠地覆盖一个2 * n的大矩形，总共有多少种方法？ 题解123f(n) = 1, 当n=0时f(n) = 1, 当n=1时f(n) = f(n-1) + f(n-2), 当n&gt;=2时 1234567891011121314151617public class Solution &#123; public int RectCover(int n) &#123; if(n &lt;= 0) return 0; if(n == 1) return 1; int num = 0; int num1 = 1; int num2 = 1; for(int i = 2; i &lt;= n; i++)&#123; num = num1 + num2; num2 = num1; num1 = num; &#125; return num; &#125;&#125; 14 剪绳子题目描述一根长度为n的绳子，将绳子剪为m段（剪m-1次），每段绳子的长度为k[0] - k[m]；要求k[0] k[1] k[2] ··· k[m]的乘积为最大。n &gt;1 且 m&gt; 1。 题解这道题可以采用动态规划来做。在剪第一刀的时候，我们有n-1种可能的选择，因此f(n)=max(f(i) * f(n-i))。由于递归会产生很多重复的子问题，因此采用由下而上的循环方式，将每个子问题的最优解放到数组dp里。最终的答案就是dp[n]。 在刚开始看书的时候并不理解为什么要对dp[1], dp[2], [dp3]逐一初始化，后来经过反复调试并思考，发现当n&gt;3时dp[3]也就是当绳子长度为3时，不应该对其进行切割，因为切割后理论应得问题最优解就是2，而它的父问题要想得到最优解，应该直接使用整段未切割绳子也就是3。而当n&lt;=3时，将在方法最开始就进行了一个正确的返回，即当绳子长度为3时，对其进行切割得到最优解为2。 1234567891011121314151617181920212223242526public class Solution &#123; public int integerBreak(int n) &#123; if(n &lt; 2) return 0; if(n == 2) return 1; if(n == 3) return 2; int []dp = new int[n +1]; dp[1] = 1; dp[2] = 2; dp[3] = 3; for(int i = 4; i &lt;= n; i++)&#123; //把长度为i的绳子切成若干段 int max = 0; for(int j = 1; j &lt;= i/2; j++)&#123; int p = dp[j] * dp[i-j]; if(max &lt; p) max = p; &#125; dp[i] = max; &#125; return dp[n]; &#125;&#125; 15 二进制中1的个数题目描述输入一个整数，输出该数二进制表示中1的个数。 题解常规解法将输入的数字n与1做与运算，如果得出的结果是1，说明n的最低位是1，从而将计数器加一，并将1左移，进行n的次低位的判断，如此反复。这种做法整数为多少位就要循环多少次。 1234567891011121314public class Solution &#123; public int NumberOf1(int n)&#123; int count = 0; int flag = 1; while(flag != 0)&#123; if((n &amp; flag) != 0)&#123; count++; &#125; flag = flag &lt;&lt; 1; &#125; return count; &#125;&#125; 优化解法对输入的数字n减1再与自身进行与运算，即(n-1)&amp;n可以将n最低位的1变成0：123n: 11101100n-1: 11101011n&amp;(n-1): 11101000 基于以上，n中有多少个1，就可以进行多少次这样的操作。 12345678910public class Solution &#123; public int NumberOf1(int n)&#123; int count = 0; while(n != 0)&#123; count++; n = (n - 1) &amp; n; &#125; return count; &#125;&#125; 16 数值的整数次方题目描述给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 题解此题的关键在于对base、exponent为正数、负数和零的考虑。 循环123456789101112131415public class Solution &#123; public double Power(double base, int exponent) &#123; boolean isNegative = false; if(exponent &lt; 0)&#123; isNegative = true; exponent = -exponent; &#125; double result = 1; for(int i = 1; i &lt;= exponent; i++)&#123; result = base * result; &#125; return isNegative ? 1 / result : result; &#125;&#125; 递归a的n次方可以通过如下公式求解： 12a^n = a^(n/2) * a^(n/2), n为偶数a^n = a^((n-1)/2) * a^((n-1)/2) * a, n为奇数 每次计算n都会变为原来的1/2，因此通过递归算法可以使时间复杂度降到logn，效率得到提升。除此之外，可以用右移运算和位与运算代替除2和求余运算两个操作，从而得到进一步优化。 12345678910111213141516171819202122public class Solution &#123; public double Power(double base, int exponent) &#123; if(exponent == 0) return 1; if(exponent == 1) return base; boolean isNegative = false; if(exponent &lt; 0)&#123; isNegative = true; exponent = -exponent; &#125; double result = Power(base, exponent &gt;&gt; 1); result *= result; if((exponent &amp; 0x1) == 1)&#123; result *= base; &#125; if(exponent &lt; 0)&#123; result = 1 / result; &#125; return isNegative ? 1 / result : result; &#125;&#125; 17 打印从1到最大的n位数题目描述输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。 题解这道题可以使用递归对n位数进行全排列，在每一次递归调用之前都设置好下一位，当index为最后一位时，结束递归并打印。 123456789101112131415161718192021222324public class Solution &#123; public void PrintToMaxOfNDigits(int n)&#123; if(n &lt;= 0) return; char[] nums = new char[n]; for(int i = 0; i &lt; 10; i++)&#123; nums[0] = (char) ('0' + i); PrintToMaxOfNDigits(nums, 0); &#125; &#125; public void PrintToMaxOfNDigits(char[] nums, int index)&#123; if(index == nums.length - 1)&#123; System.out.println(nums); return; &#125; for(int i = 0; i &lt; 10; i++)&#123; nums[index+1] = (char) ('0' + i); PrintToMaxOfNDigits(nums, index+1); &#125; &#125;&#125; 18.1 在O(1)时间内删除链表节点题目描述给定单向链表的头指针和一个节点指针，定义一个函数在O(1)时间内删除该节点。 12345678910/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解对于一个链表：1-&gt;2-&gt;3-&gt;4-&gt;5，如果要删除节点4， 首先想到的思路是找到节点4前面的节点（此处也就是节点3），将3的下一个节点重新设置为要删除的节点的下一个节点（此处也就是5），此时链表就变为了1-&gt;2-&gt;3-&gt;5。但由于链表是单向链表，不能从要删除的节点直接得到上一个节点，因此只能从头开始顺序查找，时间复杂度就为O(n)了。 另一种思路则是将要删除的节点的下一个节点的值赋值给要删除的节点，再将要删除的节点的下一个节点重新设置为下下个节点：1-&gt;2-&gt;3-&gt;5-&gt;51-&gt;2-&gt;3-&gt;5此时，时间复杂度就为O(1)了。 但如果要删除的节点为尾节点，则没有下一个节点，此种情况依然要使用顺序查找的方式删除节点。 123456789101112131415161718192021222324252627public class Solution &#123; public ListNode deleteNode(ListNode head, ListNode tobeDelete) &#123; if(head == null || tobeDelete == null) &#123; return null; &#125; //要删除的节点不是尾节点 if(tobeDelete.next != null) &#123; tobeDelete.val = tobeDelete.next.val; tobeDelete.next = tobeDelete.next.next; &#125; else &#123; //要删除的节点是尾节点 ListNode node = head; if(node == tobeDelete) &#123; //如果链表中只有要删除的这一个节点 return null; &#125; while(node.next != tobeDelete) &#123; node = node.next; &#125; node.next = null; &#125; return head; &#125;&#125; 18.2 删除链表中重复的结点题目描述在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 12345678910/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解如果当前节点的值与下一个节点的值相同，那么它们就是重复的节点，都可以被删除。为了保证删除之后的链表仍然是相连的，我们要把当前节点的前一个节点和后面值比当前节点的值大的节点相连。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if(pHead == null) &#123; return null; &#125; //如果链表中只存在一个节点，则不存在重复的节点 if(pHead.next == null) &#123; return pHead; &#125; ListNode preNode = null; ListNode node = pHead; while(node != null) &#123; ListNode nextNode = node.next; if(nextNode != null &amp;&amp; !(nextNode.val == node.val)) &#123; //当前节点与下一个节点不同 preNode = node; node = nextNode; &#125; else &#123; if(node.next == null) &#123; break; &#125; //当前节点与下一个相同 int value = node.val; ListNode toBeDel = node; while(toBeDel != null &amp;&amp; toBeDel.val == value) &#123; nextNode = toBeDel.next; toBeDel = nextNode; &#125; if(preNode == null) &#123; pHead = nextNode; &#125; else &#123; preNode.next = nextNode; &#125; node = nextNode; &#125; &#125; return pHead; &#125;&#125; 19 正则表达式匹配题目描述请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配. 题解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Solution &#123; public boolean match(char[] str, char[] pattern) &#123; if(str == null || pattern == null) &#123; return false; &#125; int strIndex = 0; int patternIndex = 0; return matchCore(str, pattern, strIndex, patternIndex); &#125; public boolean matchCore(char[] str, char[] pattern, int strIndex, int patternIndex) &#123; //字符串与模式完全匹配 if(strIndex == str.length &amp;&amp; patternIndex == pattern.length) &#123; return true; &#125; //字符串未到达末尾，而模式已到达末尾，则匹配失败 if(strIndex != str.length &amp;&amp; patternIndex == pattern.length) &#123; return false; &#125; if(patternIndex + 1 &lt; pattern.length &amp;&amp; pattern[patternIndex + 1] == '*') &#123; //模式的第二个字符为* if(strIndex &lt; str.length &amp;&amp; str[strIndex] == pattern[patternIndex] || strIndex &lt; str.length &amp;&amp; pattern[patternIndex] == '.') &#123; //*前的字符与字符串中的字符相等时 //可能的情况：匹配0位，模式向后移动两位跳过*；匹配一位，模式向后移动两位跳过*；匹配一位，模式不移动，下次继续匹配。 return matchCore(str, pattern, strIndex, patternIndex+2) || matchCore(str, pattern, strIndex+1, patternIndex+2) || matchCore(str, pattern, strIndex+1, patternIndex); &#125; else &#123; //*前的字符与字符串中的字符不相等时，匹配0位，跳过* return matchCore(str, pattern, strIndex, patternIndex+2); &#125; &#125; if(pattern[patternIndex] == '.' &amp;&amp; strIndex &lt; str.length || strIndex &lt; str.length &amp;&amp; pattern[patternIndex] == str[strIndex]) &#123; //模式的第二个字符不为* if(str[strIndex] == pattern[patternIndex] || pattern[patternIndex] == '.') &#123; //如果字符相匹配,则接续操作 return matchCore(str, pattern, strIndex+1, patternIndex+1); &#125; else &#123; //字符不匹配，直接返回false return false; &#125; &#125; return false; &#125;&#125; 20 表示数值的字符串题目描述请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 题解表示数值的字符串遵循模式：A[.[b]][e|EC]或者.B[e|EC]。A和C都可以带有符号’+’或’-‘，B则不行，且A、B、C都必须为整数。因此，可以根据模式的顺序去依次匹配A、B、C。如果字符串中包含’.’，则’.’左右至少要有一方有数字，而如果字符串中包含’e’或’E’，则’e’或’E’两方都必须要有数字，且右方必须为整数。 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; private int index = 0; public boolean isNumeric(char[] str) &#123; boolean flag; if(str == null) return false; flag = scanInteger(str); if(index &lt; str.length &amp;&amp; str[index] == '.') &#123; index++; flag = scanUnsignedInteger(str) || flag; &#125; if(index &lt; str.length &amp;&amp; (str[index] == 'e' || str[index] == 'E')) &#123; index++; flag = scanInteger(str) &amp;&amp; flag; &#125; return flag &amp;&amp; (index == str.length); &#125; boolean scanUnsignedInteger(char[] str) &#123; int before = index; while(index &lt; str.length &amp;&amp; str[index] &gt;= '0' &amp;&amp; str[index] &lt;= '9') &#123; index++; &#125; return index &gt; before; &#125; boolean scanInteger(char[] str) &#123; if(index &lt; str.length &amp;&amp; (str[index] == '+' || str[index] == '-')) index++; return scanUnsignedInteger(str); &#125;&#125; 21 调整数组顺序使奇数位于偶数前面题目描述输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分（拓展：并保证奇数和奇数，偶数和偶数之间的相对位置不变）。 题解基本解法一前一后扫描数组，若发现有偶数在前，奇数在后，则交换它们两的位置。此算法的时间复杂度为O(n)，但是算法是不稳定的，也就是没法保证奇数和奇数，偶数和偶数之间的相对位置不变。 123456789101112131415161718192021public class Solution &#123; public void reOrderArray(int [] array) &#123; int head = 0; int tail = array.length - 1; while(head &lt; tail) &#123; while(head &lt; array.length &amp;&amp; array[head] % 2 != 0) &#123; //正向遍历不为偶数的时候 head++; &#125; while(tail &gt;= 0 &amp;&amp; array[tail] % 2 == 0) &#123; //反向遍历不为奇数的时候 tail--; &#125; if(head &lt; tail) &#123; int temp = array[head]; array[head] = array[tail]; array[tail] = temp; &#125; &#125; &#125;&#125; 拓展解法要保证奇数和奇数，偶数和偶数之间的相对位置不变，则需要使用一个辅助数组，首先计算出奇数的个数，以此作为将偶数插入辅助数组的起始坐标。然后遍历原数组，将奇数放置于辅助数组的奇数起始坐标（也就是0），将偶数放置于辅助数组的偶数起始坐标，最后再将调整完毕的辅助数组中的元素依次放回原数组。此算法的时间复杂度为O(n)，空间复杂度为O(n)，相当于以空间换时间。另一种思路是可以使用插入排序的思想，在此不再阐述。 1234567891011121314151617181920212223242526272829public class Solution &#123; public void reOrderArray(int [] array) &#123; int[] copy = new int[array.length]; int index = 0; int count = 0; for(int i = 0; i &lt; array.length; i++) &#123; //统计奇数个数 if(array[i] % 2 != 0) count++; &#125; int odd = 0; int even = count; while(index &lt; array.length) &#123; if(array[index] % 2 != 0) &#123; //如果是奇数 copy[odd] = array[index]; odd++; &#125; else &#123; //如果是偶数 copy[even] = array[index]; even++; &#125; index++; &#125; for(int i = 0; i &lt; array.length; i++) &#123; array[i] = copy[i]; &#125; &#125;&#125; 22 链表中倒数第K个节点题目描述输入一个链表，输出该链表中倒数第k个结点。 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解传统的思路是先遍历一遍链表，计算出节点数n，则倒数第k个节点就是从头开始的第n-k+1个节点。但此种做法要遍历链表两边，效率不高。 另一种思路是定义两个指针，让两个指针之间的距离保持在k-1，则当第一个指针到达链表的尾节点时，第二个指针则指向倒数第k个节点。这种实现只需要遍历链表一次即可。 1234567891011121314151617181920public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(head == null || k &lt;= 0) return null; ListNode node1 = head; ListNode node2 = head; for(int i = 0; i &lt; k-1; i++) &#123; if(node1.next == null) return null; node1 = node1.next; &#125; while(node1.next != null) &#123; node1 = node1.next; node2 = node2.next; &#125; return node2; &#125;&#125; 23 链表中环的入口节点题目描述给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解要找到链表中环的入口节点，整体思路与上一题类似。例如，如果环中有4个节点，则第二个指针要比第一个指针先走四步，然后同时向前走，当两个指针相遇时，所指向的节点就是入口节点。 根据此思路，要解决的问题是：如何计算环的节点数？这里可以先使用一快一慢两个指针，得到相遇时的节点（若第一个指针走到了null，说明链表中没有环，返回null），此节点必然在环内，然后从此节点开始绕环一圈，每走一步计数器加一，当回到原点时便得到了环的节点数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode head) &#123; if(head == null) return null; ListNode meetingNode = MeetingNode(head); if(meetingNode == null) return null; ListNode node1 = head; ListNode node2 = head; ListNode node = meetingNode.next; int count = 1; while(node != meetingNode) &#123; count++; node = node.next; &#125; for(int i = 0; i &lt; count; i++) &#123; node1 = node1.next; &#125; while(node1 != node2) &#123; node1 = node1.next; node2 = node2.next; &#125; return node1; &#125; public ListNode MeetingNode(ListNode head) &#123; ListNode node1 = head; ListNode node2 = head; while(node1.next != null &amp;&amp; node1.next.next != null) &#123; node1 = node1.next.next; node2 = node2.next; if(node1 == node2) return node1; &#125; return null; &#125; &#125; 24 反转链表题目描述输入一个链表，反转链表后，输出新链表的表头。 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解定义三个指针分别指向前一个节点，当前节点和后一个节点。 123456789101112131415161718192021222324public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; if(head == null) return null; ListNode preNode = null; ListNode currNode = head; ListNode nextNode = head.next; ListNode reNode = null; while(currNode != null) &#123; if(nextNode == null) &#123; reNode = currNode; currNode.next = preNode; break; &#125; currNode.next = preNode; preNode = currNode; currNode = nextNode; nextNode = currNode.next; &#125; return reNode; &#125;&#125; 25 合并两个排序的链表题目描述输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 123456789/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解1234567891011121314151617181920public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1 == null) return list2; if(list2 == null) return list1; ListNode head = null; if(list1.val &lt; list2.val) &#123; head = list1; head.next = Merge(list1.next, list2); &#125; else &#123; head = list2; head.next = Merge(list1, list2.next); &#125; return head; &#125;&#125; 26 树的子结构题目描述输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 1234567891011/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解第一步是在树A中查找与根节点的值一样的节点，第二步是判断以此节点为根节点的子树是不是和树B具有相同的结构。此题要特别注意由于计算机表示小数含有误差，不能直接使用==进行double类型的等值判断，而是判断两个小数的差的绝对值是否小于某一个可忽略的数。 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean result = false; if(root1 != null &amp;&amp; root2 != null) &#123; if(Equal(root1.val, root2.val)) result = DoesTree1HaveTree2(root1, root2); if(!result) result = HasSubtree(root1.left, root2); if(!result) result = HasSubtree(root1.right, root2); &#125; return result; &#125; public boolean DoesTree1HaveTree2(TreeNode root1, TreeNode root2) &#123; if(root2 == null) return true; if(root1 == null) return false; if(!Equal(root1.val, root2.val)) return false; return DoesTree1HaveTree2(root1.left, root2.left) &amp;&amp; DoesTree1HaveTree2(root1.right, root2.right); &#125; public boolean Equal(double num1, double num2) &#123; if(num1- num2 &gt; -0.0000001 &amp;&amp; num1 - num2 &lt; 0.0000001) return true; return false; &#125;&#125; 27 二叉树的镜像题目描述操作给定的二叉树，将其变换为源二叉树的镜像。 123456789101112131415二叉树的镜像定义： 源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 1234567891011/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解123456789101112131415161718public class Solution &#123; public void Mirror(TreeNode root) &#123; if(root == null) return; if(root.left == null &amp;&amp; root.right == null) return; TreeNode temp; temp = root.left; root.left = root.right; root.right = temp; if(root.left != null) Mirror(root.left); if(root.right != null) Mirror(root.right); &#125;&#125; 28 对称的二叉树题目描述请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 12345678910111213 对称的二叉树 8 / \ 6 6 / \ / \5 7 7 5 非对称的二叉树 8 / \ 6 9 / \ / \5 7 7 5 1234567891011/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解对于上图的非对称的二叉树，可以发现前序序列为{8, 6, 5, 7, 6, 7, 5}，对称前序序列为{8, 9, 5, 7, 6, 7, 5}。而对于对称的二叉树，前序序列与对称前序序列都为{8, 6, 5, 7, 6, 7, 5}。因此，通过比较二叉树的前序序列和对称前序序列即可判断出二叉树是否对称。 12345678910111213141516public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; return isSymmetrical(pRoot, pRoot); &#125; boolean isSymmetrical(TreeNode pRoot1, TreeNode pRoot2) &#123; if(pRoot1 == null &amp;&amp; pRoot2 == null) return true; if(pRoot1 == null || pRoot2 == null) return false; if(pRoot1.val != pRoot2.val) return false; return isSymmetrical(pRoot1.left, pRoot2.right) &amp;&amp; isSymmetrical(pRoot1.right, pRoot2.left); &#125;&#125; 29 顺时针打印矩阵题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123; if(matrix == null) return null; int columns = matrix[0].length; int rows = matrix.length; if(columns == 0 || rows == 0) return null; ArrayList&lt;Integer&gt; arr = new ArrayList(); int start = 0; while(columns &gt; start*2 &amp;&amp; rows &gt; start*2) &#123; arr.addAll(PrintMatrixInCircle(matrix, columns, rows, start)); start++; &#125; return arr; &#125; public ArrayList&lt;Integer&gt; PrintMatrixInCircle(int [][]matrix, int columns, int rows, int start)&#123; ArrayList&lt;Integer&gt; arr = new ArrayList(); int endX = columns - 1 - start; int endY = rows - 1 - start; //从左到右打印一行 for(int i = start; i &lt;= endX; ++i) &#123; int number = matrix[start][i]; arr.add(number); &#125; //从上到下打印一列 if(start &lt; endY) &#123; for(int i = start + 1; i &lt;= endY; ++i) &#123; int number = matrix[i][endX]; arr.add(number); &#125; &#125; //从右到左打印一行 if(start &lt; endX &amp;&amp; start &lt; endY) &#123; for(int i = endX - 1; i &gt;= start; --i) &#123; int number = matrix[endY][i]; arr.add(number); &#125; &#125; //从下到上打印一行 if(start &lt; endX &amp;&amp; start &lt; endY - 1) &#123; for(int i = endY - 1; i &gt;= start + 1; --i) &#123; int number = matrix[i][start]; arr.add(number); &#125; &#125; return arr; &#125;&#125; 30 包含min函数的栈题目描述定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 题解使用一个辅助栈。第一次压入的时候，把该元素同时也压入到辅助栈中。以后每次压入新元素的时候，如果新元素比辅助栈栈顶的元素小，就把新元素也压入到辅助栈中，否则，就把辅助栈栈顶的元素再次压入。这么做可以使辅助栈的每个元素对应着数据栈中该位置元素之前的最小元素，即每次从数据栈和辅助栈中弹出一个元素时，辅助栈的栈顶都保存着数据栈的最小元素。由此我们也可以发现，在辅助栈中，新元素的值要么比上一层的值小，要么等于上一层的值。 1234567891011121314151617181920212223242526272829303132333435import java.util.Stack;public class Solution &#123; private Stack&lt;Integer&gt; data = new Stack&lt;&gt;(); private Stack&lt;Integer&gt; dataHelper = new Stack&lt;&gt;(); public void push(int node) &#123; data.push(node); if(dataHelper.isEmpty()) &#123; dataHelper.push(node); &#125; else &#123; if(node &lt; dataHelper.peek()) &#123; dataHelper.push(node); &#125; else &#123; dataHelper.push(dataHelper.peek()); &#125; &#125; &#125; public void pop() &#123; data.pop(); dataHelper.pop(); &#125; public int top() &#123; return data.peek(); &#125; public int min() &#123; return dataHelper.peek(); &#125;&#125; 31 栈的压入、弹出序列题目描述输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 题解使用一个栈来模拟压入、弹出的操作，可以得到以下规律： 如果下一个弹出的数字刚好是栈顶数字，直接弹出 否则，把压栈序列中还没有入栈的数字压入栈中，直到把下一个需要弹出的数字压入栈顶为止 压栈序列为空还没找到，离开循环 判断栈是否为空，为空则说明弹出序列匹配，否则，不匹配 1234567891011121314151617181920212223import java.util.ArrayList;import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; helper = new Stack&lt;&gt;(); public boolean IsPopOrder(int [] pushA,int [] popA) &#123; if(pushA == null || popA == null) return false; for(int i = 0, j = 0; i &lt; pushA.length; i++) &#123; helper.push(pushA[i]); while(!helper.isEmpty() &amp;&amp; j &lt; popA.length &amp;&amp; helper.peek() == popA[j]) &#123; helper.pop(); j++; &#125; &#125; return helper.isEmpty(); &#125;&#125; 32.1 从上往下打印二叉树题目描述从上往下打印出二叉树的每个节点，同层节点从左至右打印。 题解每次打印一个节点的时候，如果该节点有子节点，就把子节点加入到队列中，然后再从队列头取首元素并打印，重复以上操作，直至队列为空。 123456789101112131415161718192021222324import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null) return list; queue.add(root); while(queue.size() != 0) &#123; TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) &#123; queue.add(node.left); &#125; if(node.right != null) &#123; queue.add(node.right); &#125; &#125; return list; &#125;&#125; 32.2 把二叉树打印成多行题目描述从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 题解用两个变量分别记录当前行还剩余的节点与下一行需要打印的节点。每打印完一行，都将下一行需要打印的节点数赋给当前剩余节点数，并将自身置0，以便重新开始新的一行。 123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); if(root == null) return listAll; int toBePrinted = 1; //当前层中还没打印的节点数 int nextLevel = 0; //下一层的节点数 queue.add(root); while(queue.size() != 0) &#123; TreeNode node = queue.poll(); list.add(node.val); if(node.left != null) &#123; queue.add(node.left); nextLevel++; &#125; if(node.right != null) &#123; queue.add(node.right); nextLevel++; &#125; toBePrinted--; if(toBePrinted == 0) &#123; listAll.add(list); list = new ArrayList&lt;&gt;(); toBePrinted = nextLevel; nextLevel = 0; &#125; &#125; return listAll; &#125;&#125; 32.3 按之字形顺序打印二叉树题目描述请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 题解如果当前节点在奇数层，则将子节点以从左往右的顺序入栈；如果当前节点在偶数层，则将子节点以从右往左的顺序入栈。更简单地说：子节点入栈的方向与当前层节点弹出的方向一致。 在下面的算法中，用一个Stack数组保存当前层的栈与下一层的栈，用1和0表示奇数层和偶数层。当前层栈的节点弹出时，下一层栈的节点压入。如果当前层栈为空，则说明该行已经打印完成，将current与next置换（奇偶置换）后开始新的一行。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.LinkedList;import java.util.Queue;import java.util.Stack;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; Print(TreeNode root) &#123; if(root == null) return new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); Stack&lt;TreeNode&gt;[] stack = new Stack[2]; stack[0] = new Stack&lt;TreeNode&gt;(); stack[1] = new Stack&lt;TreeNode&gt;(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return listAll; int current = 1; //表示奇数层 int next = 0; //表示偶数层 stack[current].push(root); while(stack[current].size() != 0 || stack[next].size() != 0) &#123; TreeNode node = stack[current].pop(); list.add(node.val); if(current == 1) &#123; //如果在奇数层，则子节点从左往右入栈 if(node.left != null) &#123; stack[next].push(node.left); &#125; if(node.right != null) &#123; stack[next].push(node.right); &#125; &#125; else &#123; //如果在偶数层，则子节点从右往左入栈 if(node.right != null) &#123; stack[next].push(node.right); &#125; if(node.left != null) &#123; stack[next].push(node.left); &#125; &#125; if(stack[current].size() == 0) &#123; listAll.add(list); list = new ArrayList&lt;&gt;(); current = 1 - current; next = 1 - next; &#125; &#125; return listAll; &#125;&#125; 33 二叉搜索树的后序遍历序列题目描述输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 题解先以以下二叉树为例，其输入数组为{5, 7, 6, 9, 11, 10, 8}。 12345 8 / \ 6 10 / \ / \5 7 9 11 我们可以发现，数组的最后一个数字8就是二叉树的根节点，然后从数组开始进行遍历，凡是比8小的都属于根节点的左子树，其余的就是根节点的右子树，即{5, 7, 6, /9, 11, 10,/ 8}。我们在看看根节点的左子树，同样最后一个数字6是左子树的根节点，而5、7分别属于左子树根节点的左右子树。 再看看另一个例子：{7, 4, 6, 5}，由以上分析的规律可以发现，5为二叉树的根节点，而7、4、6都比5大，说明此二叉树没有左子树，而在右子树{7, 4, 6}中，7比6大，说明7在根节点的右子树中，而4却又比6小，这有违二叉树的定义，说明此数组不属于任何一个二叉树。 因此，我们可以使用递归来解决这个问题，先找到二叉树的根节点，再基于此根节点将数组拆分成左右子树，然后对左右子树分别进行递归。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence == null || sequence.length &lt;= 0) return false; return VerifySquenceOfBST(sequence, 0, sequence.length - 1); &#125; public boolean VerifySquenceOfBST(int [] sequence, int begin, int end) &#123; if(end-begin&lt;0) return true; int root = sequence[end]; int i = begin; for(;i &lt; end; i++) &#123; if(sequence[i] &gt; root) break; &#125; int j = i; for(;j &lt; end; j++) &#123; if(sequence[j] &lt; root) return false; &#125; boolean left = true; if(i &gt; 0) left = VerifySquenceOfBST(sequence, begin, i-1); boolean right = true; if(i &lt; end) right = VerifySquenceOfBST(sequence, i, end - 1); return (right &amp;&amp; left); &#125;&#125; 34 二叉树中和为某一值的路径题目描述输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)。 1234567891011/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解此题运用深度优先搜索的思想。从左开始向下深度遍历，遇到叶节点之后，判断其值是否等于target，如果相等则将此路径加入到所有路径的列表中。每次回退的时候，都要将路径最后一个节点删除。 此题需要注意，将某一路径加入到所有路径列表时，必须新建一个ArrayList，否则每次都是将对同一个对象的引用加入到listAll中，而java中通过引用是可以改变对象内部的属性的，所以每次对list进行remove操作都会影响到listAll中已加入的所有list，最后由于list会回退到根节点并把根节点remove掉，导致listAll的路径数目虽然正确，但每条路径列表都为空。 12345678910111213141516171819202122232425262728293031public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(root == null) return listAll; findPath(listAll, list, root, target); return listAll; &#125; public void findPath(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll, ArrayList&lt;Integer&gt; list, TreeNode root, int target) &#123; list.add(root.val); //如果为叶节点 if(root.left == null &amp;&amp; root.right == null) &#123; if(root.val == target) &#123; ArrayList&lt;Integer&gt; newList = new ArrayList&lt;&gt;(); newList.addAll(list); listAll.add(newList); &#125; list.remove(list.size() - 1); return; &#125; if(root.left != null) findPath(listAll, list, root.left, target-root.val); if(root.right != null) findPath(listAll, list, root.right, target-root.val); list.remove(list.size() - 1); return; &#125;&#125; 35 复杂链表的复制题目描述输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 1234567891011/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/ 题解解决此题大体有以下两个步骤： 1、根据原始链表的每个节点创建对应的复制节点 2、设置复制出来的节点的random节点 此题的关键在于定位random节点，需保证算法的时间复杂度在O(n)。 哈希表在第一步创建每个复制节点时，使用哈希表保存原节点与复制节点，之后设置random节点时，每当通过查找哈希表原节点的random节点便可以在O(1)的时间找到该复制节点应指向的random节点。此算法相当于以空间换时间，空间复杂度为O(n)。 这里需要注意，java中的map是不能直接使用iterator遍历的，因此需要先通过entrySet()方法获取set视图。 1234567891011121314151617181920212223242526272829303132import java.util.HashMap;import java.util.Iterator;import java.util.Map.Entry;public class Solution &#123; public RandomListNode Clone(RandomListNode head)&#123; if(head == null) return null; HashMap&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;(); RandomListNode cloneNodeHead = new RandomListNode(head.label); RandomListNode cloneNode = cloneNodeHead; map.put(head, cloneNode); while(head.next != null) &#123; RandomListNode nextNode = new RandomListNode(head.next.label); cloneNode.next = nextNode; cloneNode = cloneNode.next; head = head.next; map.put(head, cloneNode); &#125; Iterator&lt;Entry&lt;RandomListNode, RandomListNode&gt;&gt; it = map.entrySet().iterator(); while(it.hasNext()) &#123; Entry&lt;RandomListNode, RandomListNode&gt; entry = it.next(); //时间复杂度为O(1)，相当于以空间换时间 RandomListNode sib = map.get(entry.getKey().random); entry.getValue().random = sib; &#125; return cloneNodeHead; &#125;&#125; 更好的解法思路：在旧链表中创建新链表-&gt;根据旧链表的random节点初始化新链表的random节点-&gt;把新链表从旧链表中拆分出来。 此算法的时间复杂度为O(n)，且不需要辅助空间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class Solution &#123; public RandomListNode Clone(RandomListNode head) &#123; if(head == null) return null; CloneNodes(head); ConnectSiblingNodes(head); return ReconnectNodes(head); &#125; public void CloneNodes(RandomListNode head) &#123; RandomListNode test = head; while(head != null) &#123; RandomListNode cloneNode = new RandomListNode(head.label); RandomListNode next = head.next; head.next = cloneNode; cloneNode.next = next; head = next; &#125; &#125; public void ConnectSiblingNodes(RandomListNode head) &#123; while(head != null) &#123; RandomListNode cloneNode = head.next; if(head.random != null) &#123; cloneNode.random = head.random.next; &#125; head = head.next.next; &#125; &#125; public RandomListNode ReconnectNodes(RandomListNode head) &#123; RandomListNode cloneNode = head.next; RandomListNode cloneNodeHead = cloneNode; while(head != null) &#123; RandomListNode next = head.next.next; RandomListNode cloneNext; //防止在最后一个节点处报空指针异常 if(next == null) &#123; cloneNext = null; &#125; else &#123; cloneNext = cloneNode.next.next; &#125; head.next = next; cloneNode.next = cloneNext; head = next; cloneNode = cloneNext; &#125; return cloneNodeHead; &#125;&#125; 36 二叉搜索树与双向链表题目描述输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 1234567891011/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/ 题解1234567891011121314151617181920212223public class Solution &#123; public TreeNode Convert(TreeNode root) &#123; if(root == null) return null; if(root.left == null &amp;&amp; root.right == null) return root; TreeNode left = Convert(root.left); TreeNode p = left; while(p != null &amp;&amp; p.right != null) &#123; p = p.right; &#125; if(left != null) &#123; root.left = p; p.right = root; &#125; TreeNode right = Convert(root.right); if(right != null) &#123; root.right = right; right.left = root; &#125; return left != null ? left : root; &#125;&#125; 37 序列化二叉树题目描述请实现两个函数，分别用来序列化和反序列化二叉树 题解123456789101112131415161718192021222324252627public class Solution &#123; private int index = -1; String Serialize(TreeNode root) &#123; StringBuilder str = new StringBuilder(); if(root == null) &#123; str.append("$,"); return str.toString(); &#125; str.append(root.val+","); str.append(Serialize(root.left)); str.append(Serialize(root.right)); return str.toString(); &#125; TreeNode Deserialize(String str) &#123; String[] newStr = str.split(","); index++; if(index &lt; str.length() &amp;&amp; !newStr[index].equals("$")) &#123; TreeNode root = new TreeNode(Integer.valueOf(newStr[index])); root.left = Deserialize(str); root.right = Deserialize(str); return root; &#125; return null; &#125;&#125; 38 字符串的排列题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 题解回溯法： 123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.List;import java.util.Collections;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); if(str == null || str.length() == 0) return list; Permutation(str.toCharArray(), 0, list); Collections.sort(list); return list; &#125; public void Permutation(char[] c, int i, ArrayList&lt;String&gt; list) &#123; if(i == c.length) &#123; String str = String.valueOf(c); if(!list.contains(str)) list.add(String.valueOf(c)); return; &#125; else &#123; for(int j = i; j &lt; c.length; j++) &#123; swap(c, i, j); Permutation(c, i+1, list); swap(c, i, j); &#125; &#125; &#125; public void swap(char[] c, int i, int j)&#123; char temp; temp = c[i]; c[i] = c[j]; c[j] = temp; &#125;&#125; 39 数组中出现次数超过一半的数字题目描述数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 题解基于辅助数组的解法此种解法利用了辅助数组，在辅助数组中以原始数组的值为索引存储该值出现的次数，一旦次数超过原始数组的一半，则跳出循环返回该值。该解法空间复杂度为O(n)，相当于以空间换时间，且由于数组的限制，事先必须要知道原始数组中值的范围，若要克服后者，可以使用其它数据结构。 1234567891011121314151617181920public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array == null || array.length == 0) &#123; return 0; &#125; int length = array.length; int[] helper = new int[length+1]; int result = 0; for(int i = 0; i &lt; length; i++) &#123; helper[array[i]]++; if(helper[array[i]] &gt; length / 2) &#123; result = array[i]; break; &#125; &#125; return result; &#125;&#125; 多数投票算法多数投票算(摩尔投票算法)：定义一个结果变量和一个计数器，初始化的情况下计数器为0. 算法依次扫描序列中的元素，当处理某元素的时候，如果计数器为0，那么将该元素赋值给结果变量，然后将计数器设置为1，如果计数器不为0，那么将结果变量和该元素比较，如果相等，那么计数器加1，如果不等，那么计数器减1。处理之后，最后存储的结果变量就是这个数组中超过一半以上的元素。 需注意：如果一个元素的出现次数超过数组长度的一半，那么结果变量肯定为该元素，但结果变量元素的出现次数不一定超过数组长度的一半，因此需要进行第二次遍历确认。 12345678910111213141516171819202122232425262728293031public class Solution &#123; public int MoreThanHalfNum_Solution(int [] array) &#123; if(array == null || array.length == 0) &#123; return 0; &#125; int result = array[0]; int n = 1; for(int i = 1; i &lt; array.length; i++) &#123; if(n == 0) &#123; result = array[i]; n = 1; &#125; else if(array[i] == result) n++; else n--; &#125; n = 0; for(int i = 0; i &lt; array.length; i++) &#123; if(array[i] == result) &#123; n++; &#125; &#125; if(n &lt;= array.length / 2) return 0; return result; &#125;&#125; 40 最小的k个数题目描述输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 题解123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.PriorityQueue;import java.util.Comparator;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int [] input, int k) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if(input == null || input.length &lt;= 0 || k &lt; 1 || k &gt; input.length) &#123; return list; &#125; PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;&gt;(k+1, new Comparator&lt;Integer&gt;() &#123; public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); for(int i = 0; i &lt; input.length; i++) &#123; heap.add(input[i]); if(heap.size() &gt; k) &#123; heap.poll(); &#125; &#125; for(Integer i : heap) &#123; list.add(i); &#125; return list; &#125;&#125; 41 数据流中的中位数题目描述如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 题解用最大堆与最小堆来实现，插入的时间复杂度为O(log(n))。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import java.util.PriorityQueue;import java.util.Comparator;public class Solution &#123; PriorityQueue&lt;Integer&gt; max = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o2.compareTo(o1); &#125; &#125;); PriorityQueue&lt;Integer&gt; min = new PriorityQueue&lt;&gt;(new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1.compareTo(o2); &#125; &#125;); public void Insert(Integer num) &#123; if((min.size()+max.size() &amp; 1) == 0) &#123; //如果当前总数是偶数，则插入到最大堆 if(min.size() != 0 &amp;&amp; num &gt; min.peek()) &#123; //如果最小堆的数目不为0，且新插入的数字比最小堆的头要大 int temp = min.poll(); max.add(temp); min.add(num); &#125; else &#123; //插入到最大堆 max.add(num); &#125; &#125; else &#123; //如果当前总数是奇数，则插入到最小堆 if(max.size() != 0 &amp;&amp; num &lt; max.peek()) &#123; //同理 int temp = max.poll(); min.add(temp); max.add(num); &#125; else &#123; min.add(num); &#125; &#125; &#125; public Double GetMedian() &#123; int size = max.size() + min.size(); Double d; if(size == 0) return -1.0; if((size &amp; 1) != 0) &#123; d = Double.valueOf(max.peek()); &#125; else &#123; d = (double) (max.peek() + min.peek()) / 2; &#125; return d; &#125;&#125; 42 连续子数组的最大和题目描述HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 题解1234567891011121314151617181920public class Solution &#123; public int FindGreatestSumOfSubArray(int[] data) &#123; if(data == null ||data.length &lt;= 0)&#123; return 0; &#125; int sum=data[0], max=data[0]; for(int i = 1; i &lt; data.length; i++)&#123; if(sum &lt;= 0)&#123; sum = data[i]; &#125; else&#123; sum += data[i]; &#125; if(sum &gt; max)&#123; max = sum; &#125; &#125; return max; &#125;&#125; 44 数字序列中某一位的数字题目描述数字以 0123456789101112131415… 的格式序列化到一个字符串中，求这个字符串的第 index 位。 题解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public int digitAtIndex(int index) &#123; if(index &lt; 0) return -1; int digits = 1; //digits表示有几位数，初始为一位数 while(true) &#123; int numbers = countOfIntegers(digits); //返回当前位数共有多少个数 if(index &lt; numbers * digits) &#123; //数字的个数乘位数能得到具体的某一位数字的下标 return digitAtIndex(index, digits); &#125; index -= digits * numbers; //如果要查找的数字不在这位数里面，则跳过这些数字 digits++; //位数加一 &#125; &#125; /* * 在n位数中的第index个数 */ private int digitAtIndex(int index, int digits) &#123; int number = beginNumber(digits) + index / digits; int indexFromRight = digits - index % digits; //得到在查找到的数字中具体从右数的哪一位 for(int i = 1; i &lt; indexFromRight; i++) &#123; number /= 10; &#125; return number % 10; &#125; /* * 计算n位的数字总共有多少，如二位数有10~99这90个数，三位数有100~999这900个数 */ private int countOfIntegers(int digits) &#123; if(digits == 1) return 10; int count = (int) Math.pow(10, digits-1); return count * 9; &#125; /* * 计算n位数的第一个数字，如二位数的第一个数字是10，三位数的第一个数字是100 */ private int beginNumber(int digits) &#123; if(digits == 1) return 0; return (int)Math.pow(10, digits-1); &#125;&#125; 45 把数组排成最小的数题目描述输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 题解本题的关键在于定义一个规则判断两个数中谁应该排在前面，应该排在前面的数我们称其“小于”另一个数。例如，令m=32，n=2，则mn=322，nm=232，因为nm&lt;mn，我们就称n小于m。之后我们便可使用这个比较方法（比较器）对数组中的所有元素进行排序即可。 123456789101112131415161718192021222324252627282930import java.util.Arrays;import java.util.Comparator;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; if(numbers == null || numbers.length &lt;= 0) return ""; StringBuilder res = new StringBuilder(); int len = numbers.length; String[] str = new String[len]; for(int i = 0; i &lt; len; i++) &#123; str[i] = numbers[i] + ""; &#125; Arrays.sort(str, new Comparator&lt;String&gt;() &#123; public int compare(String o1, String o2) &#123; String str1 = o1 + o2; String str2 = o2 + o1; return str1.compareTo(str2); &#125; &#125;); for(String s : str) &#123; res.append(s); &#125; return res.toString(); &#125;&#125; 46 把数字翻译成字符串题目描述给定一个数字，按照如下规则翻译成字符串：0 翻译成“a”，1 翻译成“b”… 25 翻译成“z”。一个数字有多种翻译可能，例如 12258 一共有 5 种，分别是 bccfi，bwfi，bczi，mcfi，mzi。实现一个函数，用来计算一个数字有多少种不同的翻译方法。 题解如果用递归方法从上往下求解，必然会遇到许多重复的计算，因此可以从下往上进行求解。 我们可以先得到方程f(i) = f(i+1) + af(i+2)，当第i个数与第i+1个数组成的数字在10-25的范围内，则a=1，否则a=0。以字符串“13225”为例，下标为0和1的数分别是1和3，组成的13是在10-25的范围内的，因此可以将其看成剩下的3225或者225这两种组合方式。以上是自顶向下的分析，再看看自底向上的实现，以下标为2的数2为例，首先就单独把这个数进行翻译，则加上上一个数的计算结果，又因为上一个数2和它组成的22是在10-25的范围内的，所以可以把它们组合在一起翻译，基于这种情况则再加上上上个数的结果，这两种情况的结果相加就是自底到这一个数的计算结果。一直循环到第一个数，dp[0]便是最终答案。 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int numDecodings(String s) &#123; if(s == null || s.length() &lt;= 0) return 0; int count = 0; int n = s.length() - 1; int[] dp = new int[n+1]; for(int i = n; i &gt;= 0; i--) &#123; count = 0; if(i == n) &#123; count = 1; &#125; else &#123; count += dp[i+1]; &#125; if(i &lt; n) &#123; int num1 = s.charAt(i)-'0'; int num2 = s.charAt(i+1)-'0'; int num = num1 * 10 + num2; if(num &gt;= 10 &amp;&amp; num &lt;= 25) &#123; if(i &lt; n-1) &#123; count += dp[i+2]; &#125; else &#123; count++; &#125; &#125; &#125; dp[i] = count; &#125; return dp[0]; &#125;&#125; 47 礼物的最大价值题目描述小东所在公司要发年终奖，而小东恰好获得了最高福利，他要在公司年会上参与一个抽奖游戏，游戏在一个6*6的棋盘上进行，上面放着36个价值不等的礼物，每个小的棋盘上面放置着一个礼物，他需要从左上角开始游戏，每次只能向下或者向右移动一步，到达右下角停止，一路上的格子里的礼物小东都能拿到，请设计一个算法使小东拿到价值最高的礼物。 给定一个6*6的矩阵board，其中每个元素为对应格子的礼物价值,左上角为[0,0],请返回能获得的最大价值，保证每个礼物价值大于100小于1000。 题解使用动态规划的思路：f(i,j) = max(f(i-1,j), f(i,j-1))，每一个坐标(i,j)的解只需要依赖其左边与上边的坐标，且最左边坐标的解只依赖上边的坐标，因此只需要一个一维数组作为缓存即可，该数组存有i行j列左边的所有解以及i-1行j列右边的所有解。 12345678910111213141516public class Solution &#123; public int getMost(int[][] values) &#123; if(values == null || values.length == 0 || values[0].length == 0) return 0; int n = values[0].length; int[] dp = new int[n]; for(int[] value : values) &#123; dp[0] += value[0]; for(int i = 1; i &lt; n; i++) &#123; dp[i] = Math.max(dp[i], dp[i-1]) + value[i]; &#125; &#125; return dp[n-1]; &#125;&#125; 48 最长不含重复字符的子字符串题目描述输入一个字符串（只包含 a~z 的字符），求其最长不含重复字符的子字符串的长度。例如对于 arabcacfr，最长不含重复字符的子字符串为 acfr，长度为 4。 题解1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public int LongestSubstringWithoutDupSolution(String str) &#123; if(str == null || str.length() &lt;= 0) return 0; int maxLen = 0; int curLen = 0; int[] position = new int[26]; for(int i = 0; i &lt; 26; i++) &#123; position[i] = -1; &#125; for(int i = 0; i &lt; str.length(); i++) &#123; //当前字母在position的下标index int index = str.charAt(i) - 'a'; if(position[index] &lt; 0) &#123; //如果这个字母之前没出现过 curLen += 1; &#125; else &#123; if(i-position[index] &lt;= curLen) &#123; curLen = i-position[index]; &#125; else &#123; curLen += 1; &#125; &#125; position[index] = i; if(curLen &gt; maxLen) maxLen = curLen; &#125; return maxLen; &#125;&#125; 49 丑数题目描述把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 题解12345678910111213141516171819202122public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 6) return index; int[] ugly = new int[index]; ugly[0] = 1; int t2=0, t3=0, t5=0; for(int i = 1; i &lt; index; i++) &#123; ugly[i] = Math.min(ugly[t2]*2, Math.min(ugly[t3]*3, ugly[t5]*5)); while(ugly[t2] * 2 &lt;= ugly[i]) t2++; while(ugly[t3] * 3 &lt;= ugly[i]) t3++; while(ugly[t5] * 5 &lt;= ugly[i]) t5++; &#125; return ugly[ugly.length-1]; &#125;&#125; 50.1 第一个只出现一次的字符题目描述在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 题解123456789101112131415161718192021222324252627282930import java.util.HashMap;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str == null) return -1; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); int index = -1; for(int i = 0; i &lt; str.length(); i++) &#123; char curr = str.charAt(i); if(!map.containsKey(curr)) &#123; map.put(curr, 1); &#125; else &#123; int value = map.get(curr); map.put(curr, ++value); &#125; &#125; for(int i = 0; i &lt; str.length(); i++) &#123; char curr = str.charAt(i); if(map.get(curr) == 1) &#123; index = i; break; &#125; &#125; return index; &#125;&#125; 50.2 字符流中第一个不重复的字符题目描述请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 题解1234567891011121314151617181920212223242526272829303132public class Solution &#123; private int[] map = new int[256]; private int index = 0; public Solution() &#123; for(int i = 0; i &lt; map.length; i++) &#123; map[i] = -1; //-1代表从未出现过 &#125; &#125; //Insert one char from stringstream public void Insert(char ch) &#123; if(map[ch] == -1) &#123; map[ch] = index; //从未出现过，将它的下标赋值给它 &#125; else &#123; map[ch] = -2; //出现过，则值为-2 &#125; index++; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; char result = '#'; int minIndex = Integer.MAX_VALUE; for(int i = 0; i &lt; map.length; i++) &#123; if(map[i] &gt;= 0 &amp;&amp; map[i] &lt; minIndex) &#123; minIndex = map[i]; result = (char)i; &#125; &#125; return result; &#125;&#125; 51 数组中的逆序对题目描述在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 题解统计逆序对的过程：先把数组分隔成子数组，统计出子数组内部的逆序对的数目，然后再统计出两个相邻子数组之间的逆序对的数目。在统计逆序对的过程中，还需要对数组进行归并排序，而计算逆序对数目其实就是在进行归并排序的时候完成的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; private long cnt = 0; private int[] tmp; public int InversePairs(int [] array) &#123; tmp = new int[array.length]; if(array == null || array.length &lt;= 0) &#123; return -1; &#125; mergeSort(array, 0, array.length-1); return (int) (cnt % 1000000007); &#125; private void mergeSort(int[] a, int lo, int hi) &#123; if(hi &lt;= lo) return; int m = lo + (hi - lo) / 2; mergeSort(a, lo, m); mergeSort(a, m+1, hi); merge(a, lo, m, hi); &#125; private void merge(int[] a, int lo, int m, int hi) &#123; int i = lo, j = m+1, k = lo; while(k &lt;= hi) &#123; if(i &gt; m) &#123; tmp[k] = a[j++]; &#125; else if(j &gt; hi) &#123; tmp[k] = a[i++]; &#125; else if(a[i] &lt; a[j]) &#123; tmp[k] = a[i++]; &#125; else &#123; tmp[k] = a[j++]; cnt += m - i + 1; &#125; k++; &#125; for(k = lo; k &lt;= hi; k++) &#123; a[k] = tmp[k]; &#125; &#125;&#125; 52 两个链表的第一个公共结点题目描述输入两个链表，找出它们的第一个公共结点。 12345678public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125; 题解此题大体有两种思路： 1、如果从后往前遍历两条链表，那么最后一个相同的节点就是我们要找的节点。这种思路要解决的问题在于链表是单向链表，该怎么逆序遍历链表。 2、如果从前往后遍历两条链表，那么第一个相同的节点就是我们要找的节点。这种思路要解决的问题在于如果两条链表的长度不同，便无法同时到达第一个公共节点，进而也就无法比较是否相等。 思路一：以空间换时间将两个链表分别装到两个栈中，每次取出链表尾部的一个节点判断是否相等，最后一个相等的节点即为两个链表的第一个公共节点。 1234567891011121314151617181920212223242526272829public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if(pHead1 == null || pHead2 == null) return null; Stack&lt;ListNode&gt; stack1 = new Stack&lt;&gt;(); Stack&lt;ListNode&gt; stack2 = new Stack&lt;&gt;(); ListNode h1 = pHead1; ListNode h2 = pHead2; ListNode common = null; while(h1!=null) &#123; stack1.push(h1); h1 = h1.next; &#125; while(h2 != null) &#123; stack2.push(h2); h2 = h2.next; &#125; while(!stack1.empty() &amp;&amp; !stack2.empty()) &#123; ListNode node1 = stack1.pop(); ListNode node2 = stack2.pop(); if(node1 == node2) &#123; common = node1; &#125; &#125; return common; &#125;&#125; 思路二：进一步优化上一种思路需要两个栈作为辅助空间，其实完全可以不用辅助空间，先分别遍历两个链表并记录他们的长度，长链表先走几步以此和短链表在同一起点出发，之后便可以同时遍历直至找出相同的节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if(pHead1 == null || pHead2 == null) return null; int len1 = 0; int len2 = 0; int diff; //两条链表的长度差 ListNode listLong; //标识链表的长短 ListNode listShort; ListNode h1 = pHead1; //用于遍历的节点 ListNode h2 = pHead2; while(h1!=null) &#123; len1++; h1 = h1.next; &#125; while(h2 != null) &#123; len2++; h2 = h2.next; &#125; if(len1 &gt; len2) &#123; listLong = pHead1; listShort = pHead2; diff = len1 - len2; &#125; else &#123; listLong = pHead2; listShort = pHead1; diff = len2 - len1; &#125; for(int i = 0; i &lt; diff; i++) &#123; listLong = listLong.next; &#125; while(listLong != null &amp;&amp; listShort != null) &#123; if(listLong == listShort) return listLong; listLong = listLong.next; listShort = listShort.next; &#125; return null; &#125;&#125; 53.1 数字在排序数组中出现的次数题目描述统计一个数字在排序数组中出现的次数。 题解最直观的做法是顺序扫描，时间复杂度为O(n)，不是最优解。由于输入的数组是排序的，那么就可以用二分查找的思路，找到第一个要查找的数字和最后一个要查找的数字，其坐标差即为该数字出现的次数。此时时间复杂度为O(logn)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; if(array == null || array.length &lt;= 0) return 0; int start = getFirstK(array, k); int end = getLastK(array, k); int num = 0; if(start != -1 &amp;&amp; end != -1) &#123; num = end - start + 1; &#125; return num; &#125; public int getFirstK(int[] array, int k) &#123; int lo = 0; int hi = array.length - 1; int middle; while(lo &lt;= hi) &#123; middle = lo + (hi - lo) / 2; if(array[middle] &lt; k) &#123; lo = middle + 1; &#125; else if(array[middle] &gt; k) &#123; hi = middle - 1; &#125; else &#123; if(middle - 1 &gt;= 0 &amp;&amp; array[middle - 1] == k) &#123; hi = middle - 1; &#125; else &#123; return middle; &#125; &#125; &#125; return -1; &#125; public int getLastK(int[] array, int k) &#123; int lo = 0; int hi = array.length - 1; int middle; while(lo &lt;= hi) &#123; middle = lo + (hi - lo) / 2; if(array[middle] &lt; k) &#123; lo = middle + 1; &#125; else if(array[middle] &gt; k) &#123; hi = middle - 1; &#125; else &#123; if(middle + 1 &lt; array.length &amp;&amp; array[middle + 1] == k) &#123; lo = middle + 1; &#125; else &#123; return middle; &#125; &#125; &#125; return -1; &#125;&#125; 53.2 0至n-1中缺失的数字题目描述在范围0~n-1内的n个数字中有且只有一个数字不在长度为n-1的递增排序数组（数字唯一）中，请找出这个数字。例如，{1,2,3,4}中少了0，{0,1,2,3}中少了4，{0,1,3,4}中少了2。 题解用二分查找法找到第一个数字与下标不同的元素。 12345678910111213141516171819202122public class Solution &#123; public int getMissingNumber(int[] array) &#123; if(array == null || array.length &lt;= 0) return -1; int lo = 0; int hi = array.length - 1; int middle; while(lo &lt;= hi) &#123; middle = lo + (hi - lo) / 2; if(array[middle] == middle) &#123; lo = middle + 1; &#125; else &#123; if(middle - 1 &gt;= 0 &amp;&amp; array[middle - 1] != middle - 1) &#123; hi = middle - 1; &#125; else &#123; return middle; &#125; &#125; &#125; return array.length; &#125;&#125; 53.3 数组中数值和下标相等的元素题目描述假设一个单调递增的数组里的每个元素都是整数并且是唯一的。请编写实现一个函数，找出数组中任意一个数值等于其下标的元素。 题解由于每个数都是唯一的，如果第i个数字的值大于i，那么它右边的数字都大于对应的下标；如果第i个数字的值小于i，那么它左边的数字都小于对应的下标。 123456789101112131415161718192021222324public class Solution &#123; public int IntegerIdenticalToIndex(int[] array) &#123; if(array == null || array.length &lt;= 0) return -1; int lo = 0; int hi = array.length - 1; int middle; while(lo &lt;= hi) &#123; middle = lo + (hi - lo) / 2; if(array[middle] &gt; middle) &#123; hi = middle - 1; &#125; else if(array[middle] &lt; middle) &#123; lo = middle + 1; &#125; else &#123; if(middle - 1 &gt;= 0 &amp;&amp; array[middle - 1] == middle - 1) &#123; hi = middle - 1; &#125; else &#123; return middle; &#125; &#125; &#125; return -1; &#125;&#125; 54 二叉搜索树的第k个结点题目描述给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。 123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 题解12345678910111213141516171819202122public class Solution &#123; private int cnt; private TreeNode target; TreeNode KthNode(TreeNode pRoot, int k) &#123; if(pRoot == null || k &lt;= 0) return null; KthNodeCore(pRoot, k); return target; &#125; void KthNodeCore(TreeNode pRoot, int k) &#123; if(pRoot == null || target != null) &#123; return; &#125; KthNodeCore(pRoot.left, k); cnt++; if(cnt == k) target = pRoot; KthNodeCore(pRoot.right, k); &#125;&#125; 55.1 二叉树的深度题目描述输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 123456789public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125; 题解123456789public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root == null) return 0; int left = TreeDepth(root.left); int right = TreeDepth(root.right); return left &gt; right ? (left+1):(right+1); &#125;&#125; 55.2 平衡二叉树题目描述输入一棵二叉树，判断该二叉树是否是平衡二叉树。 题解1234567891011121314151617public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return IsBalanced(root) != -1; &#125; public int IsBalanced(TreeNode root) &#123; if(root == null) return 0; int left = IsBalanced(root.left); if(left == -1) return left; int right = IsBalanced(root.right); if(right == -1) return right; return Math.abs(left-right) &gt; 1 ? -1 : 1+Math.max(left,right); &#125;&#125; 56.1 数组中只出现一次的数字题目描述一个整型数组里除了两个数字之外，其他的数字都出现了偶数次。请写程序找出这两个只出现一次的数字。 题解因为任何一个数字异或它自己都等于0，而0异或任何一个数字都等于其本身，所以可以将数组中的所有数字都异或，例如对于含有一个数字只出现一次的数组{3,3,4,4,6}：123 3 ^ 3 ^ 4 ^ 4 ^ 6-&gt; 0 ^ 0 ^ 6-&gt; 6 而在此题中，数组里有两个数字只出现了一次，所以从头到尾异或数组中的每个数字会得到这两个数字的异或结果，由于这两个数字肯定不同，所以异或结果至少会包含一个1，我们以最右侧的1为标准将这两个数分到两个子数组中，于此同时这一位为1或0的出现两次的数字也会分别到这两个子数组中，然后再对两个子数组运用最上面的思路。 在这里，diff &amp;= -diff可以得到只有最右侧为1的数，以此作为分割标准。（在计算机中，负数以其正值的补码形式表达，补码=反码+1） 1234567891011121314public class Solution &#123; public void FindNumsAppearOnce(int[] nums, int num1[], int num2[]) &#123; int diff = 0; for (int num : nums) diff ^= num; diff &amp;= -diff; for (int num : nums) &#123; if ((num &amp; diff) == 0) num1[0] ^= num; else num2[0] ^= num; &#125; &#125;&#125; 56.2 数组中唯一只出现一次的数字题目描述在一个数组中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 题解把数组中所有数字的二进制表示的每一位都加起来，如果某一位的和能被3整除，那么那个只出现一次的数字二进制表示中对应的那一位是0，否则就是1。 1234567891011121314151617181920212223public class NumberAppearingOnce &#123; public int solution(int numbers[]) &#123; if(numbers == null || numbers.length == 0) return -1; int[] bitSum = new int[32]; for(int i = 0; i &lt; numbers.length; i++) &#123; int bitMask = 1; for(int j = 31; j &gt;= 0; j--) &#123; int bit = numbers[i] &amp; bitMask; if(bit != 0) bitSum[j] += 1; bitMask = bitMask &lt;&lt; 1; &#125; &#125; int result = 0; for(int i = 0; i &lt; 32; i++) &#123; result = result &lt;&lt; 1; result += bitSum[i] % 3; &#125; return result; &#125;&#125; 57.1 和为s的两个数字题目描述输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 题解定义两个指针，一个指向数组头，一个指向数组末尾，如果指针指向的这两个数字相加小于S，则将头指针向后移动一位，否则将尾指针向前移动一位。 12345678910111213141516171819202122232425import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int [] array,int sum) &#123; ArrayList&lt;Integer&gt; result = new ArrayList&lt;&gt;(); if(array == null || array.length == 0) return result; int lo = 0; int hi = array.length - 1; while(lo &lt; hi) &#123; int curSum = array[lo] + array[hi]; if(curSum &lt; sum) &#123; lo++; &#125; else if(curSum &gt; sum) &#123; hi--; &#125; else &#123; result.add(array[lo]); result.add(array[hi]); break; &#125; &#125; return result; &#125;&#125; 57.2 和为s的连续正数序列题目描述小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 题解首先把lo和hi分别初始化为1和2（因为连续序列为正，且至少含有两个数字），如果lo和hi之间的数字相加大于S，将lo加一，而如果lo和hi之间的数字相加小于S，则将hi加一。 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt; &gt; FindContinuousSequence(int sum) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; listAll = new ArrayList&lt;&gt;(); if(sum &lt;= 0) return listAll; int lo = 1; int hi = 2; int middle = sum / 2; int curSum = lo + hi; while(lo &lt;= middle) &#123; if(curSum &lt; sum) &#123; hi++; curSum += hi; &#125; else if(curSum &gt; sum) &#123; curSum -= lo; lo++; &#125; else &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); int i = lo; while(i &lt;= hi) list.add(i++); listAll.add(list); curSum += ++hi; &#125; &#125; return listAll; &#125;&#125; 58.1 翻转单词序列题目描述牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 题解进行两次翻转：首先将整体进行翻转，得到.tneduts a ma I，再将每个单词进行局部翻转，得到student. a am I即为答案。 123456789101112131415161718192021222324252627282930public class Solution &#123; public String ReverseSentence(String str) &#123; if(str == null) return null; else if(str == "") return ""; char[] data = str.toCharArray(); int i = 0, j = data.length-1; reverse(data, i, j); j = 0; while(i &lt; data.length) &#123; if(j == data.length || data[j] == ' ') &#123; reverse(data, i, j-1); i = j + 1; &#125; j++; &#125; return new String(data); &#125; private void reverse(char[] data, int i, int j) &#123; while(i &lt;= j) &#123; char temp = data[i]; data[i] = data[j]; data[j] = temp; i++; j--; &#125; &#125;&#125; 58.2 左旋转字符串题目描述汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 题解1234567891011121314151617181920212223242526public class Solution &#123; public String LeftRotateString(String str,int n) &#123; if(str == null) return null; else if(str == "") return ""; else if(n &gt;= str.length()) return str; char[] data = str.toCharArray(); reverse(data, 0, n-1); reverse(data, n, data.length-1); reverse(data, 0, data.length-1); return new String(data); &#125; private void reverse(char[] data, int i, int j) &#123; while(i &lt;= j) &#123; char temp = data[i]; data[i] = data[j]; data[j] = temp; i++; j--; &#125; &#125;&#125; 60 n个骰子的点数题目描述把 n 个骰子仍在地上，求点数和为 s 的概率。 题解我们以n表示要扔的骰子数，s为所有骰子的点数之和，f(n, s)表示扔n个骰子时所有骰子的点数之和为s的排列情况总数。例如，n=2，s=5时，f(n, s) = f(2, 5) = 4 （4种情况即{1, 4}, {4, 1}, {2, 3}, {3, 2}） 因为一个骰子有六个点数，那么第n个骰子可能出现1到6的点数，当第n个骰子点数为1的话，f(n,s) = f(n-1, s-1)，当第n个骰子点数为2的话，f(n,s) = f(n-1, s-2)，…，依次类推。 由以上分析我们便可以得到状态转移方程：f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6) 使用递归得到状态方程后，最直观的就是使用递归求解。点数和的最小值为骰子数n，而最大值为6 * n。 1234567891011121314151617181920212223242526public class Solution &#123; public List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(int n) &#123; List&lt;Map.Entry&lt;Integer, Double&gt;&gt; result = new ArrayList&lt;&gt;(); int minSum = n; int maxSum = 6 * n; double totalCase = Math.pow(6, n); for(int i = minSum; i &lt;= maxSum; i++) &#123; result.add(new AbstractMap.SimpleEntry&lt;&gt;(i, dicesSumCore(n, i) / totalCase)); &#125; return result; &#125; private int dicesSumCore(int n, int sum)&#123; if(n&lt;1||sum&lt;n||sum&gt;6*n)&#123; return 0; &#125; if(n==1)&#123; return 1; &#125; int resCount=0; resCount=dicesSumCore(n-1,sum-1)+dicesSumCore(n-1,sum-2)+ dicesSumCore(n-1,sum-3)+dicesSumCore(n-1,sum-4)+ dicesSumCore(n-1,sum-5)+dicesSumCore(n-1,sum-6); return resCount; &#125;&#125; 动态规划使用递归求解会产生大量重复的计算，所以使用动态规划更好。 在以下代码中使用了一个二维数组dp[2][maxSum+1]，dp[0]和dp[1]表示当前状态和前一个状态（由状态转移方程f(n,s)=f(n-1,s-1)+f(n-1,s-2)+f(n-1,s-3)+f(n-1,s-4)+f(n-1,s-5)+f(n-1,s-6)可以看出当前状态仅依赖前一个状态，所以只用两个一维数组即可），而这两个状态的数组使用flag变量进行旋转。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public List&lt;Map.Entry&lt;Integer, Double&gt;&gt; dicesSum(int n) &#123; List&lt;Map.Entry&lt;Integer, Double&gt;&gt; result = new ArrayList&lt;&gt;(); if(n &lt; 1) return result; int face = 6; int minSum = n; int maxSum = face * n; int flag = 1; double totalCase = Math.pow(face, n); //总共有6的n次方种排列情况 long[][] dp = new long[2][maxSum+1]; //dp[flag][j]表示当前状态下产生点数和为j的排列次数 //设置初始状态，即f(1,1) = f(1,2) = f(1,3) = f(1,4) = f(1,5) = f(1,6) = 1 for(int i = 1; i &lt;= face; i++) dp[0][i] = 1; //i表示当前扔出的骰子数，骰子数为1的情况在上面已经有过初始化 for (int i = 2; i &lt;= n; i++, flag = 1 - flag) &#123; //将表示当前状态的数组清零 for (int j = 0; j &lt;= maxSum; j++) dp[flag][j] = 0; for (int j = i; j &lt;= maxSum; j++) for (int k = 1; k &lt;= face &amp;&amp; k &lt;= j; k++) //此处即体现出状态转移方程 dp[flag][j] += dp[1 - flag][j - k]; &#125; for(int i = minSum; i &lt;= maxSum; i++) &#123; result.add(new AbstractMap.SimpleEntry&lt;&gt;(i, dp[1 - flag][i] / totalCase)); &#125; return result; &#125;&#125; 61 扑克牌顺子题目描述从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。大小王可看成任意数字。 题解把大小王看成0，首先把数组排序，其次统计数组中0的个数，最后统计排序后的数组中相邻数字之间的空缺总数。如果空缺总数小于或者等于0的个数，那么这个数组就是连续的。 123456789101112131415161718192021222324import java.util.Arrays;public class Solution &#123; public boolean isContinuous(int [] numbers) &#123; if(numbers == null || numbers.length == 0) return false; int numOfZero = 0; int numOfGap = 0; Arrays.sort(numbers); for(int i = 0; i &lt; numbers.length &amp;&amp; numbers[i] == 0; i++) &#123; numOfZero++; &#125; for(int i = numOfZero+1; i &lt; numbers.length; i++) &#123; if(numbers[i] == numbers[i-1]) return false; numOfGap += numbers[i] - numbers[i-1] - 1; &#125; return numOfZero &gt;= numOfGap ? true : false; &#125;&#125; 62 圆圈中最后剩下的数字题目描述首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 题解环形链表法采用链表来模拟整个过程。 1234567891011121314151617181920import java.util.LinkedList;public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n &lt; 1 || m &lt; 1) return -1; LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); int index = 0; for(int i = 0; i &lt; n; i++) &#123; list.add(i); &#125; while(list.size() &gt; 1) &#123; index = (index + m - 1) % list.size(); list.remove(index); &#125; return list.get(0); &#125;&#125; 公式法我们可以根据此公式使用递归或者循环来做：f(n,m) = [f(n-1,m) + m] % n。 123456789public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if (n == 0) return -1; if (n == 1) return 0; return (LastRemaining_Solution(n - 1, m) + m) % n; &#125;&#125; 63 股票的最大利润题目描述假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可获得的最大利润是多少？ 题解12345678910111213141516public class MaximalProfit &#123; public int maxProfit(int[] prices) &#123; if(prices == null || prices.length == 0) return 0; int minPrice = prices[0]; int maxProfit = 0; for(int i = 1; i &lt; prices.length; i++) &#123; if(prices[i] &lt; minPrice) minPrice = prices[i]; int currProfit = prices[i] - minPrice; if(currProfit &gt; maxProfit) maxProfit = currProfit; &#125; return maxProfit; &#125;&#125; 64 求1+2+···+n题目描述题解1234567public class Solution &#123; public int Sum_Solution(int n) &#123; int sum = n; boolean flag = (sum &gt; 0) &amp;&amp; ((sum += Sum_Solution(--n)) &gt; 0); return sum; &#125;&#125; 65 不用加减乘除做加法题目描述写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 题解十进制加法三步走：1、只做各位相加不进位2、求出进位值3、把前面两个结果加起来 而对于二进制也正是如此。使用异或完成相加的操作，而使用位与运算再左移完成进位的操作。 123456789101112public class Solution &#123; public int Add(int num1,int num2) &#123; int sum, carry; do &#123; sum = num1 ^ num2; carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; num2 = carry; &#125; while(carry != 0); return sum; &#125;&#125; 拓展不使用新变量交换两个变量的值: 基于加减法 基于异或运算 a = a + b a = a ^ b b = a - b a = a ^ b a = a - b a = a ^ b 66 构建乘积数组题目描述给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0] A[1] … A[i-1] A[i+1] … A[n-1]。不能使用除法。 题解12345678910111213141516171819public class Solution &#123; public int[] multiply(int[] A) &#123; int[] B = new int[A.length]; if(A == null || A.length == 0) return B; B[0] = 1; for(int i = 1; i &lt; A.length; i++) &#123; B[i] = B[i-1] * A[i-1]; &#125; int temp = 1; for(int i = B.length - 2; i &gt;= 0; i--)&#123; temp = A[i+1] * temp; B[i] = temp * B[i]; &#125; return B; &#125;&#125; 67 把字符串转换成整数题目描述将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 题解1234567891011121314151617public class Solution &#123; public int StrToInt(String str) &#123; if(str == null || str.length() == 0) return 0; boolean neg = str.charAt(0) == '-'; int num = 0; for(int i = 0; i &lt; str.length(); i++) &#123; char c = str.charAt(i); if(i == 0 &amp;&amp; (c == '+' || c == '-')) continue; if(c &lt; '0' || c &gt; '9') return 0; int temp = num; num = num * 10 + (c - '0'); if((num - c + '0') / 10 != temp) return 0; &#125; return neg ? -num : num; &#125;&#125; 68.1 二叉查找树中两个节点的最低公共祖先题目描述找到二叉查找树中两个节点的最低公共祖先 123456789/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 题解从根节点开始向下查找直到找到满足root.val &gt;= p.val且root.val &lt;= q.val的节点。 12345678910111213class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; while(root != null) &#123; if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) root = root.left; else if(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) root = root.right; else return root; &#125; return null; &#125;&#125; 68.2 普通二叉树中两个节点的最低公共祖先题目描述找到普通二叉树中两个节点的最低公共祖先 123456789/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */ 题解深度优先搜索的思想： 12345678910class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == null || root.val == p.val || root.val == q.val) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); return left == null ? right : right == null ? left : root; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL查询性能优化]]></title>
    <url>%2F2019%2F01%2F28%2FMySQL%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化数据访问减少请求的数据量 只返回必要的行：使用LIMIT语句来限制返回的数据。 只返回必要的列：最好不要使用SELECT *语句。 缓存重复查询的数据。 减少服务器端扫描的行数最有效的方式是使用索引来覆盖查询。 重构查询方式切分查询一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。因此可以将大查询切分成小查询，每个查询功能完全一样，只完成一小部分，每次只返回一小部分查询结果。 分解关联查询可以对每一个表进行一次单表查询，然后将结果在应用程序中进行关联。这么做有如下优势： 让缓存的效率更高。对于关联查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 将查询分解后，执行单个查询可以减少锁的竞争。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 查询执行 客户端发送一条查询给服务器。 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。 服务器端进行SQL解析、预处理再由优化器生成对应的执行计划。 MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。 将结果返回给客户端。 MySQL解析器将使用MySQL语法规则验证和解析查询；预处理器则根据一些MySQL规则进一步检查解析树是否合法，例如检查数据表和数据列是否存在，之后会验证权限；查询优化器的作用是根据存储引擎提供的统计信息找出一个最优的执行计划。 优化 Limit 分页在偏移量特别大的时候，例如可能是LIMIT 1000, 20这样的查询，这时MySQL需要查询10020条记录然后只返回最后20条，前面10000条记录都将被抛弃，这样的代价非常高。可以通过延迟关联和书签两个技巧进行优化。 延迟关联优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。然后根据需要做一次关联操作再返回所需的列。考虑下面的查询： 1SELECT film_id, description FROM sakila.film ORDER BY title LIMIT 50, 5; 此时没有覆盖索引，因此要回表获取记录55条，而只返回最后5条1。这时候可以用延迟关联的技巧改写成如下： 123456SELECT film.film_id, film.descriptionFROM sakila.film INNER JOIN( SELECT film_id FROM sakala.film ORDER BY title LIMIT 50, 5 ) AS lim USING(film_id); 这时候子查询中能使用覆盖索引，因此在索引结构中就能获取到需要访问的记录而无需回表，之后再根据关联列回表查询需要的所有列。 书签LIMIT和OFFSET的问题，其实是OFFSET的问题，它会导致MySQL扫描大量不需要的行然后再抛弃掉。如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。例如，若需要按照租借记录做翻页，那么可以根据最新一条租借记录向后追溯，首先使用下面的查询获得第一组结果： 12SELECT * FROM sakila.rentalORDER BY rental_id DESC LIMIT 20; 会返回49到30的记录，那么下一页查询就可以从30这个点开始： 123SELECT * FROM sakila.rentalWHERE rental_id &lt; 30ORDER BY rental_id DESC LIMIT 20; 该技术的好处是无论翻页到多么后面，其性能都会很好。 参考资料 高性能 MySQL[M]. 电子工业出版社, 2013. CS-Notes]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引类型与优化]]></title>
    <url>%2F2019%2F01%2F28%2FMySQL%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[索引的优点 索引大大减少了服务器需要扫描的数据量 索引可以帮助服务器避免排序、分组和临时表（临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表） 索引可以将随机I/O变为顺序I/O（B-Tree索引是有序的，会将相邻的数据都存储在一起） 索引的类型在MySQL中，索引是在存储引擎层而不是服务器层实现的，所以不同的存储引擎的索引类型和实现不同。 B-Tree索引大多数存储引擎都使用B-Tree作为默认索引类型，但实际在技术上往往使用的是B+Tree，例如InnoDB。B-Tree索引之能够加快访问数据的速度，是因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。关于B-Tree和B+Tree的工作原理可以参考之前的一篇笔记：常用查找算法之B/B+树。 B-Tree索引适用于全键值、键值范围或键前缀（最左前缀）查找。因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的ORDER BY操作。 B-Tree同样也有一些限制： 如果不是按照索引的最左列开始查找，则无法使用索引。 不能跳过索引中的列，否则只会使用跳过之前的索引列。 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。 哈希索引哈希索引基于哈希表实现，对于每一行数据，存储引擎都会对所有索引列计算一个哈希码并存储在索引中，同时在哈希表中保存指向每个数据行的指针。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。哈希索引有如下限制： 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。 无法用于排序。 不支持部分索引列匹配查找。 不支持范围查询。 哈希冲突。 InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”，当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B+Tree索引具有哈希索引的一些优点，比如快速的哈希查找。 全文索引全文索引是一种特殊类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。在相同的列上同时创建全文索引和基于值的B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。 空间数据索引MyISAM存储引擎支持空间数据索引（R-Tree），可以用作地理数据存储。空间索引会从所有维度来索引数据，查询时可以有效利用任意维度来组合查询。必须使用MySQL的GIS相关函数来维护数据。 索引优化独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则MySQL无法使用索引。 例如：SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把actor_id和film_id设置为多列索引： 12SELECT film_id, actor_id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1; 索引列的顺序将选择性最强的索引列放在前面。索引的选择性是指不重复的索引值（基数）和记录总数的比值，选择性越高则查询效率也越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。 前缀索引对于很长的字符串可以索引开始的部分字符，使得前缀的选择性接近于完整列的选择性。 聚簇索引B-Tree索引类型都可以用在MyISAM和InnoDB上，但InnoDB有聚簇索引的特性而MyISAM没有。 聚簇表示数据行和相邻的键值紧凑地存储在一起，因为无法同时把数据行存放在两个不同的地方，所以每张Innodb引擎表都只有一个聚簇索引。一般情况，聚簇索引就是主键索引（因为聚簇索引在有主键的情况下，默认指定主键为聚簇索引），而非聚簇索引都是二级索引。 如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。采用聚簇索引，索引和其他列值存储在一起，因此数据访问比采用非聚簇索引（如MyISAM引擎）更快，节省了磁盘I/O资源。 二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这样虽然会让二级索引占用更多的空间，但换来的好处是InnoDB在移动行时减少了二级索引的维护工作。 MyISAM没有聚簇索引的特性，主键索引和其它索引在结构上没有什么不同。 使用InnoDB存储引擎时应该尽可能地按主键顺序插入数据（可以使用AUTO_INCREMENT自增），最好避免随机的插入（例如使用UUID作为主键）。因为当主键的值是顺序的时，InnoDB会把每一条记录都存储在上一条记录的后面，当达到页的最大填充因子时（默认为15/16），下一条记录就会写入新的页中。而每次插入主键的值近似于随机时，新纪录根据值的大小要被插入到现有索引页的中间某个合适位置，此时页分裂会导致大量的数据移动并产生碎片，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销。 覆盖索引如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”，此时不需要回表操作。其具有以下优点： 索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。 因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，比较费时。 对于InnoDB引擎，若二级索引能够覆盖查询，则可以避免对主键索引的二次查询。 使用索引扫描来排序MySQL有两种方式可以生成有序的结果：通过排序操作或者按索引顺序扫描。如果EXPLAIN出来的type列的值为index，则说明MySQL使用了索引扫描来做排序。 只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求，否则MySQL都需要执行排序操作，而无法利用索引排序。 参考资料 高性能 MySQL[M]. 电子工业出版社, 2013. mysql的索引——innodb索引（1）聚簇索引和次级索引 为什么InnoDB表最好要有自增列做主键]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL常用数据类型]]></title>
    <url>%2F2019%2F01%2F28%2FMySQL%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[整型TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT分别使用1，2，3，4，8字节的存储空间。 可以使用UNSIGNED属性表示不允许负值以提高正数的上限，但有符号和无符号类型的存储空间和性能依旧一样。 MySQL可以为整数类型指定宽度，如INT(11)，但它不会限制值的合法范围，只是规定了交互工具显示字符的个数。 浮点数FLOAT和DOUBLE为浮点类型（浮点数），DECIMAL为高精度小数类型（定点数）。 CPU原生支持浮点运算，但不支持对DECIMAL的运算，因此浮点运算会更快。但是浮点数会引起精度问题，像货币这样对精度敏感的数据，应该用DECIMAL来存储。 浮点和定点都可以指定精度，例如DECIMAL(18, 9)表示总共18位，取9位存储小数部分，剩下9位存储整数部分。 字符串MySQL主要有VARCHAR和CHAR两种字符串类型。 VARCHAR类型是可变长的，它比定长类型更节省空间，因为它仅使用必要的空间。但是在执行UPDATE时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行放进页内。 CHAR类型是定长的，总是根据定义的字符串长度分配足够的空间，并且在存储和检索时删除末尾的空格，而VARCHAR是会保留末尾的空格的。 当字符串列的长度比平均长度大很多时、列的更新很少时，使用VARCHAR类型更好；对于定长的字符串如MD5、经常变更或者非常短的字符串（因为VARCHAR需要额外的1个或2个字节记录字符串长度）则使用CHAR类型更好。 日期和时间MySQL提供两种相似的日期类型：DATETIME和TIMESTAMP。 DATETIME能够保存从1001年到9999年的日期和时间，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节的存储空间。默认情况下，MySQL以一种可排序的、无歧义的格式显示，例如2008-01-16 22:37:08。 TIMESTAMP保存从1970年1月1日午夜（格林威治时间）以来的秒数，使用4个字节，只能表示从1970年到2038年。这种类型的时间是和时区有关的，默认情况下，如果插入时没有指定TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。 应该尽量使用TIMESTAMP，因为它比DATETIME空间效率更高。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务、锁与设计原理]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[事务事务是指满足ACID特性的一组操作，它们要么完全地执行，要么完全地不执行。 ACID特性原子性（Atomicity）一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。 一致性（Consistency）数据库总是从一个一致性的状态转换到另外一个一致性状态。事务开始和结束之间的中间状态不会被其他事务看到。 隔离性（Isolation）一个事务所作的修改在最终提交前，对其它事务是不可见的。 持久性（Durability）一旦事务提交，则其所作的修改就会永久保存到数据库中。即使系统崩溃，修改的数据也不会丢失。 理解事务的ACID特性概念简单，但不是很好理解，主要是因为这几个特性不是一种平级关系： 只要满足一致性，事务的执行结果才是正确的。 在无并发的情况下，事务串行执行，隔离性一定能够满足。此时只要满足原子性，就一定能满足一致性。 在并发的情况下，多个事务并行执行，事务不仅要满足原子性，还要满足隔离性，才能满足一致性。 事务满足持久化是为了能应对数据库崩溃的情况。 隔离级别在并发环境下需要关注事务的隔离性，SQL标准中定义了以下四种隔离级别。 未提交读（READ UNCOMMITTED）事务中的修改即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读。 提交读（READ COMMITTED）一个事务从开始直到提交之前，所做的任何修改对其它事务都是不可见的。 这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。例如，T2读取一个数据，T1对该数据做了修改并提交，如果T2再次读取这个数据，那么读取的结果和第一次读取的结果不同。 可重复读（REPEATABLE READ）可重复读保证了在同一事物中多次读取同样记录的结果是一致的。 该级别无法解决幻读问题，即当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。 可串行化（SERIALIZABLE）该级别是最高的隔离级别，通过强制事务串行执行避免上面的幻读问题。 总结 隔离级别 脏读 不可重复读 幻读 加锁读 未提交读 √ √ √ × 提交读 × √ √ × 未提交读 × × √ × 未提交读 × × × √ 锁当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。所以，锁主要用于处理并发问题。 从数据库系统角度分为三种：排他锁、共享锁、更新锁。从程序员角度分为两种：一种是悲观锁，一种乐观锁。 悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。 传统的关系数据库里用到了很多这种锁机制，比如按使用性质划分的读锁、写锁和按作用范围划分的行锁、表锁。 共享锁共享锁（S锁）又称为读锁，若事务T对数据对象A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。 排他锁排他锁（X锁）又称为写锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。 表锁每次操作锁住整张表，开销小，加锁快，锁粒度大，发生锁冲突的概率最高，并发度最低。 行锁每次操作锁住一行数据，开销大，加锁慢，锁粒度小，发生锁冲突的概率最低，并发度最高。 数据库能够确定哪些行需要锁的情况下使用行锁，如果不知道会影响哪些行的时候就会使用表锁。 乐观锁总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。 版本号机制一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值与当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。 CAS算法CAS即compare and swap（比较并交换），是一种有名的无锁算法，在不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步。CAS算法涉及到三个操作数： 要更新的变量V 预期的值E 新值N 仅当V值等于E值时，才会将V的值设置成N，否则什么都不做。最后CAS返回当前V的值。CAS算法需要你额外给出一个期望值，也就是你认为现在变量应该是什么样子，如果变量不是你想象的那样，就说明已经被别人修改过，就重新读取，再次尝试修改即可。 因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时就会误以为它的值没有发生变化，这个问题称为ABA问题。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A-B-A就会变成1A-2B-3A，以此来防止不恰当的写入。 两种锁的适用场景乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行重试，这样反倒是降低了性能，所以一般多写的场景下用悲观锁比较合适。 关系型数据库设计函数依赖部分函数依赖设X、Y是关系R的两个属性集合，存在X→Y，若X’是X的真子集，存在X’→Y，则称Y部分函数依赖于X。 完全函数依赖设X、Y是关系R的两个属性集合，X’是X的真子集，存在X→Y，但对每一个X’都有X’ !→Y，则称Y完全函数依赖于X。 传递函数依赖设X、Y、Z是关系R中互不相同的属性集合，存在X→Y（Y !→X），Y→Z，则称Z传递函数依赖于X。 范式第一范式（1NF）在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 所谓第一范式（1NF）是指数据库表的每一列（每个属性）都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。简而言之，第一范式就是无重复的列。 第二范式（2NF）第二范式（2NF）要求实体的属性完全依赖于主关键字。 第三范式（3NF）在满足第二范式的基础上，且不存在传递函数依赖，那么就是第三范式。简而言之，第三范式就是属性不依赖于其它非主属性。 ER图ER图由三个部分组成：实体、属性、联系。 参考资料 CS-NOTE 数据库锁分类和总结 面试必备之乐观锁与悲观锁 并发策略-CAS算法]]></content>
      <categories>
        <category>数据库</category>
        <category>数据库原理</category>
      </categories>
      <tags>
        <tag>锁</tag>
        <tag>事务</tag>
        <tag>范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路径问题—Dijkstra算法及相关例题]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E2%80%94Dijkstra%E7%AE%97%E6%B3%95%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BE%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在做算法题的时候总是遇到Dijkstra相关的题目，之前虽然学过图论的一些算法，但第一次做这类题时完全不知从何入手。看了一些博客，并且在PAT上折腾了几题后，发现一些常用的模板与套路，因此在这里进行一个总结。关于Dijkstra的理论知识可以参考这篇博客：最短路径问题-Dijkstra算法详解 Dijkstra算法Dijkstra算法往往和dfs结合在一起考，因此这里给出一个求解基础Dijkstra+dfs相关题目的大致模板： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485public class Main &#123; static int n; //节点数 static int m; //边数 static int C1; //起始点 static int C2; //终点 static int[][] e;//边权 static int[] weight; //点权（非必需，视题目而定） static int[] dis; //到起始点的最短路径长 static boolean[] visit; //是否访问过 static ArrayList&lt;Integer&gt;[] pre; //可构成最短路径的前一个节点 static LinkedList&lt;Integer&gt; tempPath = new LinkedList&lt;Integer&gt;(); //可能的最短路径 static LinkedList&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;(); //最短路径 public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); C1 = sc.nextInt(); C2 = sc.nextInt(); visit = new boolean[n]; weight = new int[n]; for(int i = 0; i &lt; n; i++) &#123; weight[i] = sc.nextInt(); &#125; e = new int[n][n]; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; e[i][j] = e[j][i] = Integer.MAX_VALUE; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; int c1 = sc.nextInt(); int c2 = sc.nextInt(); e[c1][c2] = e[c2][c1] = sc.nextInt(); &#125; dis = new int[n]; for(int i = 0; i &lt; n; i++) &#123; dis[i] = Integer.MAX_VALUE; &#125; dis[C1] = 0; pre = new ArrayList[n]; for(int i = 0; i &lt; n; i++) &#123; pre[i] = new ArrayList&lt;&gt;(); &#125; /**************以上为初始化****************/ for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = Integer.MAX_VALUE; for(int j = 0; j &lt; n; j++) &#123; if(!visit[j] &amp;&amp; dis[j] &lt; min) &#123; min = dis[j]; u = j; &#125; &#125; if(u == -1) break; visit[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(!visit[v] &amp;&amp; e[u][v] != Integer.MAX_VALUE) &#123; if(dis[v] &gt; dis[u] + e[u][v]) &#123; dis[v] = dis[u] + e[u][v]; pre[v].clear(); pre[v].add(u); &#125; else if(dis[v] == dis[u] + e[u][v]) &#123; pre[v].add(u); &#125; &#125; &#125; &#125; //至此已经找到多个最短路径，下面的dfs算法将在多个最短路径中找到最终解 dfs(C2); &#125; private static void dfs(int v) &#123; tempPath.push(v); if(v == C1) &#123; //此处进行一些判断，在多个最短路径中确认最终解 tempPath.pop(); return; &#125; for(int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v].get(i)); tempPath.pop(); &#125;&#125; Emergency题目链接：1003 Emergency 此题要求求出两点之间的最短路径，如果存在多条最短路径，那么就选择点权和最大的路径。这里的代码和上面模板几乎一模一样，做题时都需要考虑点权。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class Main &#123; private static int n; private static int m; private static int C1; private static int C2; private static int[][] e; private static int[] weight; private static int[] dis; private static boolean[] visit; private static int max = Integer.MIN_VALUE; private static ArrayList&lt;Integer&gt;[] pre; private static LinkedList&lt;Integer&gt; tempPath = new LinkedList&lt;Integer&gt;(); private static LinkedList&lt;Integer&gt; path = new LinkedList&lt;Integer&gt;(); private static int cnt = 0; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); C1 = sc.nextInt(); C2 = sc.nextInt(); visit = new boolean[n]; weight = new int[n]; for(int i = 0; i &lt; n; i++) &#123; weight[i] = sc.nextInt(); &#125; e = new int[n][n]; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; e[i][j] = e[j][i] = Integer.MAX_VALUE; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; int c1 = sc.nextInt(); int c2 = sc.nextInt(); e[c1][c2] = e[c2][c1] = sc.nextInt(); &#125; dis = new int[n]; for(int i = 0; i &lt; n; i++) &#123; dis[i] = Integer.MAX_VALUE; &#125; dis[C1] = 0; pre = new ArrayList[n]; for(int i = 0; i &lt; n; i++) &#123; pre[i] = new ArrayList&lt;&gt;(); &#125; /**********************************************/ for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = Integer.MAX_VALUE; for(int j = 0; j &lt; n; j++) &#123; if(!visit[j] &amp;&amp; dis[j] &lt; min) &#123; min = dis[j]; u = j; &#125; &#125; if(u == -1) break; visit[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(!visit[v] &amp;&amp; e[u][v] != Integer.MAX_VALUE) &#123; if(dis[v] &gt; dis[u] + e[u][v]) &#123; dis[v] = dis[u] + e[u][v]; pre[v].clear(); pre[v].add(u); &#125; else if(dis[v] == dis[u] + e[u][v]) &#123; pre[v].add(u); &#125; &#125; &#125; &#125; /***********************************************/ dfs(C2); System.out.printf("%d %d", cnt, max); &#125; private static void dfs(int v) &#123; tempPath.push(v); if(v == C1) &#123; int a = 0; for(int i = 0; i &lt; tempPath.size(); i++) &#123; a += weight[tempPath.get(i)]; &#125; if(a &gt; max) &#123; max = a; path = new LinkedList&lt;&gt;(tempPath); &#125; cnt++; tempPath.pop(); return; &#125; for(int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v].get(i)); tempPath.pop(); &#125;&#125; 事实上，我们也可以不使用DFS，而在执行Dijkstra就完成最大点权和的判断: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Main &#123; private static int n; //城市数 private static int m; //路径数 private static int c1; //源城市 private static int c2; //目标城市 private static int[][] e; //边长 private static int[] dis; //从出发点到当前节点的最短路径 private static int[] nums; //从出发点到当前节点最短路径的数目 private static int[] w; //从出发点到当前节点救援对数目之和 private static int[] weight; //当前节点的救援队数目 private static boolean[] visit; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); c1 = sc.nextInt(); c2 = sc.nextInt(); weight = new int[n]; e = new int[n][n]; dis = new int[n]; nums = new int[n]; w = new int[n]; visit = new boolean[n]; for(int i = 0; i &lt; n; i++) &#123; weight[i] = sc.nextInt(); &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; e[i][j] = Integer.MAX_VALUE; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; int s = Integer.valueOf(sc.nextInt()); int d = Integer.valueOf(sc.nextInt()); e[s][d] = e[d][s] = Integer.valueOf(sc.nextInt()); &#125; for(int i = 0; i &lt; n; i++) &#123; dis[i] = Integer.MAX_VALUE; &#125; dis[c1] = 0; nums[c1] = 1; w[c1] = weight[c1]; /******************************************/ for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = Integer.MAX_VALUE; for(int j = 0; j &lt; n; j++) &#123; if(!visit[j] &amp;&amp; dis[j] &lt; min) &#123; u = j; min = dis[j]; &#125; &#125; if(u == -1) break; visit[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(!visit[v] &amp;&amp; e[u][v] != Integer.MAX_VALUE) &#123; if(dis[u] + e[u][v] &lt; dis[v]) &#123; dis[v] = dis[u] + e[u][v]; nums[v] = nums[u]; w[v] = w[u] + weight[v]; &#125; else if(dis[u] + e[u][v] == dis[v]) &#123; nums[v] += nums[u]; w[v] = w[u] + weight[v] &gt; w[v] ? w[u] + weight[v] : w[v]; &#125; &#125; &#125; &#125; System.out.printf("%d %d", nums[c2], w[c2]); &#125;&#125; Travel Plan题目链接：1030 Travel Plan 这题对比上题是将点权换成了边权，先通过Dijkstra算法求出多条最短路径，然后用DFS找到最短路径中边权（此题中就是cost）最小的那条路径。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class Main &#123; private static int n; private static int m; private static int s; private static int d; private static int[][] e; private static int[][] cost; private static int[] dis; private static boolean[] visit; private static ArrayList&lt;Integer&gt;[] pre; private static LinkedList&lt;Integer&gt; tempPath = new LinkedList&lt;&gt;(); private static LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); private static int min = Integer.MAX_VALUE; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); n = sc.nextInt(); m = sc.nextInt(); s = sc.nextInt(); d = sc.nextInt(); visit = new boolean[n]; e = new int[n][n]; cost = new int[n][n]; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; e[i][j] = e[j][i] = Integer.MAX_VALUE; cost[i][j] = cost[j][i] = Integer.MAX_VALUE; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; int i1 = sc.nextInt(); int i2 = sc.nextInt(); e[i1][i2] = e[i2][i1] = sc.nextInt(); cost[i1][i2] = cost[i2][i1] = sc.nextInt(); &#125; dis = new int[n]; for(int i = 0; i &lt; n; i++) &#123; dis[i] = Integer.MAX_VALUE; &#125; dis[s] = 0; pre = new ArrayList[n]; for(int i = 0; i &lt; n; i++) &#123; pre[i] = new ArrayList&lt;&gt;(); &#125; /***********************************************/ for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = Integer.MAX_VALUE; for(int j = 0; j &lt; n; j++) &#123; if(!visit[j] &amp;&amp; dis[j] &lt; min) &#123; min = dis[j]; u = j; &#125; &#125; if(u == -1) break; visit[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(!visit[v] &amp;&amp; e[u][v] != Integer.MAX_VALUE) &#123; if(dis[v] &gt; dis[u] + e[u][v]) &#123; dis[v] = dis[u] + e[u][v]; pre[v].clear(); pre[v].add(u); &#125; else if(dis[v] == dis[u] + e[u][v]) &#123; pre[v].add(u); &#125; &#125; &#125; &#125; /**********************************************/ ArrayList&lt;Integer&gt;[] temppre = pre; dfs(d); for(int i = 0; i &lt; path.size(); i++) &#123; System.out.print(path.get(i) + " "); &#125; System.out.print(dis[d] + " "); System.out.print(min); &#125; private static void dfs(int v) &#123; tempPath.push(v); if(v == s) &#123; int c = 0; for(int i = 1; i &lt; tempPath.size(); i++) &#123; c += cost[tempPath.get(i)][tempPath.get(i-1)]; &#125; if(c &lt; min) &#123; min = c; path = new LinkedList&lt;&gt;(tempPath); &#125; tempPath.pop(); return; &#125; for(int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v].get(i)); tempPath.pop(); &#125;&#125; All Roads Lead to Rome题目链接：1087 All Roads Lead to Rome 这题和上面两题也没什么不同，基本思路是一样的，只不过题目输入的是城市的名称也就是字符串，并且输出也要用城市的名称，我们直接用map来存储城市名与下标的映射即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class Main &#123; private static int[][] e; private static int[] dis; private static int[] weight; private static boolean[] visit; private static int n; private static int k; private static HashMap&lt;Integer, String&gt; map1; private static HashMap&lt;String, Integer&gt; map2; private static LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;(); private static LinkedList&lt;Integer&gt; tempPath = new LinkedList&lt;&gt;(); private static ArrayList&lt;Integer&gt;[] pre; private static int max = Integer.MIN_VALUE; private static int avg = Integer.MIN_VALUE; private static int cnt = 0; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String[] line1 = sc.nextLine().split(" "); n = Integer.valueOf(line1[0]); k = Integer.valueOf(line1[1]); map1 = new HashMap&lt;&gt;(); map2 = new HashMap&lt;&gt;(); map1.put(0, line1[2]); map2.put(line1[2], 0); weight = new int[n]; for(int i = 1; i &lt; n; i++) &#123; String[] line = sc.nextLine().split(" "); map1.put(i, line[0]); map2.put(line[0], i); weight[i] = Integer.valueOf(line[1]); &#125; e = new int[n][n]; for(int i = 0; i &lt; e.length; i++) &#123; for(int j = 0; j &lt; e.length; j++) &#123; e[i][j] = e[j][i] = Integer.MAX_VALUE; &#125; &#125; for(int i = 0; i &lt; k; i++) &#123; String[] line = sc.nextLine().split(" "); int c1 = map2.get(line[0]); int c2 = map2.get(line[1]); e[c1][c2] = e[c2][c1] = Integer.valueOf(line[2]); &#125; dis = new int[n]; dis[0] = 0; for(int i = 1; i &lt; n; i++) &#123; dis[i] = Integer.MAX_VALUE; &#125; visit = new boolean[n]; pre = new ArrayList[n]; for(int i = 0; i &lt; n; i++) &#123; pre[i] = new ArrayList&lt;&gt;(); &#125; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = Integer.MAX_VALUE; for(int j = 0; j &lt; n; j++) &#123; if(!visit[j] &amp;&amp; dis[j] &lt; min) &#123; u = j; min = dis[j]; &#125; &#125; if(u == -1) break; visit[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(!visit[v] &amp;&amp; e[u][v] != Integer.MAX_VALUE) &#123; if(dis[u] + e[u][v] &lt; dis[v]) &#123; dis[v] = dis[u] + e[u][v]; pre[v].clear(); pre[v].add(u); &#125; else if(dis[u] + e[u][v] == dis[v]) &#123; pre[v].add(u); &#125; &#125; &#125; &#125; dfs(map2.get("ROM")); System.out.printf("%d %d %d %d\n", cnt, dis[map2.get("ROM")], max, avg); System.out.print(map1.get(0)); for(int i = 1; i &lt; path.size(); i++) &#123; System.out.print("-&gt;" + map1.get(path.get(i))); &#125; &#125; private static void dfs(int v) &#123; tempPath.push(v); if(v == 0) &#123; int happy = 0; int average = 0; for(int i = 1; i &lt; tempPath.size(); i++) &#123; happy += weight[tempPath.get(i)]; &#125; average = happy / (tempPath.size()-1); if(happy &gt; max) &#123; max = happy; avg = average; path = new LinkedList&lt;&gt;(tempPath); &#125; else if(happy == max &amp;&amp; average &gt; avg) &#123; avg = average; path = new LinkedList&lt;&gt;(tempPath); &#125; cnt++; tempPath.pop(); return; &#125; for(int i = 0; i &lt; pre[v].size(); i++) dfs(pre[v].get(i)); tempPath.pop(); &#125;&#125; 至此，简单的Dijkstra题都可以套用上述模板很容易地做出来，当然平时做题时还是需要根据具体题目灵活变通，以上代码只是将其思路梳理了一遍，在实现上也依然存在许多可以优化的地方。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Dijkstra</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用查找算法之散列表]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[前言散列表类似于数组，可以把散列表的散列值看成数组的索引值。访问散列表和访问数组元素一样快速，它可以在常数时间内实现查找和插入操作。使用散列的查找算法分为两步：用散列函数将被查找的键转化为数组的一个索引；处理碰撞冲突。 散列函数要为一个数据类型实现优秀的散列方法需要满足三个条件： 一致性：等价的键必然产生相等的散列值。 高效性：计算简便。 均匀性：均匀的散列所有的键。 对于一致性，在Java中意味着每一种数据类型的hashCode()方法都必须和equals()方法一致。也就是说，如果a.equals(b)返回true，那么a.hashCode()和b.hashCode()的返回值必然相同。但要注意，如果a.hashCode()和b.hashCode()的返回值相同，a.equals(b)不一定返回true。 保证均匀性的最好办法就是保证键的每一位都在散列值的计算中起到了相同的作用，而常见的错误就是忽略了键的高位。在jdk的HashMap中，为了保证均匀性将默认散列函数得到的散列值与其高16位进行异或运算重新得到新的散列值。 为了将一个32位的整数散列值转换成数组的索引，我们在实现中还要将散列值和除留余数法结合起来产生一个0到M-1（M代表数组的大小）的整数。这在HashMap中是通过这行代码实现的：hash &amp; (table.length - 1)。 碰撞处理基于拉链法的散列表拉链法是将大小为M的数组中的每个元素指向一条链表，链表中的每个节点都存储了散列值为该元素的索引的键值对。基于拉链法的查找分为两步：首先根据散列值找到对应的链表，然后沿着链表顺序查找相应的键。 在实现基于拉链法的散列表时，要选择适当的数组大小M，既不会因为空链表而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。 基于线性探测法的散列表实现散列表的另一种方式就是用大小为M的数组保存N个键值对，其中M&gt;N。我们需要依靠数组中的空位解决碰撞冲突，基于这种策略的所有方法被统称为开放地址散列表。 开放地址散列表中最简单的方法叫做线性探测法。我们在实现中使用并行数组，一个保存键，一个保存值。 12345678910111213141516171819202122232425262728293031323334public class LinearProbingHashST&lt;Key, Value&gt; &#123; private static final int INIT_CAPACITY = 4; private int n; //符号表中键值对的总数 private int m; //线性探测表的大小 private Key[] keys; //键 private Value[] vals; //值 public LinearProbingHashST() &#123; this(INIT_CAPACITY); &#125; public LinearProbingHashST(int capacity) &#123; m = capacity; n = 0; keys = (Key[]) new Object[m]; vals = (Value[]) new Object[m]; &#125; private int hash(Key key) &#123; return (key.hashCode() &amp; 0x7fffffff) % m; &#125; //实现见下文 private void resize(int capacity) //实现见下文 public void put(Key key, Value val) //实现见下文 public Value get(Key key) //实现见下文 public void delete(Key key) 查找要查找一个键，我们从它的散列值开始顺序查找，如果找到则命中，否则直接检查散列表中的下一个位置（将索引值加1），直到找到该键或者遇到一个空元素。 123456public Value get(Key key) &#123; for (int i = hash(key); keys[i] != null; i = (i + 1) % m) if (keys[i].equals(key)) return vals[i]; return null;&#125; 插入如果新建的散列值是一个空元素，那么就将它保存在那里；如果不是，我们就顺序查找一个空元素来保存它。 1234567891011121314public void put(Key key, Value val) &#123; if (n &gt;= m/2) resize(2*m); int i; for (i = hash(key); keys[i] != null; i = (i + 1) % m) &#123; if (keys[i].equals(key)) &#123; vals[i] = val; return; &#125; &#125; keys[i] = key; vals[i] = val; n++;&#125; 删除直接将要删除的键所在的位置设为null是不行的，因为这会使在此位置之后的元素无法被查找。因此，我们需要将簇中被删除键的右侧的所有键重新插入散列表。 1234567891011121314151617181920212223242526public void delete(Key key) &#123; int i = hash(key); while (keys[i] != null &amp;&amp; !key.equals(keys[i])) i = (i + 1) % M; // 不存在则直接返回 if (keys[i] == null) return; keys[i] = null; values[i] = null; // 将之后相连的键值对重新插入 i = (i + 1) % M; while (keys[i] != null) &#123; Key keyToRedo = keys[i]; Value valToRedo = values[i]; keys[i] = null; values[i] = null; N--; put(keyToRedo, valToRedo); i = (i + 1) % M; &#125; N--; //如果键值对太小，我们就将数组的大小减半 if (n &gt; 0 &amp;&amp; n &lt;= m/8) resize(m/2);&#125; 为了保证性能，我们会动态调整数组的大小来保证使用率在1/8到1/2之间。 调整数组大小线性探测法的成本取决于连续条目的长度，连续条目也叫聚簇。当聚簇很长时，在查找和插入时需要进行很多次探测。为了保证散列表的性能，应当动态调整数组的大小，使得散列表的使用率不超过1/2。 1234567891011private void resize(int capacity) &#123; LinearProbingHashST&lt;Key, Value&gt; temp = new LinearProbingHashST&lt;Key, Value&gt;(capacity); for (int i = 0; i &lt; m; i++) &#123; if (keys[i] != null) &#123; temp.put(keys[i], vals[i]); &#125; &#125; keys = temp.keys; vals = temp.vals; m = temp.m;&#125; 以上实现会将原表中所有的键重新散列并插入到新表中。 参考资料 Algorithms (Fourth Edition) CS-Notes 算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树的前中后层序遍历（递归与非递归方式）]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%A0%91%E7%9A%84%E5%89%8D%E4%B8%AD%E5%90%8E%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%88%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[DescriptionLeetCode的第590题与429、589题型类似，都为树（不一定是二叉树）的各种形式的遍历，因此放在一起总结。 对于上图，要求求出前序遍历、后序遍历和层级遍历的结果。 Example12345678前序遍历结果：[1,3,5,6,2,4]后序遍历结果：[5,6,3,2,4,1]层级遍历结果：[ [1], [3,2,4], [5,6]] Analysis对于树我们一般有两种策略： 广度优先搜索（BFS）：从上到下一层一层的遍历树 ，也就是题目要求的层级遍历。 深度优先搜索（DFS）：从一个根节点开始，一直到达某个叶子节点，然后回到根节点到达另一个分支的叶子节点。根据根节点、左节点和右节点之间的相对顺序，DFS策略可以进一步区分为前序、中序和后序。 根据深度优先搜索与广度优先搜索可以整理出下图的四种情况： Solution对于第一题求前序遍历，我们可以使用递归或者循环来完成，实际上这三道题都是如此。我们先看看递归版本： 12345678910111213141516171819public class Solution &#123; List&lt;Integer&gt; list; public List&lt;Integer&gt; preorder(Node root) &#123; list = new ArrayList&lt;&gt;(); if(root == null) return list; preorderCore(root); return list; &#125; private void preorderCore(Node root) &#123; if(root == null) return; list.add(root.val); for(Node node : root.children) preorderCore(node); &#125;&#125; 前序遍历就是先将根节点放入结果列表中，然后再将左右子节点放入。递归的解法较为简单，下面看看循环的解法： 123456789101112131415161718public class Solution2 &#123; public List&lt;Integer&gt; preorder(Node root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(root == null) return res; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; Node node = stack.pop(); res.add(node.val); Collections.reverse(node.children); for(Node children : node.children) &#123; stack.push(children); &#125; &#125; return res; &#125;&#125; 在递归中我们使用栈来保存接下来要访问的节点。首先我们将根节点压入栈，栈中元素为[1]，然后我们将它弹出至结果列表并把它的子节点翻转并放入栈，此时栈中元素为[4, 2, 3]；由于栈顶元素为3，因此将3弹出至结果列表并把它的子节点翻转并放入栈，此时栈中元素为[4, 2, 6, 5]；栈顶元素为5，因此将5弹出至结果列表，5没有子节点，再把6弹出至结果列表。如此反复，我们便可以通过这种方式得到前序遍历的结果列表[1, 3, 5, 6, 2, 4]。 求后序遍历与这题异曲同工，同样先看看递归版本： 123456789101112131415161718public class Solution &#123; List&lt;Integer&gt; list; public List&lt;Integer&gt; postorder(Node root) &#123; list = new ArrayList&lt;&gt;(); if(root == null) return list; postorderCore(root); return list; &#125; private void postorderCore(Node root) &#123; if(root == null) return; for(Node node : root.children) postorderCore(node); list.add(root.val); &#125;&#125; 我们仅仅将list.add(root.val); 这行代码放到了遍历子节点的for语句之后，意味着先将所有子节点加入结果列表，最后再将根节点加入结果列表。下面是使用循环的解法： 123456789101112131415161718public class Solution2 &#123; public List&lt;Integer&gt; postorder(Node root) &#123; LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;(); if(root == null) return res; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); while(!stack.isEmpty()) &#123; Node node = stack.pop(); res.addFirst(node.val); for(Node children : node.children) &#123; stack.push(children); &#125; &#125; return res; &#125;&#125; 与前序遍历不同的是我们不需要翻转子节点列表，但是每次将结果添加到结果列表头而不是尾。 第三题是层序遍历（广度优先搜索），不像上面两题用递归实现更加简单，我们通过循环来实现会更加简洁明了，思路是使用一个队列而非栈来保存每一层节点： 12345678910111213141516171819public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; levelOrder(Node root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;(); if(root == null) return res; Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;(); queue.add(root); while(!queue.isEmpty()) &#123; int size = queue.size(); List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while(size-- != 0) &#123; Node node = queue.poll(); for(Node children : node.children) queue.add(children); list.add(node.val); &#125; res.add(list); &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树的遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用查找算法之B/B+树]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8BB-B-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前言从算法逻辑上讲二叉查找树的查找和插入操作效率都已经很高，但是在实际应用中由于我们不能将整个索引表加载到内存，只能逐一加载每个磁盘页，这里的磁盘页就对应着索引树的节点。因此我们要将原本“瘦高”的树结构变得“矮胖”，从而减少磁盘IO的次数。 B- 树B-树是一种多路平衡查找树，是对2-3树的一个扩展。一个m阶的B树（m的大小取决于磁盘页的大小）具有如下几个特征： 根结点至少有两个子女。 每个中间节点都包含k-1个元素和k个孩子，其中 k ∈ [m/2, m] 每一个叶子节点都包含k-1个元素，其中 k ∈ [m/2, m] 所有的叶子结点都位于同一层。 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 查找下图以一个3阶B-树为例，第一次磁盘IO并在内存中和9比较： 第二次磁盘IO并在内存中和2、6比较： 第三次磁盘IO并在内存中和3、5比较： 单从比较次数来说B树相比二叉查找树并不占优势，但由于节点中存储着多个元素，因此它的磁盘IO次数比二叉查找树少很多，而内存中的比较耗时几乎可以忽略，因此查找性能也就比二叉查找树更好。 插入以插入元素4为例，自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间，而由于此B-树是3阶的，每个节点最多能有2个元素，因此该节点无法再增加，而其父节点也含有两个元素，根节点只有一个元素。 于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 删除以删除元素11为例，先自顶向下查找元素11的节点位置。 删除11后，节点12只有一个孩子，不符合B树规范。因此找出12,13,15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子（左旋操作）。 B+ 树B+树是B-树的一个变体，有着比B-树更高的查询性能。一个m阶的B+树（m的大小取决于磁盘页的大小）具有如下几个特征： 有k个子树的中间节点包含有k个元素（B-树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 注意，根节点的最大元素（上图中是15）等同于整个B+树的最大元素；由于父节点的元素都出现在子节点，因此所有叶子节点包含了全量元素信息，并且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。 查找在B-树中，无论中间节点还是叶子节点都带有卫星数据（索引元素所指向的数据记录），而Ｂ+树中间节点没有卫星数据，只有索引，这就意味着同样大小的磁盘页可以容纳更多节点元素，在相同的数据量下，B+树更加“矮胖”，IO操作更少。 下图以查找元素3为例，第一次磁盘IO： 第二次磁盘IO： 第三次磁盘IO： B+树除了比B树更加“矮胖”这一点不同外，由于B+树的查询必须最终查找到叶子节点，而B-树中无论匹配元素处于中间节点还是叶子节点只要找到匹配元素即可，所以B+树的查找性能是稳定的，而B-树的查找性能不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。 范围查找由于B+树的叶子节点构成了一条有序链表，因此B+树的范围查找比B-树简单得多，下面以查询范围为3到11的元素为例。 自顶向下，查找到范围的下限3： 通过链表指针，遍历到元素6、8： 通过链表指针，遍历到元素9、11，遍历结束： 总结为了减少磁盘IO的次数，必须降低树的深度，将“瘦高”的树变得“矮胖，使得磁盘页可以容纳更多节点元素，因此出现了B-树。B+树是B-树的变体，相比B-树有以下优势： 单一节点存储更多的元素，使得查询的IO次数更少。 所有查询都要查找到叶子节点，查询性能稳定。 所有叶子节点形成有序链表，便于范围查询。 除了B-树和B+树，平时还会听到有B*树的概念，同样B*树是B+树的一个变体，相比B+树的不同之处如下： 将结点的最低利用率从1/2提高到2/3。 在B+树基础上，为非叶子结点也增加链表指针：B+树当一个结点满时，会分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B*树当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，而如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。 参考资料 漫画：什么是B-树？ 漫画：什么是B+树？]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>B树</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用查找算法之红黑树]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[前言二叉查找树对于大多数情况下的查找和插入操作在效率上来说是没有问题的，但是在最差的情况下会达到线性级别，其效率取决于插入顺序。平衡查找树的数据结构能够保证在最差的情况下也能是对数级别，要实现这一目标我们需要保证树在插入完成之后始终保持平衡状态。 2-3查找树在学习红黑树之前要先了解2-3查找树作为基础，一棵2-3查找树或为一棵空树，或由以下节点组成： 2-节点：含有一个键值对和两条链接，左链接指向的2-3树中的键都小于该节点，右链接指向的2-3树中的键都大于该节点。 3-节点：含有两个键值对和三条链接，左链接指向的2-3树中的键都小于该节点，中链接指向的2-3树中的键都位于该节点的两个键之间，右链接指向的2-3树中的键都大于该节点。 指向一棵空树的链接称为空链接，一棵完美平衡的2-3查找树的所有空链接到根节点的距离应该是相同的。 查找要判断一个键是否在树中，我们先将它和根节点中的键比较。如果它和其中任意一个相等，查找命中；否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找。如果这是个空链接，查找未命中。 插入 如果插入到2-节点上，那么直接将新节点和原来的节点组成3-节点即可。 如果是插入到3-节点上，就会产生一个临时4-节点时，需要将4-节点分裂成3个2-节点，并将中间的2-节点移到上层节点中。如果上移操作继续产生临时4-节点则一直进行分裂上移，直到不存在临时4-节点。 如果从插入节点到根节点的路径上全都是3-节点，我们的根节点最终变成一个临时的4-节点，此时我们将临时的4-节点分解为3个2-节点，使得树高加一。这次最后的变换仍然保持了树的完美平衡性，因为它变换的是根节点。 构造轨迹二叉查找树是由上向下生长的，而2-3树的生长是由下向上的。 红黑树2-3查找树实现起来十分复杂，因此我们使用一种名为红黑二叉查找树的简单数据结构来表达并实现它。 我们将树中的链接分为两种类型：红链接将两个2-节点连接起来构成一个3-节点，黑链接则是2-3树中的普通链接。 红黑树有以下性质: 红链接均为左链接。 没有任何一个节点同时和两条红链接相连。 红黑树是完美黑色平衡的，即任意空链接到根节点的路径上的黑链接数量相同。 如果我们将由红链接相连的节点合并，得到的就是一棵2-3树： 基本实现我们将由父节点指向自己的链接的颜色保存在表示节点的Node数据类型的布尔变量Color中。如果是红色则为true，黑色则为false。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class RedBlackBST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private static final boolean RED = true; private static final boolean BLACK = false; private Node root; private class Node &#123; private Key key; private Value val; private Node left, right; private boolean color; //由其父节点指向它的链接的颜色 private int size; //这棵子树中的节点总数 public Node(Key key, Value val, boolean color, int size) &#123; this.key = key; this.val = val; this.color = color; this.size = size; &#125; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) return 0; return x.size; &#125; private boolean isRed(Node x) &#123; if (x == null) return false; return x.color == RED; &#125; //实现见下文 private Node rotateLeft(Node h) //实现见下文 private Node rotateRight(Node h) //实现见下文 private void flipColors(Node h)&#125; 旋转假设我们有一条红色的右链接需要被转化为左链接，我们要进行左旋转。同理，也有右旋转。 1234567891011121314151617181920212223//左旋转 private Node rotateLeft(Node h) &#123; Node x = h.right; h.right = x.left; x.left = h; x.color = x.left.color; x.left.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x; &#125;//右旋转private Node rotateRight(Node h) &#123; Node x = h.left; h.left = x.right; x.right = h; x.color = x.right.color; x.right.color = RED; x.size = h.size; h.size = size(h.left) + size(h.right) + 1; return x; &#125; 颜色转换一个4-节点在红黑树中表现为一个节点的左右子节点都是红色的。分裂4- 节点除了需要将子节点的颜色由红变黑之外，同时需要将父节点的颜色由黑变红，从2-3树的角度看就是将中间节点移到上层节点。 12345private void flipColors(Node h) &#123; h.color = !h.color; h.left.color = !h.left.color; h.right.color = !h.right.color;&#125; 插入先将一个节点按二叉查找树的方法插入到正确位置，然后在沿着插入点到根节点的路径向上移动时，在所经过的每个节点中顺序完成如下操作： 如果右子节点是红色的而左子节点是黑色的，进行左旋转； 如果左子节点是红色的，而且左子节点的左子节点也是红色的，进行右旋转； 如果左右子节点均为红色的，进行颜色转换，将红链接在树中向上传递。 颜色转换会使根节点变为红色，但根节点并没有父节点，因此在每次插入后都将根节点设为黑色。注意，每当根节点由红变黑时树的黑链接高度就会加一，因为这意味着它由一个4-节点分裂出去成为2-节点了。 12345678910111213141516171819202122public void put(Key key, Value val) &#123; //查找key，找到则更新其值，否则为它新建一个节点 root = put(root, key, val); root.color = BLACK;&#125;private Node put(Node h, Key key, Value val) &#123; if (h == null) //标准的插入操作，和父节点用红链接相连 return new Node(key, val, RED, 1); int cmp = key.compareTo(h.key); if (cmp &lt; 0) h.left = put(h.left, key, val); else if (cmp &gt; 0) h.right = put(h.right, key, val); else h.val = val; if (isRed(h.right) &amp;&amp; !isRed(h.left)) h = rotateLeft(h); if (isRed(h.left) &amp;&amp; isRed(h.left.left)) h = rotateRight(h); if (isRed(h.left) &amp;&amp; isRed(h.right)) flipColors(h); h.size = size(h.left) + size(h.right) + 1; return h;&#125; 除了递归调用后的三条if语句，红黑树中put()的递归实现和二叉查找树中put()的实现完全相同。 删除最小键为保证树的完美平衡性，沿着左链接向下进行变换，确保不会删除一个2-节点。在最后得到的含有最小键的3-节点或4-节点中，我们可以直接将最小键删除，然后向上分解所有临时的4-节点。 删除在查找路径上进行和删除最小键相同的变换同样可以保证在查找过程中任意当前节点均不是2-节点。如果被查找的键在树的底部，我们可以直接删除它。如果不在，我们需要将它和它的后继节点交换，就和二叉查找树一样。因为当前节点必然不是2-节点，问题已经转化为在一棵根节点不是2-节点的子树中删除最小的键，可以直接使用上文的算法。删除之后我们需要向上回溯并分解余下的4-节点。 查找红黑树的get()方法不会检查节点的颜色，因此实现和二叉查找树一样，但由于树是平衡的，所以查找比二叉查找树更快。 12345678910111213public Value get(Key key) &#123; return get(root, key);&#125;private Value get(Node x, Key key) &#123; while (x != null) &#123; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x = x.left; else if (cmp &gt; 0) x = x.right; else return x.val; &#125; return null;&#125; 复杂度分析无论键的插入顺序如何，红黑树都几乎是完美平衡的，因此查找、插入等操作在最坏的情况下所需的时间仍是对数级别的。 参考资料 Algorithms (Fourth Edition) CS-Notes 算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用查找算法之二叉查找树]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%2F</url>
    <content type="text"><![CDATA[定义一棵二叉查找树（又称二叉排序树、二叉搜索树）是一棵二叉树，其中每个节点都含有一个Comparable的键以及相关联的值且每个节点的键都大于其左子树中的任意节点的键而小于右子树的任意节点的键。 二叉查找树有一个重要性质，就是它的中序遍历结果递增排序。 基本实现树由Node对象组成，每个对象都含有一对键值、两条链接和一个节点计数器。节点计数器表示以该节点为根的子树中的节点总数，总是满足size(x) = size(x.left) + size(x.right) + 1。 123456789101112131415161718192021222324252627282930313233public class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; private Node root; // 二叉查找树的根节点 private class Node &#123; private Key key; // 键 private Value val; // 值 private Node left, right; // 指向子树的链接 private int size; // 以该节点为根的子树中的节点总数 public Node(Key key, Value val, int size) &#123; this.key = key; this.val = val; this.size = size; &#125; &#125; public int size() &#123; return size(root); &#125; private int size(Node x) &#123; if (x == null) return 0; else return x.size; &#125; //实现见下文 public Value get(Key key) //实现见下文 public void put(Key key, Value val) //其它有序性相关的方法及删除操作见下文&#125; 查找如果树是空的，则查找未命中；如果被查找的键和根节点的键相等，查找命中；否则递归地在子树中查找：如果被查找的键较小就在左子树中查找，较大就在右子树中查找。 当找到一个含有被查找的键的节点（命中）或者当前子树变为空（未命中）时这个过程才会结束。 123456789101112public Value get(Key key) &#123; return get(root, key);&#125;private Value get(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return get(x.left, key); else if (cmp &gt; 0) return get(x.right, key); else return x.val;&#125; 插入如果树是空的，就返回一个含有该键值对的新节点（使上层节点的链接指向该节点）；如果被查找的键小于根节点的键，继续在左子树中插入该键，否则在右子树中插入该键。 1234567891011121314@Overridepublic void put(Key key, Value value) &#123; root = put(root, key, value);&#125; private Node put(Node x, Key key, Value val) &#123; if (x == null) return new Node(key, val, 1); int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = put(x.left, key, val); else if (cmp &gt; 0) x.right = put(x.right, key, val); else x.val = val; x.size = 1 + size(x.left) + size(x.right); return x; &#125; 有序性相关的方法及删除操作范围查找利用二叉查找树中序遍历的结果为递增的特点对其进行指定范围的查找。 12345678910111213141516Overridepublic List&lt;Key&gt; keys(Key l, Key h) &#123; List&lt;Key&gt; list = new ArrayList&lt;&gt;(); keys(root, list, l, h); return list;&#125;private void keys(Node x, List&lt;key&gt; list, Key l, Key h) &#123; if (x == null) return; int cmpL = l.compareTo(x.key); int cmpH = h.compareTo(x.key); if (cmpL &lt; 0) keys(x.left, list, l, h); if (cmpL &lt;= 0 &amp;&amp; cmpH &gt;= 0) list.add(x.key); if (cmpH &gt; 0) keys(x.right, list, l, h);&#125; 删除最小节点只需令指向最小节点的链接指向最小节点的右子树。 1234567891011public void deleteMin() &#123; root = deleteMin(root);&#125;private Node deleteMin(Node x) &#123; if (x.left == null) return x.right; x.left = deleteMin(x.left); x.size = size(x.left) + size(x.right) + 1; return x;&#125; 删除指定节点如果待删除的节点只有一个子树， 那么只需要让指向待删除节点的链接指向唯一的子树即可；否则，让右子树的最小节点替换该节点。 1234567891011121314151617181920212223public void delete(Key key) &#123; root = delete(root, key);&#125;private Node delete(Node x, Key key) &#123; if (x == null) return null; int cmp = key.compareTo(x.key); if (cmp &lt; 0) x.left = delete(x.left, key); else if (cmp &gt; 0) x.right = delete(x.right, key); else &#123; if (x.right == null) return x.left; if (x.left == null) return x.right; Node t = x; x = min(t.right); x.right = deleteMin(t.right); x.left = t.left; &#125; x.size = size(x.left) + size(x.right) + 1; return x;&#125; 查找最小键123456789101112@Overridepublic Key min() &#123; return min(root).key;&#125;private Node min(Node x) &#123; if (x == null) return null; if (x.left == null) return x; return min(x.left);&#125; 排名rank(key)返回key的排名，排名从0开始。如果键和根节点的键相等，返回左子树的节点数；如果小于，递归计算在左子树中的排名；如果大于，递归计算在右子树中的排名，加上左子树的节点数，再加上1（根节点）。 123456789101112@Overridepublic int rank(Key key) &#123; return rank(key, root);&#125;private int rank(Key key, Node x) &#123; if (x == null) return 0; int cmp = key.compareTo(x.key); if (cmp &lt; 0) return rank(key, x.left); else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right); else return size(x.left); &#125; 复杂度分析在最好的情况下，一棵含有N个节点的树是完全平衡的，插入和查找的时间复杂度均为O(logn)；在最坏的情况下，搜索路径上可能有N个节点，此时的时间复杂度为O(n)。 参考资料 Algorithms (Fourth Edition) CS-Notes 算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用查找算法之二分查找]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[前言符号表是一种存储键值对的数据结构，可以支持高效地插入、查找等操作，因此在这里使用一个有序符号表接口来定义这些操作，这个符号表将保持键的有序性。 12345678910111213141516public interface OrderedST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123; int size(); void put(Key key, Value value); Value get(Key key); Key min(); Key max(); int rank(Key key); List&lt;Key&gt; keys(Key l, Key h);&#125; 二分查找二分查找先将被查找的键和数组的中间键比较，如果被查找的键小于中间键，我们就在左子数组中继续查找，如果大于我们就在右子数组中继续查找，否则中间键就是我们要找的键。如果表中存在该键，此方法将返回该键的位置，否则，将返回该键应该插入的位置。 二分查找有很多种不同的实现方式，但个人更加喜欢用以下的方式实现，这同时也是书上的实现方式： 1234567891011public int binarySearch(int[] nums, int target) &#123; int low = 0; int high = nums.length - 1; while(low &lt;= high) &#123; int mid = low + (high - low) / 2; if(nums[mid] &lt; target) low = mid + 1; else if(nums[mid] &gt; target) high = mid - 1; else return mid; &#125; return low;&#125; 查找数字第一次出现的位置对二分查找可以做一个简单的拓展，即当一个有序数组中有重复的数字时，查找一个数字在数组中第一次出现的位置。例如，对于数组{1, 2, 3, 3, 3, 3, 4}，要查找的数字3的下标应该为2而不是3。我们仅仅需要对普通的二分查找算法做一个简单的修改就能完成此功能： 12345678910public int binarySearchFirst(int[] nums, int target) &#123; int low = 0; int high = nums.length - 1; while(low &lt;= high) &#123; int mid = low + (high - low) / 2; if(nums[mid] &lt; target) low = mid + 1; else if(nums[mid] &gt;= target) high = mid - 1; &#125; return low;&#125; 查找数字最后一次出现的位置同理，我们也可以使用二分查找找到重复数字在有序数组中最后一次出现的位置： 12345678910public int binarySearchLast(int[] nums, int target) &#123; int low = 0; int high = nums.length - 1; while(low &lt;= high) &#123; int mid = low + (high - low) / 2; if(nums[mid] &lt;= target) low = mid + 1; else if(nums[mid] &gt; target) high = mid - 1; &#125; return high;&#125; 二分查找实现有序符号表使用一对平行数组，分别用来存储键和值。 这份实现的核心是rank()方法，它几乎和上面单独列出的二分查找法一样，返回找到的键的位置或者键应该插入的位置。对于put()方法，如果键存在于表中则更新它的值，否则插入到合适的位置，并将所有更大的键向后移动一格。get()方法根据rank()方法的返回值来取键相应的值，如果不存在则返回null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class BinarySearchOrderedST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; implements OrderedST&lt;Key, Value&gt; &#123; private Key[] keys; private Value[] values; private int N = 0; public BinarySearchOrderedST(int capacity) &#123; keys = (Key[]) new Comparable[capacity]; values = (Value[]) new Object[capacity]; &#125; @Override public int size() &#123; return N; &#125; @Override public int rank(Key key) &#123; int l = 0, h = N - 1; while (l &lt;= h) &#123; int m = l + (h - l) / 2; int cmp = key.compareTo(keys[m]); if (cmp == 0) return m; else if (cmp &lt; 0) h = m - 1; else l = m + 1; &#125; return l; &#125; @Override public List&lt;Key&gt; keys(Key l, Key h) &#123; int index = rank(l); List&lt;Key&gt; list = new ArrayList&lt;&gt;(); while (keys[index].compareTo(h) &lt;= 0) &#123; list.add(keys[index]); index++; &#125; return list; &#125; @Override public void put(Key key, Value value) &#123; int index = rank(key); if (index &lt; N &amp;&amp; keys[index].compareTo(key) == 0) &#123; values[index] = value; return; &#125; for (int j = N; j &gt; index; j--) &#123; keys[j] = keys[j - 1]; values[j] = values[j - 1]; &#125; keys[index] = key; values[index] = value; N++; &#125; @Override public Value get(Key key) &#123; int index = rank(key); if (index &lt; N &amp;&amp; keys[index].compareTo(key) == 0) return values[index]; return null; &#125; @Override public Key min() &#123; return keys[0]; &#125; @Override public Key max() &#123; return keys[N - 1]; &#125;&#125; 复杂度分析二分查找的时间复杂度是对数级别的，故使用二分查找实现的符号表的查找操作所需要的时间也是对数级别的，但是插入操作由于需要移动数组元素，因此是线性级别的。 参考资料 Algorithms (Fourth Edition) CS-Notes 算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap源码分析]]></title>
    <url>%2F2019%2F01%2F28%2FHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashMap简介（jdk1.8）在jdk1.8中，HashMap底层由数组+链表+红黑树来实现，性能较之前有了较大的提升。如下为HashMap的继承体系结构：12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 在这里，AbstractMap已经实现了Map接口，再实现一遍并没有任何用处，java集合框架的创始人也承认其为一个小失误。 HashMap中，当链表节点较多时会转为红黑树进行存储，而红黑树这一数据结构涉及的知识点过多，关于红黑树的基础知识需要另外学习，本篇将以链表为主，红黑树为辅的形式分析其源码。 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 默认的初始化容量为16 */ static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; /** * 最大容量 */ static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; /** * 默认负载因子为0.75 */ static final float DEFAULT_LOAD_FACTOR = 0.75f; /** * 链表转红黑树的阈值，当有8个节点的时候转换 */ static final int TREEIFY_THRESHOLD = 8; /** * 红黑树转链表的阈值，当有6个节点的时候转换 */ static final int UNTREEIFY_THRESHOLD = 6; /** * 转红黑树时table的最小容量，如果当前容量小于64则进行扩容而非转换 */ static final int MIN_TREEIFY_CAPACITY = 64; /** * 基本hash节点 */ static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + &quot;=&quot; + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; 注意：在HashMap中，table的容量只为2的n次方。 构造函数1234567891011121314151617181920212223242526//指定了初始容量和负载因子 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125;//指定了初始容量，将会设置默认负载因子 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 在构造函数中，并没有对table数组进行初始化，而是在第一次put的时候进行初始化，这会在下文进行详细介绍。 tableSizeFortableSizeFor方法的主要功能是返回一个比给定整数大且最接近的2的幂次方整数，如给定10，返回2的4次方16。 12345678910static final int tableSizeFor(int cap) &#123; //防止当容量已经是2的幂次方(2^m)了，进行如下操作得到的最终结果会多乘个2，即2^(m+1) int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; 这个方法比较巧妙，n|=n&gt;&gt;&gt;1这一操作确保第一次出现1的位及其后一位（也就是头两位）都是1，而n |= n &gt;&gt;&gt; 2确保头四位都是1，n |= n &gt;&gt;&gt; 4确保头八位都是1，以此类推，一直到n |= n &gt;&gt;&gt; 16结束后就能确保第一次出现1的位及其后面所有位都为1。而此时，n+1即为最接近指定容量的2的幂次方整数。举个例子：123456789n: 0000 0000 0110 0001 = 97 n|=n&gt;&gt;&gt;1: 0000 0000 0111 0001 n|=n&gt;&gt;&gt;2: 0000 0000 0111 1001n|=n&gt;&gt;&gt;2: 0000 0000 0111 1101 n|=n&gt;&gt;&gt;4: 0000 0000 0111 1111...n|=n&gt;&gt;&gt;16: 0000 0000 0111 1111n+1: 0000 0000 1000 0000 = 128 hash1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 这个方法先得到key的hashCode，然后将其与高16位进行异或运算重新得到哈希值，之后再通过hash &amp; (table.length - 1) 定位到key在table中的索引位置。假设table的长度为16，具体过程如下： 12345h = key.hashCode(): 1111 1111 1111 1111 0000 0000 0011 0101h &gt;&gt;&gt; 16: 0000 0000 0000 0000 1111 1111 1111 1111hash = h ^ (h &gt;&gt;&gt; 16): 1111 1111 1111 1111 1111 1111 1100 1010table.length - 1: 0000 0000 0000 0000 0000 0000 0000 1111hash &amp; (table.length - 1):0000 0000 0000 0000 0000 0000 0000 1010 其中，&gt;&gt;&gt;为无符号右移，左边都将补0，而之所以要进行这一步，是为了当table的值很小时，能让hashCode的高位也参与运算，以减少碰撞的几率，否则仅在高位发生变化总是会发生碰撞。 我们知道，hash如果对table.length取模将得到key在table长度范围内的索引位置，但由于模运算效率较低，这里便采用了与运算进行优化，提高了效率。 get12345678910111213141516171819202122232425262728public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value; &#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; //哈希表不为null &amp;&amp; 表的长度大于0 &amp;&amp; 根据hash值算出表索引的第一个节点不为null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; //如果第一个节点的key与传入的key相同，则直接返回第一个节点 if (first.hash == hash &amp;&amp; //always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; //如果第一个节点是树节点，则调用红黑树的相关方法 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; //向下遍历链表直至找到key相同的节点并返回 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; //未找到符合要求的节点，返回null return null; &#125; getTreeNode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; //如果当前节点有父节点，则先找到其根节点，之后再调用find方法 return ((parent != null) ? root() : this).find(h, k, null);&#125;final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; //如果当前节点的父节点为空，则当前节点为根节点，将其返回 if ((p = r.parent) == null) return r; r = p; &#125;&#125;final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; //传入的哈希值小于当前节点的哈希值，则向左遍历 if ((ph = p.hash) &gt; h) p = pl; //传入的哈希值大于当前节点的哈希值，则向右遍历 else if (ph &lt; h) p = pr; //传入的哈希值等于当前节点的哈希值，则再判断key值是否相同，因为不同的key有可能有相同的hash，这也正是哈希冲突所在 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; //如果左节点为空，则向右开始遍历 else if (pl == null) p = pr; //如果右节点为空，则向左开始遍历 else if (pr == null) p = pl; //走到这里说明左右节点都不为空，要开始判断究竟往左还是往右 else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; //如果不为null，说明key实现了Comparable接口 (dir = compareComparables(kc, k, pk)) != 0) //比较k和pk的大小，若k&lt;pk则dir&lt;0，k&gt;pk则dir&gt;0 p = (dir &lt; 0) ? pl : pr; //key所属类没有实现Comparable接口，则直接向右开始遍历 else if ((q = pr.find(h, k, kc)) != null) return q; //向右没有找到，则向左开始遍历 else p = pl; &#125; while (p != null); //找不到符合的返回null return null;&#125; 在这个方法中有些人可能会疑虑在同一个索引位置下的红黑树各节点hash值不应该相同吗，为什么还会有判断哈希值大小进入左右节点的操作。其实，不同的hash值在与table的长度相与后，是有可能进入同一个索引位置下的，考虑以下这种情况：123节点1的hash值： 1110 0000 0000 1000 0111节点2的hash值： 1001 1111 0000 1010 0111table.length-1：0000 0000 0000 0000 0111 可以看出，节点1与节点2在进行了hash &amp; (table.length - 1)后值都为0000 0000 0000 0000 0111，因此会放置在table中同一个索引位置下。 comparableClassFor、compareComparablescomparableClassFor方法判断对象x所属类c是否实现了Comparable接口，如果实现了则返回所属类c，否则返回null 123456789101112131415161718192021222324static Class&lt;?&gt; comparableClassFor(Object x) &#123; if (x instanceof Comparable) &#123; Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p; //如果x是个字符串对象则直接返回String类，因为String类本身就已经实现了Comparable接口 if ((c = x.getClass()) == String.class) // bypass checks return c; //Type[] getGenericInterfaces，此方法将返回带泛型参数信息的本类直接实现的接口 if ((ts = c.getGenericInterfaces()) != null) &#123; for (int i = 0; i &lt; ts.length; ++i) &#123; //如果此接口为泛型接口 if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp; //如果该泛型接口的原始类型为Comparable ((p = (ParameterizedType)t).getRawType() == Comparable.class) &amp;&amp; //如果该泛型接口只有一个泛型参数，且此泛型参数类型为c，则返回c (as = p.getActualTypeArguments()) != null &amp;&amp; as.length == 1 &amp;&amp; as[0] == c) // type arg is c return c; &#125; &#125; &#125; //如果该对象所属类没有实现Comparable接口，则返回null return null;&#125; 以上代码中，for (int i = 0; i &lt; ts.length; ++i)下的一系列判断其实就是想要看x所属类c是否实现了Comparable&lt;c&gt;。 1234static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) &#123; return (x == null || x.getClass() != kc ? 0 : ((Comparable)k).compareTo(x));&#125; 此方法中，如果x与k的类相同，则进行比较。否则，返回0。 put1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125; /** * @param onlyIfAbsent 如果为true，则不改变已经存在的value，仅仅当不存在value的时候put进去 */ final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //如果table为空或者长度为0，则先调用resize()方法进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果通过hash计算得到的table该索引位置还没有节点，则创建一个新节点作为头节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); //该索引位置已存在节点 else &#123; Node&lt;K,V&gt; e; K k; //判断当前节点的hash与key是否与参数中的hash与key相同，如果相同，则说明p为要查找的节点，将其赋值给e if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //判断节点是否为红黑树节点，如果是则调用红黑树的相关方法 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //如果节点不为红黑树节点而是链表节点，则遍历链表节点，并统计该链表的节点数binCount for (int binCount = 0; ; ++binCount) &#123; //如果已经到了链表尾部，则根据传入的hash与key等创建一个新节点加入链表尾部 if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //如果链表的节点数超过阈值，则将其转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //此时e节点即为目标节点，跳出循环 break; //将p设置为下一个节点 p = e; &#125; &#125;//如果e节点不为null，则说明链表中包含目标节点，用新值覆盖旧值并返回旧值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; //走到这一步说明插入了新的节点，size大小需要加一 ++modCount; if (++size &gt; threshold) //如果size超过了阈值，则进行扩容 resize(); afterNodeInsertion(evict); return null; &#125; putTreeVal在进行红黑树的操作时，依然会维护链表的结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; //如果目标节点的hash值小于当前节点，则将dir设为-1，代表向左查找 if ((ph = p.hash) &gt; h) dir = -1; //如果目标节点的hash值大于当前节点，则将dir设为1，代表向右查找 else if (ph &lt; h) dir = 1; //如果目标节点的hash值等于当前节点，则判断key是否相等，如果相等，则说明当前节点为目标节点，将其返回 else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; //如果要查找的key没有实现Comparable接口或者pk与k的所属类不同 else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; //第一次执行查找 if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; //左右子树分别调用find进行查找，如果找到了则返回 if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; //如果依然没有找到，则再进行最后一次比较 dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; //如果p节点的左节点或者右节点为null，则说明找到了要放入的位置 if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; //到这里维护了xp-&gt;x-&gt;xpn这一链表结构 xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; //进行红黑树的插入平衡操作 moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125;&#125; resize123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //如果老table为空，则老t int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //如果老table不为空 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //且老table的容量已经大于最大容量 //将阈值设置为最大整型 threshold = Integer.MAX_VALUE; //直接返回老table，不再扩容 return oldTab; &#125; //将新容量设置为老容量的两倍 //如果新容量小于最大容量且老容量大于十六，则将新阈值也提高到原来的两倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; //如果table为空，但老阈值大于0，说明构造函数时指定了初始化容量但从未加入过元素，此时将老阈值赋给新容量，详解见下文 else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; //老table为空，且老阈值为0，说明构造函数时未指定初始化容量 else &#123; // zero initial threshold signifies using defaults //将新容量设置为默认初始化容量 newCap = DEFAULT_INITIAL_CAPACITY; //将新阈值设置为默认负载因子*默认初始化容量 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //如果新阈值为0，则用新容量*负载因子赋值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; //如果新容量或者新阈值大于最大容量，则将新阈值设为最大整型，以后不再扩容 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //将新阈值赋值给阈值属性 threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) //用新容量大小创建一个新table Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; //将新table赋值给table属性 table = newTab; //如果老table不为空，则将其中的元素全部放到新table中去 if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; //如果该索引位置头节点不为空 if ((e = oldTab[j]) != null) &#123; //将老表该索引位置设为空，方便垃圾收集器回收 oldTab[j] = null; //如果该索引位置只有一个节点，则根据其hash计算值放入新表中 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; //如果为树节点，则调用红黑树相关方法 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); //该索引位置有多个节点 else &#123; // preserve order //存储原索引位置的头节点与尾节点 Node&lt;K,V&gt; loHead = null, loTail = null; //存储原索引位置+原容量的头节点与尾节点 Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //如果hash与oldCap相与为0则存储在原索引位置，详解见下方 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) //e为头节点的情况 loHead = e; else loTail.next = e; loTail = e; &#125; //如果hash与oldCap相与不为0则存储在原索引位置+原容量，详解见下方 else &#123; if (hiTail == null) //e为头节点的情况 hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; //尾节点的next属性为空 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; //尾节点的next属性为空 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; //返回新表 return newTab;&#125; 我们可以看到在此方法中有一个条件判断else if (oldThr &gt; 0)，当table为空但阈值却大于零时，将阈值赋值给新容量。这里有个疑问是为什么会发生table为空但阈值却大于零这种情况？我们可以回过头看看构造函数，可以发现在所有构造函数中都没有对数组table进行过分配，而仅仅设置了阈值this.threshold = tableSizeFor(initialCapacity);，既然在构造时没有分配，那肯定就是在第一次扩容时分配的，也就正是上面的代码。 此处还有一个疑问是：为什么扩容后新的存储位置只为原位置或原位置+原容量？请看这么一个例子，假设oldCap=0100, newCap=1000,节点a的hash为1110,节点b的hash为1010。oldCap-1的值为0011，显然对于节点来说只有后两位决定了它们的位置（因为前两位无论如何都为0），而newCap-1的值为0111，此时后三位决定了它们的位置，与之前不同正在于节点的第三位是0还是1，而第三位的值正可以通过oldCap(在此也就是0100)相与来进行判断，如果相与结果为0000，则说明第三位的值为0，在和newCap-1相与后结果将不变，依然在原索引位置；而如果相与结果为0100，则说明节点第三位值是1，也就是原索引值加上原容量。 treeifyBin123456789101112131415161718192021222324252627282930313233final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; //如果table为空或者table的长度小于可转换为红黑树的最小容量，则调用resize方法扩容 if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); //如果根据hash计算得到的索引位置下的节点不为空，则遍历整条链表 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; //将链表节点转换为红黑树节点 TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); //如果为第一次循环 if (tl == null) //将p设置为头节点 hd = p; //否则，不为第一次循环 else &#123; //将当前节点与上一个节点关联起来，维护链表结构 p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); //将hash计算得到的索引位置的头节点赋为新的树节点 if ((tab[index] = hd) != null) //以头节点为根构建红黑树 hd.treeify(tab); &#125;&#125;TreeNode&lt;K,V&gt; replacementTreeNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) &#123; return new TreeNode&lt;&gt;(p.hash, p.key, p.value, next);&#125; treeify123456789101112131415161718192021222324252627282930313233343536373839404142434445464748final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; //x的初始值为根节点，但开始时还未赋值给root for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; //如果root还未被赋值，则将根节点赋值给它 if (root == null) &#123; //根节点没有父节点 x.parent = null; //红黑树根节点必须为黑色 x.red = false; root = x; &#125; else &#123; //见下文 K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; //红黑树的插入平衡调整 root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; //将根节点移到table索引位置的头节点 moveRootToFront(tab, root);&#125; treeify方法用来构建一棵以调用该方法的节点为根节点的红黑树。由于红黑树依然维护着链表结构，每次通过next属性获得下一个节点时，都会从根节点开始向下查找，根据hash值的大小找到合适的位置放入，并设置好parent与left或right属性以关联节点。 remove12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public V remove(Object key) &#123; Node&lt;K,V&gt; e; //如果未找到要删除的节点则返回空，否则返回要删除的节点的value值 return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;/** * @param matchValue 如果为true，则只有当value也相等的时候才移除 */final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; //如果table不为空且table的长度不为0且table该索引位置的头节点不为空 if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; //如果当前节点的hash值和key都与传入的相等，则当前节点就是目标节点，将其赋值给node if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; //如果当前节点不是目标节点，则遍历之后的节点 else if ((e = p.next) != null) &#123; //如果节点为树节点，则调用红黑树相关方法 if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; //如果当前节点是目标节点，则将其赋值给node，并跳出循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; //将p设为下一节点 p = e; &#125; while ((e = e.next) != null); &#125; &#125; //如果找到了要删除的节点且要删除的节点的value与传入的value相等或者压根不需要匹配value if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; //如果节点为树节点，则调用红黑树移除方法 if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); //如果要删除的节点是头节点 else if (node == p) //直接将索引位置指向要删除节点的下一个节点 tab[index] = node.next; else //如果要删除的节点不是头节点，则将要删除节点的上下节点关联起来 p.next = node.next; ++modCount; //总节点数减一 --size; afterNodeRemoval(node); //返回被移除的节点 return node; &#125; &#125; //未找到要删除的节点，直接返回null return null;&#125; 常见问题有关HashMap的常见面试题总结请移步 HashMap常见面试题总结]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法之堆排序]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言排序算法的成本模型计算的是比较和交换的次数。less()方法对元素进行比较，exch()方法将元素交换位置。 123456789private static boolean less(Comparable v, Comparable w) &#123; return (v.compareTo(w) &lt; 0);&#125;private static void exch(Comparable[] a, int i, int j) &#123; Comparable swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 堆的定义堆的某个节点的值总是大于等于子节点的值，并且堆是一颗完全二叉树。当这棵树的每个结点都大于等于它的两个子节点时，它被称为堆有序。 堆可以用数组来表示，这是因为堆是完全二叉树，而完全二叉树很容易就存储在数组中。位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。 上浮在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。 实现如下： 123456private void swim(int k) &#123; while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123; exch(k, k/2); k = k/2; &#125;&#125; 下沉在堆中，当一个节点比子节点小，需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。 实现如下： 123456789private void sink(int k) &#123; while (2*k &lt;= N) &#123; int j = 2*k; if (j &lt; N &amp;&amp; less(j, j+1)) j++; if (!less(k, j)) break; exch(k, j); k = j; &#125;&#125; 堆排序堆排序可以分为两个阶段。在堆的构造阶段中，我们将原始数组重新组织安排进一个堆中；然后在下沉排序阶段，我们从堆中按递减顺序取出所有元素并得到排序结果。 堆的构造无序数组建立堆最直接的方法是从左到右遍历数组进行上浮操作。一个更高效的方法是从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。叶子节点不需要进行下沉操作，可以忽略叶子节点的元素，因此只需要遍历一半的元素即可。 下沉排序堆排序的主要工作都是在这一阶段完成的。这里我们将堆中的最大元素删除，然后放入堆缩小后数组中空出的位置。 12345678910111213141516171819202122232425262728293031public class Heap &#123; public static void sort(Comparable[] pq) &#123; int n = pq.length; for (int k = n/2; k &gt;= 1; k--) sink(pq, k, n); while (n &gt; 1) &#123; exch(pq, 1, n--); sink(pq, 1, n); &#125; &#125; private static void sink(Comparable[] pq, int k, int n) &#123; while (2*k &lt;= n) &#123; int j = 2*k; if (j &lt; n &amp;&amp; less(pq, j, j+1)) j++; if (!less(pq, k, j)) break; exch(pq, k, j); k = j; &#125; &#125; private static boolean less(Comparable[] pq, int i, int j) &#123; return pq[i-1].compareTo(pq[j-1]) &lt; 0; &#125; private static void exch(Object[] pq, int i, int j) &#123; Object swap = pq[i-1]; pq[i-1] = pq[j-1]; pq[j-1] = swap; &#125;&#125; 复杂度分析一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。 对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。 现代系统的许多应用很少使用它，因为它无法利用缓存。数组元素很少和相邻的其它元素进行比较，因此无法利用局部性原理，缓存未命中的次数很高。 最坏时间复杂度 О(nlogn) 最优时间复杂度 O(nlogn) 平均时间复杂度 O(nlogn) 空间复杂度 O(1) 不稳定 参考资料 Algorithms (Fourth Edition) CS-Notes 算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法之快速排序]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言排序算法的成本模型计算的是比较和交换的次数。less()方法对元素进行比较，exch()方法将元素交换位置。 123456789private static boolean less(Comparable v, Comparable w) &#123; return (v.compareTo(w) &lt; 0);&#125;private static void exch(Comparable[] a, int i, int j) &#123; Comparable swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 思路快速排序是一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立地排序。 快速排序和归并排序是互补的：归并排序将数组分成两个子数组分别排序，并将有序的子数组归并以将整个数组排序；而快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了。前者的递归调用发生在处理整个数组之前，而后者的递归调用则发生在处理整个数组之后。 实现过程 基本算法12345678910111213141516171819public class Quick &#123; public static void sort(Comparable[] a) &#123; shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int j = partition(a, lo, hi); sort(a, lo, j-1); sort(a, j+1, hi); &#125; private void shuffle(T[] nums) &#123; List&lt;Comparable&gt; list = Arrays.asList(nums); Collections.shuffle(list); list.toArray(nums); &#125;&#125; 该方法的关键在于切分。 切分方法一般策略是先随意地取a[lo]作为切分元素，即那个将会被排序的元素，然后我们从数组的左端开始向右扫描直到找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素。这两个元素显然是没有排定的，因此交换它们的位置。如此继续，我们就可以保证左指针i的左侧元素都不大于切分元素，右指针j的右侧元素都不小于切分元素。当两个指针相遇时，我们只需要将切分元素a[lo]和左子数组最右侧的元素（a[j]）交换然后返回j即可。 12345678910111213141516171819private static int partition(Comparable[] a, int lo, int hi) &#123; int i = lo; int j = hi + 1; Comparable v = a[lo]; while (true) &#123; while (less(a[++i], v)) &#123; if (i == hi) break; &#125; while (less(v, a[--j])) &#123; if (j == lo) break; &#125; if (i &gt;= j) break; exch(a, i, j); &#125; exch(a, lo, j); return j;&#125; 这个过程使得数组满足下面三个条件： 对于某个j，a[j]已经排定 a[lo]到a[j-1]中的所有元素都不大于a[j] a[j+1]到a[hi]中的所有元素都不小于a[j] 复杂度分析快速排序的最好情况是每次都正好将数组对半分。在这种情况下快速排序所用的比较次数正好满足分治递归的Cn=2Cn/2+n。2Cn/2表示将两个子数组排序的成本，n表示用切分元素和所有数组元素进行比较的成本，这个递归公式的解Cn~nlogn。（下文有具体数学推导） 而在最坏情况下，切分不平衡使得第一次从最小的元素切分，第二次从第二小的元素切分，如此继续，每次切分后两个子数组之一总是为空的，比较次数为(n - 1) + (n - 2) +...+ 1 = n × (n - 1 ) / 2。 而对于空间复杂度来说，主要考虑的是递归调用使用的栈空间，在最好的情况下（也就是对半分），递归深度为logn，最坏情况下的递归深度为n。 最坏时间复杂度 О(n²) 最优时间复杂度 O(nlogn) 平均时间复杂度 O(nlogn) 最坏空间复杂度 O(n) 最优空间复杂度 O(logn) 不稳定 最优时间复杂度的数学证明 算法改进切换到插入排序因为快速排序在小数组中也会递归调用自己，对于小数组，插入排序比快速排序的性能更好，因此在小数组中可以切换到插入排序。 只需要将代码中的if (hi &lt;= lo) return;改为if (hi &lt;= lo + M) {Insertion.sort(a, lo, hi); return;}。 三取样切分最好的情况下是每次都能取数组的中位数作为切分元素，但是计算中位数的代价很高。人们发现取 3 个元素并将大小居中的元素作为切分元素的效果最好。 三向切分法从左到右遍历数组一次，维护一个指针lt使得a[lo…lt-1]中的元素都小于v，一个指针gt使得a[gt+1…hi]中的元素都大于v，一个指针i使得a[lt..i-1]中的元素都等于v，a[i..gt]中的元素都还未确定。 一开始i和lo相等，对a[i]进行三向比较： a[i]小于v，将a[lt]和a[i]交换，将lt和i加一 a[i]大于v，将a[gt]和a[i]交换，将gt减一 a[i]等于v，将i加一 对于包含大量重复元素的数组，它将排序时间从线性对数级降低到了线性级别。 1234567891011121314151617181920212223242526272829public class Quick3way &#123; public static void sort(Comparable[] a) &#123; shuffle(a); sort(a, 0, a.length - 1); &#125; private static void sort(Comparable[] a, int lo, int hi) &#123; if (hi &lt;= lo) return; int lt = lo, gt = hi; Comparable v = a[lo]; int i = lo + 1; while (i &lt;= gt) &#123; int cmp = a[i].compareTo(v); if (cmp &lt; 0) exch(a, lt++, i++); else if (cmp &gt; 0) exch(a, i, gt--); else i++; &#125; // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. sort(a, lo, lt-1); sort(a, gt+1, hi); &#125; private void shuffle(T[] nums) &#123; List&lt;Comparable&gt; list = Arrays.asList(nums); Collections.shuffle(list); list.toArray(nums); &#125;&#125; 参考资料 Algorithms (Fourth Edition) CS-NOTE 算法 排序算法之快速排序的时间复杂度和空间复杂度]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法之归并排序]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言排序算法的成本模型计算的是比较和交换的次数。less()方法对元素进行比较，exch()方法将元素交换位置。 123456789private static boolean less(Comparable v, Comparable w) &#123; return (v.compareTo(w) &lt; 0);&#125;private static void exch(Comparable[] a, int i, int j) &#123; Comparable swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 原地归并方法该方法将两个不同的有序数组归并到第三个数组中。 123456789101112131415private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; // copy to aux[] for (int k = lo; k &lt;= hi; k++) &#123; aux[k] = a[k]; &#125; // merge back to a[] int i = lo, j = mid+1; for (int k = lo; k &lt;= hi; k++) &#123; if (i &gt; mid) a[k] = aux[j++]; else if (j &gt; hi) a[k] = aux[i++]; else if (less(aux[j], aux[i])) a[k] = aux[j++]; else a[k] = aux[i++]; &#125;&#125; 自顶向下的归并排序自顶向下的归并排序应用了分治的思想，要对子数组a[lo..hi]进行排序，先将它分为a[lo..mid]和a[mid+1..hi]两部分，分别通过递归调用将它们单独排序，最后将有序的子数组归并为最终的排序结果。 图为自顶向下的归并排序中归并结果的轨迹 1234567891011121314public class Merge &#123; public static void sort(Comparable[] a) &#123; Comparable[] aux = new Comparable[a.length]; sort(a, aux, 0, a.length-1); &#125; private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123; if (hi &lt;= lo) return; int mid = lo + (hi - lo) / 2; sort(a, aux, lo, mid); sort(a, aux, mid + 1, hi); merge(a, aux, lo, mid, hi); &#125;&#125; 自底向上的归并排序实现归并排序的另一种方法是先归并那些微型数组，然后再成对归并得到子数组，如此这般地多次遍历整个数组，直到我们将整个数组归并到一起。 图为自底向上的归并排序中归并结果的轨迹 12345678910111213public class MergeBU &#123; public static void sort(Comparable[] a) &#123; int n = a.length; Comparable[] aux = new Comparable[n]; for (int len = 1; len &lt; n; len *= 2) &#123; for (int lo = 0; lo &lt; n-len; lo += len+len) &#123; int mid = lo+len-1; int hi = Math.min(lo+len+len-1, n-1); merge(a, aux, lo, mid, hi); &#125; &#125; &#125;&#125; 特点 归并排序的空间复杂度不是最优的 和选择排序一样，排序的性能不受输入数据的影响，但表现比选择排序好的多 复杂度分析 最坏情况时间复杂度 O(nlogn) 最好情况时间复杂度 O(nlogn) 平均情况时间复杂度 O(nlogn) 空间复杂度 O(n) 稳定 参考资料 Wikipedia Algorithms (Fourth Edition) 十大经典排序算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初级排序算法]]></title>
    <url>%2F2019%2F01%2F28%2F%E5%88%9D%E7%BA%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言排序算法的成本模型计算的是比较和交换的次数。less()方法对元素进行比较，exch()方法将元素交换位置。 123456789private static boolean less(Comparable v, Comparable w) &#123; return (v.compareTo(w) &lt; 0);&#125;private static void exch(Comparable[] a, int i, int j) &#123; Comparable swap = a[i]; a[i] = a[j]; a[j] = swap;&#125; 选择排序首先找到数组中最小的那个元素，其次将它和数组的第一个元素交换位置。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换位置。如此反复，直到将整个数组排序。 上图为选择排序的示例动画。红色表示当前最小值，黄色表示已排序序列，蓝色表示当前位置。 特点 运行时间和输入无关：一个已经有序的数组或主键全部相等的数组和一个元素随机排列的数组所用的排序时间一样长。 数据移动是最少的：每次交换都会改变两个数组的元素的值，因此选择排序用了N次交换。 复杂度分析比较次数与关键字的初始状态无关，总的比较次数N = (n - 1) + (n - 2) +...+ 1 = n × (n - 1 ) / 2。交换次数最好情况是已经有序，交换0次；最坏情况是逆序，交换n-1次。 最坏时间复杂度 О(n²) 最优时间复杂度 О(n²) 平均时间复杂度 О(n²) 空间复杂度 O(1) 不稳定 实现123456789101112public class Selection &#123; public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 0; i &lt; n; i++) &#123; int min = i; for (int j = i+1; j &lt; n; j++) &#123; if (less(a[j], a[min])) min = j; &#125; exch(a, i, min); &#125; &#125;&#125; 插入排序插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 特点 插入排序所需时间取决于输入中元素的初始顺序。 插入排序对于部分有序的数组十分高效。 复杂度分析最好情况是序列已经是升序排列了，在这种情况下，需要进行的比较操作需n-1次即可，不需要进行交换；最坏情况是降序排列，那么此时需要进行的比较共有n × (n - 1) / 2次，交换同样需要n × (n - 1) / 2次。 最坏时间复杂度 О(n²) 最优时间复杂度 О(n) 平均时间复杂度 О(n²) 空间复杂度 O(1) 稳定 实现12345678910public class Insertion &#123; public static void sort(Comparable[] a) &#123; int n = a.length; for (int i = 1; i &lt; n; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; less(a[j], a[j-1]); j--) &#123; exch(a, j, j-1); &#125; &#125; &#125;&#125; 希尔排序希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序的思想是使数组中任意间隔为h的元素都是有序的，这样的数组称为h有序数组。 实现希尔排序只需要在插入排序的代码中将移动元素的距离由1改为h即可。 一个h有序数组即一个由h个有序子数组组成的数组 上图表示以23, 10, 4, 1的步长序列进行希尔排序。 特点 希尔排序的时间复杂度与递增序列密切相关，所以分析希尔排序的时间复杂度是个比较麻烦的事。 希尔排序对于中等大小规模表现良好，对规模非常大的数据排序不是最优选择。 希尔排序实现简单，几乎任何排序工作在开始时都可以用希尔排序，若在实际使用中证明它不够快，再改成快速排序这样更高级的排序算法。 实现12345678910111213141516171819public class Shell &#123; public static void sort(Comparable[] a) &#123; int n = a.length; // 3x+1 increment sequence: 1, 4, 13, 40, 121, 364, 1093, ... int h = 1; while (h &lt; n/3) h = 3*h + 1; while (h &gt;= 1) &#123; // h-sort the array for (int i = h; i &lt; n; i++) &#123; for (int j = i; j &gt;= h &amp;&amp; less(a[j], a[j-h]); j -= h) &#123; exch(a, j, j-h); &#125; &#125; h /= 3; &#125; &#125;&#125; 参考资料 Wikipedia Algorithms (Fourth Edition) 十大经典排序算法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ATR-CKN算法的研究与实现]]></title>
    <url>%2F2019%2F01%2F28%2FATR-CKN%E7%AE%97%E6%B3%95%E7%9A%84%E7%A0%94%E7%A9%B6%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言最近在学校做了无线传感器网络（WSN）睡眠调度算法方面的一些研究，本篇文章主要对其中的CKN、EC-CKN算法的学习做个总结，并给出基于这两种算法而改进后的ATR-CKN算法的核心实现以及在Nettopo上的运行结果。 CKN与EC-CKN算法K-邻居节点连通算法（CKN）是一个有效的分布式睡眠/工作时序安排算法。该算法可以在有效的减少网络中处于工作状态的节点个数的同时保证整个网络处于连通状态和需求的路径延迟。执行CKN算法时对WSN中的每个节点u主要进行以下几步： 针对CKN算法在能量消耗方面存在的问题，基于能量消耗的睡眠/工作时序安排算法（EC-CKN）可以延长网络的寿命。EC-CKN算法利用节点当前的剩余能量信息作为参数来决定节点是否进入睡眠状态。EC-CKN算法不仅可以保证整个网络处于K邻居节点连通状态，同时还可以保证每个节点处于工作状态的K个邻居节点当前的剩余能量在所有邻居节点当前剩余能量排序中为最大的K个。 存在的问题EC-CKN对CKN有了一定的改进，但在某些场景下仍然会存在一些问题，例如下文将介绍的死亡加速与网络隔离。 死亡加速在下图的场景中，节点B有很多个邻居节点，按理是可以进入睡眠状态的，但是由于它的其中一个邻居节点A只有它一个邻居节点，因此节点A和B永远得不到睡眠机会，这导致的后果就是：节点B的能量很快就被消耗完了，而节点B周围原本刚好满足睡眠条件的节点由于少了一个醒着的邻居节点，睡眠的几率也因此下降，从而加速了整个网络的死亡。 网络隔离类似于死亡加速，在下面的场景中节点A和B永远也得不到睡眠机会，因此会更快的消耗完能量，导致相连的两个网络被隔离开了。 ATR-CKN算法ATR-CKN算法优于原始的基于CKN的睡眠调度算法，它的优势在于可以在物理上调整传感器节点的传输半径，从而执行CKN使部分节点进入睡眠状态。ATR-CKN算法在继承了EC-CKN算法的所有主要属性的同时，通过提高节点的睡眠率为延长网络生命周期做出了重要贡献。 相较于EC-CKN，ATR-CKN只用在之前加入一个判断逻辑即可： 核心实现下面给出在Nettopo上对于ATR-CKN算法的实现，其关键在于执行EC-CKN之前加入下面一段判断逻辑： 123456789101112131415161718192021private void ATRCKN_Function() &#123;//... boolean flag = false; Integer[] neighbors1 = neighbors.get(currentID); if(neighbors1.length &lt; k) &#123; while(!isUsingMaxTR(currentID)) &#123; increaseTR(currentID); neighbors1 = neighbors.get(currentID); if(neighbors1.length &gt;= k) &#123; for(int j = 0; j &lt; neighbors1.length; j++) &#123; int tr = ((SensorNode)wsn.getNodeByID(currentID)).getMaxTR(); ((SensorNode)wsn.getNodeByID(neighbors1[j])).setMaxTR(tr); &#125; flag = true; break; &#125; &#125; if(!flag) setDefaultTR(currentID); &#125; //...&#125; 运行结果下面将在Nettopo上简单的演示一遍ATR-CKN算法对于死亡加速问题的解决。 k = 2，round = 1的时候： k = 2，round = 10的时候： k = 2，round = 30的时候 k = 2，round = 43的时候： 由于增大了传感器节点的物理传输半径，可以看到两个关键节点都可以进入睡眠状态，以此延长了网络的整体寿命。虽然增大传输半径的同时也增加了能量消耗，但在进行了大量实验并对统计数据进行详细分析后，我们可以发现ATR-CKN的生命周期相比EC-CKN平均增加了19％，最大增加了41%，因此可以得出其更优于EC-CKN的结论。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>WSN</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM-垃圾收集与内存分配]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[对象存活判断判断对象是否存活一般有引用计数法和可达性分析两种方式。 引用计数算法为每个对象添加一个引用计数器，新增一个引用时计数器加1，引用释放时计数器减1，计数器为0时该对象可以被回收。 引用计数法实现简单且高效，但无法解决对象之间相互循环引用的问题。 可达性分析算法通过一系列GC Roots作为起始点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可引用的。 可作为GC Roots的对象包括下面几种： 虚拟机栈中引用的对象。 方法区中类静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象。 finalize如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。如果没有覆盖finalize()方法或者该方法已经被虚拟机调用过，那么它将被回收；否则，会将这个对象放置在一个叫做F-Queue的队列中，要想不被回收，就要在finalize()中重新与引用链上的任何一个对象建立关联。 引用类型对象的引用类型分为强引用、软引用、弱引用、虚引用，这四种引用强度依次减弱。 强引用：类似Object obj = new Object()这类的引用，强引用关联的对象永远不会被回收。 软引用：软引用是用来描述一些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存才会抛出内存溢出异常。简单的说，被软引用关联的对象只有在内存不够的情况下才会被回收。 弱引用：强度比软引用更弱一些，无论当前内存是否足够，被弱引用关联的对象一定会被回收。 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。 垃圾收集算法最基础的垃圾收集算法有三种：标记-清除算法、复制算法、标记-整理算法，我们常用的垃圾回收器一般都采用分代收集算法。 标记-清除算法首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。 不足：标记和清除的两个过程的效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 复制算法将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。 现在的商业虚拟机都采用这种收集算法来回收新生代，但并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 标记-整理算法复制算法在对象存活率较高时要进行较多的复制操作，也有可能需要额外的空间进行分配担保，所以在老年代一般不能直接选用这种算法。 标记-整理算法的标记过程仍与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 分代收集算法现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为新生代和老年代，新生代使用复制算法，老年代使用标记-清除或者标记-整理算法。 垃圾收集器如果说收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体实现。 Serial收集器串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。 ParNew收集器ParNew收集器其实就是Serial收集器的多线程版本。 Parallel Scavenge收集器Parallel是一个多线程收集器。其它收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控制的吞吐量，它被称为“吞吐量优先”收集器。这里的吞吐量指 CPU 用于运行用户代码的时间占总时间的比值。 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。缩短停顿时间是以牺牲吞吐量和新生代空间来换取的：新生代空间变小，收集时间缩短，但同时垃圾回收也变得频繁，导致吞吐量下降。 可以通过一个开关参数打开GC自适应的调节策略（GC Ergonomics），就不需要手工指定新生代的大小、Eden和Survivor区的比例、晋升老年代对象年龄等细节参数了。虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 Serial Old收集器Seriol Old是Serial收集器的老年代版本，同样是一个单线程收集器。 Parallel Old收集器Parallel Old是Parallel Scavenge收集器的老年代版本，同样是一个多线程收集器。 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。 从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为以下几个阶段： Initial Mark：这个是CMS两次stop-the-wolrd事件的其中一次，这个阶段的目标是标记那些直接被GC root引用或者被年轻代存活对象所引用的所有对象。 Concurrent Mark：在这个阶段收集器会根据上个阶段找到的GC Roots遍历查找，然后标记所有存活的对象，也就是进行GC Roots Tracing的过程。这个阶段会与用户的应用程序并发运行，因此在标记期间用户的程序可能会改变一些引用，并不是老年代所有的存活对象都会被标记。 Concurrent Preclean：这也是一个并发阶段，与应用的线程并发运行。在并发运行的过程中，一些对象的引用可能会发生变化，但当种情况发生时，JVM会将包含这个对象的区域（Card）标记为Dirty，这也就是Card Marking。在这个阶段，能够从Dirty对象到达的对象也会被标记，这个标记做完之后，dirty card标记就会被清除了。 Concurrent Abortable Preclean：这也是一个并发阶段，这个阶段是为了尽量承担stop-the-world中最终标记阶段的工作。 Final Remark：这是第二个STW阶段，也是CMS中的最后一个，这个阶段的目标是标记老年代所有的存活对象，由于之前的阶段是并发执行的，gc线程可能跟不上应用程序的变化，为了完成标记老年代所有存活对象的目标，STW就非常有必要了。 Concurrent Sweep：这个阶段清除那些不再使用的对象，回收它们的占用空间为将来使用。 Concurrent Reset：这个阶段会重设CMS内部的数据结构，为下次的GC做准备。 由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。 CMS收集器具有以下几个缺点： 在并发阶段，CMS虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。 CMS无法处理浮动垃圾。 需要预留一部分空间提供并发收集时的程序运作使用，因此不能等到老年代完全被填满再进行收集，要是CMS运行期间预留的内存无法满足程序需要，就会出现“Concurrent Mode Failure”失败，这时将会启用Serial Old收集器重新进行老年代的垃圾收集，停顿时间就很长了。 CMS是基于“标记-清除”算法实现的收集器，会产生大量空间碎片。 浮动垃圾：由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉，这一部分垃圾就称为“浮动垃圾”。 G1收集器G1（Garbage-First）收集器是一款面向服务端应用的垃圾收集器，在多CPU和大内存的场景下有很好的性能。HotSpot开发团队赋予它的使命是未来可以替换掉CMS收集器。G1收集器具有以下几个特点： 垃圾收集线程和应用线程并发执行，和CMS一样。 分代收集：不需要其它收集器配合就能独立管理整个GC堆，采用不同的方式去收集。 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不得超过N毫秒。 在G1算法中，采用了一种完全不同的方式组织堆内存，它将整个Java堆划分为多个大小相等的独立区域Region，每个Region是逻辑连续的一段内存，虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了。 G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，这保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。 每个Region都有一个Remembered Set，用来记录该Region对象的引用对象所在的Region。通过使用Remembered Set，在做可达性分析的时候就可以避免全堆扫描。 G1收集器的运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 前三个步骤与CMS收集器相似，最后的筛选回收阶段对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。 内存分配策略 对象优先分配在Eden区：如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。 大对象直接进入老年代：大对象是指需要大量连续内存空间的对象，这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。 长期存活的对象进入老年代：为对象定义年龄计数器，对象在Eden区出生并经过Minor GC依然存活，将被移动到Survivor区中，年龄增加1岁，增加到年龄阈值则移动到老年代中。 动态判断对象的年龄：如果在Survivor区中相同年龄所有对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代而无需达到年龄阈值。 空间分配担保：新生代使用复制收集算法，但为了了内存利用率，只是用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，一共有多少对象会活下来在实际完成内存回收之前是无法明确知道的，所以在发生Minor GC之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果大于则确保是安全的，如果不大于，则只好以晋升到老年代对象容量的平均大小值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多的空间。 方法区的回收垃圾收集主要针对于Java堆进行，方法区虽然也有垃圾收集，但性价比很低，主要回收两部分内容：废弃常量和无用的类。 无用的类需要满足下面三个条件： 该类所有的实例都已经被回收，也就是堆中不存在该类的任何实例。 加载该类的ClassLoader已经被回收。 该类对应的Class对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。 参考资料 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011. JVM 之 ParNew 和 CMS 日志分析]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM-类加载机制]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[类的生命周期 类加载过程类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。 在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。 加载在加载阶段，虚拟机需要完成以下三件事情： 通过一个类的全限定名来获取其定义的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。 加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。 二进制字节流不一定要从一个Class文件中获取，还可以通过以下几种方式获取： 从ZIP包读取，成为JAR、EAR、WAR格式的基础。 从网络中获取，最典型的应用是Applet。 运行时计算生成，例如动态代理技术，在java.lang.reflect.Proxy中使用ProxyGenerator.generateProxyClass来为特定接口生成代理类的二进制字节流。 由其他文件生成，例如由JSP文件生成对应的Class类。 验证确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作： 文件格式验证：验证字节流是否符合Class文件格式的规范。 元数据验证：对类的元数据信息进行语义校验，保证不存在不符合Java语言规范的元数据信息。（例如：这个类是否有父类）。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 符号引用验证：确保解析动作能正确执行。 验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用-Xverifynone参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。 注意： 这时候进行内存分配的仅包括类变量（被static修饰的变量），实例变量将会在对象实例化时（实例化不是类加载的一个过程）随着对象一起分配在Java堆中。 初始值通常情况下是数据类型的零值，但如果类字段同时被final和static修饰（即为常量），那么在准备阶段就会被初始化为所指定的值。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用以一组符号来描述所引用的目标，可以是任何形式的字面量，与虚拟机实现的内存布局无关，引用的目标不一定已经加载到内存中。 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的，引用的目标必定已经在内存中存在。 其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java的动态绑定。 动态绑定是指在执行期间（非编译期）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 程序运行过程中，把函数（或过程）调用与响应调用所需要的代码相结合的过程称为动态绑定。 初始化初始化阶段才真正开始执行类中定义的Java程序代码。初始化阶段即虚拟机执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。 与类的构造函数（或者说实例构造器&lt;init&gt;()）不同，不需要显式的调用父类的构造器。虚拟机会自动保证在子类的&lt;clinit&gt;()方法运行之前，父类的&lt;clinit&gt;()方法已经执行结束。因此虚拟机中第一个执行&lt;clinit&gt;()方法的类肯定为java.lang.Object。 由于父类的&lt;clinit&gt;()方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。 &lt;clinit&gt;()方法对于类或接口不是必须的，如果一个类中不包含静态语句块，也没有对类变量的赋值操作，编译器可以不为该类生成&lt;clinit&gt;()方法。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit&gt;()方法。但接口与类不同的是，执行接口的&lt;clinit&gt;()方法不需要先执行父接口的&lt;clinit&gt;()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit&gt;()方法。 虚拟机会保证一个类的&lt;clinit&gt;()方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的&lt;clinit&gt;()方法，其它线程都会阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。如果在一个类的&lt;clinit&gt;()方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。 在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。在Java中对类变量进行初始值设定有两种方式： 声明类变量时指定初始值。 使用静态代码块为类变量指定初始值。 只有当对类主动引用的时候才会导致类的初始化，主动引用有以下几种： 创建类的实例，也就是new的方式。 访问某个类或接口的静态变量，或者对该静态变量赋值。 调用类的静态方法。 使用java.lang.reflect包的方法对类进行反射调用的时候。 当初始化一个类的时候，如果其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。 除主动引用外的所有引用类的方式都不会触发初始化，被称为被动引用，常见有以下几个例子: 通过子类引用父类的静态字段，不会导致子类初始化。 通过数组定义来引用类，不会触发此类的初始化。该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自Object的子类，其中包含了数组的属性和方法。 类加载器两个类相等需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。 从 Java 虚拟机的角度来讲，只存在以下两种不同的类加载器： 启动类加载器（Bootstrap ClassLoader），这个类加载器用C++实现，是虚拟机自身的一部分。 所有其他类的加载器，这些类由Java实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类： 启动类加载器（Bootstrap ClassLoader）：此类加载器负责将存放在 &lt;JRE_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用null代替即可。 扩展类加载器（Extension ClassLoader）：此类加载器是由ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将&lt;JAVA_HOME&gt;/lib/ext或者被java.ext.dir系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：此类加载器是由AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。 该模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。这里类加载器之间的父子关系一般通过组合关系来实现，而不是通过继承的关系实现。 具体过程 当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。 当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。 如果BootStrapClassLoader加载失败（例如在&lt;JRE_HOME&gt;\lib里未查找到该class），会使用ExtClassLoader来尝试加载。 若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。 优点使得Java类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。 例如java.lang.Object存放在rt.jar中，如果编写另外一个java.lang.Object的类并放到ClassPath中，程序可以编译通过。由于双亲委派模型的存在，所以在rt.jar中的Object比在ClassPath中的Object优先级更高，这是因为rt.jar中的Object使用的是启动类加载器，而ClassPath中的Object使用的是应用程序类加载器。rt.jar中的Object优先级更高，那么程序中所有的Object都是这个Object。 自定义类加载器通常情况下，我们都是直接使用系统类加载器，但是有的时候，我们也需要自定义类加载器。 自定义类加载器一般都是继承自ClassLoader类，而java.lang.ClassLoader的loadClass()实现了双亲委派模型的逻辑，因此自定义类加载器最好不要去重写它。 参考资料 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解JVM-内存模型]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java内存模型由于计算机上的内存模型涉及到物理的主内存、高速缓存和寄存器等。这些不同的计算机不同的操场系统可能会存在差异，Java虚拟机规范中试图定义一种Java内存模型，来屏蔽掉各种硬件和操作系统的内存访问差异，让Java程序在各个平台下都能达到一致的访问效果。 主内存与工作内存 Java内存模型规定了所有变量都存储在主内存内（主内存包括方法区和堆），此处主内存隶属于Java虚拟机内存的一部分，而虚拟机内存是操作系统分配的。每条Java线程还有自己的工作内存，工作内存中保存了被该线程使用到的变量的主内存的副本，线程对变量的所有操作都在工作内存中进行，Java线程之间的变量值传递都通过主内存来完成。 内存间的交互关于主内存和工作内存间的交互协议，即一个变量如何从主内存拷贝到工作内存、又是如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8种操作，这8种操作实现时必须保证每一种操作都是原子的、不可再分的，其中前4条是作用于主内存，后4条作用于工作内存： lock锁定：将一个变量标识为线程独占状态 unlock解锁：将锁定状态的变量解除锁定，释放后的变量才可以被其他变量锁定 read读取：将变量从主内存传输到线程的工作内存中，待之后的load加载 write写入：把store操作从工作内存中得到的变量值写入主内存的变量中 load加载：将read后从主内存得到的变量值加载到工作内存的变量副本中 use使用：把工作内存中的一个变量值传递给字节码执行引擎，等待字节码指令使用 assign赋值：把一个从执行引擎接收到的值赋值给工作内存的变量 store存储：把工作内存中一个变量的值传送到主内存中，以便随后的write使用 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。其中程序计数器、JVM栈、本地方法栈是线程私有的，而方法区和堆是所有线程共享的。 程序计数器一块较小的内存空间，可以看作当前线程所执行的字节码的行号指示器：如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行Native方法，这个计数器值为空。 Java虚拟机栈Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 局部变量表：局部变量表是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。局部变量表所需的内存空间在编译期间完成分配。 动态链接：动态链接是在运行时将符号引用解析为直接引用的过程。 操作数：参与运算的常量或者变量称为操作数。 该区域可能抛出以下异常： 当线程请求的栈深度超过最大值，会抛出StackOverflowError异常。 栈进行动态扩展时如果无法申请到足够内存，会抛出OutOfMemoryError异常。 本地方法栈本地方法栈与Java虚拟机栈类似，它们的区别只不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为本地方法服务。该区域可能抛出的异常与Java虚拟机栈一样。 Java堆Java堆是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，还可以细分为新生代和老年代。 一般情况下，新创建的对象都会存放到新生代中。 在新生代每进行一次垃圾收集后，就会给存活的对象“加1岁”，当年龄达到一定数量的时候就会进入老年代，另外，比较大的对象也会进入老年代。 Java堆不需要物理上连续的内存空间，逻辑上连续即可。如果堆中没有内存完成实例分配且堆也无法再扩展时，将抛出OutOfMemoryError异常。 方法区方法区也是各个线程共享的内存区域，之前是用永久代实现的，用于存储已被虚拟机加载的类信息、常量、静态变量等数据。由于永久代的回收效率低，对于永久代的大小指定困难且容易发生内存溢出等原因，JDK1.8彻底废弃永久代而使用元空间取代，并将字符串常量转移到堆中。元空间并不在虚拟机中，而是使用本地内存，因此默认情况下元空间的大小仅受本地内存限制。 控制参数汇总可以通过如下参数来控制各区域的内存大小：123456789-Xms设置堆的最小空间大小-Xmx设置堆的最大空间大小-XX:NewSize设置新生代最小空间大小-XX:MaxNewSize设置新生代最大空间大小-Xss设置每个线程的堆栈大小 参考资料 周志明. 深入理解 Java 虚拟机 [M]. 机械工业出版社, 2011.]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理-死锁]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁的定义一组进程中，每个进程都无限等待被该组进程中另一进程所占有的资源，因而永远无法得到的资源，这种现象称为进程死锁，这一组进程就称为死锁进程。 死锁与活锁的区别活锁指的是一组进程既无进展也没有阻塞 ，由于某些条件没有满足，导致一直重复尝试并失败。例如错误地使用Pertonson算法： 产生死锁的必要条件 互斥使用（资源独占）：一个资源每次只能给一个进程使用。 占有且等待（请求和保持）：进程在申请新的资源的同时保持对原有资源的占有。 不可抢占：资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放。 循环等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 资源分配图系统由若干类资源构成，一类资源称为一个资源类；每个资源类中包含若干个同种资源，称为资源实例。用方框表示资源类，用方框中的黑圆点表示资源实例，用圆圈中加进程名表示进程。如果资源分配图中没有环路，则系统中没有死锁， 如果图中存在环路则系统中可能存在死锁。 资源分配图化简 找一个非孤立、且只有分配边的进程结点，去掉分配边，将其变为孤立结点。 再把相应的资源分配给一个等待该资源的进程，即将该进程的申请边变为分配边。 如果一个图可完全化简（所有的资源和进程都变成孤立的点），则不会产生死锁；如果一个图不可完全化简（即图中还有边存在），则会产生死锁。 死锁预防防止产生死锁的四个必要条件中任何一个条件发生，以此排除发生死锁的可能性。 破坏“互斥使用”条件把独占资源变为共享资源。例如在SPOOLing系统中，实际上并没有为任何进程分配这台打印机，而只是在输入井和输出井中，为进程分配一存储区和建立一章I/O请求表。这样，便把独占设备改造为共享设备。 破坏“占有且等待”条件实现方案一：要求每个进程在运行前必须一次性申请它所要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配。 实现方案二：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资 源，若需要再重新申请。 破坏“不可抢占”条件当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源(两个进程优先级不同) 。 破坏“循环等待”条件通过定义资源类型的线性顺序实现。 把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进行，否则操作系统不予分配。 死锁避免在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统发生死锁或可能发生死锁，则不予分配，否则予以分配。 安全状态如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 例如，图a的第二列Has表示已拥有的资源数，第三列Max表示总共需要的资源数，Free表示还有可以使用的资源数。从图a开始出发，先让B拥有所需的所有资源（图b），运行结束后释放B，此时Free变为5（图c）；接着以同样的方式运行C和A，使得所有进程都能成功运行，因此可以称图a所示的状态时安全的。 单个资源的银行家算法一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 由图可知，状态b进入状态c是进入了一个不安全的状态，因此恢复原来状态，避免了进入不安全状态。 多个资源的银行家算法上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的E、P以及A分别表示：总资源、已分配资源以及可用资源。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到A 中。 重复以上两步，直到所有进程都标记为终止，则状态是安全的。 如果一个状态不是安全的，需要拒绝进入这个状态。 死锁检测与解除允许死锁发生，但是操作系统会不断监视系统进展情况，判断死锁是否真的发生，一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行。 死锁的检测死锁的检测与银行家算法几乎一样，此处不再阐述。 死锁的解除 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 鸵鸟算法把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 哲学家就餐问题五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 123456789101112#define N 5void philosopher(int i) &#123; while(true) &#123; think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); &#125;&#125; 为了防止死锁的发生，有以下几种解法： 仅当一个哲学家左右两边的筷子都可用时，才允许他拿筷子。 最多允许4个哲学家同时坐在桌子周围。 规定奇数号哲学家先拿左筷子再拿右筷子，而偶数号哲学家相反。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 北京大学操作系统原理（Operating Systems） 计算机操作系统]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>死锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理-文件系统]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[文件的分类 普通文件：包含了用户的信息，一般为ASCII或二进制文件 目录文件：管理文件系统的系统文件 特殊文件（设备文件） 文件的逻辑结构逻辑结构是从用户观点出发看到的文件的组织形式。分为以下两类： 流式文件：无结构，对文件内信息不再划分单位，它是依次的一串字符流构成的文件。 记录式文件：有结构，文件由若干个记录组成，可以按记 录进行读、写、查找等操作。 存储介质与物理块典型的存储介质磁盘(包括固态盘SSD)、磁带、光盘、U盘等等，以下为典型的磁盘结构： 物理块 信息存储、传输、分配的独立单位 存储设备划分为大小相等的物理块，统一编号 磁盘访问 寻道：磁头移动定位到指定磁道 旋转延迟：等待指定扇区从磁头下旋转经过 数据传输：数据在磁盘与内存之间的实际传输 文件控制块（FCB）为管理文件而设置的数据结构，保存管理文件所需的所有有关信息（文件属性或元数据）。 文件控制块一般包含下列常用属性： 文件名 文件号 文件大小 文件地址 创建时间 最后修改时间 最后访问时间 各种标志(只读、隐藏、系统、归档等) … 文件目录 文件目录：文件目录由目录项构成，统一管理每个文件的元数据，以支持文件名到文件物理地址的转换。 目录文件：将文件目录以文件的形式存放在磁盘上。 目录项：可以看成是FCB。 文件的物理结构文件的物理结构指的是文件在存储介质上的存放方式。 连续结构文件的信息存放在若干连续的物理块中。 连续结构实现简单，且所需的磁盘寻道次数和寻道时间最少，支持顺序存取和随机存取，但文件不能动态增长，且会产生许多外部碎片。 链接结构一个文件的信息存放在若干不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一 个物理块。 使用链接结构不存在外部碎片的问题，提高了磁盘空间利用率，有利于文件的动态扩充，但是比起连续结构需要更多的寻道次数和寻道时间，且存取速度慢，不适于随机存取。 索引结构一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些物理块的块号存放在该索引表中。 索引结构保持了链接结构的优点，也解决了其缺点：既能顺序存取又能随机存取，满足了文件动态增长的要求，能充分利用磁盘空间。但是索引结构依然有较多的寻道次数和寻道时间，而索引表本身也带来了额外系统开销。 多级索引结构（综合模式） UNIX文件系统采用的便是这种多级索引结构（综合模式）：每个文件的索引表有15个索引项，每项2个字节，前12项直接存放文件的物理块号，如果文件大于12块，则利用第13项指向一个物理块作为一级索引表。假设扇区大小为512字节，物理块等于扇区块大小，那么一级索引表可以存放256个物理块号。对于更大的文件还可利用第14和第15项作为二级和三级索引表。 文件目录检索用户给出文件名，按文件名查找到目录项/FCB，根据目录项/FCB中文件物理地址等信息，计算出文件中任意记录或字符在存储介质上的地址。 目录项分解法通过目录项分解法可以加快文件目录的检索速度。 目录项分解法即把FCB分解成两部分：符号目录项（文件名，文件号）、基本目录项（除文件名外的所有字段）。目录文件改进后减少了访盘次数，提高了文件检索速度。 磁盘调度算法当有多个访盘请求等待时，采用一定的策略，对这些请求的服务顺序调整安排，以降低平均磁盘服务时间，达到公平、高效。 先来先服务（FCFS）按访问请求到达的先后次序服务。 优点是简单公平，但效率不高，相临两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利。 最短寻道时间优先（Shortest Seek Time First）优先选择距当前磁头最近的访问请求进行服务。 虽然改善了磁盘平均服务时间，但是造成某些访问请求长期等待得不到服务，也就是饥饿现象。 扫描算法（SCAN）扫描算法又称为电梯算法，当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。 单向扫描算法（CSCAN）扫描调度算法（SCAN）存在这样的问题：当磁头刚从里向外移动过某一磁道时，恰有一进程请求访问此磁道，这时该进程必须等待，待磁头从里向外，然后再从外向里扫描完所有要访问的磁道后，才处理该进程的请求，致使该进程的请求被严重地推迟。 为了减少这种延迟，CSCAN算法规定磁头只做单向移动。例如，磁头只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。 旋转调度算法旋转调度算法根据延迟时间来决定执行次序的调度，请求访问分为以下三种情况： 若干等待访问者请求访问同一磁头上的不同扇区 若干等待访问者请求访问不同磁头上的不同编号的扇区 若干等待访问者请求访问不同磁头上具有相同的扇区 对于前两种情况总是让首先到达读写磁头位置下的扇区先进行传送操作，而对于第三种情况，这些扇区同时到达读写磁头位置下，可任意选择一个读写磁头进行传送操作。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 北京大学操作系统原理（Operating Systems） 计算机操作系统]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理-存储模型]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[地址重定位为了保证CPU执行指令时可正确访问内存单元，需要将用户程序中的逻辑地址转换为运行时可由机器直接寻址的物理地址，这一过程称为地址重定位（又称地址转换、地址变换、地址翻译、地址映射）。 逻辑地址（相对地址，虚拟地址）：目标代码通常采用相对地址的形式，其首地址为0， 其余地址都相对于首地址而编址。不能用逻辑地址在内存中读取信息。 物理地址（绝对地址，实地址）：内存中存储单元的地址，可直接寻址。 地址重定位分为静态重定位和动态重定位： 静态重定位：当用户程序加载到内存时，一次性实现逻辑地址到物理地址的转换。 动态重定位：在进程执行过程中进行地址变换，即逐条指令执行时完成地址转换。 伙伴系统Linux底层内存管理采用伙伴系统这一种经典的内存分配方案。 主要思想：将内存按2的幂进行划分，组成若干空闲块链表；查找该链表找到能满足进程需求的最佳匹配块。 过程： 首先将整个可用空间看作一块： 2^u 假设进程申请的空间大小为 s，如果满足 2^u-1 &lt; s &lt;= 2^u，则分配整个块；否则，将块划分为两个大小相等的伙伴，大小为2^u-1 一直划分下去直到产生大于或等于 s 的最小块 基本内存管理方案一整个进程进入内存中一片连续区域。 单一连续区内存在此方式下分为系统区和用户区，系统区仅提供给操作系统使用，用户区是为用户提供的、除系统区之外的内存空间。一段时间内只有一个进程在内存，简单但内存利用率低。 固定分区把内存空间分割成若干区域，称为分区，每个分区的大小可以相同也可以不同，但分区大小固定不变，每个分区装一个且只能装一个进程。 这种方式会产生两个问题：一是程序太大而放不进任何一个分区中；二是容易产生内部碎片。 可变分区可变分区是一种动态划分内存的分区方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态地建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。 可变分区虽然不会产生内部碎片，但容易产生外部碎片，导致内存利用率下降。 在进程装入或换入主存时，如果内存中有多个足够大的空闲块，操作系统必须确定分配哪个内存块给进程使用，考虑以下几种分配算法： 首次适配（first fit）：在空闲区表中找到第一个满足进程要求的空闲区。该算法优先使用低址部分空闲区，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。 下次适配（next fit）：从上次找到的空闲区处接着查找。 最佳适配（best fit）：查找整个空闲区表，找到能够满足进程要求的最小空闲区。该算法保留大的空闲区，但造成许多小的空闲区。 最差适配（worst fit ）：总是分配满足进程要求的最大空闲区。该算法保留小的空闲区，尽量减少小的碎片产生。 基本内存管理方案二一个进程进入内存中若干片不连续的区域。 页式存储管理方案用户进程地址空间被划分为大小相等的部分，称为页（page）或页面，从0开始编号。内存空间按同样大小划分为大小相等的区域，称为页框（page frame）或物理页面或内存块，从0开始编号。 内存分配规则：以页为单位进行分配，并按进程需要的页数来分配；逻辑上相邻的页，物理上不一定相邻。 每个进程一个页表，存放在内存。 地址转换CPU取到逻辑地址，自动划分为页号和页内地址；用页号查页表，得到页框号，再与页内偏移拼接成为物理地址。 段式存储管理方案将用户进程地址空间按程序自身的逻辑关系划分为若干个程序段，每个程序段都有一个段号。内存空间被动态划分为若干长度不相同的区域， 称为物理段，每个物理段由起始地址和长度确定。 内存分配规则：以段为单位进行分配，每段在内存中占据连续空间，但各段之间可以不相邻。 地址转换CPU取到逻辑地址，自动划分为段号和段内地址；用段号查段表，得到该段在内存的起始地址，与段内偏移地址计算出物理地址。 覆盖技术把一个程序划分为一系列功能相对独立的程序段，让执行时不要求同时装入内存的程序段组成一组（称为覆盖段），共享同一块内存区域 ，这种内存扩充技术就是覆盖技术。 程序段先保存在磁盘上，当有关程序段的前一部分执行结束，把后续程序段调入内存，覆盖前面的程序段。 一般要求作业各模块之间有明确的调用结构，程序员要向系统指明覆盖结构，然后由操作系统完成自动覆盖。 交换技术内存空间紧张时，系统将内存中某些进程暂时移到外存，把外存中某些进程换进内存，占据前者所占用的区域（进程在内存与磁盘之间的动态调度）。 虚拟存储技术所谓虚拟存储技术是指：当进程运行时，先将其一部分装入内存，另一部分暂留在磁盘，当要执行的指令或访问的数据不在内存时，由操作系统自动完成将它们从磁盘调入内存的工作。 虚拟地址空间：分配给进程的虚拟内存 虚拟地址：在虚拟内存中指令或数据的位置， 该位置可以被访问，仿佛它是内存的一部分 虚拟内存：把内存与磁盘有机地结合起来使用，从而得到一个容量很大的“内存” 虚拟页式存储管理系统虚拟页式即将虚拟存储技术和页式存储管理方案结合起来，以CPU时间和磁盘空间换取昂贵内存空间。 基本思想：进程开始运行之前，不是装入全部页面， 而是装入一个或零个页面，之后，根据进程运行的需要，动态装入其他页面。当内存空间已满，而又需要装入新的页面时，则根据某种算法置换内存中的某个页面，以便装入新的页面。 内存管理单元（MMU）内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。 上图为一级页表结构的地址转换，下图为二级页表结构的地址转换及MMU的位置。 二级页表结构及地址映射页目录表共有2^10 = 1K个表项，每个表项是4B，因此页目录大小为4K，存储在一个4K字节的页面中。同理，一个页表也存储在一个4K字节的页面中。 为什么要使用多级页表系统分配给每个进程的虚拟地址都是4G，那么采用一级页表需要4G／4K = 2^20个表项，如果每个页表项是4B，那么需要4MB的内存空间。但是大多数程序根本用不到4G的虚拟内存空间，比如hello world程序，这样一个几kb的程序却需要4MB的内存空间是很浪费的。如果采用二级页表，那么一级页表只需要4KB的空间用来索引二级页表的地址，像hello world这样的程序可能只需要一个物理页，那么只需要一条记录就可以了，故对于二级页表也只要4KB就足够了，所以这样只需要8KB就能解决问题。 TLB（快表）页表一般都很大，并且存放在内存中，所以处理器引入MMU后，读取指令、数据需要访问两次内存：首先通过查询页表得到物理地址，然后访问该物理地址读取指令、数据。由于CPU的指令处理速度与内存指令的访问速度差异大，CPU的速度得不到充分利用，为了减少因为MMU导致的处理器性能下降，引入了TLB。 TLB(Translation Lookaside Buffer)转换检测缓冲区相当于页表的缓存，利用程序访问的局部性原理改进虚拟地址到物理地址的转换速度。TLB保存正在运行进程的页表的子集(部分页表项)，只有在TLB无法完成地址转换任务时，才会到内存中查询页表，这样就减少了页表查询导致的处理器性能下降。 缺页异常缺页异常是一种Page Fault（页错误）。在地址映射过程中，硬件检查页表时发现所要访问的页面不在内存，则产生缺页异常，操作系统执行缺页异常处理程序：获得磁盘地址，启动磁盘，将该页调入内存。此时分为两种情况： 如果内存中有空闲页框，则分配一个页框， 将新调入页装入，并修改页表中相应页表项的有效位及相应的页框号。 若内存中没有空闲页框，则要置换内存中某一页框；若该页框内容被修改过，则要将其写回磁盘。 页面置换算法最佳页面置换算法（OPT，Optimal）置换以后不再需要的或最远的将来才会用到的页面。 这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问，它作为一种标准来衡量其他算法的性能。 先进先出算法（FIFO）选择在内存中驻留时间最长的页并置换它。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 第二次机会算法（SCR，Second Chance）当页面被访问 (读或写) 时设置该页面的R位为1。需要替换的时候，检查最老页面的R位。如果R位是0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是1，就将R位清0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 这个算法是对FIFO算法的改进，不会像FIFO一样把经常使用的页面置换出去。 时钟算法（CLOCK）第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 最近未使用算法（NRU，Not Recently Used）选择在最近一段时间内未使用过的一页并置换。 每个页面都有两个状态位：R与M，当页面被访问时设置页面的R=1，当页面被修改时设置M=1。其中R位会定时被清零。可以将页面分成以下四类： R=0，M=0 R=0，M=1 R=1，M=0 R=1，M=1 当发生缺页中断时，NRU算法随机地从类编号最小的非空类中挑选一个页面将它换出。 NRU算法优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。 最近最久未使用算法（LRU，Least Recently Used ）虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU算法选择最后一次访问时间距离当前时间最长的一页并置换，即置换未使用时间最长的一页。 为了实现LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最长时间未访问的。 LRU的性能接近OPT，但因为每次访问都需要更新链表，因此这种方式实现的LRU代价很高。 最不经常使用算法（NFU，Not Frequently Used）NFU算法选择访问次数最少的页面置换。 因为LRU算法的实现比较麻烦而且开销很大，所以提出了用软件来模拟LRU算法的NFU算法，该算法为每一页设置一个软件计数器，初值为0，每次时钟中断的时候就将计数器加R，发生缺页中断时选择计数器值最小的一页置换。 老化算法（AGING）在NFU算法中存在一个问题：在第一次时钟中断的时候其中一页可能被访问了很多次，之后再未被访问过，然而在以后的时钟中断这一页计数器的值仍然高于其它页，因此其虽然长时间未被访问也不会被置换出去。 为了更好地模拟LRU算法，老化算法对NFU进行了改进，计数器在加R前先右移一位，R位加到计数器的最左端。 工作集算法基本思想：根据程序的局部性原理，一般情况下，进程在一段时间内总是集中访问一些页面，这些页面称为活跃页面，如果分配给一个进程的物理页面数太少了，使该进程所需的活跃页面不能全部装入内存，则进程在运行过程中将频繁发生中断 。如果能为进程提供与活跃页面数相等的物理页 面数，则可减少缺页中断次数。 工作集W(t, Δ) = 该进程在过去的Δ个虚拟时间单位中访问到的页面的集合 工作集算法就是找出一个不在工作集中的页面并置换它。具体过程为：扫描所有页表项，如果一个页面的R位是1，则将该页面的最后一次访问时间设为当前时间，将R位清零；如果一个页面的R位是0，则检查该页面的访问 时间是否在“当前时间-T”之前，如果是，则该页面为被置换的页面；如果不是，记录当前所有被扫描过页面的最后访问时间里面的最小值，扫描下一个页面并重复上述过程。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 北京大学操作系统原理（Operating Systems） 计算机操作系统 内存连续分配方式的几种算法及优劣 多级页表]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理-同步机制]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程互斥由于各进程要求使用共享资源（变量、文件等），而这些资源需要排他性使用，各进程之间竞争使用这些资源，这一关系称为进程互斥。 临界资源与临界区系统中某些资源一次只允许一个进程使用，称这样的资源为临界资源或互斥资源或共享变量。 而各个进程中对某个临界资源（共享变量）实施操作的程序片段称为临界区或互斥区。 临界区的使用原则 没有进程在临界区时，想进入临界区的进程可进入 不允许两个进程同时处于其临界区中 临界区外运行的进程不得阻塞其他进程进入临界区 不得使进程无限期等待进入临界区 进程互斥的软件解决方案错误解法考虑两个进程p和q，pturn与qturn表示哪个进程要进入临界区，P进入临界区的条件为pturn &amp;&amp; not qturn，而Q进入临界区的条件为not pturn &amp;&amp; qturn: 12345//进程p：pturn = true; while (qturn) ; visit(); //访问临界区pturn = false; 12345//进程q：qturn = true; while (pturn) ; visit(); //访问临界区qturn = false; 如果由于CPU调度使得两个进程都执行完了第一行语句，也就是pturn和qturn都为true了，那么就都会在下一行while语句上死循环，互相都在谦让对方执行，也就不满足了临界区的使用原则—不得使进程无限期等待进入临界区。 Dekker算法Dekker互斥算法是由荷兰数学家Dekker提出的一种解决并发进程互斥与同步的软件实现方法。假设有p和q两个进程，变量pturn、qturn表示p和q进程是否想要资源（可以想象为举手示意想要），变量turn表示安排资源给谁： 123456789101112//进程P：pturn = true; //进程p举手示意想要访问while (qturn) &#123; //如果进程q也举手了 if (turn == 2) &#123; //资源被安排给了q pturn = false; //进程p把手放下 while (turn == 2); //资源安排给q的时候一直等待 pturn = true; //此时资源安排给了自己，进程p再举手 &#125;&#125;visit(); //访问临界区turn = 2; //进程p使用完了，安排资源给qpturn = false; //进程p把手放下 123456789101112//进程q：qturn = true; while (pturn) &#123; if (turn == 1) &#123; qturn = false; while (turn == 1); qturn = true; &#125;&#125;visit(); //访问临界区turn = 1;qturn = false; 如果两个进程都执行完了第一行语句，也就是pturn和qturn都为true了，那么会根据变量turn进一步查看究竟是把资源安排给了谁，如果安排给了另一个进程，那么自己就先把手放下，等待安排资源给自己。 与之前的错误解法相比，可以发现Dekker算法就是在原本的while死循环上做了进一步的判断，引入的turn变量总是会安排一个进程访问临界区。 Peterson算法Peterson算法是另一种解决并发进程互斥与同步的软件实现方法，而且克服了强制轮流法的缺点。其使用十分方便，只需要向如下这样调用即可: 123enter_region(i);visit(); //访问临界区leave_region(i); 其中的enter_region方法实现如下： 1234567891011121314#define FALSE 0#define TRUE 1#define N 2 //进程的个数int turn; //轮到谁int interested[N]; //兴趣数组，初始值均为FALSE void enter_region(int process) // process = 0 或 1&#123; int other; // 另外一个进程的进程号 other = 1 - process; interested[process] = TRUE; // 表明本进程感兴趣 turn = process; // 设置标志位 while(turn == process &amp;&amp; interested[other] == TRUE); &#125; 如果有两个进程都要执行的话，turn会被设置成后一个进程的进程号，这时候因为要按照先来后到的规矩，后一个进程在判断while条件的时候turn == process成立，也就进行循环等待，而先进入的进程可以访问临界区。当先进入的进程离开了临界区，就调用leave_region方法，将自己的兴趣设为FALSE，后一个进程判断interested[other] == TRUE不成立时就可以跳出while循环进入临界区了。 123void leave_region(int process)&#123; interested[process] = FALSE; // 本进程已离开临界区&#125; 进程互斥的硬件解决方案“测试并加锁”指令 “交换”指令 进程同步进程同步指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务。具体地说，一个进程运行到某一点时， 要求另一伙伴进程为它提供消息，在未获得消息之前，该进程进入阻塞态，获得消息后被唤醒进入就绪态。 信号量及PV操作信号量是一个特殊变量，用于进程间传递信息的一个整数值，定义如下： 12345struct semaphore&#123; int count; queueType queue;&#125; 可以对其执行down和up操作，也就是常见的P和V操作（PV操作均为原语操作），定义如下： 12345678910111213141516171819P(semaphore s) &#123; s.count--; if (s.count &lt; 0) &#123; //该进程状态置为阻塞状态； //将该进程插入相应的等待队列s.queue末尾; //重新调度； &#125;&#125;V(semaphore s) &#123; s.count++; if (s.count &lt;= 0) &#123; //唤醒相应等待队列s.queue中等待的一个进程； //改变其状态为就绪态，并将其插入就绪队列； &#125; &#125; 用PV操作解决进程间互斥问题 分析并发进程的关键活动，划定临界区 设置信号量 mutex，初值为1 在临界区前实施 P(mutex) 在临界区之后实施 V(mutex) 用信号量解决生产者-消费者问题问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 这里使用三个信号量，其中mutex用于解决互斥问题，empty和full用于解决同步问题。 123456789101112131415161718192021222324252627#define N 100 //缓冲区个数typedef int semaphore; //信号量是一种特殊的整型数据semaphore mutex = 1; //互斥信号量：控制对临界区的访问semaphore empty = N; //空缓冲区个数，初始为Nsemaphore full = 0; //满缓冲区个数，初始为0void producer() &#123; while(TRUE) &#123; int item = produce_item(); p(&amp;empty); p(&amp;mutex); insert_item(item); v(&amp;mutex); v(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE) &#123; p(&amp;full); p(&amp;mutex); int item = remove_item(); v(&amp;mutex); v(&amp;empty); consume_item(item); &#125;&#125; 注意：不能交换p(&amp;empty);和p(&amp;mutex);的顺序，否则会导致死锁。 用信号量解决读者-写者问题问题描述：多个进程共享一个数据区，这些进程分为只读数据区中的数据的读者进程和只往数据区中写数据的写者进程。允许多个读者同时执行读操作，不允许多个写者同时操作，不允许读者、写者同时操作。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1; //对count加锁semaphore data_mutex = 1; //对读写的数据加锁int count = 0; //对数据进行读操作的进程数量void reader() &#123; while(TRUE) &#123; p(&amp;count_mutex); count = count + 1; if(count == 1) p(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 v(&amp;count_mutex); read(); p(&amp;count_mutex); count = count - 1; if(count == 0) v(&amp;data_mutex); v(&amp;count_mutex); &#125;&#125;void writer() &#123; while(TRUE) &#123; p(&amp;data_mutex); write(); v(&amp;data_mutex); &#125;&#125; 管程由于信号量机制程序编写困难、易出错，所以在程序设计语言中引入管程。 管程是一个抽象数据类型，由关于共享资源的数据结构及在其上操作的一组过程组成，进程只能通过调用管程中的过程来间接地访问管程中的数据结构。 互斥/同步互斥：管程是互斥进入的，管程的互斥性是由编译器负责保证的。 同步：管程中设置条件变量及等待/唤醒操作以解决同步问题，可以让一个进程或线程在条件变量上等待（此时，应先释放管程的使用权），也可以通过发送信号将等待在条件变量上的进程或线程唤醒。 Hoare管程因为管程是互斥进入的，所以当一个进程试图进入一个已被占用的管程时，应当在管程的入口处等待，为此，管程的入口处设置一个进程等待队列，称作入口等待队列。 如果进程P唤醒进程Q，则P等待Q执行；如果进程Q执行中又唤醒进程R，则Q等待R执行；如此， 在管程内部可能会出现多个等待进程。在管程内需要设置一个进程等待队列，称为紧急等待队列，紧急等待队列的优先级高于入口等待队列的优先级。 条件变量条件变量是在管程内部说明和使用的一种特殊类型的变量，对于条件变量，可以执行wait和signal操作： wait(c)：如果紧急等待队列非空，则唤醒第一个等待者；否则释放管程的互斥权，执行此操作的进程进入c链末尾。 signal(c)：如果c链为空，则相当于空操作，执行此操作的进程继续执行；否则唤醒第一个等待者，执行此操作的进程进入紧急等待队列的末尾。 用管程解决生产者-消费者问题12345678910111213141516171819202122232425262728293031323334353637383940//管程monitor ProducerConsumer condition full, empty; //条件变量 integer count; procedure insert (item: integer); begin if count == N then wait(full); insert_item(item); count++; if count ==1 then signal(empty); end; function remove: integer; begin if count==0 then wait(empty); remove = remove_item; count--; if count==N-1 then signal(full); end; count:=0; end monitor; //生产者procedure producer; begin while true do begin item = produce_item; ProducerConsumer.insert(item); end end; //消费者procedure consumer; begin while true do begin item=ProducerConsumer.remove; consume_item(item); end end; MESA管程Hoare管程有个缺点就是会有两次额外的进程切换，因此MESA管程将原本的signal操作变为notify操作：当一个正在管程中的进程执行notify(x)时，它使得x条件队列得到通知，发信号的进程继续执行，而位于条件队列头的进程在将来合适的时候且当处理器可用时恢复执行。 由于收到通知时并未执行，且对等待进程在notify之后何时运行没有任何限制，所以当进程真正被调度时，条件不一定成立，因而这个进程必须重新检查条件，也就是用while循环取代if语句。 IPC（进程间通信）进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 进程通信的方式通常有管道（包括无名管道和命名管道）、消息队列、信号量、共享存储、Socket、Streams等。其中 Socket和Streams支持不同主机上的两个进程IPC。 管道管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。 管道是通过调用 pipe 函数创建的，当一个管道建立时，它会创建两个文件描述符：fd[0]为读而打开，fd[1]为写而打开，要关闭管道只需将这两个文件描述符关闭即可。 单个进程中的管道几乎没有任何用处。所以，通常调用 pipe 的进程接着调用 fork，这样就创建了父进程与子进程之间的 IPC 通道。若要数据流从父进程流向子进程，则关闭父进程的读端（fd[0]）与子进程的写端（fd[1]）；反之，则可以使数据流从子进程流向父进程。 特点: 它是半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。 它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。 FIFOFIFO也称为命名管道，它是一种文件类型，可以在无关的进程之间交换数据，与无名管道不同。 FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 消息队列消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。 消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取。 信号量信号量是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。 共享内存共享内存指两个或多个进程共享一个给定的存储区，因为数据不需要在进程之间复制，所以这是最快的一种 IPC。由于多个进程可以同时操作，所以信号量与共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。 套接字与其它通信机制不同的是，它可用于不同机器间的进程通信。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 北京大学操作系统原理（Operating Systems） 计算机操作系统 进程间的五种通信方式介绍]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理-进程线程模型]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86-%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[进程的定义进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。 进程控制块PCBPCB：Process Control Block，又称进程描述符、进程属性，是操作系统用于管理控制进程的一个专门数据结构，是系统感知进程存在的唯一标志。 PCB的内容包括： 进程描述信息 进程控制信息 所拥有的资源和使用情况 CPU现场信息 进程状态及状态转换进程的三种基本状态 运行态（Running）：占有CPU，并在CPU上运行 就绪态（Ready）：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行 等待态（Waiting/Blocked）：因等待某一事件而暂时不能运行（如等待读盘结果，又称为阻塞态、睡眠态） 三状态模型及状态转换 其中，只有就绪态和运行态可以相互转换，其它的都是单向转换。 进程的其它状态 创建：已完成创建一进程所必要的工作，但因为资源有限尚未同意执行该进程 终止：终止执行后，进程进入该状态，回收资源 挂起：用于调节负载，进程不占用内存空间，其进程映像交换到磁盘上 进程的五状态模型 进程队列操作系统为每一类进程建立一个或多个队列，队列元素为PCB，伴随进程状态的改变，其PCB从一个队列进入另一个队列。以下为五状态进程模型的队列模型： 进程控制进程控制操作完成进程各状态之间的转换，由具有特定功能的原语完成： 进程创建原语 进程撤消原语 阻塞原语 唤醒原语 挂起原语… 原语：完成某种特定功能的一段程序，具有不可分割性或不可中断性，即原语的执行必须是连续的，在执行过程中不允许被中断 进程的创建 给新进程分配一个唯一标识以及进程控制块 为进程分配地址空间 初始化进程控制块 设置相应的队列指针（如: 把新进程加到就绪队列链表中） 进程的撤销 收回进程所占有的资源（如：关闭打开的文件、断开网络连接、回收分配的内存） 撤消该进程的PCB 进程阻塞处于运行状态的进程，在其运行过程中期待某一事件发生，如等待键盘输入、等待磁盘数据传输完成、等待其它进程发送消息，当被等待的事件未发生时，由进程自己执行阻塞原语，使自己由运行态变为阻塞态。 上下文切换将CPU硬件状态从一个进程换到另一个进程的过程称为上下文切换。 进程运行时，其硬件状态保存在CPU上的寄存器中；进程不运行时，这些寄存器的值保存在进程控制块PCB中；当操作系统要运行一个新的进程时，将PCB中的相关值送到对应的寄存器中。 线程的定义进程中的一个运行实体，是CPU的调度单位，有时将线程称为轻量级进程。 线程共享所在进程的地址空间和其他资源。 线程机制的实现用户级线程在用户空间建立线程库：提供一组管理线程的过程。运行时系统完成线程的管理工作，内核管理的还是进程，不知道线程的存在，线程切换不需要内核态特权。 优点： 线程切换快 调度算法是应用程序特定的 用户级线程可运行在任何操作系统上（只需要实现线程库） 缺点： 大多数系统调用是阻塞的，因此，由于内核阻塞进程，故进程中所有线程也被阻塞 核心级线程内核管理所有线程管理，并向应用程序提供API接口。内核维护进程和线程的上下文，且线程的切换需要内核支持。 混合模型线程创建在用户空间完成，线程调度等在核心态完成。 线程与进程的区别 拥有资源：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 调度：线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 北京大学操作系统原理（Operating Systems） 计算机操作系统]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统 </tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统原理-处理器调度]]></title>
    <url>%2F2019%2F01%2F28%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E2%80%94%2F</url>
    <content type="text"><![CDATA[CPU调度即按一定的调度算法从就绪队列中选择一个进程， 把CPU的使用权交给被选中的进程，其任务是控制、协调进程对CPU的竞争。 调度算法衡量指标吞吐量：每单位时间完成的进程数目 周转时间：每个进程从提出请求到运行完成的时间 响应时间：从提出请求到第一次回应的时间 进程调度算法批处理系统目标：吞吐量，周转时间，cpu利用率，包含以下四种调度算法： 先来先服务（FCFS） 短作业优先（SJF） 最短剩余时间优先（SRTN） 最高响应比优先（HRRN） 先来先服务（FCFS） First Come First Serve 按照进程就绪的先后顺序使用CPU 非抢占 长进程后面的短进程需要等很长时间，不利于用户体验。 短作业优先（SJF） Shortest Job First 具有最短完成时间的进程优先执行 非抢占式 最短剩余时间优先（SRTN） Shortest Remaining Time Next SJF的抢占式版本，即当一个新就绪的进程比当前运行进程具有更短的完成时间时，系统抢占当前进程， 选择新就绪的进程执行 短作业优先的调度算法可以得到最短的平均周转时间，但随着源源不断的短任务到来，可能使长的任务长时间得不到运行，即产生 “饥饿”现象。 最高响应比优先（HRRN） Highest Response Ratio Next 调度时，首先计算每个进程的响应比R；之后，总是选择R最高的进程执行 响应比R = 周转时间 / 处理时间 =（处理时间 + 等待时间）/ 处理时间 = 1 +（等待时间 / 处理时间） 交互式系统目标：响应时间，包含以下三种调度算法： 时间片轮转（RR） 最高优先级（HPF） 多级反馈队列（Multiple feedback queue） 时间片轮转 Round Robin 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法中选择合适的时间片很重要： 如果太长，会降级为先来先服务算法，延长短进程的响应时间 如果太短，进程切换会浪费CPU时间 最高优先级 Highest Priority First 选择优先级最高的进程投入运行 优先级可以是静态不变的，也可以是动态调整的 不公平 会导致优先级翻转问题，解决方案：1、优先级天花板；2、优先级继承 优先级翻转是当一个高优先级任务通过信号量机制访问共享资源时，该信号量已被一低优先级任务占有，因此造成高优先级任务被许多具有较低优先级任务阻塞，实时性难以得到保证。 例如：有优先级为A、B和C三个任务，优先级A&gt;B&gt;C，任务A，B处于挂起状态，等待某一事件发生，任务C正在运行，此时任务C开始使用某一共享资源S。在使用中，任务A等待事件到来，任务A转为就绪态，因为它比任务C优先级高，所以立即执行。当任务A要使用共享资源S时，由于其正在被任务C使用，因此任务A被挂起，任务C开始运行。如果此时任务B等待事件到来，则任务B转为就绪态。由于任务B优先级比任务C高，因此任务B开始运行，直到其运行完毕，任务C才开始运行。直到任务C释放共享资源S后，任务A才得以执行。在这种情况下，优先级发生了翻转，任务B先于任务A运行。 解决优先级翻转问题有优先级天花板(priority ceiling)和优先级继承(priority inheritance)两种办法。 优先级天花板是当任务申请某资源时， 把该任务的优先级提升到可访问这个资源的所有任务中的最高优先级， 这个优先级称为该资源的优先级天花板。这种方法简单易行， 不必进行复杂的判断， 不管任务是否阻塞了高优先级任务的运行， 只要任务访问共享资源都会提升任务的优先级。 优先级继承是当任务A 申请共享资源S 时， 如果S正在被任务C 使用，通过比较任务C 与自身的优先级，如发现任务C 的优先级小于自身的优先级， 则将任务C的优先级提升到自身的优先级， 任务C 释放资源S 后，再恢复任务C 的原优先级。这种方法只在占有资源的低优先级任务阻塞了高优先级任务时才动态的改变任务的优先级，如果过程较复杂， 则需要进行判断。 多级反馈队列设置多个就绪队列，第一级队列优先级最高，给不同就绪队列中的进程分配长度不同的时间片，第一级队列时间片最小；随着队列优先级别的降低，时间片增大。当第一级队列为空时，在第二级队列调度，以此类推。当一个新创建进程就绪后，进入第一级队列，进程用完时间片而放弃CPU，进入下一级就绪队列。由于阻塞而放弃CPU的进程进入相应的等待队列，一旦等待的事件发生，该进程回到原来一级就绪队列。 调度算法总结 调度算法 占用CPU方式 吞吐量 响应时间 开销 对进程的影响 饥饿问题 FCFS 非抢占式 不强调 可能很慢，特别是当进程的执行时间差别很大时 最小 对短进程不利；对I/O型的进程不利 无 RR 抢占式(时间片用完时) 若时间片小，吞吐量会很低 为短进程提供好的响应时间 较大 公平对待 无 SJF 非抢占式 高 为短进程提供好的响应时间 可能较大 对长进程不利 可能 SRTN 抢占式(到达时) 高 提供好的响应时间 可能较大 对长进程不利 可能 HRRN 非抢占式 高 提供好的响应时间 可能较大 很好的平衡性 无 Feedback 抢占式(时间片用完时) 不强调 不强调 可能较大 对I/O型进程有利 可能 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 北京大学操作系统原理（Operating Systems） 计算机操作系统 优先级翻转]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList源码分析]]></title>
    <url>%2F2018%2F09%2F11%2FLinkedList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LinkedList简介（jdk1.8)LinkedList是基于双向链表实现的。如下为LinkedList的继承体系结构： 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 可以看到，LinkedList实现了Deque接口，Deque表示双端队列，即在两端都可以进行插入和删除的队列。Deque是一个比Stack和Queue功能更强大的接口，它同时实现了栈和队列的功能。Deque接口的部分方法如下：1234567891011// *** Queue methods *** boolean add(E e); boolean offer(E e); E remove(); E poll(); E element(); E peek(); // *** Stack methods *** void push(E e); E pop(); 从代码可以看出，Deque既可以用作后进先出的栈，也可以用作先进先出的队列。 与ArrayList一样，LinkedList也不是线程安全的，因此只能在单线程环境下使用。 属性LinkedList有size、first、last三个属性： 12345678//LinkedList中元素的数量transient int size = 0;//指向第一个元素transient Node&lt;E&gt; first;//指向最后一个元素transient Node&lt;E&gt; last; Node既然LinkedList是基于链表实现的，那就必须要介绍一下它的内部类Node：1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 因为是双向链表，所以每个节点都包含前一个节点的指向与后一个节点的指向。 构造函数 无参构造函数 12public LinkedList() &#123;&#125; 有参构造函数 1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 此方法先调用一个无参构造函数构造一个空列表，然后再将集合内的所有元素添加进去。 addAll将集合内的所有元素加入到LinkedLiist中。 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125; 123456789101112131415161718192021222324252627282930313233343536373839 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;//判断是否满足index &gt;= 0 &amp;&amp; index &lt;= size，若不满足，则抛出异常 checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; 此段代码中，succ表示后节点，pred表示前节点。 在进行了下标检查与长度检查后，首先判断要加入的元素是加入在末尾还是中间，如果在末尾，则succ应指向null，而pred应指向last，否则，succ应指向下标为index的节点，而pred指向该节点的前一个节点。这样，要插入的节点的前后节点就都有了，接下来就可以将要插入的节点的前后节点都连接好，从而完成插入操作。 这里有必要介绍一下取出指定位置的节点的方法：123456789101112131415Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; 与数组不同，链表无法直接通过下标找到指定的元素，而需要依次遍历。由于LinkedList是通过双向链表实现的，所以既可以从头也可以从尾开始遍历。为了提高效率，该方法先判断指定的位置index在链表的前半段还是后半段，从而决定从头还是从尾开始遍历。 linkFirst，linkLast，linkBefore在介绍add方法与其它相关方法前，有必要先介绍一下这三个辅助方法：123456789101112131415161718192021222324252627282930313233343536private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++;&#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; linkFirst、linkLast、linkBefore方法分别将元素加入到链表头部、链表尾部与链表中指定节点之前。 以linkFirst为例，先创建一个新的节点，并将first指向该节点。然后判断以前的first节点是否为null，如果为null，则说明之前链表中没有元素，应将last指向新节点，否则，将原first节点的prev指向新节点。 add，addFirst，addLast介绍完上面三个辅助方法后，我们再来看看add相关的方法。 123456789101112131415161718192021public boolean add(E e) &#123; linkLast(e); return true;&#125;public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;public void addFirst(E e) &#123; linkFirst(e);&#125;public void addLast(E e) &#123; linkLast(e);&#125; 由源码可以看到，add相关的代码都是直接调用上面介绍的辅助方法，十分简单。 unlink，unlinkFirst，unlinkLast同样，在介绍remove及相关方法时，先介绍这三个辅助方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125; 这三个方法也很好理解。以unlink方法为例，将要删除的元素的前后节点相连接，并且把要删除的节点的属性设为null以帮助垃圾回收机制回收，从而达到移除该节点的目的。最后，将要删除的节点的值返回。 remove，removeFirst，removeLast接下来介绍移除链表中元素的几个方法。 123456789101112131415161718192021222324252627public E remove() &#123; return removeFirst();&#125;public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; 前两个方法比较简单，而对于remove(Object o)方法，要先判断对象是否为null，如果为null，则遍历链表找到值为null的节点，并调用unlink方法移除该节点，否则，同样遍历链表并用equals方法根据内容进行等值比较，如果找到值相等的节点，调用unlink方法将其移除。 12345678910111213public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125; public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125; 这两个方法先判断链表中是否有元素，如果没有，则抛出异常，否则就调用辅助方法将其移除。 get，getFirst，getLast123456789101112131415161718public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125;public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; get(int index)方法在进行了下标检查后，直接通过node方法找到该节点并返回节点的值。而getFirst和getLast先判断first和last是否为null，如果不为null则返回节点的值，否则抛出异常。 setset方法将替换链表中指定位置的节点的值。 1234567public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; 该方法先判断index是否合法，然后获取到该下标的节点，并将该节点的值重新设置即可。 linkedList总结 linkedList是通过双向链表实现的，因此删除效率很高，而查找效率很低，且不存在扩容问题。 linkedList实现了Deque接口，因此既可以当作栈，也可以当作队列。 与ArrayList一样，linkedList也是非线程安全的，只能在单线程环境下使用。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2018%2F09%2F06%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList简介（jdk1.8）ArrayList就是动态数组，其容量能够自动增长。如下为ArrayList的继承体系结构： 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable ArrayList实现了List, RandomAccess, Cloneable, java.io.Serializable接口，且不是线程安全的，因此只能用在单线程环境下。 属性ArrayList主要有elementData和size两个属性：12transient Object[] elementData; private int size; elementData数组是用来存储元素的，而size表示ArrayList中已有的元素数量（不等于elementData.length）。 构造方法ArrayList共有三种构造方法： 指定容量的构造函数 123456789public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: " + initialCapacity); &#125;&#125; 此方法接受一个初始化容量来初始化底层数组elementData，如果初始化容量值为0则将其初始化为一个空的常量数组：private static final Object[] EMPTY_ELEMENTDATA = {}; ，如果值小于零，则抛出异常。 无参构造函数 12345private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 此方法中的DEFAULTCAPACITY_EMPTY_ELEMENTDATA区别于EMPTY_ELEMENTDATA，通过将数组设为前者，在添加元素的时候会将容量设置为默认值10。 Collection作为参数的构造函数 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 此方法接受一个Collection，并且将其转换为数组赋给elementData，如果被赋值后的elementData长度为0，则将空的常量数组赋值给它。相反，则再判断Collection是否转化为了Object数组，如果没有则将其进行转化。 这里用到了Arrays.copyof()方法：123456789public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 可以看出，该方法构造了一个新的长度为newLength的Object类型数组，并且将原数组复制到新的数组中 。而此处的复制用了System.arraycopy()方法，该方法被标记了native，调用了系统的C/C++代码，可以在openJDK中查看到源码。 get123456789public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 此方法可以得到指定下标的元素，先对下标进行越界检查，然后再通过一个间接方法获取到elementData的index下标的元素。 set1234567public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125; 此方法用于设置指定下标的元素，并将该下标原有的元素返回。 addadd方法比较复杂，也是ArrayList核心所在，有下面两种形式： 将元素加入到列表末尾 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125; 12345678910private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; 此处的calculateCapacity正是与上文DEFAULTCAPACITY_EMPTY_ELEMENTDATA常量相照应的方法。如果ArrayList是默认构造函数构造的话，在添加元素的时候此方法将返回DEFAULT_CAPACITY也就是10。而size已经大于10的情况，该方法便也失去了意义。12345678910111213141516171819202122232425262728private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 从源码可以看出，当需要的容量大于elementData数组的长度时，就需要对其进行扩张。而扩张的大小则根据if条件判断。一般情况下，会将长度扩张为原来的1.5倍，但是当1.5倍仍小于所需的容量时，会将长度直接设为所需容量。而新容量如果大于最大数组长度MAX_ARRAY_SIZE ，则根据所需容量分配Integer.MAX_VALUE或者MAX_ARRAY_SIZE。 ensureExplicitCapacity方法的第一行语句modCount++;的作用是记录修改次数。我们知道，ArrayList不是线程安全的，因此在迭代ArrayList的时候如果有其它线程修改了内容，那么就会导致modCount与迭代器初始化时的modCount不同，从而抛出异常ConcurrentModificationException。说白了，就是防止一个线程正在迭代遍历，另一个线程修改了这个列表的结构。 将元素添加到指定位置上 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 在此方法中，先对index进行越界检查，然后再进行扩容。这里用了System.arraycopy方法，j将包括index在内的之后的所有元素均向右移动一位，再将要添加的元素放置在elementData的index下标下。 addAll 将集合中的元素全部添加到ArrayList末尾 12345678public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0;&#125; 将Collection对象转化为Object数组后，先根据其长度进行扩容，再同样利用System.arraycopy函数把数组中的所有元素添加到elementData数组末尾。 将集合中的元素全部添加到ArrayList指定位置 12345678910111213141516public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125; 原理与add(int index, E element)类似，都是通过将已有元素右移实现，此处将不再阐述。 remove 移除指定下标上的元素 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 在这里，移除操作是将要移除的元素后面的所有元素均向左移动一位，并将size数减小实现的。此方法将返回要移除的元素。 移除指定的元素 12345678910111213141516171819202122232425public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false;&#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 先找到指定元素的下标，再根据下标进行移除。指定的元素有可能为null，而不为null的情况下将根据元素内容进行比较，因此将分为两种情况遍历数组。fastRemove的实现与remove(int index)基本一致，区别在于fastRemove不需要对下标进行检查，也不返回被移除的元素。 indexOf1234567891011121314151617181920212223242526272829public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125; 由源码可以看出，indexOf和lastIndexOf与remove(Object o)方法类似，并且找到元素时返回下标，没找到时返回-1，而contains方法正是通过indexOf判断是否找到元素实现的。 ArrayList总结 ArrayList底层是通过数组实现的，随机访问速度快，但插入和移除由于要移动大量的元素，所以性能较差。 ArrayList不是线程安全的，在多线程环境下，通过modCount域检测是否出现问题。 ArrayList每次扩容为原本的1.5倍，若依然不够，则会直接设置为所需容量大小。]]></content>
      <categories>
        <category>JDK</category>
      </categories>
      <tags>
        <tag>JDK</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈对尾递归的理解]]></title>
    <url>%2F2018%2F08%2F22%2F%E6%B5%85%E8%B0%88%E5%AF%B9%E5%B0%BE%E9%80%92%E5%BD%92%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天在做《剑指Offer》第十题时，发现了一个用尾递归的解法，由于之前对于尾递归并没有太多了解，于是查阅了一些资料，在此对其进行一个简单的总结。关于其它题目的题解与笔记，感兴趣的朋友可以到我的Github或个人博客上看看：剑指Offer笔记 Cenjie’s Blog ， 以下是正文。 递归本质递归的本质是自己调用自己，因为是嵌套调用，所以栈帧无法回收，在递归调用的层级太多时，往往会引发调用栈溢出，也就是内存溢出。 尾递归概述尾递归本质与递归并无区别，只不过是递归的一种特殊写法。尾递归要求递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分，例如 return 3f(n)或者return f(n)+f(n-1) 都是不允许的。 由于尾递归也是一种递归，因此这种写法本身并不会有任何的优化效果，内存依旧会溢出，只不过一些编译器中会加入对尾递归的优化机制，在编译代码时自动根据尾递归的特性对其进行优化。 如何优化尾递归因为在递归调用自身的时候，这一层函数已经没有要做的事情了，虽然被递归调用的函数是在当前的函数里，但是他们之间的关系已经在传参的时候了断了，也就是这一层函数的所有变量什么的都不会再被用到了，所以当前函数虽然没有执行完，不能弹出栈，但它确实已经可以出栈了，这是一方面。 另一方面，正因为调用的是自身，所以需要的存储空间是一模一样的，那干脆重新刷新这些空间给下一层利用就好了，不用销毁再另开空间。 因此，为尾递归进行优化主要分两个步骤：1、写成尾递归的形式。2、编译器遇到此形式时自动为其优化。 而在第十题：斐波那契数列中，由于Java没有对尾递归进行优化，因此与使用普通递归并无太大区别，依然会产生内存溢出的问题。 本文参考：https://www.cnblogs.com/bellkosmos/p/5280619.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[README文档的规范写法总结]]></title>
    <url>%2F2018%2F06%2F25%2FREADME%E6%96%87%E6%A1%A3%E7%9A%84%E8%A7%84%E8%8C%83%E5%86%99%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[俗话说的好：“一个好开源项目一定有一个好的 README”。 要想自己放到github上的项目能吸引更多人的眼球，就必须写一个规范舒适的README.md，这么做不仅可以梳理自己对于项目的思路，也方便他人上手使用或学习。因此，此文根据Github上众多项目以及查阅相关资料对README做了一个小小的总结， 方便以后写README的时候可以直接套用该模板。 XXX系统（如果有Logo可以加上Logo）xxx系统是一个..系统，支持…，…（此处为简要描述） 官方网站 | 文档手册 | 别的东西 目前，此系统包含有以下功能： 功能1 功能2 功能3 准备 依赖1 依赖2 依赖3 搭建环境IntelliJ IDEA + MySQL 或者 eclipse + MySQL，… 快速开始 步骤1 步骤2 步骤3 相关截图截图1截图2 To Do List 功能1 功能2 功能3 CHANGE LOG此处填写版本更新记录 至此，我们可以看到一个相对规范的README.md模板，在开源项目时可以直接套用该模板，而不必每次都采用不同的零零散散的格式去书写README。Markdown代码在下方给出，当然，大家也可以根据项目具体情况进行修改而使用。 12345678910111213141516171819202122232425262728293031323334## XXX系统（如果有Logo可以加上Logo）xxx系统是一个..系统，支持...，...（此处为简要描述）[官方网站](http://example.com) | [文档手册](http://example.com) | [别的东西](http://example.com) 目前，此系统包含有以下功能：* 功能1* 功能2* 功能3### 准备* 依赖1* 依赖2* 依赖3### 搭建环境IntelliJ IDEA + MySQL 或者 eclipse + MySQL，...### 快速开始* 步骤1* 步骤2* 步骤3### 相关截图截图1截图2### To Do List* 功能1* 功能2* 功能3### CHANGE LOG此处填写版本更新记录 ContactIf you have some questions after you see this article, you can just find some info by clicking these links. Cenjie’s CSDN Cenjie’s Github Cenjie’s Gmail Cenjie’s Weibo]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>README</tag>
        <tag>markdown</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Welcome To My Blog]]></title>
    <url>%2F2018%2F06%2F22%2FWelcome-To-My-Blog%2F</url>
    <content type="text"><![CDATA[写在前面的话大家好！我是就读于南京某高校的一名大二学生，在昨天搭建了这个个人博客网站用于记录自己在学习以及项目过程中的技术积累，希望通过这个平台能与大家分享自己的经验与教训，同时也欢迎大家随时可以联系我，期待与大家共同进步。 关于我我在学校的专业是电子信息科学与技术，曾利用课余时间学习过C、C++、Python等多门语言(仅限于皮毛)，经过两年的不断试错，终于在大二下学期确定了自己以后的发展方向—Java后台研发工程师。于是从基础语法到各大框架，这半年里接触到了许多新技术，看似学了许多东西却仍浮于水面终无所获，逐渐了解到自己要走的路还很长，而自己目前对于基础方面知识也尤为欠缺。因此需记住，沉下心，耐下性子，Coding the World。 铭记Work hard in silence, let success make the noise. ContactIf you have some questions after you see this article, you can just find some info by clicking these links. Cenjie’s CSDN Cenjie’s Github Cenjie’s Gmail]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>hello</tag>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
